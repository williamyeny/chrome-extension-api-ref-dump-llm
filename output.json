[
  {
    "https://developer.chrome.com/docs/extensions/reference/api/accessibilityFeatures": "#  chrome.accessibilityFeatures\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.accessibilityFeatures` API to manage Chrome's accessibility\nfeatures. This API relies on the ChromeSetting prototype of the type API for\ngetting and setting individual accessibility features. In order to get feature\nstates the extension must request `accessibilityFeatures.read` permission. For\nmodifying feature state, the extension needs `accessibilityFeatures.modify`\npermission. Note that `accessibilityFeatures.modify` does not imply\n`accessibilityFeatures.read` permission.\n\n## Permissions\n\n`accessibilityFeatures.modify`  \n`accessibilityFeatures.read`  \n\n## Properties\n\n### animationPolicy\n\n`get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<\"allowed\"  \n | \"once\"   \n | \"none\"   \n>\n\n### autoclick\n\n**ChromeOS only.**\n\nAuto mouse click after mouse stops moving. The value indicates whether the\nfeature is enabled or not. `get()` requires `accessibilityFeatures.read`\npermission. `set()` and `clear()` require `accessibilityFeatures.modify`\npermission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### caretHighlight\n\nChrome 51+\n\n**ChromeOS only.**\n\nCaret highlighting. The value indicates whether the feature is enabled or not.\n`get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### cursorColor\n\nChrome 85+\n\n**ChromeOS only.**\n\nCursor color. The value indicates whether the feature is enabled or not,\ndoesn't indicate the color of it. `get()` requires\n`accessibilityFeatures.read` permission. `set()` and `clear()` require\n`accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### cursorHighlight\n\nChrome 51+\n\n**ChromeOS only.**\n\nCursor highlighting. The value indicates whether the feature is enabled or\nnot. `get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### dictation\n\nChrome 90+\n\n**ChromeOS only.**\n\nDictation. The value indicates whether the feature is enabled or not. `get()`\nrequires `accessibilityFeatures.read` permission. `set()` and `clear()`\nrequire `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### dockedMagnifier\n\nChrome 87+\n\n**ChromeOS only.**\n\nDocked magnifier. The value indicates whether docked magnifier feature is\nenabled or not. `get()` requires `accessibilityFeatures.read` permission.\n`set()` and `clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### focusHighlight\n\nChrome 51+\n\n**ChromeOS only.**\n\nFocus highlighting. The value indicates whether the feature is enabled or not.\n`get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### highContrast\n\n**ChromeOS only.**\n\nHigh contrast rendering mode. The value indicates whether the feature is\nenabled or not. `get()` requires `accessibilityFeatures.read` permission.\n`set()` and `clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### largeCursor\n\n**ChromeOS only.**\n\nEnlarged cursor. The value indicates whether the feature is enabled or not.\n`get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### screenMagnifier\n\n**ChromeOS only.**\n\nFull screen magnification. The value indicates whether the feature is enabled\nor not. `get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### selectToSpeak\n\nChrome 51+\n\n**ChromeOS only.**\n\nSelect-to-speak. The value indicates whether the feature is enabled or not.\n`get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### spokenFeedback\n\n**ChromeOS only.**\n\nSpoken feedback (text-to-speech). The value indicates whether the feature is\nenabled or not. `get()` requires `accessibilityFeatures.read` permission.\n`set()` and `clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### stickyKeys\n\n**ChromeOS only.**\n\nSticky modifier keys (like shift or alt). The value indicates whether the\nfeature is enabled or not. `get()` requires `accessibilityFeatures.read`\npermission. `set()` and `clear()` require `accessibilityFeatures.modify`\npermission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### switchAccess\n\nChrome 51+\n\n**ChromeOS only.**\n\nSwitch Access. The value indicates whether the feature is enabled or not.\n`get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### virtualKeyboard\n\n**ChromeOS only.**\n\nVirtual on-screen keyboard. The value indicates whether the feature is enabled\nor not. `get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/action": "#  chrome.action\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.action` API to control the extension's icon in the Google\nChrome toolbar.\n\nThe action icons are displayed in the browser toolbar next to the omnibox.\nAfter installation, these appear in the extensions menu (the puzzle piece\nicon). Users can pin your extension icon to the toolbar.\n\n## Availability\n\nChrome 88+ MV3+\n\n## Manifest\n\nThe following keys must be declared in the manifest to use this API.\n\n`\"action\"`  \n\nTo use the `chrome.action` API, specify a `\"manifest_version\"` of `3` and\ninclude the `\"action\"` key in your manifest file.\n\n**Note:** Every extension has an icon in the Chrome toolbar, even if the\n`\"action\"` key isn't added to the manifest.\n\n    \n    \n    {\n      \"name\": \"Action Extension\",\n      ...\n      \"action\": {\n        \"default_icon\": {              // optional\n          \"16\": \"images/icon16.png\",   // optional\n          \"24\": \"images/icon24.png\",   // optional\n          \"32\": \"images/icon32.png\"    // optional\n        },\n        \"default_title\": \"Click Me\",   // optional, shown in tooltip\n        \"default_popup\": \"popup.html\"  // optional\n      },\n      ...\n    }\n    \n\nThe `\"action\"` key (along with its children) is optional. When it isn't\nincluded, your extension is still shown in the toolbar to provide access to\nthe extension's menu. For this reason, we recommend that you always include at\nleast the `\"action\"` and `\"default_icon\"` keys.\n\n## Concepts and usage\n\n### Parts of the UI\n\n#### Icon\n\nThe icon is the main image on the toolbar for your extension, and is set by\nthe `\"default_icon\"` key in your manifest's `\"action\"` key. Icons must be 16\ndevice-independent pixels (DIPs) wide and tall.\n\nThe `\"default_icon\"` key is a dictionary of sizes to image paths. Chrome uses\nthese icons to choose which image scale to use. If an exact match is not\nfound, Chrome selects the closest available and scales it to fit the image,\nwhich might affect image quality.\n\nBecause devices with less-common scale factors like 1.5x or 1.2x are becoming\nmore common, we encourage you to provide multiple sizes for your icons. This\nalso futureproofs your extension against potential icon display size changes.\nHowever, if only providing a single size, the `\"default_icon\"` key can also be\nset to a string with the path to a single icon instead of a dictionary.\n\nYou can also call `action.setIcon()` to set your extension's icon\nprogrammatically by specifying a different image path or providing a\ndynamically-generated icon using the HTML canvas element, or, if setting from\nan extension service worker, the offscreen canvas API.\n\n    \n    \n    const canvas = new OffscreenCanvas(16, 16);\n    const context = canvas.getContext('2d');\n    context.clearRect(0, 0, 16, 16);\n    context.fillStyle = '#00FF00';  // Green\n    context.fillRect(0, 0, 16, 16);\n    const imageData = context.getImageData(0, 0, 16, 16);\n    chrome.action.setIcon({imageData: imageData}, () => { /* ... */ });\n    \n\n**Note:** The `action.setIcon()` API is intended to set a static image. Don't\nuse animated images for your icons.\n\nFor packed extensions (installed from a .crx file), images can be in most\nformats that the Blink rendering engine can display, including PNG, JPEG, BMP,\nICO, and others. SVG isn't supported. Unpacked extensions must use PNG images.\n\n#### Tooltip (title)\n\nThe tooltip, or title, appears when the user holds their mouse pointer over\nthe extension's icon in the toolbar. It's also included in the accessible text\nspoken by screen readers when the button gets focus.\n\nThe default tooltip is set using the `\"default_title\"` field of the `\"action\"`\nkey in `manifest.json`. You can also set it programmatically by calling\n`action.setTitle()`.\n\n#### Badge\n\nActions can optionally display a \"badge\" -- a bit of text layered over the\nicon. This lets you update the action to display a small amount of information\nabout the state of the extension, such as a counter. The badge has a text\ncomponent and a background color. Because space is limited, we recommend that\nbadge text use four or fewer characters.\n\nTo create a badge, set it programmatically by calling\n`action.setBadgeBackgroundColor()` and `action.setBadgeText()`. There isn't a\ndefault badge setting in the manifest. Badge color values can be either an\narray of four integers between 0 and 255 that make up the RGBA color of the\nbadge or a string with a CSS color value.\n\n    \n    \n    chrome.action.setBadgeBackgroundColor(\n      {color: [0, 255, 0, 0]},  // Green\n      () => { /* ... */ },\n    );\n    \n    chrome.action.setBadgeBackgroundColor(\n      {color: '#00FF00'},  // Also green\n      () => { /* ... */ },\n    );\n    \n    chrome.action.setBadgeBackgroundColor(\n      {color: 'green'},  // Also, also green\n      () => { /* ... */ },\n    );\n    \n\n#### Popup\n\nAn action's popup is shown when the user clicks on the extension's action\nbutton in the toolbar. The popup can contain any HTML contents you like, and\nwill be automatically sized to fit its contents. The popup's size must be\nbetween 25x25 and 800x600 pixels.\n\nThe popup is initially set by the `\"default_popup\"` property in the `\"action\"`\nkey in the `manifest.json` file. If present, this property should point to a\nrelative path within the extension directory. It can also be updated\ndynamically to point to a different relative path using the\n`action.setPopup()` method.\n\n**Note:** The `action.onClicked` event won't be sent if the extension action\nhas specified a popup to show on click of the current tab.\n\n## Use cases\n\n### Per-tab state\n\nExtension actions can have different states for each tab. To set a value for\nan individual tab, use the `tabId` property in the `action` API's setting\nmethods. For example, to set the badge text for a specific tab, do something\nlike the following:\n\n    \n    \n    function getTabId() { /* ... */}\n    function getTabBadge() { /* ... */}\n    \n    chrome.action.setBadgeText(\n      {\n        text: getTabBadge(tabId),\n        tabId: getTabId(),\n      },\n      () => { ... }\n    );\n    \n\nIf the `tabId` property is left out, the setting is treated as a global\nsetting. Tab-specific settings take priority over global settings.\n\n### Enabled state\n\nBy default, toolbar actions are enabled (clickable) on every tab. You can\nchange this default by setting the `default_state` property in the `action`\nkey of the manifest. If `default_state` is set to `\"disabled\"`, the action is\ndisabled by default and must be enabled programmatically to be clickable. If\n`default_state` is set to `\"enabled\"` (the default), the action is enabled and\nclickable by default.\n\nYou can control the state programmatically using the `action.enable()` and\n`action.disable()` methods. This only affects whether the popup (if any) or\n`action.onClicked` event is sent to your extension; it doesn't affect the\naction's presence in the toolbar.\n\n## Examples\n\nThe following examples show some common ways that actions are used in\nextensions. To try this API, install the Action API example from the chrome-\nextension-samples repository.\n\n### Show a popup\n\nIt's common for an extension to display a popup when the user clicks the\nextension's action. To implement this in your own extension, declare the popup\nin your `manifest.json` and specify the content that Chrome should display in\nthe popup.\n\n    \n    \n    // manifest.json\n    {\n      \"name\": \"Action popup demo\",\n      \"version\": \"1.0\",\n      \"manifest_version\": 3,\n      \"action\": {\n        \"default_title\": \"Click to view a popup\",\n        \"default_popup\": \"popup.html\"\n      }\n    }\n    \n    \n    \n    <!-- popup.html -->\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <style>\n        html {\n          min-height: 5em;\n          min-width: 10em;\n          background: salmon;\n        }\n      </style>\n    </head>\n    <body>\n      <p>Hello, world!</p>\n    </body>\n    </html>\n    \n\n### Inject a content script on click\n\nA common pattern for extensions is to expose their primary feature using the\nextension's action. The following example demonstrates this pattern. When the\nuser clicks the action, the extension injects a content script into the\ncurrent page. The content script then displays an alert to verify that\neverything worked as expected.\n\n    \n    \n    // manifest.json\n    {\n      \"name\": \"Action script injection demo\",\n      \"version\": \"1.0\",\n      \"manifest_version\": 3,\n      \"action\": {\n        \"default_title\": \"Click to show an alert\"\n      },\n      \"permissions\": [\"activeTab\", \"scripting\"],\n      \"background\": {\n        \"service_worker\": \"background.js\"\n      }\n    }\n    \n    \n    \n    // background.js\n    chrome.action.onClicked.addListener((tab) => {\n      chrome.scripting.executeScript({\n        target: {tabId: tab.id},\n        files: ['content.js']\n      });\n    });\n    \n    \n    \n    // content.js\n    alert('Hello, world!');\n    \n\n### Emulate actions with declarativeContent\n\nThis example shows how an extension's background logic can (a) disable an\naction by default and (b) use declarativeContent to enable the action on\nspecific sites.\n\n    \n    \n    // service-worker.js\n    \n    // Wrap in an onInstalled callback to avoid unnecessary work\n    // every time the service worker is run\n    chrome.runtime.onInstalled.addListener(() => {\n      // Page actions are disabled by default and enabled on select tabs\n      chrome.action.disable();\n    \n      // Clear all rules to ensure only our expected rules are set\n      chrome.declarativeContent.onPageChanged.removeRules(undefined, () => {\n        // Declare a rule to enable the action on example.com pages\n        let exampleRule = {\n          conditions: [\n            new chrome.declarativeContent.PageStateMatcher({\n              pageUrl: {hostSuffix: '.example.com'},\n            })\n          ],\n          actions: [new chrome.declarativeContent.ShowAction()],\n        };\n    \n        // Finally, apply our new array of rules\n        let rules = [exampleRule];\n        chrome.declarativeContent.onPageChanged.addRules(rules);\n      });\n    });\n    \n\n## Types\n\n### OpenPopupOptions\n\nChrome 99+\n\n#### Properties\n\n  * windowId\n\nnumber optional\n\nThe ID of the window to open the action popup in. Defaults to the currently-\nactive window if unspecified.\n\n### TabDetails\n\n#### Properties\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to query state for. If no tab is specified, the non-tab-\nspecific state is returned.\n\n### UserSettings\n\nChrome 91+\n\nThe collection of user-specified settings relating to an extension's action.\n\n#### Properties\n\n  * isOnToolbar\n\nboolean\n\nWhether the extension's action icon is visible on browser windows' top-level\ntoolbar (i.e., whether the extension has been 'pinned' by the user).\n\n### UserSettingsChange\n\nChrome 130+\n\n#### Properties\n\n  * isOnToolbar\n\nboolean optional\n\nWhether the extension's action icon is visible on browser windows' top-level\ntoolbar (i.e., whether the extension has been 'pinned' by the user).\n\n## Methods\n\n### disable()\n\nPromise\n\n    \n    \n    chrome.action.disable(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nDisables the action for a tab.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab for which you want to modify the action.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### enable()\n\nPromise\n\n    \n    \n    chrome.action.enable(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nEnables the action for a tab. By default, actions are enabled.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab for which you want to modify the action.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getBadgeBackgroundColor()\n\nPromise\n\n    \n    \n    chrome.action.getBadgeBackgroundColor(  \n      details: TabDetails,  \n      callback?: function,  \n    )\n\nGets the background color of the action.\n\n#### Parameters\n\n  * details\n\nTabDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ColorArray) => void\n\n    * result\n\nColorArray\n\n#### Returns\n\n  * Promise<browserAction.ColorArray>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getBadgeText()\n\nPromise\n\n    \n    \n    chrome.action.getBadgeText(  \n      details: TabDetails,  \n      callback?: function,  \n    )\n\nGets the badge text of the action. If no tab is specified, the non-tab-\nspecific badge text is returned. If displayActionCountAsBadgeText is enabled,\na placeholder text will be returned unless the declarativeNetRequestFeedback\npermission is present or tab-specific badge text was provided.\n\n#### Parameters\n\n  * details\n\nTabDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: string) => void\n\n    * result\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getBadgeTextColor()\n\nPromise Chrome 110+\n\n    \n    \n    chrome.action.getBadgeTextColor(  \n      details: TabDetails,  \n      callback?: function,  \n    )\n\nGets the text color of the action.\n\n#### Parameters\n\n  * details\n\nTabDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ColorArray) => void\n\n    * result\n\nColorArray\n\n#### Returns\n\n  * Promise<browserAction.ColorArray>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPopup()\n\nPromise\n\n    \n    \n    chrome.action.getPopup(  \n      details: TabDetails,  \n      callback?: function,  \n    )\n\nGets the html document set as the popup for this action.\n\n#### Parameters\n\n  * details\n\nTabDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: string) => void\n\n    * result\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getTitle()\n\nPromise\n\n    \n    \n    chrome.action.getTitle(  \n      details: TabDetails,  \n      callback?: function,  \n    )\n\nGets the title of the action.\n\n#### Parameters\n\n  * details\n\nTabDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: string) => void\n\n    * result\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getUserSettings()\n\nPromise Chrome 91+\n\n    \n    \n    chrome.action.getUserSettings(  \n      callback?: function,  \n    )\n\nReturns the user-specified settings relating to an extension's action.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (userSettings: UserSettings) => void\n\n    * userSettings\n\nUserSettings\n\n#### Returns\n\n  * Promise<UserSettings>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### isEnabled()\n\nPromise Chrome 110+\n\n    \n    \n    chrome.action.isEnabled(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nIndicates whether the extension action is enabled for a tab (or globally if no\n`tabId` is provided). Actions enabled using only `declarativeContent` always\nreturn false.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab for which you want check enabled status.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (isEnabled: boolean) => void\n\n    * isEnabled\n\nboolean\n\nTrue if the extension action is enabled.\n\n#### Returns\n\n  * Promise<boolean>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### openPopup()\n\nPromise Chrome 127+\n\n    \n    \n    chrome.action.openPopup(  \n      options?: OpenPopupOptions,  \n      callback?: function,  \n    )\n\nOpens the extension's popup. Between Chrome 118 and Chrome 126, this is only\navailable to policy installed extensions.\n\n#### Parameters\n\n  * options\n\nOpenPopupOptions optional\n\nSpecifies options for opening the popup.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setBadgeBackgroundColor()\n\nPromise\n\n    \n    \n    chrome.action.setBadgeBackgroundColor(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the background color for the badge.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * color\n\nstring | ColorArray\n\nAn array of four integers in the range [0,255] that make up the RGBA color of\nthe badge. For example, opaque red is `[255, 0, 0, 255]`. Can also be a string\nwith a CSS value, with opaque red being `#FF0000` or `#F00`.\n\n    * tabId\n\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets\nwhen the tab is closed.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setBadgeText()\n\nPromise\n\n    \n    \n    chrome.action.setBadgeText(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the badge text for the action. The badge is displayed on top of the icon.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * tabId\n\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets\nwhen the tab is closed.\n\n    * text\n\nstring optional\n\nAny number of characters can be passed, but only about four can fit in the\nspace. If an empty string (`''`) is passed, the badge text is cleared. If\n`tabId` is specified and `text` is null, the text for the specified tab is\ncleared and defaults to the global badge text.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setBadgeTextColor()\n\nPromise Chrome 110+\n\n    \n    \n    chrome.action.setBadgeTextColor(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the text color for the badge.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * color\n\nstring | ColorArray\n\nAn array of four integers in the range [0,255] that make up the RGBA color of\nthe badge. For example, opaque red is `[255, 0, 0, 255]`. Can also be a string\nwith a CSS value, with opaque red being `#FF0000` or `#F00`. Not setting this\nvalue will cause a color to be automatically chosen that will contrast with\nthe badge's background color so the text will be visible. Colors with alpha\nvalues equivalent to 0 will not be set and will return an error.\n\n    * tabId\n\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets\nwhen the tab is closed.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setIcon()\n\nPromise\n\n    \n    \n    chrome.action.setIcon(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the icon for the action. The icon can be specified either as the path to\nan image file or as the pixel data from a canvas element, or as dictionary of\neither one of those. Either the **path** or the **imageData** property must be\nspecified.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * imageData\n\nImageData | object optional\n\nEither an ImageData object or a dictionary {size -> ImageData} representing\nicon to be set. If the icon is specified as a dictionary, the actual image to\nbe used is chosen depending on screen's pixel density. If the number of image\npixels that fit into one screen space unit equals `scale`, then image with\nsize `scale` * n will be selected, where n is the size of the icon in the UI.\nAt least one image must be specified. Note that 'details.imageData = foo' is\nequivalent to 'details.imageData = {'16': foo}'\n\n    * path\n\nstring | object optional\n\nEither a relative image path or a dictionary {size -> relative image path}\npointing to icon to be set. If the icon is specified as a dictionary, the\nactual image to be used is chosen depending on screen's pixel density. If the\nnumber of image pixels that fit into one screen space unit equals `scale`,\nthen image with size `scale` * n will be selected, where n is the size of the\nicon in the UI. At least one image must be specified. Note that 'details.path\n= foo' is equivalent to 'details.path = {'16': foo}'\n\n    * tabId\n\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets\nwhen the tab is closed.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setPopup()\n\nPromise\n\n    \n    \n    chrome.action.setPopup(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the HTML document to be opened as a popup when the user clicks on the\naction's icon.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * popup\n\nstring\n\nThe relative path to the HTML file to show in a popup. If set to the empty\nstring (`''`), no popup is shown.\n\n    * tabId\n\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets\nwhen the tab is closed.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setTitle()\n\nPromise\n\n    \n    \n    chrome.action.setTitle(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the title of the action. This shows up in the tooltip.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * tabId\n\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets\nwhen the tab is closed.\n\n    * title\n\nstring\n\nThe string the action should display when moused over.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onClicked\n\n    \n    \n    chrome.action.onClicked.addListener(  \n      callback: function,  \n    )\n\nFired when an action icon is clicked. This event will not fire if the action\nhas a popup.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (tab: tabs.Tab) => void\n\n    * tab\n\ntabs.Tab\n\n### onUserSettingsChanged\n\nChrome 130+\n\n    \n    \n    chrome.action.onUserSettingsChanged.addListener(  \n      callback: function,  \n    )\n\nFired when user-specified settings relating to an extension's action change.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (change: UserSettingsChange) => void\n\n    * change\n\nUserSettingsChange\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/alarms": "#  chrome.alarms\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Chrome 120:** Starting in Chrome 120, the minimum alarm interval has been\nreduced from 1 minute to 30 seconds. For an alarm to trigger in 30 seconds,\nset `periodInMinutes: 0.5`.  \n**Chrome 117:** Starting in Chrome 117, the number of active alarms is limited\nto 500. Once this limit is reached, `chrome.alarms.create()` will fail. When\nusing a callback, `chrome.runtime.lastError` will be set. When using promises,\nthe promise will be rejected.\n\n## Description\n\nUse the `chrome.alarms` API to schedule code to run periodically or at a\nspecified time in the future.\n\n## Permissions\n\n`alarms`  \n\nTo use the `chrome.alarms` API, declare the `\"alarms\"` permission in the\nmanifest:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"alarms\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nTo ensure reliable behavior, it is helpful to understand how the API behaves.\n\n### Device sleep\n\nAlarms continue to run while a device is sleeping. However, an alarm will not\nwake up a device. When the device wakes up, any missed alarms will fire.\nRepeating alarms will fire at most once and then be rescheduled using the\nspecified period starting from when the device wakes, not taking into account\nany time that has already elapsed since the alarm was originally set to run.\n\n### Persistence\n\nAlarms generally persist until an extension is updated. However, this is not\nguaranteed, and alarms may be cleared when the browser is restarted.\nConsequently, consider setting a value in storage when an alarm is created,\nand then ensure it exists each time your service worker starts up. For\nexample:\n\n    \n    \n    const STORAGE_KEY = \"user-preference-alarm-enabled\";\n    \n    async function checkAlarmState() {\n      const { alarmEnabled } = await chrome.storage.get(STORAGE_KEY);\n    \n      if (alarmEnabled) {\n        const alarm = await chrome.alarms.get(\"my-alarm\");\n    \n        if (!alarm) {\n          await chrome.alarms.create({ periodInMinutes: 1 });\n        }\n      }\n    }\n    \n    checkAlarmState();\n    \n\n## Examples\n\nThe following examples show how to use and respond to an alarm. To try this\nAPI, install the Alarm API example from the chrome-extension-samples\nrepository.\n\n### Set an alarm\n\nThe following example sets an alarm in the service worker when the extension\nis installed:\n\nservice-worker.js:\n\n    \n    \n    chrome.runtime.onInstalled.addListener(async ({ reason }) => {\n      if (reason !== 'install') {\n        return;\n      }\n    \n      // Create an alarm so we have something to look at in the demo\n      await chrome.alarms.create('demo-default-alarm', {\n        delayInMinutes: 1,\n        periodInMinutes: 1\n      });\n    });\n    \n\n### Respond to an alarm\n\nThe following example sets the action toolbar icon based on the name of the\nalarm that went off.\n\nservice-worker.js:\n\n    \n    \n    chrome.alarms.onAlarm.addListener((alarm) => {\n      chrome.action.setIcon({\n        path: getIconPath(alarm.name),\n      });\n    });\n    \n\n## Types\n\n### Alarm\n\n#### Properties\n\n  * name\n\nstring\n\nName of this alarm.\n\n  * periodInMinutes\n\nnumber optional\n\nIf not null, the alarm is a repeating alarm and will fire again in\n`periodInMinutes` minutes.\n\n  * scheduledTime\n\nnumber\n\nTime at which this alarm was scheduled to fire, in milliseconds past the epoch\n(e.g. `Date.now() + n`). For performance reasons, the alarm may have been\ndelayed an arbitrary amount beyond this.\n\n### AlarmCreateInfo\n\n#### Properties\n\n  * delayInMinutes\n\nnumber optional\n\nLength of time in minutes after which the `onAlarm` event should fire.\n\n  * periodInMinutes\n\nnumber optional\n\nIf set, the onAlarm event should fire every `periodInMinutes` minutes after\nthe initial event specified by `when` or `delayInMinutes`. If not set, the\nalarm will only fire once.\n\n  * when\n\nnumber optional\n\nTime at which the alarm should fire, in milliseconds past the epoch (e.g.\n`Date.now() + n`).\n\n## Methods\n\n### clear()\n\nPromise\n\n    \n    \n    chrome.alarms.clear(  \n      name?: string,  \n      callback?: function,  \n    )\n\nClears the alarm with the given name.\n\n#### Parameters\n\n  * name\n\nstring optional\n\nThe name of the alarm to clear. Defaults to the empty string.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (wasCleared: boolean) => void\n\n    * wasCleared\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### clearAll()\n\nPromise\n\n    \n    \n    chrome.alarms.clearAll(  \n      callback?: function,  \n    )\n\nClears all alarms.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (wasCleared: boolean) => void\n\n    * wasCleared\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### create()\n\nPromise\n\n    \n    \n    chrome.alarms.create(  \n      name?: string,  \n      alarmInfo: AlarmCreateInfo,  \n      callback?: function,  \n    )\n\nCreates an alarm. Near the time(s) specified by `alarmInfo`, the `onAlarm`\nevent is fired. If there is another alarm with the same name (or no name if\nnone is specified), it will be cancelled and replaced by this alarm.\n\nIn order to reduce the load on the user's machine, Chrome limits alarms to at\nmost once every 30 seconds but may delay them an arbitrary amount more. That\nis, setting `delayInMinutes` or `periodInMinutes` to less than `0.5` will not\nbe honored and will cause a warning. `when` can be set to less than 30 seconds\nafter \"now\" without warning but won't actually cause the alarm to fire for at\nleast 30 seconds.\n\nTo help you debug your app or extension, when you've loaded it unpacked,\nthere's no limit to how often the alarm can fire.\n\n#### Parameters\n\n  * name\n\nstring optional\n\nOptional name to identify this alarm. Defaults to the empty string.\n\n  * alarmInfo\n\nAlarmCreateInfo\n\nDescribes when the alarm should fire. The initial time must be specified by\neither `when` or `delayInMinutes` (but not both). If `periodInMinutes` is set,\nthe alarm will repeat every `periodInMinutes` minutes after the initial event.\nIf neither `when` or `delayInMinutes` is set for a repeating alarm,\n`periodInMinutes` is used as the default for `delayInMinutes`.\n\n  * callback\n\nfunction optional\n\nChrome 111+\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### get()\n\nPromise\n\n    \n    \n    chrome.alarms.get(  \n      name?: string,  \n      callback?: function,  \n    )\n\nRetrieves details about the specified alarm.\n\n#### Parameters\n\n  * name\n\nstring optional\n\nThe name of the alarm to get. Defaults to the empty string.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (alarm?: Alarm) => void\n\n    * alarm\n\nAlarm optional\n\n#### Returns\n\n  * Promise<Alarm | undefined>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.alarms.getAll(  \n      callback?: function,  \n    )\n\nGets an array of all the alarms.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (alarms: Alarm[]) => void\n\n    * alarms\n\nAlarm[]\n\n#### Returns\n\n  * Promise<Alarm[]>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onAlarm\n\n    \n    \n    chrome.alarms.onAlarm.addListener(  \n      callback: function,  \n    )\n\nFired when an alarm has elapsed. Useful for event pages.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (alarm: Alarm) => void\n\n    * alarm\n\nAlarm\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/audio": "#  chrome.audio\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nThe `chrome.audio` API is provided to allow users to get information about and\ncontrol the audio devices attached to the system. This API is currently only\navailable in kiosk mode for ChromeOS.\n\n## Permissions\n\n`audio`  \n\n## Availability\n\nChrome 59+  ChromeOS only\n\n## Types\n\n### AudioDeviceInfo\n\n#### Properties\n\n  * deviceName\n\nstring\n\nDevice name.\n\n  * deviceType\n\nDeviceType\n\nType of the device.\n\n  * displayName\n\nstring\n\nThe user-friendly name (e.g. \"USB Microphone\").\n\n  * id\n\nstring\n\nThe unique identifier of the audio device.\n\n  * isActive\n\nboolean\n\nTrue if this is the current active device.\n\n  * level\n\nnumber\n\nThe sound level of the device, volume for output, gain for input.\n\n  * stableDeviceId\n\nstring optional\n\nThe stable/persisted device id string when available.\n\n  * streamType\n\nStreamType\n\nStream type associated with this device.\n\n### DeviceFilter\n\n#### Properties\n\n  * isActive\n\nboolean optional\n\nIf set, only audio devices whose active state matches this value will satisfy\nthe filter.\n\n  * streamTypes\n\nStreamType[] optional\n\nIf set, only audio devices whose stream type is included in this list will\nsatisfy the filter.\n\n### DeviceIdLists\n\n#### Properties\n\n  * input\n\nstring[] optional\n\nList of input devices specified by their ID.\n\nTo indicate input devices should be unaffected, leave this property unset.\n\n  * output\n\nstring[] optional\n\nList of output devices specified by their ID.\n\nTo indicate output devices should be unaffected, leave this property unset.\n\n### DeviceProperties\n\n#### Properties\n\n  * level\n\nnumber optional\n\nThe audio device's desired sound level. Defaults to the device's current sound\nlevel.\n\nIf used with audio input device, represents audio device gain.\n\nIf used with audio output device, represents audio device volume.\n\n### DeviceType\n\nAvailable audio device types.\n\n#### Enum\n\n\"HEADPHONE\"  \n\n\"MIC\"  \n\n\"USB\"  \n\n\"BLUETOOTH\"  \n\n\"HDMI\"  \n\n\"INTERNAL_SPEAKER\"  \n\n\"INTERNAL_MIC\"  \n\n\"FRONT_MIC\"  \n\n\"REAR_MIC\"  \n\n\"KEYBOARD_MIC\"  \n\n\"HOTWORD\"  \n\n\"LINEOUT\"  \n\n\"POST_MIX_LOOPBACK\"  \n\n\"POST_DSP_LOOPBACK\"  \n\n\"ALSA_LOOPBACK\"  \n\n\"OTHER\"  \n\n### LevelChangedEvent\n\n#### Properties\n\n  * deviceId\n\nstring\n\nID of device whose sound level has changed.\n\n  * level\n\nnumber\n\nThe device's new sound level.\n\n### MuteChangedEvent\n\n#### Properties\n\n  * isMuted\n\nboolean\n\nWhether or not the stream is now muted.\n\n  * streamType\n\nStreamType\n\nThe type of the stream for which the mute value changed. The updated mute\nvalue applies to all devices with this stream type.\n\n### StreamType\n\nType of stream an audio device provides.\n\n#### Enum\n\n\"INPUT\"  \n\n\"OUTPUT\"  \n\n## Methods\n\n### getDevices()\n\nPromise\n\n    \n    \n    chrome.audio.getDevices(  \n      filter?: DeviceFilter,  \n      callback?: function,  \n    )\n\nGets a list of audio devices filtered based on `filter`.\n\n#### Parameters\n\n  * filter\n\nDeviceFilter optional\n\nDevice properties by which to filter the list of returned audio devices. If\nthe filter is not set or set to `{}`, returned device list will contain all\navailable audio devices.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (devices: AudioDeviceInfo[]) => void\n\n    * devices\n\nAudioDeviceInfo[]\n\n#### Returns\n\n  * Promise<AudioDeviceInfo[]>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getMute()\n\nPromise\n\n    \n    \n    chrome.audio.getMute(  \n      streamType: StreamType,  \n      callback?: function,  \n    )\n\nGets the system-wide mute state for the specified stream type.\n\n#### Parameters\n\n  * streamType\n\nStreamType\n\nStream type for which mute state should be fetched.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (value: boolean) => void\n\n    * value\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setActiveDevices()\n\nPromise\n\n    \n    \n    chrome.audio.setActiveDevices(  \n      ids: DeviceIdLists,  \n      callback?: function,  \n    )\n\nSets lists of active input and/or output devices.\n\n#### Parameters\n\n  * ids\n\nDeviceIdLists\n\nSpecifies IDs of devices that should be active. If either the input or output\nlist is not set, devices in that category are unaffected.\n\nIt is an error to pass in a non-existent device ID.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setMute()\n\nPromise\n\n    \n    \n    chrome.audio.setMute(  \n      streamType: StreamType,  \n      isMuted: boolean,  \n      callback?: function,  \n    )\n\nSets mute state for a stream type. The mute state will apply to all audio\ndevices with the specified audio stream type.\n\n#### Parameters\n\n  * streamType\n\nStreamType\n\nStream type for which mute state should be set.\n\n  * isMuted\n\nboolean\n\nNew mute value.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setProperties()\n\nPromise\n\n    \n    \n    chrome.audio.setProperties(  \n      id: string,  \n      properties: DeviceProperties,  \n      callback?: function,  \n    )\n\nSets the properties for the input or output device.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * properties\n\nDeviceProperties\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onDeviceListChanged\n\n    \n    \n    chrome.audio.onDeviceListChanged.addListener(  \n      callback: function,  \n    )\n\nFired when audio devices change, either new devices being added, or existing\ndevices being removed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (devices: AudioDeviceInfo[]) => void\n\n    * devices\n\nAudioDeviceInfo[]\n\n### onLevelChanged\n\n    \n    \n    chrome.audio.onLevelChanged.addListener(  \n      callback: function,  \n    )\n\nFired when sound level changes for an active audio device.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (event: LevelChangedEvent) => void\n\n    * event\n\nLevelChangedEvent\n\n### onMuteChanged\n\n    \n    \n    chrome.audio.onMuteChanged.addListener(  \n      callback: function,  \n    )\n\nFired when the mute state of the audio input or output changes. Note that mute\nstate is system-wide and the new value applies to every audio device with\nspecified stream type.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (event: MuteChangedEvent) => void\n\n    * event\n\nMuteChangedEvent\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/bookmarks": "#  chrome.bookmarks\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.bookmarks` API to create, organize, and otherwise manipulate\nbookmarks. Also see Override Pages, which you can use to create a custom\nBookmark Manager page.\n\n![Clicking the star adds a\nbookmark](/static/docs/extensions/reference/api/images/bookmarks.png) Clicking\nthe star adds a bookmark.\n\n## Permissions\n\n`bookmarks`  \n\nYou must declare the \"bookmarks\" permission in the extension manifest to use\nthe bookmarks API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"bookmarks\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\n### Objects and properties\n\nBookmarks are organized in a tree, where each node in the tree is either a\nbookmark or a folder (sometimes called a _group_). Each node in the tree is\nrepresented by a bookmarks.BookmarkTreeNode object.\n\n`BookmarkTreeNode` properties are used throughout the `chrome.bookmarks` API.\nFor example, when you call bookmarks.create, you pass in the new node's parent\n(`parentId`), and, optionally, the node's `index`, `title`, and `url`\nproperties. See bookmarks.BookmarkTreeNode for information about the\nproperties a node can have.\n\n**Note:** You cannot use this API to add or remove entries in the root folder.\nYou also cannot rename, move, or remove the special \"Bookmarks Bar\" and \"Other\nBookmarks\" folders.\n\n### Examples\n\nThe following code creates a folder with the title \"Extension bookmarks\". The\nfirst argument to `create()` specifies properties for the new folder. The\nsecond argument defines a function to be executed after the folder is created.\n\n    \n    \n    chrome.bookmarks.create(\n      {'parentId': bookmarkBar.id, 'title': 'Extension bookmarks'},\n      function(newFolder) {\n        console.log(\"added folder: \" + newFolder.title);\n      },\n    );\n    \n\nThe next snippet creates a bookmark pointing to the developer documentation\nfor extensions. Since nothing bad will happen if creating the bookmark fails,\nthis code doesn't bother to define a callback function.\n\n    \n    \n    chrome.bookmarks.create({\n      'parentId': extensionsFolderId,\n      'title': 'Extensions doc',\n      'url': 'https://developer.chrome.com/docs/extensions',\n    });\n    \n\nTo try this API, install the Bookmarks API example from the chrome-extension-\nsamples repository.\n\n## Types\n\n### BookmarkTreeNode\n\nA node (either a bookmark or a folder) in the bookmark tree. Child nodes are\nordered within their parent folder.\n\n#### Properties\n\n  * children\n\nBookmarkTreeNode[] optional\n\nAn ordered list of children of this node.\n\n  * dateAdded\n\nnumber optional\n\nWhen this node was created, in milliseconds since the epoch (`new\nDate(dateAdded)`).\n\n  * dateGroupModified\n\nnumber optional\n\nWhen the contents of this folder last changed, in milliseconds since the\nepoch.\n\n  * dateLastUsed\n\nnumber optional\n\nChrome 114+\n\nWhen this node was last opened, in milliseconds since the epoch. Not set for\nfolders.\n\n  * folderType\n\nFolderType optional\n\nChrome 134+\n\nIf present, this is a folder that is added by the browser and that cannot be\nmodified by the user or the extension. Child nodes may be modified, if this\nnode does not have the `unmodifiable` property set. Omitted if the node can be\nmodified by the user and the extension (default).\n\nThere may be zero, one or multiple nodes of each folder type. A folder may be\nadded or removed by the browser, but not via the extensions API.\n\n  * id\n\nstring\n\nThe unique identifier for the node. IDs are unique within the current profile,\nand they remain valid even after the browser is restarted.\n\n  * index\n\nnumber optional\n\nThe 0-based position of this node within its parent folder.\n\n  * parentId\n\nstring optional\n\nThe `id` of the parent folder. Omitted for the root node.\n\n  * syncing\n\nboolean\n\nChrome 134+\n\nWhether this node is synced with the user's remote account storage by the\nbrowser. This can be used to distinguish between account and local-only\nversions of the same `FolderType`. The value of this property may change for\nan existing node, for example as a result of user action.\n\nNote: this reflects whether the node is saved to the browser's built-in\naccount provider. It is possible that a node could be synced via a third-\nparty, even if this value is false.\n\nFor managed nodes (nodes where `unmodifiable` is set to `true`), this property\nwill always be `false`.\n\n  * title\n\nstring\n\nThe text displayed for the node.\n\n  * unmodifiable\n\n\"managed\"  \n optional\n\nIndicates the reason why this node is unmodifiable. The `managed` value\nindicates that this node was configured by the system administrator or by the\ncustodian of a supervised user. Omitted if the node can be modified by the\nuser and the extension (default).\n\n  * url\n\nstring optional\n\nThe URL navigated to when a user clicks the bookmark. Omitted for folders.\n\n### BookmarkTreeNodeUnmodifiable\n\nChrome 44+\n\nIndicates the reason why this node is unmodifiable. The `managed` value\nindicates that this node was configured by the system administrator. Omitted\nif the node can be modified by the user and the extension (default).\n\n#### Value\n\n\"managed\"  \n\n### CreateDetails\n\nObject passed to the create() function.\n\n#### Properties\n\n  * index\n\nnumber optional\n\n  * parentId\n\nstring optional\n\nDefaults to the Other Bookmarks folder.\n\n  * title\n\nstring optional\n\n  * url\n\nstring optional\n\n### FolderType\n\nChrome 134+\n\nIndicates the type of folder.\n\n#### Enum\n\n\"bookmarks-bar\"  \nThe folder whose contents is displayed at the top of the browser window.\n\n\"other\"  \nBookmarks which are displayed in the full list of bookmarks on all platforms.\n\n\"mobile\"  \nBookmarks generally available on the user's mobile devices, but modifiable by\nextension or in the bookmarks manager.\n\n\"managed\"  \nA top-level folder that may be present if the system administrator or the\ncustodian of a supervised user has configured bookmarks.\n\n## Properties\n\n### MAX_SUSTAINED_WRITE_OPERATIONS_PER_MINUTE\n\nDeprecated\n\nBookmark write operations are no longer limited by Chrome.\n\n#### Value\n\n1000000  \n\n### MAX_WRITE_OPERATIONS_PER_HOUR\n\nDeprecated\n\nBookmark write operations are no longer limited by Chrome.\n\n#### Value\n\n1000000  \n\n## Methods\n\n### create()\n\nPromise\n\n    \n    \n    chrome.bookmarks.create(  \n      bookmark: CreateDetails,  \n      callback?: function,  \n    )\n\nCreates a bookmark or folder under the specified parentId. If url is NULL or\nmissing, it will be a folder.\n\n#### Parameters\n\n  * bookmark\n\nCreateDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: BookmarkTreeNode) => void\n\n    * result\n\nBookmarkTreeNode\n\n#### Returns\n\n  * Promise<BookmarkTreeNode>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### get()\n\nPromise\n\n    \n    \n    chrome.bookmarks.get(  \n      idOrIdList: string | [string, ...string[]],  \n      callback?: function,  \n    )\n\nRetrieves the specified BookmarkTreeNode(s).\n\n#### Parameters\n\n  * idOrIdList\n\nstring | [string, ...string[]]\n\nA single string-valued id, or an array of string-valued ids\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: BookmarkTreeNode[]) => void\n\n    * results\n\nBookmarkTreeNode[]\n\n#### Returns\n\n  * Promise<BookmarkTreeNode[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getChildren()\n\nPromise\n\n    \n    \n    chrome.bookmarks.getChildren(  \n      id: string,  \n      callback?: function,  \n    )\n\nRetrieves the children of the specified BookmarkTreeNode id.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: BookmarkTreeNode[]) => void\n\n    * results\n\nBookmarkTreeNode[]\n\n#### Returns\n\n  * Promise<BookmarkTreeNode[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getRecent()\n\nPromise\n\n    \n    \n    chrome.bookmarks.getRecent(  \n      numberOfItems: number,  \n      callback?: function,  \n    )\n\nRetrieves the recently added bookmarks.\n\n#### Parameters\n\n  * numberOfItems\n\nnumber\n\nThe maximum number of items to return.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: BookmarkTreeNode[]) => void\n\n    * results\n\nBookmarkTreeNode[]\n\n#### Returns\n\n  * Promise<BookmarkTreeNode[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getSubTree()\n\nPromise\n\n    \n    \n    chrome.bookmarks.getSubTree(  \n      id: string,  \n      callback?: function,  \n    )\n\nRetrieves part of the Bookmarks hierarchy, starting at the specified node.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe ID of the root of the subtree to retrieve.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: BookmarkTreeNode[]) => void\n\n    * results\n\nBookmarkTreeNode[]\n\n#### Returns\n\n  * Promise<BookmarkTreeNode[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getTree()\n\nPromise\n\n    \n    \n    chrome.bookmarks.getTree(  \n      callback?: function,  \n    )\n\nRetrieves the entire Bookmarks hierarchy.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: BookmarkTreeNode[]) => void\n\n    * results\n\nBookmarkTreeNode[]\n\n#### Returns\n\n  * Promise<BookmarkTreeNode[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### move()\n\nPromise\n\n    \n    \n    chrome.bookmarks.move(  \n      id: string,  \n      destination: object,  \n      callback?: function,  \n    )\n\nMoves the specified BookmarkTreeNode to the provided location.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * destination\n\nobject\n\n    * index\n\nnumber optional\n\n    * parentId\n\nstring optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: BookmarkTreeNode) => void\n\n    * result\n\nBookmarkTreeNode\n\n#### Returns\n\n  * Promise<BookmarkTreeNode>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### remove()\n\nPromise\n\n    \n    \n    chrome.bookmarks.remove(  \n      id: string,  \n      callback?: function,  \n    )\n\nRemoves a bookmark or an empty bookmark folder.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeTree()\n\nPromise\n\n    \n    \n    chrome.bookmarks.removeTree(  \n      id: string,  \n      callback?: function,  \n    )\n\nRecursively removes a bookmark folder.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### search()\n\nPromise\n\n    \n    \n    chrome.bookmarks.search(  \n      query: string | object,  \n      callback?: function,  \n    )\n\nSearches for BookmarkTreeNodes matching the given query. Queries specified\nwith an object produce BookmarkTreeNodes matching all specified properties.\n\n#### Parameters\n\n  * query\n\nstring | object\n\nEither a string of words and quoted phrases that are matched against bookmark\nURLs and titles, or an object. If an object, the properties `query`, `url`,\nand `title` may be specified and bookmarks matching all specified properties\nwill be produced.\n\n    * query\n\nstring optional\n\nA string of words and quoted phrases that are matched against bookmark URLs\nand titles.\n\n    * title\n\nstring optional\n\nThe title of the bookmark; matches verbatim.\n\n    * url\n\nstring optional\n\nThe URL of the bookmark; matches verbatim. Note that folders have no URL.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: BookmarkTreeNode[]) => void\n\n    * results\n\nBookmarkTreeNode[]\n\n#### Returns\n\n  * Promise<BookmarkTreeNode[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### update()\n\nPromise\n\n    \n    \n    chrome.bookmarks.update(  \n      id: string,  \n      changes: object,  \n      callback?: function,  \n    )\n\nUpdates the properties of a bookmark or folder. Specify only the properties\nthat you want to change; unspecified properties will be left unchanged.\n**Note:** Currently, only 'title' and 'url' are supported.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * changes\n\nobject\n\n    * title\n\nstring optional\n\n    * url\n\nstring optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: BookmarkTreeNode) => void\n\n    * result\n\nBookmarkTreeNode\n\n#### Returns\n\n  * Promise<BookmarkTreeNode>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onChanged\n\n    \n    \n    chrome.bookmarks.onChanged.addListener(  \n      callback: function,  \n    )\n\nFired when a bookmark or folder changes. **Note:** Currently, only title and\nurl changes trigger this.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, changeInfo: object) => void\n\n    * id\n\nstring\n\n    * changeInfo\n\nobject\n\n      * title\n\nstring\n\n      * url\n\nstring optional\n\n### onChildrenReordered\n\n    \n    \n    chrome.bookmarks.onChildrenReordered.addListener(  \n      callback: function,  \n    )\n\nFired when the children of a folder have changed their order due to the order\nbeing sorted in the UI. This is not called as a result of a move().\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, reorderInfo: object) => void\n\n    * id\n\nstring\n\n    * reorderInfo\n\nobject\n\n      * childIds\n\nstring[]\n\n### onCreated\n\n    \n    \n    chrome.bookmarks.onCreated.addListener(  \n      callback: function,  \n    )\n\nFired when a bookmark or folder is created.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, bookmark: BookmarkTreeNode) => void\n\n    * id\n\nstring\n\n    * bookmark\n\nBookmarkTreeNode\n\n### onImportBegan\n\n    \n    \n    chrome.bookmarks.onImportBegan.addListener(  \n      callback: function,  \n    )\n\nFired when a bookmark import session is begun. Expensive observers should\nignore onCreated updates until onImportEnded is fired. Observers should still\nhandle other notifications immediately.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onImportEnded\n\n    \n    \n    chrome.bookmarks.onImportEnded.addListener(  \n      callback: function,  \n    )\n\nFired when a bookmark import session is ended.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onMoved\n\n    \n    \n    chrome.bookmarks.onMoved.addListener(  \n      callback: function,  \n    )\n\nFired when a bookmark or folder is moved to a different parent folder.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, moveInfo: object) => void\n\n    * id\n\nstring\n\n    * moveInfo\n\nobject\n\n      * index\n\nnumber\n\n      * oldIndex\n\nnumber\n\n      * oldParentId\n\nstring\n\n      * parentId\n\nstring\n\n### onRemoved\n\n    \n    \n    chrome.bookmarks.onRemoved.addListener(  \n      callback: function,  \n    )\n\nFired when a bookmark or folder is removed. When a folder is removed\nrecursively, a single notification is fired for the folder, and none for its\ncontents.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, removeInfo: object) => void\n\n    * id\n\nstring\n\n    * removeInfo\n\nobject\n\n      * index\n\nnumber\n\n      * node\n\nBookmarkTreeNode\n\nChrome 48+\n\n      * parentId\n\nstring\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/browsingData": "#  chrome.browsingData\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.browsingData` API to remove browsing data from a user's local\nprofile.\n\n## Permissions\n\n`browsingData`  \n\nYou must declare the `\"browsingData\"` permission in the extension manifest to\nuse this API.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"browsingData\",\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nThe simplest use-case for this API is a a time-based mechanism for clearing a\nuser's browsing data. Your code should provide a timestamp which indicates the\nhistorical date after which the user's browsing data should be removed. This\ntimestamp is formatted as the number of milliseconds since the Unix epoch\n(which can be retrieved from a JavaScript `Date` object using the `getTime()`\nmethod).\n\nFor example, to clear all of a user's browsing data from the last week, you\nmight write code as follows:\n\n    \n    \n    var callback = function () {\n      // Do something clever here once data has been removed.\n    };\n    \n    var millisecondsPerWeek = 1000 * 60 * 60 * 24 * 7;\n    var oneWeekAgo = (new Date()).getTime() - millisecondsPerWeek;\n    chrome.browsingData.remove({\n      \"since\": oneWeekAgo\n    }, {\n      \"appcache\": true,\n      \"cache\": true,\n      \"cacheStorage\": true,\n      \"cookies\": true,\n      \"downloads\": true,\n      \"fileSystems\": true,\n      \"formData\": true,\n      \"history\": true,\n      \"indexedDB\": true,\n      \"localStorage\": true,\n      \"passwords\": true,\n      \"serviceWorkers\": true,\n      \"webSQL\": true\n    }, callback);\n    \n\nThe `chrome.browsingData.remove()` method lets you remove various types of\nbrowsing data with a single call, and will be much faster than calling\nmultiple more specific methods. If, however, you only want to clear one\nspecific type of browsing data (cookies, for example), the more granular\nmethods offer a readable alternative to a call filled with JSON.\n\n    \n    \n    var callback = function () {\n      // Do something clever here once data has been removed.\n    };\n    \n    var millisecondsPerWeek = 1000 * 60 * 60 * 24 * 7;\n    var oneWeekAgo = (new Date()).getTime() - millisecondsPerWeek;\n    chrome.browsingData.removeCookies({\n      \"since\": oneWeekAgo\n    }, callback);\n    \n\nIf the user is syncing their data, `chrome.browsingData.remove()` may\nautomatically rebuild the cookie for the Sync account after clearing it. This\nis to ensure that Sync can continue working, so that the data can be\neventually deleted on the server. However the more specific\n`chrome.browsingData.removeCookies()` can be used to clear the cookie for the\nSync account, and Sync will be paused in this case.\n\n**Important:** Removing browsing data involves a good deal of heavy lifting in\nthe background, and can take _tens of seconds_ to complete, depending on a\nuser's profile. You should use either the returned promise or the callback to\nkeep your users up to date on the removal's status.\n\n### Specific origins\n\nTo remove data for a specific origin or to exclude a set of origins from\ndeletion, you can use the `RemovalOptions.origins` and\n`RemovalOptions.excludeOrigins` parameters. They can only be applied to\ncookies, cache, and storage (CacheStorage, FileSystems, IndexedDB,\nLocalStorage, ServiceWorkers, and WebSQL).\n\n    \n    \n    chrome.browsingData.remove({\n      \"origins\": [\"https://www.example.com\"]\n    }, {\n      \"cacheStorage\": true,\n      \"cookies\": true,\n      \"fileSystems\": true,\n      \"indexedDB\": true,\n      \"localStorage\": true,\n      \"serviceWorkers\": true,\n      \"webSQL\": true\n    }, callback);\n    \n\n**Important:** As cookies are scoped more broadly than other types of storage,\ndeleting cookies for an origin will delete all cookies of the registrable\ndomain. For example, deleting data for `https://www.example.com` will delete\ncookies with a domain of `.example.com` as well.\n\n### Origin types\n\nAdding an `originTypes` property to the APIs options object lets you specify\nwhich types of origins ought to be effected. Origins are divided into three\ncategories:\n\n  * `unprotectedWeb` covers the general case of websites that users visit without taking any special action. If you don't specify an `originTypes`, the API defaults to removing data from unprotected web origins.\n  * `protectedWeb` covers those web origins that have been installed as hosted applications. Installing Angry Birds, for example, protects the origin `https://chrome.angrybirds.com`, and removes it from the `unprotectedWeb` category. Be careful when triggering deletion of data for these origins: make sure your users know what they're getting, as this will irrevocably remove their game data. No one wants to knock tiny pig houses over more often than necessary.\n  * `extension` covers origins under the `chrome-extensions:` scheme. Removing extension data is, again, something you should be very careful about.\n\nWe could adjust the previous example to remove only data from protected\nwebsites as follows:\n\n    \n    \n    var callback = function () {\n      // Do something clever here once data has been removed.\n    };\n    \n    var millisecondsPerWeek = 1000 * 60 * 60 * 24 * 7;\n    var oneWeekAgo = (new Date()).getTime() - millisecondsPerWeek;\n    chrome.browsingData.remove({\n      \"since\": oneWeekAgo,\n      \"originTypes\": {\n        \"protectedWeb\": true\n      }\n    }, {\n      \"appcache\": true,\n      \"cache\": true,\n      \"cacheStorage\": true,\n      \"cookies\": true,\n      \"downloads\": true,\n      \"fileSystems\": true,\n      \"formData\": true,\n      \"history\": true,\n      \"indexedDB\": true,\n      \"localStorage\": true,\n      \"passwords\": true,\n      \"serviceWorkers\": true,\n      \"webSQL\": true\n    }, callback);\n    \n\n**Warning:** Be careful with the `protectedWeb` and `extension` origin types.\nThese are destructive operations that may surprise your users if they're not\nwell-informed about what to expect when your extension removes data on their\nbehalf.\n\n## Examples\n\nTo try this API, install the browsingData API example from the chrome-\nextension-samples repository.\n\n## Types\n\n### DataTypeSet\n\nA set of data types. Missing data types are interpreted as `false`.\n\n#### Properties\n\n  * appcache\n\nboolean optional\n\nWebsites' appcaches.\n\n  * cache\n\nboolean optional\n\nThe browser's cache.\n\n  * cacheStorage\n\nboolean optional\n\nChrome 72+\n\nCache storage\n\n  * cookies\n\nboolean optional\n\nThe browser's cookies.\n\n  * downloads\n\nboolean optional\n\nThe browser's download list.\n\n  * fileSystems\n\nboolean optional\n\nWebsites' file systems.\n\n  * formData\n\nboolean optional\n\nThe browser's stored form data.\n\n  * history\n\nboolean optional\n\nThe browser's history.\n\n  * indexedDB\n\nboolean optional\n\nWebsites' IndexedDB data.\n\n  * localStorage\n\nboolean optional\n\nWebsites' local storage data.\n\n  * passwords\n\nboolean optional\n\nStored passwords.\n\n  * pluginData\n\nboolean optional\n\nDeprecated since Chrome 88\n\nSupport for Flash has been removed. This data type will be ignored.\n\nPlugins' data.\n\n  * serverBoundCertificates\n\nboolean optional\n\nDeprecated since Chrome 76\n\nSupport for server-bound certificates has been removed. This data type will be\nignored.\n\nServer-bound certificates.\n\n  * serviceWorkers\n\nboolean optional\n\nService Workers.\n\n  * webSQL\n\nboolean optional\n\nWebsites' WebSQL data.\n\n### RemovalOptions\n\nOptions that determine exactly what data will be removed.\n\n#### Properties\n\n  * excludeOrigins\n\nstring[] optional\n\nChrome 74+\n\nWhen present, data for origins in this list is excluded from deletion. Can't\nbe used together with `origins`. Only supported for cookies, storage and\ncache. Cookies are excluded for the whole registrable domain.\n\n  * originTypes\n\nobject optional\n\nAn object whose properties specify which origin types ought to be cleared. If\nthis object isn't specified, it defaults to clearing only \"unprotected\"\norigins. Please ensure that you _really_ want to remove application data\nbefore adding 'protectedWeb' or 'extensions'.\n\n    * extension\n\nboolean optional\n\nExtensions and packaged applications a user has installed (be _really_\ncareful!).\n\n    * protectedWeb\n\nboolean optional\n\nWebsites that have been installed as hosted applications (be careful!).\n\n    * unprotectedWeb\n\nboolean optional\n\nNormal websites.\n\n  * origins\n\n[string, ...string[]] optional\n\nChrome 74+\n\nWhen present, only data for origins in this list is deleted. Only supported\nfor cookies, storage and cache. Cookies are cleared for the whole registrable\ndomain.\n\n  * since\n\nnumber optional\n\nRemove data accumulated on or after this date, represented in milliseconds\nsince the epoch (accessible via the `getTime` method of the JavaScript `Date`\nobject). If absent, defaults to 0 (which would remove all browsing data).\n\n## Methods\n\n### remove()\n\nPromise\n\n    \n    \n    chrome.browsingData.remove(  \n      options: RemovalOptions,  \n      dataToRemove: DataTypeSet,  \n      callback?: function,  \n    )\n\nClears various types of browsing data stored in a user's profile.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * dataToRemove\n\nDataTypeSet\n\nThe set of data types to remove.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeAppcache()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeAppcache(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears websites' appcache data.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeCache()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeCache(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears the browser's cache.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeCacheStorage()\n\nPromise Chrome 72+\n\n    \n    \n    chrome.browsingData.removeCacheStorage(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears websites' cache storage data.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeCookies()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeCookies(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears the browser's cookies and server-bound certificates modified within a\nparticular timeframe.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeDownloads()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeDownloads(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears the browser's list of downloaded files (_not_ the downloaded files\nthemselves).\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeFileSystems()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeFileSystems(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears websites' file system data.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeFormData()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeFormData(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears the browser's stored form data (autofill).\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeHistory()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeHistory(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears the browser's history.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeIndexedDB()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeIndexedDB(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears websites' IndexedDB data.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeLocalStorage()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeLocalStorage(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears websites' local storage data.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removePasswords()\n\nPromise\n\n    \n    \n    chrome.browsingData.removePasswords(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears the browser's stored passwords.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removePluginData()\n\nPromise  Deprecated since Chrome 88\n\n    \n    \n    chrome.browsingData.removePluginData(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nSupport for Flash has been removed. This function has no effect.\n\nClears plugins' data.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeServiceWorkers()\n\nPromise Chrome 72+\n\n    \n    \n    chrome.browsingData.removeServiceWorkers(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears websites' service workers.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeWebSQL()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeWebSQL(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears websites' WebSQL data.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### settings()\n\nPromise\n\n    \n    \n    chrome.browsingData.settings(  \n      callback?: function,  \n    )\n\nReports which types of data are currently selected in the 'Clear browsing\ndata' settings UI. Note: some of the data types included in this API are not\navailable in the settings UI, and some UI settings control more than one data\ntype listed here.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: object) => void\n\n    * result\n\nobject\n\n      * dataRemovalPermitted\n\nDataTypeSet\n\nAll of the types will be present in the result, with values of `true` if they\nare permitted to be removed (e.g., by enterprise policy) and `false` if not.\n\n      * dataToRemove\n\nDataTypeSet\n\nAll of the types will be present in the result, with values of `true` if they\nare both selected to be removed and permitted to be removed, otherwise\n`false`.\n\n      * options\n\nRemovalOptions\n\n#### Returns\n\n  * Promise<object>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/certificateProvider": "#  chrome.certificateProvider\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse this API to expose certificates to the platform which can use these\ncertificates for TLS authentications.\n\n## Permissions\n\n`certificateProvider`  \n\n## Availability\n\nChrome 46+  ChromeOS only\n\n## Concepts and usage\n\nTypical usage of this API to expose client certificates to ChromeOS follows\nthese steps:\n\n  * The Extension registers for the events `onCertificatesUpdateRequested` and `onSignatureRequested`.\n  * The Extension calls `setCertificates()` to provide the initial list of certificates after the initialization.\n  * The Extension monitors the changes in the list of available certificates and calls `setCertificates()` to notify the browser about every such change.\n  * During a TLS handshake, the browser receives a client certificate request. With an `onCertificatesUpdateRequested` event, the browser asks the Extension to report all certificates that it currently provides.\n  * The Extension reports back with the currently available certificates, using the `setCertificates()` method.\n  * The browser matches all available certificates with the client certificate request from the remote host. The matches are presented to the user in a selection dialog.\n  * The user can select a certificate and thereby approve the authentication or abort the authentication.\n\n![Certificate selection\ndialog](/static/docs/extensions/reference/api/images/certificate_provider_selection_dialog.png)\nCertificate selection dialog.\n\n  * If the user aborts the authentication or no certificate matched the request, the TLS client authentication is aborted.\n  * Otherwise, if the user approves the authentication with a certificate provided by this Extension, the browser requests the Extension to sign the data to continue the TLS handshake. The request is sent as a `onSignatureRequested` event.\n  * This event contains input data, declares which algorithm has to be used to generate the signature, and refers to one of the certificates that were reported by this Extension. The Extension must create a signature for the given data using the private key associated with the referenced certificate. Creating the signature might require prepending a DigestInfo and padding the result before the actual signing.\n  * The Extension sends back the signature to the browser using the `reportSignature()` method. If the signature couldn't be calculated, the method has to be called without signature.\n  * If the signature was provided, the browser completes the TLS handshake.\n\nThe actual sequence of steps can be different. For example, the user will not\nbe asked to select a certificate if the enterprise policy to automatically\nselect a certificate is used (see `AutoSelectCertificateForUrls` and Chrome\npolicies for users).\n\nIn the Extension, this can look similar to the following snippet:\n\n    \n    \n    function collectAvailableCertificates() {\n      // Return all certificates that this Extension can currently provide.\n      // For example:\n      return [{\n        certificateChain: [new Uint8Array(...)],\n        supportedAlgorithms: ['RSASSA_PKCS1_v1_5_SHA256']\n      }];\n    }\n    \n    // The Extension calls this function every time the currently available list of\n    // certificates changes, and also once after the Extension's initialization.\n    function onAvailableCertificatesChanged() {\n      chrome.certificateProvider.setCertificates({\n        clientCertificates: collectAvailableCertificates()\n      });\n    }\n    \n    function handleCertificatesUpdateRequest(request) {\n      // Report the currently available certificates as a response to the request\n      // event. This is important for supporting the case when the Extension is\n      // unable to detect the changes proactively.\n      chrome.certificateProvider.setCertificates({\n        certificatesRequestId: request.certificatesRequestId,\n        clientCertificates: collectAvailableCertificates()\n      });\n    }\n    \n    // Returns a private key handle for the given DER-encoded certificate.\n    // |certificate| is an ArrayBuffer.\n    function getPrivateKeyHandle(certificate) {...}\n    \n    // Digests and signs |input| with the given private key. |input| is an\n    // ArrayBuffer. |algorithm| is an Algorithm.\n    // Returns the signature as ArrayBuffer.\n    function signUnhashedData(privateKey, input, algorithm) {...}\n    \n    function handleSignatureRequest(request) {\n      // Look up the handle to the private key of |request.certificate|.\n      const key = getPrivateKeyHandle(request.certificate);\n      if (!key) {\n        // Handle if the key isn't available.\n        console.error('Key for requested certificate no available.');\n    \n        // Abort the request by reporting the error to the API.\n        chrome.certificateProvider.reportSignature({\n          signRequestId: request.signRequestId,\n          error: 'GENERAL_ERROR'\n        });\n        return;\n      }\n    \n      const signature = signUnhashedData(key, request.input, request.algorithm);\n      chrome.certificateProvider.reportSignature({\n        signRequestId: request.signRequestId,\n        signature: signature\n      });\n    }\n    \n    chrome.certificateProvider.onCertificatesUpdateRequested.addListener(\n        handleCertificatesUpdateRequest);\n    chrome.certificateProvider.onSignatureRequested.addListener(\n        handleSignatureRequest);\n    \n\n## Types\n\n### Algorithm\n\nChrome 86+\n\nTypes of supported cryptographic signature algorithms.\n\n#### Enum\n\n\"RSASSA_PKCS1_v1_5_MD5_SHA1\"  \nSpecifies the RSASSA PKCS#1 v1.5 signature algorithm with the MD5-SHA-1\nhashing. The extension must not prepend a DigestInfo prefix but only add\nPKCS#1 padding. This algorithm is deprecated and will never be requested by\nChrome as of version 109.\n\n\"RSASSA_PKCS1_v1_5_SHA1\"  \nSpecifies the RSASSA PKCS#1 v1.5 signature algorithm with the SHA-1 hash\nfunction.\n\n\"RSASSA_PKCS1_v1_5_SHA256\"  \nSpecifies the RSASSA PKCS#1 v1.5 signature algorithm with the SHA-256 hashing\nfunction.\n\n\"RSASSA_PKCS1_v1_5_SHA384\"  \nSpecifies the RSASSA PKCS#1 v1.5 signature algorithm with the SHA-384 hashing\nfunction.\n\n\"RSASSA_PKCS1_v1_5_SHA512\"  \nSpecifies the RSASSA PKCS#1 v1.5 signature algorithm with the SHA-512 hashing\nfunction.\n\n\"RSASSA_PSS_SHA256\"  \nSpecifies the RSASSA PSS signature algorithm with the SHA-256 hashing\nfunction, MGF1 mask generation function and the salt of the same size as the\nhash.\n\n\"RSASSA_PSS_SHA384\"  \nSpecifies the RSASSA PSS signature algorithm with the SHA-384 hashing\nfunction, MGF1 mask generation function and the salt of the same size as the\nhash.\n\n\"RSASSA_PSS_SHA512\"  \nSpecifies the RSASSA PSS signature algorithm with the SHA-512 hashing\nfunction, MGF1 mask generation function and the salt of the same size as the\nhash.\n\n### CertificateInfo\n\n#### Properties\n\n  * certificate\n\nArrayBuffer\n\nMust be the DER encoding of a X.509 certificate. Currently, only certificates\nof RSA keys are supported.\n\n  * supportedHashes\n\nHash[]\n\nMust be set to all hashes supported for this certificate. This extension will\nonly be asked for signatures of digests calculated with one of these hash\nalgorithms. This should be in order of decreasing hash preference.\n\n### CertificatesUpdateRequest\n\nChrome 86+\n\n#### Properties\n\n  * certificatesRequestId\n\nnumber\n\nRequest identifier to be passed to `setCertificates`.\n\n### ClientCertificateInfo\n\nChrome 86+\n\n#### Properties\n\n  * certificateChain\n\nArrayBuffer[]\n\nThe array must contain the DER encoding of the X.509 client certificate as its\nfirst element.\n\nThis must include exactly one certificate.\n\n  * supportedAlgorithms\n\nAlgorithm[]\n\nAll algorithms supported for this certificate. The extension will only be\nasked for signatures using one of these algorithms.\n\n### Error\n\nChrome 86+\n\nTypes of errors that the extension can report.\n\n#### Value\n\n\"GENERAL_ERROR\"  \n\n### Hash\n\nDeprecated. Replaced by `Algorithm`.\n\n#### Enum\n\n\"MD5_SHA1\"  \nSpecifies the MD5 and SHA1 hashing algorithms.\n\n\"SHA1\"  \nSpecifies the SHA1 hashing algorithm.\n\n\"SHA256\"  \nSpecifies the SHA256 hashing algorithm.\n\n\"SHA384\"  \nSpecifies the SHA384 hashing algorithm.\n\n\"SHA512\"  \nSpecifies the SHA512 hashing algorithm.\n\n### PinRequestErrorType\n\nChrome 57+\n\nThe types of errors that can be presented to the user through the requestPin\nfunction.\n\n#### Enum\n\n\"INVALID_PIN\"  \nSpecifies the PIN is invalid.\n\n\"INVALID_PUK\"  \nSpecifies the PUK is invalid.\n\n\"MAX_ATTEMPTS_EXCEEDED\"  \nSpecifies the maximum attempt number has been exceeded.\n\n\"UNKNOWN_ERROR\"  \nSpecifies that the error cannot be represented by the above types.\n\n### PinRequestType\n\nChrome 57+\n\nThe type of code being requested by the extension with requestPin function.\n\n#### Enum\n\n\"PIN\"  \nSpecifies the requested code is a PIN.\n\n\"PUK\"  \nSpecifies the requested code is a PUK.\n\n### PinResponseDetails\n\nChrome 57+\n\n#### Properties\n\n  * userInput\n\nstring optional\n\nThe code provided by the user. Empty if user closed the dialog or some other\nerror occurred.\n\n### ReportSignatureDetails\n\nChrome 86+\n\n#### Properties\n\n  * error\n\n\"GENERAL_ERROR\"  \n optional\n\nError that occurred while generating the signature, if any.\n\n  * signRequestId\n\nnumber\n\nRequest identifier that was received via the `onSignatureRequested` event.\n\n  * signature\n\nArrayBuffer optional\n\nThe signature, if successfully generated.\n\n### RequestPinDetails\n\nChrome 57+\n\n#### Properties\n\n  * attemptsLeft\n\nnumber optional\n\nThe number of attempts left. This is provided so that any UI can present this\ninformation to the user. Chrome is not expected to enforce this, instead\nstopPinRequest should be called by the extension with errorType =\nMAX_ATTEMPTS_EXCEEDED when the number of pin requests is exceeded.\n\n  * errorType\n\nPinRequestErrorType optional\n\nThe error template displayed to the user. This should be set if the previous\nrequest failed, to notify the user of the failure reason.\n\n  * requestType\n\nPinRequestType optional\n\nThe type of code requested. Default is PIN.\n\n  * signRequestId\n\nnumber\n\nThe ID given by Chrome in SignRequest.\n\n### SetCertificatesDetails\n\nChrome 86+\n\n#### Properties\n\n  * certificatesRequestId\n\nnumber optional\n\nWhen called in response to `onCertificatesUpdateRequested`, should contain the\nreceived `certificatesRequestId` value. Otherwise, should be unset.\n\n  * clientCertificates\n\nClientCertificateInfo[]\n\nList of currently available client certificates.\n\n  * error\n\n\"GENERAL_ERROR\"  \n optional\n\nError that occurred while extracting the certificates, if any. This error will\nbe surfaced to the user when appropriate.\n\n### SignatureRequest\n\nChrome 86+\n\n#### Properties\n\n  * algorithm\n\nAlgorithm\n\nSignature algorithm to be used.\n\n  * certificate\n\nArrayBuffer\n\nThe DER encoding of a X.509 certificate. The extension must sign `input` using\nthe associated private key.\n\n  * input\n\nArrayBuffer\n\nData to be signed. Note that the data is not hashed.\n\n  * signRequestId\n\nnumber\n\nRequest identifier to be passed to `reportSignature`.\n\n### SignRequest\n\n#### Properties\n\n  * certificate\n\nArrayBuffer\n\nThe DER encoding of a X.509 certificate. The extension must sign `digest`\nusing the associated private key.\n\n  * digest\n\nArrayBuffer\n\nThe digest that must be signed.\n\n  * hash\n\nHash\n\nRefers to the hash algorithm that was used to create `digest`.\n\n  * signRequestId\n\nnumber\n\nChrome 57+\n\nThe unique ID to be used by the extension should it need to call a method that\nrequires it, e.g. requestPin.\n\n### StopPinRequestDetails\n\nChrome 57+\n\n#### Properties\n\n  * errorType\n\nPinRequestErrorType optional\n\nThe error template. If present it is displayed to user. Intended to contain\nthe reason for stopping the flow if it was caused by an error, e.g.\nMAX_ATTEMPTS_EXCEEDED.\n\n  * signRequestId\n\nnumber\n\nThe ID given by Chrome in SignRequest.\n\n## Methods\n\n### reportSignature()\n\nPromise Chrome 86+\n\n    \n    \n    chrome.certificateProvider.reportSignature(  \n      details: ReportSignatureDetails,  \n      callback?: function,  \n    )\n\nShould be called as a response to `onSignatureRequested`.\n\nThe extension must eventually call this function for every\n`onSignatureRequested` event; the API implementation will stop waiting for\nthis call after some time and respond with a timeout error when this function\nis called.\n\n#### Parameters\n\n  * details\n\nReportSignatureDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### requestPin()\n\nPromise Chrome 57+\n\n    \n    \n    chrome.certificateProvider.requestPin(  \n      details: RequestPinDetails,  \n      callback?: function,  \n    )\n\nRequests the PIN from the user. Only one ongoing request at a time is allowed.\nThe requests issued while another flow is ongoing are rejected. It's the\nextension's responsibility to try again later if another flow is in progress.\n\n#### Parameters\n\n  * details\n\nRequestPinDetails\n\nContains the details about the requested dialog.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details?: PinResponseDetails) => void\n\n    * details\n\nPinResponseDetails optional\n\n#### Returns\n\n  * Promise<PinResponseDetails | undefined>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setCertificates()\n\nPromise Chrome 86+\n\n    \n    \n    chrome.certificateProvider.setCertificates(  \n      details: SetCertificatesDetails,  \n      callback?: function,  \n    )\n\nSets a list of certificates to use in the browser.\n\nThe extension should call this function after initialization and on every\nchange in the set of currently available certificates. The extension should\nalso call this function in response to `onCertificatesUpdateRequested` every\ntime this event is received.\n\n#### Parameters\n\n  * details\n\nSetCertificatesDetails\n\nThe certificates to set. Invalid certificates will be ignored.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### stopPinRequest()\n\nPromise Chrome 57+\n\n    \n    \n    chrome.certificateProvider.stopPinRequest(  \n      details: StopPinRequestDetails,  \n      callback?: function,  \n    )\n\nStops the pin request started by the `requestPin` function.\n\n#### Parameters\n\n  * details\n\nStopPinRequestDetails\n\nContains the details about the reason for stopping the request flow.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onCertificatesUpdateRequested\n\nChrome 86+\n\n    \n    \n    chrome.certificateProvider.onCertificatesUpdateRequested.addListener(  \n      callback: function,  \n    )\n\nThis event fires if the certificates set via `setCertificates` are\ninsufficient or the browser requests updated information. The extension must\ncall `setCertificates` with the updated list of certificates and the received\n`certificatesRequestId`.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (request: CertificatesUpdateRequest) => void\n\n    * request\n\nCertificatesUpdateRequest\n\n### onSignatureRequested\n\nChrome 86+\n\n    \n    \n    chrome.certificateProvider.onSignatureRequested.addListener(  \n      callback: function,  \n    )\n\nThis event fires every time the browser needs to sign a message using a\ncertificate provided by this extension via `setCertificates`.\n\nThe extension must sign the input data from `request` using the appropriate\nalgorithm and private key and return it by calling `reportSignature` with the\nreceived `signRequestId`.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (request: SignatureRequest) => void\n\n    * request\n\nSignatureRequest\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/commands": "#  chrome.commands\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the commands API to add keyboard shortcuts that trigger actions in your\nextension, for example, an action to open the browser action or send a command\nto the extension.\n\n## Manifest\n\nThe following keys must be declared in the manifest to use this API.\n\n`\"commands\"`  \n\n## Concepts and usage\n\nThe Commands API allows extension developers to define specific commands, and\nbind them to a default key combination. Each command an extension accepts must\nbe declared as properties of the `\"commands\"` object in the extension's\nmanifest.\n\nThe property key is used as the command's name. Command objects can take two\nproperties.\n\n`suggested_key`\n\n    \n\nAn optional property that declares default keyboard shortcuts for the command.\nIf omitted, the command will be unbound. This property can either take a\nstring or an object value.\n\n  * **A string value** specifies the default keyboard shortcut that should be used across all platforms.\n\n  * **An object value** allows the extension developer to customize the keyboard shortcut for each platform. When providing platform-specific shortcuts, valid object properties are `default`, `chromeos`, `linux`, `mac`, and `windows`.\n\nSee Key combination requirements for additional details.\n\n`description`\n\n    \n\nA string used to provide the user with a short description of the command's\npurpose. This string appears in extension keyboard shortcut management UI.\nDescriptions are required for standard commands, but are ignored for Action\ncommands.\n\nAn extension can have many commands, but may specify at most four suggested\nkeyboard shortcuts. The user can manually add more shortcuts from the\n`chrome://extensions/shortcuts` dialog.\n\n### Supported Keys\n\nThe following keys are usable command shortcuts. Key definitions are case\nsensitive. Attempting to load an extension with an incorrectly cased key will\nresult in a manifest parse error at installation time.\n\nAlpha keys\n\n    `A`  `Z`\nNumeric keys\n\n    `0`  `9`\nStandard key strings\n\n    \n\nGeneral`Comma`, `Period`, `Home`, `End`, `PageUp`, `PageDown`, `Space`,\n`Insert`, `Delete`\n\n    \n\nArrow keys`Up`, `Down`, `Left`, `Right`\n\n    \n\nMedia Keys`MediaNextTrack`, `MediaPlayPause`, `MediaPrevTrack`, `MediaStop`\n\nModifier key strings\n\n    \n\n`Ctrl`, `Alt`, `Shift`, `MacCtrl` (macOS only), `Command` (macOS only),\n`Search` (ChromeOS only)\n\n### Key combination requirements\n\n  * Extension command shortcuts must include either `Ctrl` or `Alt`.\n\n    * Modifiers **cannot** be used in combination with Media Keys.\n\n    * On many macOS keyboards, `Alt` refers to the Option key.\n\n    * On macOS, `Command` or `MacCtrl` can also be used in place of `Ctrl` or `Alt` (see next bullet point).\n\n  * On macOS `Ctrl` is automatically converted into `Command`.\n\n    * `Command` can also be used in the `\"mac\"` shortcut to explicitly refer to the Command key.\n\n    * To use the Control key on macOS, replace `Ctrl` with `MacCtrl` when defining the `\"mac\"` shortcut.\n\n    * Using `MacCtrl` in the combination for another platform will cause a validation error and prevent the extension from being installed.\n\n  * `Shift` is an optional modifier on all platforms.\n\n  * `Search` is an optional modifier exclusive to ChromeOS.\n\n  * Certain operating system and Chrome shortcuts (e.g. window management) always take priority over Extension command shortcuts and cannot be overridden.\n\n**Note:** Key combinations that involve `Ctrl+Alt` are not permitted in order\nto avoid conflicts with the `AltGr` key.\n\n### Handle command events\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"commands\": {\n        \"run-foo\": {\n          \"suggested_key\": {\n            \"default\": \"Ctrl+Shift+Y\",\n            \"mac\": \"Command+Shift+Y\"\n          },\n          \"description\": \"Run \\\"foo\\\" on the current page.\"\n        },\n        \"_execute_action\": {\n          \"suggested_key\": {\n            \"windows\": \"Ctrl+Shift+Y\",\n            \"mac\": \"Command+Shift+Y\",\n            \"chromeos\": \"Ctrl+Shift+U\",\n            \"linux\": \"Ctrl+Shift+J\"\n          }\n        }\n      },\n      ...\n    }\n    \n\nIn your service worker, you can bind a handler to each of the commands defined\nin the manifest using `onCommand.addListener`. For example:\n\nservice-worker.js:\n\n    \n    \n    chrome.commands.onCommand.addListener((command) => {\n      console.log(`Command: ${command}`);\n    });\n    \n\n### Action commands\n\nThe `_execute_action` (Manifest V3), `_execute_browser_action` (Manifest V2),\nand `_execute_page_action` (Manifest V2) commands are reserved for the action\nof trigger your action, browser action, or page action respectively. These\ncommands don't dispatch command.onCommand events like standard commands.\n\nIf you need to take action based on your popup opening, consider listening for\na DOMContentLoaded event inside your popup's JavaScript.\n\n### Scope\n\nBy default, commands are scoped to the Chrome browser. This means that when\nthe browser does not have focus, command shortcuts are inactive. Beginning in\nChrome 35, extension developers can optionally mark a command as \"global\".\nGlobal commands also work while Chrome _does not_ have focus.\n\n**Note:** ChromeOS does not support global commands.\n\nKeyboard shortcut suggestions for global commands are limited to\n`Ctrl+Shift+[0..9]`. This is a protective measure to minimize the risk of\noverriding shortcuts in other applications since if, for example, `Alt+P` were\nto be allowed as global, the keyboard shortcut for opening a print dialog\nmight not work in other applications.\n\nEnd users are free to remap global commands to their preferred key combination\nusing the UI exposed at `chrome://extensions/shortcuts`.\n\nExample:\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"commands\": {\n        \"toggle-feature-foo\": {\n          \"suggested_key\": {\n            \"default\": \"Ctrl+Shift+5\"\n          },\n          \"description\": \"Toggle feature foo\",\n          \"global\": true\n        }\n      },\n      ...\n    }\n    \n\n## Examples\n\nThe following examples flex the core functionality of the Commands API.\n\n### Basic command\n\nCommands allow extensions to map logic to keyboard shortcuts that can be\ninvoked by the user. At its most basic, a command only requires a command\ndeclaration in the extension's manifest and a listener registration as shown\nin the following example.\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"Command demo - basic\",\n      \"version\": \"1.0\",\n      \"manifest_version\": 3,\n      \"background\": {\n        \"service_worker\": \"service-worker.js\"\n      },\n      \"commands\": {\n        \"inject-script\": {\n          \"suggested_key\": \"Ctrl+Shift+Y\",\n          \"description\": \"Inject a script on the page\"\n        }\n      }\n    }\n    \n\nservice-worker.js:\n\n    \n    \n    chrome.commands.onCommand.addListener((command) => {\n      console.log(`Command \"${command}\" triggered`);\n    });\n    \n\n### Action command\n\nAs described in the Concepts and usage section, you can also map a command to\nan extension's action. The following example injects a content script that\nshows an alert on the current page when the user either clicks the extension's\naction or triggers the keyboard shortcut.\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"Commands demo - action invocation\",\n      \"version\": \"1.0\",\n      \"manifest_version\": 3,\n      \"background\": {\n        \"service_worker\": \"service-worker.js\"\n      },\n      \"permissions\": [\"activeTab\", \"scripting\"],\n      \"action\": {},\n      \"commands\": {\n        \"_execute_action\": {\n          \"suggested_key\": {\n            \"default\": \"Ctrl+U\",\n            \"mac\": \"Command+U\"\n          }\n        }\n      }\n    }\n    \n\nservice-worker.js:\n\n    \n    \n    chrome.action.onClicked.addListener((tab) => {\n      chrome.scripting.executeScript({\n        target: {tabId: tab.id},\n        func: contentScriptFunc,\n        args: ['action'],\n      });\n    });\n    \n    function contentScriptFunc(name) {\n      alert(`\"${name}\" executed`);\n    }\n    \n    // This callback WILL NOT be called for \"_execute_action\"\n    chrome.commands.onCommand.addListener((command) => {\n      console.log(`Command \"${command}\" called`);\n    });\n    \n\n### Verify commands registered\n\nIf an extension attempts to register a shortcut that is already used by\nanother extension, the second extension's shortcut won't register as expected.\nYou can provide a more robust end user experience by anticipating this\npossibility and checking for collisions at install time.\n\nservice-worker.js:\n\n    \n    \n    chrome.runtime.onInstalled.addListener((details) => {\n      if (details.reason === chrome.runtime.OnInstalledReason.INSTALL) {\n        checkCommandShortcuts();\n      }\n    });\n    \n    // Only use this function during the initial install phase. After\n    // installation the user may have intentionally unassigned commands.\n    function checkCommandShortcuts() {\n      chrome.commands.getAll((commands) => {\n        let missingShortcuts = [];\n    \n        for (let {name, shortcut} of commands) {\n          if (shortcut === '') {\n            missingShortcuts.push(name);\n          }\n        }\n    \n        if (missingShortcuts.length > 0) {\n          // Update the extension UI to inform the user that one or more\n          // commands are currently unassigned.\n        }\n      });\n    }\n    \n\n## Types\n\n### Command\n\n#### Properties\n\n  * description\n\nstring optional\n\nThe Extension Command description\n\n  * name\n\nstring optional\n\nThe name of the Extension Command\n\n  * shortcut\n\nstring optional\n\nThe shortcut active for this command, or blank if not active.\n\n## Methods\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.commands.getAll(  \n      callback?: function,  \n    )\n\nReturns all the registered extension commands for this extension and their\nshortcut (if active). Before Chrome 110, this command did not return\n`_execute_action`.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (commands: Command[]) => void\n\n    * commands\n\nCommand[]\n\n#### Returns\n\n  * Promise<Command[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onCommand\n\n    \n    \n    chrome.commands.onCommand.addListener(  \n      callback: function,  \n    )\n\nFired when a registered command is activated using a keyboard shortcut.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (command: string, tab?: tabs.Tab) => void\n\n    * command\n\nstring\n\n    * tab\n\ntabs.Tab optional\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/contentSettings": "#  chrome.contentSettings\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.contentSettings` API to change settings that control whether\nwebsites can use features such as cookies, JavaScript, and plugins. More\ngenerally speaking, content settings allow you to customize Chrome's behavior\non a per-site basis instead of globally.\n\n## Permissions\n\n`contentSettings`  \n\nYou must declare the `\"contentSettings\"` permission in your extension's\nmanifest to use the API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"contentSettings\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\n### Content setting patterns\n\nYou can use patterns to specify the websites that each content setting\naffects. For example, `https://*.youtube.com/*` specifies youtube.com and all\nof its subdomains. The syntax for content setting patterns is the same as for\nmatch patterns, with a few differences:\n\n  * For `http`, `https`, and `ftp` URLs, the path must be a wildcard (`/*`). For `file` URLs, the path must be completely specified and **must not** contain wildcards.\n  * In contrast to match patterns, content setting patterns can specify a port number. If a port number is specified, the pattern only matches websites with that port. If no port number is specified, the pattern matches all ports.\n\n### Pattern precedence\n\nWhen more than one content setting rule applies for a given site, the rule\nwith the more specific pattern takes precedence.\n\nFor example, the following patterns are ordered by precedence:\n\n  1. `https://www.example.com/*`\n  2. `https://*.example.com/*` (matching example.com and all subdomains)\n  3. `<all_urls>` (matching every URL)\n\nThree kinds of wildcards affect how specific a pattern is:\n\n  * Wildcards in the port (for example `https://www.example.com:*/*`)\n  * Wildcards in the scheme (for example `*://www.example.com:123/*`)\n  * Wildcards in the hostname (for example `https://*.example.com:123/*`)\n\nIf a pattern is more specific than another pattern in one part but less\nspecific in another part, the different parts are checked in the following\norder: hostname, scheme, port. For example, the following patterns are ordered\nby precedence:\n\n  1. `https://www.example.com:*/*` Specifies the hostname and scheme.\n  2. `*:/www.example.com:123/*` Not as high, because although it specifies the hostname, it doesn't specify the scheme.\n  3. `https://*.example.com:123/*` Lower because although it specifies the port and scheme, it has a wildcard in the hostname.\n\n### Primary and secondary patterns\n\nThe URL taken into account when deciding which content setting to apply\ndepends on the content type. For example, for `contentSettings.notifications`\nsettings are based on the URL shown in the omnibox. This URL is called the\n\"primary\" URL.\n\nSome content types can take additional URLs into account. For example, whether\na site is allowed to set a `contentSettings.cookies` is decided based on the\nURL of the HTTP request (which is the primary URL in this case) as well as the\nURL shown in the omnibox (which is called the \"secondary\" URL).\n\nIf multiple rules have primary and secondary patterns, the rule with the more\nspecific primary pattern takes precedence. If there multiple rules have the\nsame primary pattern, the rule with the more specific secondary pattern takes\nprecedence. For example, the following list of primary/secondary pattern pairs\nis ordered by precedence:\n\nPrecedence| Primary pattern| Secondary pattern  \n---|---|---  \n1| `https://www.moose.com/*`,| `https://www.wombat.com/*`  \n2| `https://www.moose.com/*`,| `<all_urls>`  \n3| `<all_urls>`,| `https://www.wombat.com/*`  \n4| `<all_urls>`,| `<all_urls>`  \n  \nSecondary patterns are not supported for the images content setting.\n\n### Resource identifiers\n\nResource identifiers allow you to specify content settings for specific\nsubtypes of a content type. Currently, the only content type that supports\nresource identifiers is `contentSettings.plugins`, where a resource identifier\nidentifies a specific plugin. When applying content settings, first the\nsettings for the specific plugin are checked. If there are no settings found\nfor the specific plugin, the general content settings for plugins are checked.\n\nFor example, if a content setting rule has the resource identifier `adobe-\nflash-player` and the pattern `<all_urls>`, it takes precedence over a rule\nwithout a resource identifier and the pattern `https://www.example.com/*`,\neven if that pattern is more specific.\n\nYou can get a list of resource identifiers for a content type by calling the\n`contentSettings.ContentSetting.getResourceIdentifiers()` method. The returned\nlist can change with the set of installed plugins on the user's machine, but\nChrome tries to keep the identifiers stable across plugin updates.\n\n## Examples\n\nTo try this API, install the contentSettings API example from the chrome-\nextension-samples repository.\n\n## Types\n\n### AutoVerifyContentSetting\n\nChrome 113+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n### CameraContentSetting\n\nChrome 46+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n\"ask\"  \n\n### ClipboardContentSetting\n\nChrome 121+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n\"ask\"  \n\n### ContentSetting\n\n#### Properties\n\n  * clear\n\nvoid\n\nPromise\n\nClear all content setting rules set by this extension.\n\nThe `clear` function looks like:\n\n        \n        (details: object, callback?: function) => {...}\n\n    * details\n\nobject\n\n      * scope\n\nScope optional\n\nWhere to clear the setting (default: regular).\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * get\n\nvoid\n\nPromise\n\nGets the current content setting for a given pair of URLs.\n\nThe `get` function looks like:\n\n        \n        (details: object, callback?: function) => {...}\n\n    * details\n\nobject\n\n      * incognito\n\nboolean optional\n\nWhether to check the content settings for an incognito session. (default\nfalse)\n\n      * primaryUrl\n\nstring\n\nThe primary URL for which the content setting should be retrieved. Note that\nthe meaning of a primary URL depends on the content type.\n\n      * resourceIdentifier\n\nResourceIdentifier optional\n\nA more specific identifier of the type of content for which the settings\nshould be retrieved.\n\n      * secondaryUrl\n\nstring optional\n\nThe secondary URL for which the content setting should be retrieved. Defaults\nto the primary URL. Note that the meaning of a secondary URL depends on the\ncontent type, and not all content types use secondary URLs.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (details: object) => void\n\n      * details\n\nobject\n\n        * setting\n\nT\n\nThe content setting. See the description of the individual ContentSetting\nobjects for the possible values.\n\n    * returns\n\nPromise<object>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * getResourceIdentifiers\n\nvoid\n\nPromise\n\nThe `getResourceIdentifiers` function looks like:\n\n        \n        (callback?: function) => {...}\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (resourceIdentifiers?: ResourceIdentifier[]) => void\n\n      * resourceIdentifiers\n\nResourceIdentifier[] optional\n\nA list of resource identifiers for this content type, or `undefined` if this\ncontent type does not use resource identifiers.\n\n    * returns\n\nPromise<ResourceIdentifier[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * set\n\nvoid\n\nPromise\n\nApplies a new content setting rule.\n\nThe `set` function looks like:\n\n        \n        (details: object, callback?: function) => {...}\n\n    * details\n\nobject\n\n      * primaryPattern\n\nstring\n\nThe pattern for the primary URL. For details on the format of a pattern, see\nContent Setting Patterns.\n\n      * resourceIdentifier\n\nResourceIdentifier optional\n\nThe resource identifier for the content type.\n\n      * scope\n\nScope optional\n\nWhere to set the setting (default: regular).\n\n      * secondaryPattern\n\nstring optional\n\nThe pattern for the secondary URL. Defaults to matching all URLs. For details\non the format of a pattern, see Content Setting Patterns.\n\n      * setting\n\nany\n\nThe setting applied by this rule. See the description of the individual\nContentSetting objects for the possible values.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### CookiesContentSetting\n\nChrome 44+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n\"session_only\"  \n\n### FullscreenContentSetting\n\nChrome 44+\n\n#### Value\n\n\"allow\"  \n\n### ImagesContentSetting\n\nChrome 44+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n### JavascriptContentSetting\n\nChrome 44+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n### LocationContentSetting\n\nChrome 44+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n\"ask\"  \n\n### MicrophoneContentSetting\n\nChrome 46+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n\"ask\"  \n\n### MouselockContentSetting\n\nChrome 44+\n\n#### Value\n\n\"allow\"  \n\n### MultipleAutomaticDownloadsContentSetting\n\nChrome 44+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n\"ask\"  \n\n### NotificationsContentSetting\n\nChrome 44+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n\"ask\"  \n\n### PluginsContentSetting\n\nChrome 44+\n\n#### Value\n\n\"block\"  \n\n### PopupsContentSetting\n\nChrome 44+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n### PpapiBrokerContentSetting\n\nChrome 44+\n\n#### Value\n\n\"block\"  \n\n### ResourceIdentifier\n\nThe only content type using resource identifiers is `contentSettings.plugins`.\nFor more information, see Resource Identifiers.\n\n#### Properties\n\n  * description\n\nstring optional\n\nA human readable description of the resource.\n\n  * id\n\nstring\n\nThe resource identifier for the given content type.\n\n### Scope\n\nChrome 44+\n\nThe scope of the ContentSetting. One of `regular`: setting for regular profile\n(which is inherited by the incognito profile if not overridden elsewhere),\n`incognito\\_session\\_only`: setting for incognito profile that can only be set\nduring an incognito session and is deleted when the incognito session ends\n(overrides regular settings).\n\n#### Enum\n\n\"regular\"  \n\n\"incognito_session_only\"  \n\n## Properties\n\n### automaticDownloads\n\nWhether to allow sites to download multiple files automatically. One of\n`allow`: Allow sites to download multiple files automatically, `block`: Don't\nallow sites to download multiple files automatically, `ask`: Ask when a site\nwants to download files automatically after the first file. Default is `ask`.\nThe primary URL is the URL of the top-level frame. The secondary URL is not\nused.\n\n#### Type\n\nContentSetting<MultipleAutomaticDownloadsContentSetting>\n\n### autoVerify\n\nChrome 113+\n\nWhether to allow sites to use the Private State Tokens API. One of `allow`:\nAllow sites to use the Private State Tokens API, `block`: Block sites from\nusing the Private State Tokens API. Default is `allow`. When calling `set()`,\nthe primary URL pattern must be `<all_urls>`. The secondary URL is not used.\n\n#### Type\n\nContentSetting<AutoVerifyContentSetting>\n\n### camera\n\nChrome 46+\n\nWhether to allow sites to access the camera. One of `allow`: Allow sites to\naccess the camera, `block`: Don't allow sites to access the camera, `ask`: Ask\nwhen a site wants to access the camera. Default is `ask`. The primary URL is\nthe URL of the document which requested camera access. The secondary URL is\nnot used. NOTE: The 'allow' setting is not valid if both patterns are\n'<all_urls>'.\n\n#### Type\n\nContentSetting<CameraContentSetting>\n\n### clipboard\n\nChrome 121+\n\nWhether to allow sites to access the clipboard via advanced capabilities of\nthe Async Clipboard API. \"Advanced\" capabilities include anything besides\nwriting built-in formats after a user gesture, i.e. the ability to read, the\nability to write custom formats, and the ability to write without a user\ngesture. One of `allow`: Allow sites to use advanced clipboard capabilities,\n`block`: Don't allow sites to use advanced clipboard capabilties, `ask`: Ask\nwhen a site wants to use advanced clipboard capabilities. Default is `ask`.\nThe primary URL is the URL of the document which requested clipboard access.\nThe secondary URL is not used.\n\n#### Type\n\nContentSetting<ClipboardContentSetting>\n\n### cookies\n\nWhether to allow cookies and other local data to be set by websites. One of\n`allow`: Accept cookies, `block`: Block cookies, `session\\_only`: Accept\ncookies only for the current session. Default is `allow`. The primary URL is\nthe URL representing the cookie origin. The secondary URL is the URL of the\ntop-level frame.\n\n#### Type\n\nContentSetting<CookiesContentSetting>\n\n### fullscreen\n\n_Deprecated._ No longer has any effect. Fullscreen permission is now\nautomatically granted for all sites. Value is always `allow`.\n\n#### Type\n\nContentSetting<FullscreenContentSetting>\n\n### images\n\nWhether to show images. One of `allow`: Show images, `block`: Don't show\nimages. Default is `allow`. The primary URL is the URL of the top-level frame.\nThe secondary URL is the URL of the image.\n\n#### Type\n\nContentSetting<ImagesContentSetting>\n\n### javascript\n\nWhether to run JavaScript. One of `allow`: Run JavaScript, `block`: Don't run\nJavaScript. Default is `allow`. The primary URL is the URL of the top-level\nframe. The secondary URL is not used.\n\n#### Type\n\nContentSetting<JavascriptContentSetting>\n\n### location\n\nWhether to allow Geolocation. One of `allow`: Allow sites to track your\nphysical location, `block`: Don't allow sites to track your physical location,\n`ask`: Ask before allowing sites to track your physical location. Default is\n`ask`. The primary URL is the URL of the document which requested location\ndata. The secondary URL is the URL of the top-level frame (which may or may\nnot differ from the requesting URL).\n\n#### Type\n\nContentSetting<LocationContentSetting>\n\n### microphone\n\nChrome 46+\n\nWhether to allow sites to access the microphone. One of `allow`: Allow sites\nto access the microphone, `block`: Don't allow sites to access the microphone,\n`ask`: Ask when a site wants to access the microphone. Default is `ask`. The\nprimary URL is the URL of the document which requested microphone access. The\nsecondary URL is not used. NOTE: The 'allow' setting is not valid if both\npatterns are '<all_urls>'.\n\n#### Type\n\nContentSetting<MicrophoneContentSetting>\n\n### mouselock\n\n_Deprecated._ No longer has any effect. Mouse lock permission is now\nautomatically granted for all sites. Value is always `allow`.\n\n#### Type\n\nContentSetting<MouselockContentSetting>\n\n### notifications\n\nWhether to allow sites to show desktop notifications. One of `allow`: Allow\nsites to show desktop notifications, `block`: Don't allow sites to show\ndesktop notifications, `ask`: Ask when a site wants to show desktop\nnotifications. Default is `ask`. The primary URL is the URL of the document\nwhich wants to show the notification. The secondary URL is not used.\n\n#### Type\n\nContentSetting<NotificationsContentSetting>\n\n### plugins\n\n_Deprecated._ With Flash support removed in Chrome 88, this permission no\nlonger has any effect. Value is always `block`. Calls to `set()` and `clear()`\nwill be ignored.\n\n#### Type\n\nContentSetting<PluginsContentSetting>\n\n### popups\n\nWhether to allow sites to show pop-ups. One of `allow`: Allow sites to show\npop-ups, `block`: Don't allow sites to show pop-ups. Default is `block`. The\nprimary URL is the URL of the top-level frame. The secondary URL is not used.\n\n#### Type\n\nContentSetting<PopupsContentSetting>\n\n### unsandboxedPlugins\n\n_Deprecated._ Previously, controlled whether to allow sites to run plugins\nunsandboxed, however, with the Flash broker process removed in Chrome 88, this\npermission no longer has any effect. Value is always `block`. Calls to `set()`\nand `clear()` will be ignored.\n\n#### Type\n\nContentSetting<PpapiBrokerContentSetting>\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/contextMenus": "#  chrome.contextMenus\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.contextMenus` API to add items to Google Chrome's context\nmenu. You can choose what types of objects your context menu additions apply\nto, such as images, hyperlinks, and pages.\n\n## Permissions\n\n`contextMenus`  \n\nYou must declare the `\"contextMenus\"` permission in your extension's manifest\nto use the API. Also, you should specify a 16 by 16-pixel icon for display\nnext to your menu item. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"contextMenus\"\n      ],\n      \"icons\": {\n        \"16\": \"icon-bitty.png\",\n        \"48\": \"icon-small.png\",\n        \"128\": \"icon-large.png\"\n      },\n      ...\n    }\n    \n\n## Concepts and usage\n\nContext menu items can appear in any document (or frame within a document),\neven those with file:// or chrome:// URLs. To control which documents your\nitems can appear in, specify the `documentUrlPatterns` field when you call the\n`create()` or `update()` methods.\n\nYou can create as many context menu items as you need, but if more than one\nfrom your extension is visible at once, Google Chrome automatically collapses\nthem into a single parent menu.\n\n## Examples\n\nTo try this API, install the contextMenus API example from the chrome-\nextension-samples repository.\n\n## Types\n\n### ContextType\n\nChrome 44+\n\nThe different contexts a menu can appear in. Specifying 'all' is equivalent to\nthe combination of all other contexts except for 'launcher'. The 'launcher'\ncontext is only supported by apps and is used to add menu items to the context\nmenu that appears when clicking the app icon in the launcher/taskbar/dock/etc.\nDifferent platforms might put limitations on what is actually supported in a\nlauncher context menu.\n\n#### Enum\n\n\"all\"  \n\n\"page\"  \n\n\"frame\"  \n\n\"selection\"  \n\n\"link\"  \n\n\"editable\"  \n\n\"image\"  \n\n\"video\"  \n\n\"audio\"  \n\n\"launcher\"  \n\n\"browser_action\"  \n\n\"page_action\"  \n\n\"action\"  \n\n### CreateProperties\n\nChrome 123+\n\nProperties of the new context menu item.\n\n#### Properties\n\n  * checked\n\nboolean optional\n\nThe initial state of a checkbox or radio button: `true` for selected, `false`\nfor unselected. Only one radio button can be selected at a time in a given\ngroup.\n\n  * contexts\n\n[ContextType, ...ContextType[]] optional\n\nList of contexts this menu item will appear in. Defaults to `['page']`.\n\n  * documentUrlPatterns\n\nstring[] optional\n\nRestricts the item to apply only to documents or frames whose URL matches one\nof the given patterns. For details on pattern formats, see Match Patterns.\n\n  * enabled\n\nboolean optional\n\nWhether this context menu item is enabled or disabled. Defaults to `true`.\n\n  * id\n\nstring optional\n\nThe unique ID to assign to this item. Mandatory for event pages. Cannot be the\nsame as another ID for this extension.\n\n  * parentId\n\nstring | number optional\n\nThe ID of a parent menu item; this makes the item a child of a previously\nadded item.\n\n  * targetUrlPatterns\n\nstring[] optional\n\nSimilar to `documentUrlPatterns`, filters based on the `src` attribute of\n`img`, `audio`, and `video` tags and the `href` attribute of `a` tags.\n\n  * title\n\nstring optional\n\nThe text to display in the item; this is _required_ unless `type` is\n`separator`. When the context is `selection`, use `%s` within the string to\nshow the selected text. For example, if this parameter's value is \"Translate\n'%s' to Pig Latin\" and the user selects the word \"cool\", the context menu item\nfor the selection is \"Translate 'cool' to Pig Latin\".\n\n  * type\n\nItemType optional\n\nThe type of menu item. Defaults to `normal`.\n\n  * visible\n\nboolean optional\n\nWhether the item is visible in the menu.\n\n  * onclick\n\nvoid optional\n\nA function that is called back when the menu item is clicked. This is not\navailable inside of a service worker; instead, you should register a listener\nfor `contextMenus.onClicked`.\n\nThe `onclick` function looks like:\n\n        \n        (info: OnClickData, tab: Tab) => {...}\n\n    * info\n\nOnClickData\n\nInformation about the item clicked and the context where the click happened.\n\n    * tab\n\nTab\n\nThe details of the tab where the click took place. This parameter is not\npresent for platform apps.\n\n### ItemType\n\nChrome 44+\n\nThe type of menu item.\n\n#### Enum\n\n\"normal\"  \n\n\"checkbox\"  \n\n\"radio\"  \n\n\"separator\"  \n\n### OnClickData\n\nInformation sent when a context menu item is clicked.\n\n#### Properties\n\n  * checked\n\nboolean optional\n\nA flag indicating the state of a checkbox or radio item after it is clicked.\n\n  * editable\n\nboolean\n\nA flag indicating whether the element is editable (text input, textarea,\netc.).\n\n  * frameId\n\nnumber optional\n\nChrome 51+\n\nThe ID of the frame of the element where the context menu was clicked, if it\nwas in a frame.\n\n  * frameUrl\n\nstring optional\n\nThe URL of the frame of the element where the context menu was clicked, if it\nwas in a frame.\n\n  * linkUrl\n\nstring optional\n\nIf the element is a link, the URL it points to.\n\n  * mediaType\n\nstring optional\n\nOne of 'image', 'video', or 'audio' if the context menu was activated on one\nof these types of elements.\n\n  * menuItemId\n\nstring | number\n\nThe ID of the menu item that was clicked.\n\n  * pageUrl\n\nstring optional\n\nThe URL of the page where the menu item was clicked. This property is not set\nif the click occured in a context where there is no current page, such as in a\nlauncher context menu.\n\n  * parentMenuItemId\n\nstring | number optional\n\nThe parent ID, if any, for the item clicked.\n\n  * selectionText\n\nstring optional\n\nThe text for the context selection, if any.\n\n  * srcUrl\n\nstring optional\n\nWill be present for elements with a 'src' URL.\n\n  * wasChecked\n\nboolean optional\n\nA flag indicating the state of a checkbox or radio item before it was clicked.\n\n## Properties\n\n### ACTION_MENU_TOP_LEVEL_LIMIT\n\nThe maximum number of top level extension items that can be added to an\nextension action context menu. Any items beyond this limit will be ignored.\n\n#### Value\n\n6  \n\n## Methods\n\n### create()\n\n    \n    \n    chrome.contextMenus.create(  \n      createProperties: CreateProperties,  \n      callback?: function,  \n    )\n\nCreates a new context menu item. If an error occurs during creation, it may\nnot be detected until the creation callback fires; details will be in\n`runtime.lastError`.\n\n#### Parameters\n\n  * createProperties\n\nCreateProperties\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * number | string\n\nThe ID of the newly created item.\n\n### remove()\n\nPromise\n\n    \n    \n    chrome.contextMenus.remove(  \n      menuItemId: string | number,  \n      callback?: function,  \n    )\n\nRemoves a context menu item.\n\n#### Parameters\n\n  * menuItemId\n\nstring | number\n\nThe ID of the context menu item to remove.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 123+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeAll()\n\nPromise\n\n    \n    \n    chrome.contextMenus.removeAll(  \n      callback?: function,  \n    )\n\nRemoves all context menu items added by this extension.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 123+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### update()\n\nPromise\n\n    \n    \n    chrome.contextMenus.update(  \n      id: string | number,  \n      updateProperties: object,  \n      callback?: function,  \n    )\n\nUpdates a previously created context menu item.\n\n#### Parameters\n\n  * id\n\nstring | number\n\nThe ID of the item to update.\n\n  * updateProperties\n\nobject\n\nThe properties to update. Accepts the same values as the `contextMenus.create`\nfunction.\n\n    * checked\n\nboolean optional\n\n    * contexts\n\n[ContextType, ...ContextType[]] optional\n\n    * documentUrlPatterns\n\nstring[] optional\n\n    * enabled\n\nboolean optional\n\n    * parentId\n\nstring | number optional\n\nThe ID of the item to be made this item's parent. Note: You cannot set an item\nto become a child of its own descendant.\n\n    * targetUrlPatterns\n\nstring[] optional\n\n    * title\n\nstring optional\n\n    * type\n\nItemType optional\n\n    * visible\n\nboolean optional\n\nChrome 62+\n\nWhether the item is visible in the menu.\n\n    * onclick\n\nvoid optional\n\nThe `onclick` function looks like:\n\n          \n          (info: OnClickData, tab: Tab) => {...}\n\n      * info\n\nOnClickData\n\nChrome 44+\n\n      * tab\n\nTab\n\nChrome 44+\n\nThe details of the tab where the click took place. This parameter is not\npresent for platform apps.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 123+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onClicked\n\n    \n    \n    chrome.contextMenus.onClicked.addListener(  \n      callback: function,  \n    )\n\nFired when a context menu item is clicked.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (info: OnClickData, tab?: tabs.Tab) => void\n\n    * info\n\nOnClickData\n\n    * tab\n\ntabs.Tab optional\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/cookies": "#  chrome.cookies\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.cookies` API to query and modify cookies, and to be notified\nwhen they change.\n\n## Permissions\n\n`cookies`  \n\nTo use the cookies API, declare the `\"cookies\"` permission in your manifest\nalong with host permissions for any hosts whose cookies you want to access.\nFor example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"host_permissions\": [\n        \"*://*.google.com/\"\n      ],\n      \"permissions\": [\n        \"cookies\"\n      ],\n      ...\n    }\n    \n\n## Partitioning\n\nPartitioned cookies allow a site to mark that certain cookies should be keyed\nagainst the origin of the top-level frame. This means that, for example, if\nsite A is embedded using an iframe in site B and site C, the embedded versions\nof a partitioned cookie from A can have different values on B and C.\n\nBy default, all API methods operate on unpartitioned cookies. The\n`partitionKey` property can be used to override this behavior.\n\nFor details on the general impact of partitioning for extensions, see Storage\nand Cookies.\n\n## Examples\n\nYou can find a simple example of using the cookies API in the\nexamples/api/cookies directory. For other examples and for help in viewing the\nsource code, see Samples.\n\n## Types\n\n### Cookie\n\nRepresents information about an HTTP cookie.\n\n#### Properties\n\n  * domain\n\nstring\n\nThe domain of the cookie (e.g. \"www.google.com\", \"example.com\").\n\n  * expirationDate\n\nnumber optional\n\nThe expiration date of the cookie as the number of seconds since the UNIX\nepoch. Not provided for session cookies.\n\n  * hostOnly\n\nboolean\n\nTrue if the cookie is a host-only cookie (i.e. a request's host must exactly\nmatch the domain of the cookie).\n\n  * httpOnly\n\nboolean\n\nTrue if the cookie is marked as HttpOnly (i.e. the cookie is inaccessible to\nclient-side scripts).\n\n  * name\n\nstring\n\nThe name of the cookie.\n\n  * partitionKey\n\nCookiePartitionKey optional\n\nChrome 119+\n\nThe partition key for reading or modifying cookies with the Partitioned\nattribute.\n\n  * path\n\nstring\n\nThe path of the cookie.\n\n  * sameSite\n\nSameSiteStatus\n\nChrome 51+\n\nThe cookie's same-site status (i.e. whether the cookie is sent with cross-site\nrequests).\n\n  * secure\n\nboolean\n\nTrue if the cookie is marked as Secure (i.e. its scope is limited to secure\nchannels, typically HTTPS).\n\n  * session\n\nboolean\n\nTrue if the cookie is a session cookie, as opposed to a persistent cookie with\nan expiration date.\n\n  * storeId\n\nstring\n\nThe ID of the cookie store containing this cookie, as provided in\ngetAllCookieStores().\n\n  * value\n\nstring\n\nThe value of the cookie.\n\n### CookieDetails\n\nChrome 88+\n\nDetails to identify the cookie.\n\n#### Properties\n\n  * name\n\nstring\n\nThe name of the cookie to access.\n\n  * partitionKey\n\nCookiePartitionKey optional\n\nChrome 119+\n\nThe partition key for reading or modifying cookies with the Partitioned\nattribute.\n\n  * storeId\n\nstring optional\n\nThe ID of the cookie store in which to look for the cookie. By default, the\ncurrent execution context's cookie store will be used.\n\n  * url\n\nstring\n\nThe URL with which the cookie to access is associated. This argument may be a\nfull URL, in which case any data following the URL path (e.g. the query\nstring) is simply ignored. If host permissions for this URL are not specified\nin the manifest file, the API call will fail.\n\n### CookiePartitionKey\n\nChrome 119+\n\nRepresents a partitioned cookie's partition key.\n\n#### Properties\n\n  * hasCrossSiteAncestor\n\nboolean optional\n\nChrome 130+\n\nIndicates if the cookie was set in a cross-cross site context. This prevents a\ntop-level site embedded in a cross-site context from accessing cookies set by\nthe top-level site in a same-site context.\n\n  * topLevelSite\n\nstring optional\n\nThe top-level site the partitioned cookie is available in.\n\n### CookieStore\n\nRepresents a cookie store in the browser. An incognito mode window, for\ninstance, uses a separate cookie store from a non-incognito window.\n\n#### Properties\n\n  * id\n\nstring\n\nThe unique identifier for the cookie store.\n\n  * tabIds\n\nnumber[]\n\nIdentifiers of all the browser tabs that share this cookie store.\n\n### FrameDetails\n\nChrome 132+\n\nDetails to identify the frame.\n\n#### Properties\n\n  * documentId\n\nstring optional\n\nThe unique identifier for the document. If the frameId and/or tabId are\nprovided they will be validated to match the document found by provided\ndocument ID.\n\n  * frameId\n\nnumber optional\n\nThe unique identifier for the frame within the tab.\n\n  * tabId\n\nnumber optional\n\nThe unique identifier for the tab containing the frame.\n\n### OnChangedCause\n\nChrome 44+\n\nThe underlying reason behind the cookie's change. If a cookie was inserted, or\nremoved via an explicit call to \"chrome.cookies.remove\", \"cause\" will be\n\"explicit\". If a cookie was automatically removed due to expiry, \"cause\" will\nbe \"expired\". If a cookie was removed due to being overwritten with an\nalready-expired expiration date, \"cause\" will be set to \"expired_overwrite\".\nIf a cookie was automatically removed due to garbage collection, \"cause\" will\nbe \"evicted\". If a cookie was automatically removed due to a \"set\" call that\noverwrote it, \"cause\" will be \"overwrite\". Plan your response accordingly.\n\n#### Enum\n\n\"evicted\"  \n\n\"expired\"  \n\n\"explicit\"  \n\n\"expired_overwrite\"  \n\n\"overwrite\"  \n\n### SameSiteStatus\n\nChrome 51+\n\nA cookie's 'SameSite' state (https://tools.ietf.org/html/draft-west-first-\nparty-cookies). 'no_restriction' corresponds to a cookie set with\n'SameSite=None', 'lax' to 'SameSite=Lax', and 'strict' to 'SameSite=Strict'.\n'unspecified' corresponds to a cookie set without the SameSite attribute.\n\n#### Enum\n\n\"no_restriction\"  \n\n\"lax\"  \n\n\"strict\"  \n\n\"unspecified\"  \n\n## Methods\n\n### get()\n\nPromise\n\n    \n    \n    chrome.cookies.get(  \n      details: CookieDetails,  \n      callback?: function,  \n    )\n\nRetrieves information about a single cookie. If more than one cookie of the\nsame name exists for the given URL, the one with the longest path will be\nreturned. For cookies with the same path length, the cookie with the earliest\ncreation time will be returned.\n\n#### Parameters\n\n  * details\n\nCookieDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (cookie?: Cookie) => void\n\n    * cookie\n\nCookie optional\n\nContains details about the cookie. This parameter is null if no such cookie\nwas found.\n\n#### Returns\n\n  * Promise<Cookie | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.cookies.getAll(  \n      details: object,  \n      callback?: function,  \n    )\n\nRetrieves all cookies from a single cookie store that match the given\ninformation. The cookies returned will be sorted, with those with the longest\npath first. If multiple cookies have the same path length, those with the\nearliest creation time will be first. This method only retrieves cookies for\ndomains that the extension has host permissions to.\n\n#### Parameters\n\n  * details\n\nobject\n\nInformation to filter the cookies being retrieved.\n\n    * domain\n\nstring optional\n\nRestricts the retrieved cookies to those whose domains match or are subdomains\nof this one.\n\n    * name\n\nstring optional\n\nFilters the cookies by name.\n\n    * partitionKey\n\nCookiePartitionKey optional\n\nChrome 119+\n\nThe partition key for reading or modifying cookies with the Partitioned\nattribute.\n\n    * path\n\nstring optional\n\nRestricts the retrieved cookies to those whose path exactly matches this\nstring.\n\n    * secure\n\nboolean optional\n\nFilters the cookies by their Secure property.\n\n    * session\n\nboolean optional\n\nFilters out session vs. persistent cookies.\n\n    * storeId\n\nstring optional\n\nThe cookie store to retrieve cookies from. If omitted, the current execution\ncontext's cookie store will be used.\n\n    * url\n\nstring optional\n\nRestricts the retrieved cookies to those that would match the given URL.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (cookies: Cookie[]) => void\n\n    * cookies\n\nCookie[]\n\nAll the existing, unexpired cookies that match the given cookie info.\n\n#### Returns\n\n  * Promise<Cookie[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAllCookieStores()\n\nPromise\n\n    \n    \n    chrome.cookies.getAllCookieStores(  \n      callback?: function,  \n    )\n\nLists all existing cookie stores.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (cookieStores: CookieStore[]) => void\n\n    * cookieStores\n\nCookieStore[]\n\nAll the existing cookie stores.\n\n#### Returns\n\n  * Promise<CookieStore[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPartitionKey()\n\nPromise Chrome 132+\n\n    \n    \n    chrome.cookies.getPartitionKey(  \n      details: FrameDetails,  \n      callback?: function,  \n    )\n\nThe partition key for the frame indicated.\n\n#### Parameters\n\n  * details\n\nFrameDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\nContains details about the partition key that's been retrieved.\n\n      * partitionKey\n\nCookiePartitionKey\n\nThe partition key for reading or modifying cookies with the Partitioned\nattribute.\n\n#### Returns\n\n  * Promise<object>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### remove()\n\nPromise\n\n    \n    \n    chrome.cookies.remove(  \n      details: CookieDetails,  \n      callback?: function,  \n    )\n\nDeletes a cookie by name.\n\n#### Parameters\n\n  * details\n\nCookieDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details?: object) => void\n\n    * details\n\nobject optional\n\nContains details about the cookie that's been removed. If removal failed for\nany reason, this will be \"null\", and `runtime.lastError` will be set.\n\n      * name\n\nstring\n\nThe name of the cookie that's been removed.\n\n      * partitionKey\n\nCookiePartitionKey optional\n\nChrome 119+\n\nThe partition key for reading or modifying cookies with the Partitioned\nattribute.\n\n      * storeId\n\nstring\n\nThe ID of the cookie store from which the cookie was removed.\n\n      * url\n\nstring\n\nThe URL associated with the cookie that's been removed.\n\n#### Returns\n\n  * Promise<object | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### set()\n\nPromise\n\n    \n    \n    chrome.cookies.set(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets a cookie with the given cookie data; may overwrite equivalent cookies if\nthey exist.\n\n#### Parameters\n\n  * details\n\nobject\n\nDetails about the cookie being set.\n\n    * domain\n\nstring optional\n\nThe domain of the cookie. If omitted, the cookie becomes a host-only cookie.\n\n    * expirationDate\n\nnumber optional\n\nThe expiration date of the cookie as the number of seconds since the UNIX\nepoch. If omitted, the cookie becomes a session cookie.\n\n    * httpOnly\n\nboolean optional\n\nWhether the cookie should be marked as HttpOnly. Defaults to false.\n\n    * name\n\nstring optional\n\nThe name of the cookie. Empty by default if omitted.\n\n    * partitionKey\n\nCookiePartitionKey optional\n\nChrome 119+\n\nThe partition key for reading or modifying cookies with the Partitioned\nattribute.\n\n    * path\n\nstring optional\n\nThe path of the cookie. Defaults to the path portion of the url parameter.\n\n    * sameSite\n\nSameSiteStatus optional\n\nChrome 51+\n\nThe cookie's same-site status. Defaults to \"unspecified\", i.e., if omitted,\nthe cookie is set without specifying a SameSite attribute.\n\n    * secure\n\nboolean optional\n\nWhether the cookie should be marked as Secure. Defaults to false.\n\n    * storeId\n\nstring optional\n\nThe ID of the cookie store in which to set the cookie. By default, the cookie\nis set in the current execution context's cookie store.\n\n    * url\n\nstring\n\nThe request-URI to associate with the setting of the cookie. This value can\naffect the default domain and path values of the created cookie. If host\npermissions for this URL are not specified in the manifest file, the API call\nwill fail.\n\n    * value\n\nstring optional\n\nThe value of the cookie. Empty by default if omitted.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (cookie?: Cookie) => void\n\n    * cookie\n\nCookie optional\n\nContains details about the cookie that's been set. If setting failed for any\nreason, this will be \"null\", and `runtime.lastError` will be set.\n\n#### Returns\n\n  * Promise<Cookie | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onChanged\n\n    \n    \n    chrome.cookies.onChanged.addListener(  \n      callback: function,  \n    )\n\nFired when a cookie is set or removed. As a special case, note that updating a\ncookie's properties is implemented as a two step process: the cookie to be\nupdated is first removed entirely, generating a notification with \"cause\" of\n\"overwrite\" . Afterwards, a new cookie is written with the updated values,\ngenerating a second notification with \"cause\" \"explicit\".\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (changeInfo: object) => void\n\n    * changeInfo\n\nobject\n\n      * cause\n\nOnChangedCause\n\nThe underlying reason behind the cookie's change.\n\n      * cookie\n\nCookie\n\nInformation about the cookie that was set or removed.\n\n      * removed\n\nboolean\n\nTrue if a cookie was removed.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/debugger": "#  chrome.debugger\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.debugger` API serves as an alternate transport for Chrome's remote\ndebugging protocol. Use `chrome.debugger` to attach to one or more tabs to\ninstrument network interaction, debug JavaScript, mutate the DOM and CSS, and\nmore. Use the `Debuggee` property `tabId` to target tabs with `sendCommand`\nand route events by `tabId` from `onEvent` callbacks.\n\n## Permissions\n\n`debugger`  \n\nYou must declare the `\"debugger\"` permission in your extension's manifest to\nuse this API.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"debugger\",\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nOnce attached, the `chrome.debugger` API lets you send Chrome DevTools\nProtocol (CDP) commands to a given target. Explaining the CDP in depth is out\nof scope for this documentationto learn more about CDP check out the official\nCDP documentation.\n\n### Targets\n\nTargets represent something which is being debuggedthis could include a tab,\nan iframe or a worker. Each target is identified by a UUID and has an\nassociated type (such as `iframe`, `shared_worker`, and more).\n\nWithin a target, there may be multiple execution contextsfor example same\nprocess iframes don't get a unique target but are instead represented as\ndifferent contexts that can be accessed from a single target.\n\n### Restricted domains\n\nFor security reasons, the `chrome.debugger` API does not provide access to all\nChrome DevTools Protocol Domains. The available domains are: Accessibility,\nAudits, CacheStorage, Console, CSS, Database, Debugger, DOM, DOMDebugger,\nDOMSnapshot, Emulation, Fetch, IO, Input, Inspector, Log, Network, Overlay,\nPage, Performance, Profiler, Runtime, Storage, Target, Tracing, WebAudio, and\nWebAuthn.\n\n### Work with frames\n\nThere is not a one to one mapping of frames to targets. Within a single tab,\nmultiple same process frames may share the same target but use a different\nexecution context. On the other hand, a new target may be created for an out-\nof-process iframe.\n\nTo attach to all frames, you need to handle each type of frame separately:\n\n  * Listen for the `Runtime.executionContextCreated` event to identify new execution contexts associated with same process frames.\n\n  * Follow the steps to attach to related targets to identify out-of-process frames.\n\n### Attach to related targets\n\nAfter connecting to a target, you may want to connect to further related\ntargets including out-of-process child frames or associated workers.\n\nStarting in Chrome 125, the `chrome.debugger` API supports flat sessions. This\nlets you add additional targets as children to your main debugger session and\nmessage them without needing another call to `chrome.debugger.attach`.\nInstead, you can add a `sessionId` property when calling\n`chrome.debugger.sendCommand` to identify the child target you would like to\nsend a command to.\n\nTo automatically attach to out of process child frames, first add a listener\nfor the `Target.attachedToTarget` event:\n\n    \n    \n    chrome.debugger.onEvent.addListener((source, method, params) => {\n      if (method === \"Target.attachedToTarget\") {\n        // `source` identifies the parent session, but we need to construct a new\n        // identifier for the child session\n        const session = { ...source, sessionId: params.sessionId };\n    \n        // Call any needed CDP commands for the child session\n        await chrome.debugger.sendCommand(session, \"Runtime.enable\");\n      }\n    });\n    \n\nThen, enable auto attach by sending the `Target.setAutoAttach` command with\nthe `flatten` option set to `true`:\n\n    \n    \n    await chrome.debugger.sendCommand({ tabId }, \"Target.setAutoAttach\", {\n      autoAttach: true,\n      waitForDebuggerOnStart: false,\n      flatten: true,\n      filter: [{ type: \"iframe\", exclude: false }]\n    });\n    \n\nAuto-attach only attaches to frames the target is aware of, which is limited\nto frames which are immediate children of a frame associated with it. For\nexample, with the frame hierarchy A -> B -> C (where all are cross-origin),\ncalling `Target.setAutoAttach` for the target associated with A would result\nin the session also being attached to B. However, this is not recursive, so\n`Target.setAutoAttach` also needs to be called for B to attach the session to\nC.\n\n## Examples\n\nTo try this API, install the debugger API example from the chrome-extension-\nsamples repository.\n\n## Types\n\n### Debuggee\n\nDebuggee identifier. Either tabId, extensionId or targetId must be specified\n\n#### Properties\n\n  * extensionId\n\nstring optional\n\nThe id of the extension which you intend to debug. Attaching to an extension\nbackground page is only possible when the `--silent-debugger-extension-api`\ncommand-line switch is used.\n\n  * tabId\n\nnumber optional\n\nThe id of the tab which you intend to debug.\n\n  * targetId\n\nstring optional\n\nThe opaque id of the debug target.\n\n### DebuggerSession\n\nChrome 125+\n\nDebugger session identifier. One of tabId, extensionId or targetId must be\nspecified. Additionally, an optional sessionId can be provided. If sessionId\nis specified for arguments sent from `onEvent`, it means the event is coming\nfrom a child protocol session within the root debuggee session. If sessionId\nis specified when passed to `sendCommand`, it targets a child protocol session\nwithin the root debuggee session.\n\n#### Properties\n\n  * extensionId\n\nstring optional\n\nThe id of the extension which you intend to debug. Attaching to an extension\nbackground page is only possible when the `--silent-debugger-extension-api`\ncommand-line switch is used.\n\n  * sessionId\n\nstring optional\n\nThe opaque id of the Chrome DevTools Protocol session. Identifies a child\nsession within the root session identified by tabId, extensionId or targetId.\n\n  * tabId\n\nnumber optional\n\nThe id of the tab which you intend to debug.\n\n  * targetId\n\nstring optional\n\nThe opaque id of the debug target.\n\n### DetachReason\n\nChrome 44+\n\nConnection termination reason.\n\n#### Enum\n\n\"target_closed\"  \n\n\"canceled_by_user\"  \n\n### TargetInfo\n\nDebug target information\n\n#### Properties\n\n  * attached\n\nboolean\n\nTrue if debugger is already attached.\n\n  * extensionId\n\nstring optional\n\nThe extension id, defined if type = 'background_page'.\n\n  * faviconUrl\n\nstring optional\n\nTarget favicon URL.\n\n  * id\n\nstring\n\nTarget id.\n\n  * tabId\n\nnumber optional\n\nThe tab id, defined if type == 'page'.\n\n  * title\n\nstring\n\nTarget page title.\n\n  * type\n\nTargetInfoType\n\nTarget type.\n\n  * url\n\nstring\n\nTarget URL.\n\n### TargetInfoType\n\nChrome 44+\n\nTarget type.\n\n#### Enum\n\n\"page\"  \n\n\"background_page\"  \n\n\"worker\"  \n\n\"other\"  \n\n## Methods\n\n### attach()\n\nPromise\n\n    \n    \n    chrome.debugger.attach(  \n      target: Debuggee,  \n      requiredVersion: string,  \n      callback?: function,  \n    )\n\nAttaches debugger to the given target.\n\n#### Parameters\n\n  * target\n\nDebuggee\n\nDebugging target to which you want to attach.\n\n  * requiredVersion\n\nstring\n\nRequired debugging protocol version (\"0.1\"). One can only attach to the\ndebuggee with matching major version and greater or equal minor version. List\nof the protocol versions can be obtained here.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### detach()\n\nPromise\n\n    \n    \n    chrome.debugger.detach(  \n      target: Debuggee,  \n      callback?: function,  \n    )\n\nDetaches debugger from the given target.\n\n#### Parameters\n\n  * target\n\nDebuggee\n\nDebugging target from which you want to detach.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getTargets()\n\nPromise\n\n    \n    \n    chrome.debugger.getTargets(  \n      callback?: function,  \n    )\n\nReturns the list of available debug targets.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: TargetInfo[]) => void\n\n    * result\n\nTargetInfo[]\n\nArray of TargetInfo objects corresponding to the available debug targets.\n\n#### Returns\n\n  * Promise<TargetInfo[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### sendCommand()\n\nPromise\n\n    \n    \n    chrome.debugger.sendCommand(  \n      target: DebuggerSession,  \n      method: string,  \n      commandParams?: object,  \n      callback?: function,  \n    )\n\nSends given command to the debugging target.\n\n#### Parameters\n\n  * target\n\nDebuggerSession\n\nDebugging target to which you want to send the command.\n\n  * method\n\nstring\n\nMethod name. Should be one of the methods defined by the remote debugging\nprotocol.\n\n  * commandParams\n\nobject optional\n\nJSON object with request parameters. This object must conform to the remote\ndebugging params scheme for given method.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result?: object) => void\n\n    * result\n\nobject optional\n\nJSON object with the response. Structure of the response varies depending on\nthe method name and is defined by the 'returns' attribute of the command\ndescription in the remote debugging protocol.\n\n#### Returns\n\n  * Promise<object | undefined>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onDetach\n\n    \n    \n    chrome.debugger.onDetach.addListener(  \n      callback: function,  \n    )\n\nFired when browser terminates debugging session for the tab. This happens when\neither the tab is being closed or Chrome DevTools is being invoked for the\nattached tab.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (source: Debuggee, reason: DetachReason) => void\n\n    * source\n\nDebuggee\n\n    * reason\n\nDetachReason\n\n### onEvent\n\n    \n    \n    chrome.debugger.onEvent.addListener(  \n      callback: function,  \n    )\n\nFired whenever debugging target issues instrumentation event.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (source: DebuggerSession, method: string, params?: object) => void\n\n    * source\n\nDebuggerSession\n\n    * method\n\nstring\n\n    * params\n\nobject optional\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/declarativeContent": "#  chrome.declarativeContent\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.declarativeContent` API to take actions depending on the\ncontent of a page, without requiring permission to read the page's content.\n\n## Permissions\n\n`declarativeContent`  \n\n## Concepts and usage\n\n**Key term:** An extension's _action_ controls the extension's toolbar icon.\n\nThe Declarative Content API lets you enable your extension's action depending\non the URL of a web page, or if a CSS selector matches an element on the page,\nwithout needing to add host permissions or inject a content script.\n\nUse the activeTab permission to interact with a page after the user clicks on\nthe extension's action.\n\n### Rules\n\nRules consists of conditions and actions. If any of the conditions is\nfulfilled, all actions are executed. The actions are `setIcon()` and\n`showAction()`.\n\nThe `PageStateMatcher` matches web pages if and only if all listed criteria\nare met. It can match a page url, a css compound selector or the bookmarked\nstate of a page. The following rule enables the extension's action on Google\npages when a password field is present:\n\n    \n    \n    let rule1 = {\n      conditions: [\n        new chrome.declarativeContent.PageStateMatcher({\n          pageUrl: { hostSuffix: '.google.com', schemes: ['https'] },\n          css: [\"input[type='password']\"]\n        })\n      ],\n      actions: [ new chrome.declarativeContent.ShowAction() ]\n    };\n    \n    \n\n**Success:** All conditions and actions are created using a constructor as\nshown in the previous example.\n\nTo also enable the extension's action for Google sites with a video, you can\nadd a second condition, as each condition is sufficient to trigger all\nspecified actions:\n\n    \n    \n    let rule2 = {\n      conditions: [\n        new chrome.declarativeContent.PageStateMatcher({\n          pageUrl: { hostSuffix: '.google.com', schemes: ['https'] },\n          css: [\"input[type='password']\"]\n        }),\n        new chrome.declarativeContent.PageStateMatcher({\n          css: [\"video\"]\n        })\n      ],\n      actions: [ new chrome.declarativeContent.ShowAction() ]\n    };\n    \n\nThe `onPageChanged` event tests whether any rule has at least one fulfilled\ncondition and executes the actions. Rules persist across browsing sessions;\ntherefore, during extension installation time you should first use\n`removeRules` to clear previously installed rules and then use `addRules` to\nregister new ones.\n\n    \n    \n    chrome.runtime.onInstalled.addListener(function(details) {\n      chrome.declarativeContent.onPageChanged.removeRules(undefined, function() {\n        chrome.declarativeContent.onPageChanged.addRules([rule2]);\n      });\n    });\n    \n\n**Note:** You should always register or unregister rules in bulk because each\nof these operations recreates internal data structures. This re-creation is\ncomputationally expensive but facilitates a faster matching algorithm.\n\nWith the activeTab permission, your extension won't display any permission\nwarnings and when the user clicks the extension action, it will only run on\nrelevant pages.\n\n### Page URL matching\n\nThe `PageStateMatcher.pageurl` matches when the URL criteria are fulfilled.\nThe most common criteria are a concatenation of either host, path, or URL,\nfollowed by Contains, Equals, Prefix, or Suffix. The following table contains\na few examples:\n\nCriteria | Matches  \n---|---  \n`{ hostSuffix: 'google.com' }` | All Google URLs  \n`{ pathPrefix: '/docs/extensions'` } | Extension docs URLs  \n`{ urlContains: 'developer.chrome.com'` } | All chrome developers docs URLs  \n  \nAll criteria are case sensitive. For a complete list of criteria, see\nUrlFilter.\n\n### CSS Matching\n\n`PageStateMatcher.css` conditions must be _compound selectors_ , meaning that\nyou can't include combinators like whitespace or \"`>`\" in your selectors. This\nhelps Chrome match the selectors more efficiently.\n\nCompound Selectors (OK) | Complex Selectors (Not OK)  \n---|---  \n`a` | `div p`  \n`iframe.special[src^='http']` | `p>span.highlight`  \n`ns|*` | `p + ol`  \n`#abcd:checked` | `p::first-line`  \n  \nCSS conditions only match displayed elements: if an element that matches your\nselector is `display:none` or one of its parent elements is `display:none`, it\ndoesn't cause the condition to match. Elements styled with\n`visibility:hidden`, positioned off-screen, or hidden by other elements can\nstill make your condition match.\n\n### Bookmarked state matching\n\nThe `PageStateMatcher.isBookmarked` condition allows matching of the\nbookmarked state of the current URL in the user's profile. To make use of this\ncondition the \"bookmarks\" permission must be declared in the extension\nmanifest.\n\n## Types\n\n### ImageDataType\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ImageData.\n\n#### Type\n\nImageData\n\n### PageStateMatcher\n\nMatches the state of a web page based on various criteria.\n\n#### Properties\n\n  * constructor\n\nvoid\n\nThe `constructor` function looks like:\n\n        \n        (arg: PageStateMatcher) => {...}\n\n    * arg\n\nPageStateMatcher\n\n    * returns\n\nPageStateMatcher\n\n  * css\n\nstring[] optional\n\nMatches if all of the CSS selectors in the array match displayed elements in a\nframe with the same origin as the page's main frame. All selectors in this\narray must be compound selectors to speed up matching. Note: Listing hundreds\nof CSS selectors or listing CSS selectors that match hundreds of times per\npage can slow down web sites.\n\n  * isBookmarked\n\nboolean optional\n\nChrome 45+\n\nMatches if the bookmarked state of the page is equal to the specified value.\nRequres the bookmarks permission.\n\n  * pageUrl\n\nUrlFilter optional\n\nMatches if the conditions of the `UrlFilter` are fulfilled for the top-level\nURL of the page.\n\n### RequestContentScript\n\nDeclarative event action that injects a content script.\n\n**WARNING:** This action is still experimental and is not supported on stable\nbuilds of Chrome.\n\n#### Properties\n\n  * constructor\n\nvoid\n\nThe `constructor` function looks like:\n\n        \n        (arg: RequestContentScript) => {...}\n\n    * arg\n\nRequestContentScript\n\n    * returns\n\nRequestContentScript\n\n  * allFrames\n\nboolean optional\n\nWhether the content script runs in all frames of the matching page, or in only\nthe top frame. Default is `false`.\n\n  * css\n\nstring[] optional\n\nNames of CSS files to be injected as a part of the content script.\n\n  * js\n\nstring[] optional\n\nNames of JavaScript files to be injected as a part of the content script.\n\n  * matchAboutBlank\n\nboolean optional\n\nWhether to insert the content script on `about:blank` and `about:srcdoc`.\nDefault is `false`.\n\n### SetIcon\n\nDeclarative event action that sets the n-dip square icon for the extension's\npage action or browser action while the corresponding conditions are met. This\naction can be used without host permissions, but the extension must have a\npage or browser action.\n\nExactly one of `imageData` or `path` must be specified. Both are dictionaries\nmapping a number of pixels to an image representation. The image\nrepresentation in `imageData` is an ImageData object; for example, from a\n`canvas` element, while the image representation in `path` is the path to an\nimage file relative to the extension's manifest. If `scale` screen pixels fit\ninto a device-independent pixel, the `scale * n` icon is used. If that scale\nis missing, another image is resized to the required size.\n\n#### Properties\n\n  * constructor\n\nvoid\n\nThe `constructor` function looks like:\n\n        \n        (arg: SetIcon) => {...}\n\n    * arg\n\nSetIcon\n\n    * returns\n\nSetIcon\n\n  * imageData\n\nImageData | object optional\n\nEither an `ImageData` object or a dictionary {size -> ImageData} representing\nan icon to be set. If the icon is specified as a dictionary, the image used is\nchosen depending on the screen's pixel density. If the number of image pixels\nthat fit into one screen space unit equals `scale`, then an image with size\n`scale * n` is selected, where _n_ is the size of the icon in the UI. At least\none image must be specified. Note that `details.imageData = foo` is equivalent\nto `details.imageData = {'16': foo}`.\n\n### ShowAction\n\nChrome 97+\n\nA declarative event action that sets the extension's toolbar action to an\nenabled state while the corresponding conditions are met. This action can be\nused without host permissions. If the extension has the activeTab permission,\nclicking the page action grants access to the active tab.\n\nOn pages where the conditions are not met the extension's toolbar action will\nbe grey-scale, and clicking it will open the context menu, instead of\ntriggering the action.\n\n#### Properties\n\n  * constructor\n\nvoid\n\nThe `constructor` function looks like:\n\n        \n        (arg: ShowAction) => {...}\n\n    * arg\n\nShowAction\n\n    * returns\n\nShowAction\n\n### ShowPageAction\n\nDeprecated since Chrome 97\n\nPlease use `declarativeContent.ShowAction`.\n\nA declarative event action that sets the extension's page action to an enabled\nstate while the corresponding conditions are met. This action can be used\nwithout host permissions, but the extension must have a page action. If the\nextension has the activeTab permission, clicking the page action grants access\nto the active tab.\n\nOn pages where the conditions are not met the extension's toolbar action will\nbe grey-scale, and clicking it will open the context menu, instead of\ntriggering the action.\n\n#### Properties\n\n  * constructor\n\nvoid\n\nThe `constructor` function looks like:\n\n        \n        (arg: ShowPageAction) => {...}\n\n    * arg\n\nShowPageAction\n\n    * returns\n\nShowPageAction\n\n## Events\n\n### onPageChanged\n\nProvides the Declarative Event API consisting of `addRules`, `removeRules`,\nand `getRules`.\n\n#### Conditions\n\nPageStateMatcher\n\n#### Actions\n\nRequestContentScript\n\nSetIcon\n\nShowPageAction\n\nShowAction\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/declarativeNetRequest": "#  chrome.declarativeNetRequest\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.declarativeNetRequest` API is used to block or modify network\nrequests by specifying declarative rules. This lets extensions modify network\nrequests without intercepting them and viewing their content, thus providing\nmore privacy.\n\n## Permissions\n\n`declarativeNetRequest`  \n`declarativeNetRequestWithHostAccess`  \n\nThe \"`declarativeNetRequest`\" and \"`declarativeNetRequestWithHostAccess`\"\npermissions provide the same capabilities. The differences between them is\nwhen permissions are requested or granted.\n\n`\"declarativeNetRequest\"`\n\n    Triggers a permission warning at install time but provides implicit access to `allow`, `allowAllRequests` and `block` rules. Use this when possible to avoid needing to request full access to hosts.\n`\"declarativeNetRequestFeedback\"`\n\n    Enables debugging features for unpacked extensions, specifically `getMatchedRules()` and `onRuleMatchedDebug`.\n`\"declarativeNetRequestWithHostAccess\"`\n\n    A permission warning is not shown at install time, but you must request host permissions before you can perform any action on a host. This is appropriate when you want to use declarative net request rules in an extension which already has host permissions without generating additional warnings.\n\n## Availability\n\nChrome 84+\n\n## Manifest\n\nIn addition to the permissions described previously, certain types of\nrulesets, static rulesets specifically, require declaring the\n`\"declarative_net_request\"` manifest key, which should be a dictionary with a\nsingle key called `\"rule_resources\"`. This key is an array containing\ndictionaries of type `Ruleset`, as shown in the following. (Note that the name\n'Ruleset' does not appear in the manifest's JSON since it is merely an array.)\nStatic rulesets are explained later in this document.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n    \n      \"declarative_net_request\" : {\n        \"rule_resources\" : [{\n          \"id\": \"ruleset_1\",\n          \"enabled\": true,\n          \"path\": \"rules_1.json\"\n        }, {\n          \"id\": \"ruleset_2\",\n          \"enabled\": false,\n          \"path\": \"rules_2.json\"\n        }]\n      },\n      \"permissions\": [\n        \"declarativeNetRequest\",\n        \"declarativeNetRequestFeedback\"\n      ],\n      \"host_permissions\": [\n        \"http://www.blogger.com/*\",\n        \"http://*.google.com/*\"\n      ],\n      ...\n    }\n    \n\n## Rules and rulesets\n\nTo use this API, specify one or more rulesets. A ruleset contains an array of\nrules. A single rule does one of the following:\n\n  * Block a network request.\n  * Upgrade the schema (http to https).\n  * Prevent a request from getting blocked by negating any matching blocked rules.\n  * Redirect a network request.\n  * Modify request or response headers.\n\nThere are three types of rulesets, managed in slightly different ways.\n\nDynamic\n\n    Persist across browser sessions and extension upgrades and are managed using JavaScript while an extension is in use.\nSession\n\n    Cleared when the browser shuts down and when a new version of the extension is installed. Session rules are managed using JavaScript while an extension is in use.\nStatic\n\n    Packaged, installed, and updated when an extension is installed or upgraded. Static rules are stored in JSON-formatted rule files and listed in the manifest file.\n\n### Dynamic and session-scoped rulesets\n\nDynamic and session rulesets are managed using JavaScript while an extension\nis in use.\n\n  * Dynamic rules persist across browser sessions and extension upgrades.\n  * Session rules are cleared when the browser shuts down and when a new version of the extension is installed.\n\nThere is only one each of these ruleset types. An extension can add or remove\nrules to them dynamically by calling `updateDynamicRules()` and\n`updateSessionRules()`, provided the rule limits aren't exceeded. For\ninformation on rule limits, see Rule limits. You can see an example of this\nunder code examples.\n\n### Static rulesets\n\nUnlike dynamic and session rules, static rules are packaged, installed, and\nupdated when an extension is installed or upgraded. They're stored in rule\nfiles in JSON format, which are indicated to the extension using the\n`\"declarative_net_request\"` and `\"rule_resources\"` keys as described above, as\nwell as one or more `Ruleset` dictionaries. A `Ruleset` dictionary contains a\npath to the rule file, an ID for the ruleset contained in the file, and\nwhether the ruleset is enabled or disabled. The last two are important when\nyou enable or disable a ruleset programmatically.\n\n    \n    \n    {\n      ...\n      \"declarative_net_request\" : {\n        \"rule_resources\" : [{\n          \"id\": \"ruleset_1\",\n          \"enabled\": true,\n          \"path\": \"rules_1.json\"\n        },\n        ...\n        ]\n      }\n      ...\n    }\n    \n\nTo test rule files, load your extension unpacked. Errors and warnings about\ninvalid static rules are only displayed for unpacked extensions. Invalid\nstatic rules in packed extensions are ignored.\n\n## Expedited review\n\nChanges to static rulesets may be eligible for expedited review. See expedited\nreview for eligible changes.\n\n## Enable and disable static rules and rulesets\n\nBoth individual static rules and complete static rulesets may be enabled or\ndisabled at runtime.\n\nThe set of enabled static rules and rulesets is persisted across browser\nsessions. Neither are persisted across extension updates, meaning that only\nrules you chose to leave in your rule files are available after an update.\n\nFor performance reasons there are also limits to the number of rules and\nrulesets that may be enabled at one time. Call `getAvailableStaticRuleCount()`\nto check the number of additional rules that may be enabled. For information\non rule limits, see Rule limits.\n\nTo enable or disable static _rules_ , call `updateStaticRules()`. This method\ntakes an `UpdateStaticRulesOptions` object, which contains arrays of IDs of\nrules to enable or disable. The IDs are defined using the `\"id\"` key of the\n`Ruleset` dictionary. There is a maximum limit of 5000 disabled static rules.\n\nTo enable or disable static _rulesets_ , call `updateEnabledRulesets()`. This\nmethod takes an `UpdateRulesetOptions` object, which contains arrays of IDs of\nrulesets to enable or disable. The IDs are defined using the `\"id\"` key of the\n`Ruleset` dictionary.\n\n## Build rules\n\nRegardless of type, a rule starts with four fields as shown in the following.\nWhile the `\"id\"` and `\"priority\"` keys take a number, the `\"action\"` and\n`\"condition\"` keys may provide several blocking and redirecting conditions.\nThe following rule blocks all script requests originating from `\"foo.com\"` to\nany URL with `\"abc\"` as a substring.\n\n    \n    \n    {\n      \"id\" : 1,\n      \"priority\": 1,\n      \"action\" : { \"type\" : \"block\" },\n      \"condition\" : {\n        \"urlFilter\" : \"abc\",\n        \"initiatorDomains\" : [\"foo.com\"],\n        \"resourceTypes\" : [\"script\"]\n      }\n    }\n    \n\n## URL matching\n\nDeclarative Net Request provides the ability to match URLs with either a\npattern matching syntax or regular expressions.\n\n### URL filter syntax\n\nA rule's `\"condition\"` key allows a `\"urlFilter\"` key for acting on URLs under\na specified domain. You create patterns using pattern matching tokens. Here\nare a few examples.\n\n`**urlFilter**` | Matches | Does not match  \n---|---|---  \n`\"abc\"` | https://abcd.com  \nhttps://example.com/abcd | https://ab.com  \n`\"abc*d\"` | https://abcd.com  \nhttps://example.com/abcxyzd | https://abc.com  \n`\"||a.example.com\"` | https://a.example.com/  \nhttps://b.a.example.com/xyz  \nhttps://a.example.company | https://example.com/  \n`\"|https*\"` | https://example.com | http://example.com/  \nhttp://https.com  \n`\"example*^123|\"` | https://example.com/123  \nhttp://abc.com/example?123 | https://example.com/1234  \nhttps://abc.com/example0123  \n  \n### Regular expressions\n\nConditions can also use regular expressions. See the `\"regexFilter\"` key. To\nlearn about the limits that apply to these conditions, see Rules that use\nregular expressions.\n\n### Write good URL conditions\n\nTake care when writing rules to always match an entire domain. Otherwise, your\nrule may match in situations that are unexpected. For example, when using the\npattern matching syntax:\n\n  * `google.com` incorrectly matches `https://example.com/?param=google.com`\n  * `||google.com` incorrectly matches `https://google.company`\n  * `https://www.google.com` incorrectly matches `https://example.com/?param=https://www.google.com`\n\nConsider using:\n\n  * `||google.com/`, which matches all paths and all subdomains.\n  * `|https://www.google.com/` which matches all paths and no subdomains.\n\nSimilarly, use the `^` and `/` characters to anchor a regular expression. For\nexample, `^https:\\/\\/www\\.google\\.com\\/` matches any path on\nhttps://www.google.com.\n\n## Rule evaluation\n\nDNR rules are applied by the browser across various stages of the network\nrequest lifecycle.\n\n### Before the request\n\nBefore a request is made, an extension can block or redirect (including\nupgrading the scheme from HTTP to HTTPS) it with a matching rule.\n\nFor each extension, the browser determines a list of matching rules. Rules\nwith a `modifyHeaders` action are not included here as they will be handled\nlater. Additionally, rules with a `responseHeaders` condition will be\nconsidered later (when response headers are available) and are not included.\n\nThen, for each extension, Chrome picks at most one candidate per request.\nChrome finds a matching rule, by ordering all matching rules by priority.\nRules with the same priority are ordered by action (`allow` or\n`allowAllRequests` > `block` > `upgradeScheme` > `redirect`).\n\nIf the candidate is an `allow` or `allowAllRequests` rule, or the frame the\nrequest is being made in previously matched an `allowAllRequests` rule of\nhigher or equal priority from this extension, the request is \"allowed\" and the\nextension won't have any effect on the request.\n\nIf more than one extension wants to block or redirect this request, a single\naction to take is chosen. Chrome does this by sorting the rules in the order\n`block` > `redirect` or `upgradeScheme` > `allow` or `allowAllRequests`. If\ntwo rules are of the same type, Chrome chooses the rule from the most recently\ninstalled extension.\n\n**Caution:** Browser vendors have agreed not to standardize the order in which\nrules with the same action and priority run. This can change between runs or\nbrowser versions, even when spread between multiple types of ruleset (such as\na static rule and a session rule). When ordering is important, you should\nalways explicitly specify a priority.\n\n### Before request headers are sent\n\nBefore Chrome sends request headers to the server, the headers are updated\nbased on matching `modifyHeaders` rules.\n\nWithin a single extension, Chrome builds the list of modifications to perform\nby finding all matching `modifyHeaders` rules. Similar to before, only rules\nwhich have a higher priority than any matching `allow` or `allowAllRequests`\nrules are included.\n\nThese rules are applied by Chrome in an order such that rules from a more\nrecently installed extension are always evaluated before rules from an older\nextension. Additionally, rules of a higher priority from one extension are\nalways applied before rules of a lower priority from the same extension.\nNotably, even across extensions:\n\n  * If a rule appends to a header, then lower priority rules can only append to that header. Set and remove operations are not allowed.\n  * If a rule sets a header, then only lower priority rules from the same extension can append to that header. No other modifications are allowed.\n  * If a rule removes a header, then lower priority rules cannot further modify the header.\n\n### Once a response is received\n\nOnce the response headers have been received, Chrome evaluates rules with a\n`responseHeaders` condition.\n\nAfter sorting these rules by `action` and `priority` and excluding any rules\nmade redundant by a matching `allow` or `allowAllRequests` rule (this happens\nidentically to the steps in \"Before the request\"), Chrome may block or\nredirect the request on behalf of an extension.\n\nNote that if a request made it to this stage, the request has already been\nsent to the server and the server has received data like the request body. A\nblock or redirect rule with a response headers condition will still runbut\ncannot actually block or redirect the request.\n\nIn the case of a block rule, this is handled by the page which made the\nrequest receiving a blocked response and Chrome terminating the request early.\nIn the case of a redirect rule, Chrome makes a new request to the redirected\nURL. Make sure to consider if these behaviors meet the privacy expectations\nfor your extension.\n\nIf the request is not blocked or redirected, Chrome applies any\n`modifyHeaders` rules. Applying modifications to response headers works in the\nsame way as described in \"Before request headers are sent\". Applying\nmodifications to request headers does nothing, since the request has already\nbeen made.\n\n## Safe rules\n\nSafe rules are defined as rules with an action of `block`, `allow`,\n`allowAllRequests` or `upgradeScheme`. These rules are subject to an increased\ndynamic rules quota.\n\n## Rule limits\n\nThere is a performance overhead to loading and evaluating rules in the\nbrowser, so some limits apply when using the API. Limits depend on the type of\nrule you're using.\n\n### Static rules\n\nStatic rules are those specified in rule files declared in the manifest file.\nAn extension can specify up to 100 static rulesets as part of the\n`\"rule_resources\"` manifest key, but only 50 of these rulesets can be enabled\nat a time. The latter is called the `MAX_NUMBER_OF_ENABLED_STATIC_RULESETS`.\nCollectively, those rulesets are guaranteed at least 30,000 rules. This is\ncalled the `GUARANTEED_MINIMUM_STATIC_RULES`.\n\n**Note:** Prior to Chrome 120, extensions were limited to a total of 50 static\nrulesets, and only 10 of these could be enabled at the same time. Use the\n`minimum_chrome_version` manifest field to limit which Chrome versions can\ninstall your extension.\n\nThe number of rules available after that depends on how many rules are enabled\nby all the extensions installed on a user's browser. You can find this number\nat runtime by calling `getAvailableStaticRuleCount()`. You can see an example\nof this under code examples.\n\n**Note:** Starting with Chrome 128, if a user disables an extension through\nchrome://extensions, the extension's static rules will no longer count towards\nthe global static rule limit. This potentially frees up static rule quota for\nother extensions, but also means that when the extension gets re-enabled, it\nmight have fewer static rules available than before.\n\n### Session rules\n\nAn extension can have up to 5000 session rules. This is exposed as the\n`MAX_NUMBER_OF_SESSION_RULES`.\n\nBefore Chrome 120, there was a limit of 5000 combined dynamic and session\nrules.\n\n### Dynamic rules\n\nAn extension can have at least 5000 dynamic rules. This is exposed as the\n`MAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES`.\n\nStarting in Chrome 121, there is a larger limit of 30,000 rules available for\nsafe dynamic rules, exposed as the `MAX_NUMBER_OF_DYNAMIC_RULES`. Any unsafe\nrules added within the limit of 5000 will also count towards this limit.\n\nBefore Chrome 120, there was a 5000 combined dynamic and session rules limit.\n\n### Rules that use regular expressions\n\nAll types of rules can use regular expressions; however, the total number of\nregular expression rules of each type cannot exceed 1000. This is called the\nMAX_NUMBER_OF_REGEX_RULES.\n\nAdditionally, each rule must be less than 2KB once compiled. This roughly\ncorrelates with the complexity of the rule. If you try to load a rule that\nexceeds this limit, you will see a warning like the following and the rule\nwill be ignored.\n\n    \n    \n    rules_1.json: Rule with id 1 specified a more complex regex than allowed\n    as part of the \"regexFilter\" key.\n    \n\n## Interactions with service workers\n\nA declarativeNetRequest only applies to requests that reach the network stack.\nThis includes responses from the HTTP cache, but may not include responses\nthat go through a service worker's `onfetch` handler. declarativeNetRequest\nwon't affect responses generated by the service worker or retrieved from\n`CacheStorage`, but it will affect calls to `fetch()` made in a service\nworker.\n\n## Web accessible resources\n\nA declarativeNetRequest rule cannot redirect from a public resource request to\na resource that is not web accessible. Doing so triggers an error. This is\ntrue even if the specified web accessible resource is owned by the redirecting\nextension. To declare resources for declarativeNetRequest, use the manifest's\n`\"web_accessible_resources\"` array.\n\n## Header modification\n\nThe append operation is only supported for the following headers: `accept`,\n`accept-encoding`, `accept-language`, `access-control-request-headers`,\n`cache-control`, `connection`, `content-language`, `cookie`, `forwarded`, `if-\nmatch`, `if-none-match`, `keep-alive`, `range`, `te`, `trailer`, `transfer-\nencoding`, `upgrade`, `user-agent`, `via`, `want-digest`, `x-forwarded-for`.\n\n## Examples\n\n### Code examples\n\n#### Update dynamic rules\n\nThe following example shows how to call `updateDynamicRules()`. The procedure\nfor `updateSessionRules()` is the same.\n\n    \n    \n    // Get arrays containing new and old rules\n    const newRules = await getNewRules();\n    const oldRules = await chrome.declarativeNetRequest.getDynamicRules();\n    const oldRuleIds = oldRules.map(rule => rule.id);\n    \n    // Use the arrays to update the dynamic rules\n    await chrome.declarativeNetRequest.updateDynamicRules({\n      removeRuleIds: oldRuleIds,\n      addRules: newRules\n    });\n    \n\n#### Update static rulesets\n\nThe following example shows how to enable and disable rulesets while\nconsidering the number of available and the maximum number of enabled static\nrulesets. You would do this when the number of static rules you need exceeds\nthe number allowed. For this to work, some of your rulesets should be\ninstalled with some of your rulesets disabled (setting `\"Enabled\"` to `false`\nwithin the manifest file).\n\n    \n    \n    async function updateStaticRules(enableRulesetIds, disableCandidateIds) {\n      // Create the options structure for the call to updateEnabledRulesets()\n      let options = { enableRulesetIds: enableRulesetIds }\n      // Get the number of enabled static rules\n      const enabledStaticCount = await chrome.declarativeNetRequest.getEnabledRulesets();\n      // Compare rule counts to determine if anything needs to be disabled so that\n      // new rules can be enabled\n      const proposedCount = enableRulesetIds.length;\n      if (enabledStaticCount + proposedCount > chrome.declarativeNetRequest.MAX_NUMBER_OF_ENABLED_STATIC_RULESETS) {\n        options.disableRulesetIds = disableCandidateIds\n      }\n      // Update the enabled static rules\n      await chrome.declarativeNetRequest.updateEnabledRulesets(options);\n    }\n    \n\n### Rule examples\n\nThe following examples illustrate how Chrome prioritizes rules in an\nextension. When reviewing them, you may want to open the prioritization rules\nin a separate window.\n\n#### The \"priority\" key\n\nThese examples require host permission to `*://*.example.com/*`.\n\nTo work out the priority of a particular URL, look at the (developer-defined)\n`\"priority\"` key, the `\"action\"` key and the `\"urlFilter\"` key. These examples\nrefer to the example rule file shown below them.\n\nNavigation to https://google.com\n\n    Two rules cover this URL: the rules with IDs 1 and 4. The rule with ID 1 applies because `\"block\"` actions have a higher priority than `\"redirect\"` actions. The remaining rules don't apply because they are for longer URLs.\nNavigation to https://google.com/1234\n\n    Because of the longer URL, the rule with ID 2 now matches in addition to the rules with IDs 1 and 4. The rule with ID 2 applies because `\"allow\"` has a higher priority than `\"block\"` and `\"redirect\"`.\nNavigation to https://google.com/12345\n\n    All four rules match this URL. The rule with ID 3 applies because its developer-defined priority is the highest of the group.\n    \n    \n    [\n      {\n        \"id\": 1,\n        \"priority\": 1,\n        \"action\": { \"type\": \"block\" },\n        \"condition\": {\"urlFilter\": \"||google.com/\", \"resourceTypes\": [\"main_frame\"] }\n      },\n      {\n        \"id\": 2,\n        \"priority\": 1,\n        \"action\": { \"type\": \"allow\" },\n        \"condition\": { \"urlFilter\": \"||google.com/123\", \"resourceTypes\": [\"main_frame\"] }\n      },\n      {\n        \"id\": 3,\n        \"priority\": 2,\n        \"action\": { \"type\": \"block\" },\n        \"condition\": { \"urlFilter\": \"||google.com/12345\", \"resourceTypes\": [\"main_frame\"] }\n      },\n      {\n        \"id\": 4,\n        \"priority\": 1,\n        \"action\": { \"type\": \"redirect\", \"redirect\": { \"url\": \"https://example.com\" } },\n        \"condition\": { \"urlFilter\": \"||google.com/\", \"resourceTypes\": [\"main_frame\"] }\n      },\n    ]\n    \n\n#### Redirects\n\nThe example below requires host permission to `*://*.example.com/*`.\n\nThe following example shows how to redirect a request from example.com to a\npage within the extension itself. The extension path `/a.jpg` resolves to\n`chrome-extension://EXTENSION_ID/a.jpg`, where `EXTENSION_ID` is the ID of\nyour extension. For this to work the manifest should declare `/a.jpg` as a web\naccessible resource.\n\n    \n    \n    {\n      \"id\": 1,\n      \"priority\": 1,\n      \"action\": { \"type\": \"redirect\", \"redirect\": { \"extensionPath\": \"/a.jpg\" } },\n      \"condition\": {\n        \"urlFilter\": \"||https://www.example.com/\",\n        \"resourceTypes\": [\"main_frame\"]\n      }\n    }\n    \n\nThe following uses the `\"transform\"` key to redirect to a subdomain of\nexample.com. It uses a domain name anchor (\"||\") to intercept requests with\nany scheme from example.com. The `\"scheme\"` key in `\"transform\"` specifies\nthat redirects to the subdomain will always use \"https\".\n\n    \n    \n    {\n      \"id\": 1,\n      \"priority\": 1,\n      \"action\": {\n        \"type\": \"redirect\",\n        \"redirect\": {\n          \"transform\": { \"scheme\": \"https\", \"host\": \"new.example.com\" }\n        }\n      },\n      \"condition\": {\n        \"urlFilter\": \"||example.com/\",\n        \"resourceTypes\": [\"main_frame\"]\n      }\n    }\n    \n\nThe following example uses regular expressions to redirect from\n`https://www.abc.xyz.com/path` to `https://abc.xyz.com/path`. In the\n`\"regexFilter\"` key, notice how periods are escaped and that the capturing\ngroup selects either \"abc\" or \"def\". The `\"regexSubstitution\"` key specifies\nthe first returned match of the regular expression using \"\\1\". In this case,\n\"abc\" is captured from the redirected URL and placed in the substitution.\n\n    \n    \n    {\n      \"id\": 1,\n      \"priority\": 1,\n      \"action\": {\n        \"type\": \"redirect\",\n        \"redirect\": {\n          \"regexSubstitution\": \"https://\\\\1.xyz.com/\"\n        }\n      },\n      \"condition\": {\n        \"regexFilter\": \"^https://www\\\\.(abc|def)\\\\.xyz\\\\.com/\",\n        \"resourceTypes\": [\n          \"main_frame\"\n        ]\n      }\n    }\n    \n\n#### Headers\n\nThe following example removes all cookies from both a main frame and any sub\nframes.\n\n    \n    \n    {\n      \"id\": 1,\n      \"priority\": 1,\n      \"action\": {\n        \"type\": \"modifyHeaders\",\n        \"requestHeaders\": [{ \"header\": \"cookie\", \"operation\": \"remove\" }]\n      },\n      \"condition\": { \"resourceTypes\": [\"main_frame\", \"sub_frame\"] }\n    }\n    \n\n## Types\n\n### DomainType\n\nThis describes whether the request is first or third party to the frame in\nwhich it originated. A request is said to be first party if it has the same\ndomain (eTLD+1) as the frame in which the request originated.\n\n#### Enum\n\n\"firstParty\"  \nThe network request is first party to the frame in which it originated.\n\n\"thirdParty\"  \nThe network request is third party to the frame in which it originated.\n\n### ExtensionActionOptions\n\nChrome 88+\n\n#### Properties\n\n  * displayActionCountAsBadgeText\n\nboolean optional\n\nWhether to automatically display the action count for a page as the\nextension's badge text. This preference is persisted across sessions.\n\n  * tabUpdate\n\nTabActionCountUpdate optional\n\nChrome 89+\n\nDetails of how the tab's action count should be adjusted.\n\n### GetDisabledRuleIdsOptions\n\nChrome 111+\n\n#### Properties\n\n  * rulesetId\n\nstring\n\nThe id corresponding to a static `Ruleset`.\n\n### GetRulesFilter\n\nChrome 111+\n\n#### Properties\n\n  * ruleIds\n\nnumber[] optional\n\nIf specified, only rules with matching IDs are included.\n\n### HeaderInfo\n\nChrome 128+\n\n#### Properties\n\n  * excludedValues\n\nstring[] optional\n\nIf specified, this condition is not matched if the header exists but its value\ncontains at least one element in this list. This uses the same match pattern\nsyntax as `values`.\n\n  * header\n\nstring\n\nThe name of the header. This condition matches on the name only if both\n`values` and `excludedValues` are not specified.\n\n  * values\n\nstring[] optional\n\nIf specified, this condition matches if the header's value matches at least\none pattern in this list. This supports case-insensitive header value matching\nplus the following constructs:\n\n**'*'** : Matches any number of characters.\n\n**'?'** : Matches zero or one character(s).\n\n'*' and '?' can be escaped with a backslash, e.g. '\\\\*' and '\\?'\n\n### HeaderOperation\n\nChrome 86+\n\nThis describes the possible operations for a \"modifyHeaders\" rule.\n\n#### Enum\n\n\"append\"  \nAdds a new entry for the specified header. This operation is not supported for\nrequest headers.\n\n\"set\"  \nSets a new value for the specified header, removing any existing headers with\nthe same name.\n\n\"remove\"  \nRemoves all entries for the specified header.\n\n### IsRegexSupportedResult\n\nChrome 87+\n\n#### Properties\n\n  * isSupported\n\nboolean\n\n  * reason\n\nUnsupportedRegexReason optional\n\nSpecifies the reason why the regular expression is not supported. Only\nprovided if `isSupported` is false.\n\n### MatchedRule\n\n#### Properties\n\n  * ruleId\n\nnumber\n\nA matching rule's ID.\n\n  * rulesetId\n\nstring\n\nID of the `Ruleset` this rule belongs to. For a rule originating from the set\nof dynamic rules, this will be equal to `DYNAMIC_RULESET_ID`.\n\n### MatchedRuleInfo\n\n#### Properties\n\n  * rule\n\nMatchedRule\n\n  * tabId\n\nnumber\n\nThe tabId of the tab from which the request originated if the tab is still\nactive. Else -1.\n\n  * timeStamp\n\nnumber\n\nThe time the rule was matched. Timestamps will correspond to the Javascript\nconvention for times, i.e. number of milliseconds since the epoch.\n\n### MatchedRuleInfoDebug\n\n#### Properties\n\n  * request\n\nRequestDetails\n\nDetails about the request for which the rule was matched.\n\n  * rule\n\nMatchedRule\n\n### MatchedRulesFilter\n\n#### Properties\n\n  * minTimeStamp\n\nnumber optional\n\nIf specified, only matches rules after the given timestamp.\n\n  * tabId\n\nnumber optional\n\nIf specified, only matches rules for the given tab. Matches rules not\nassociated with any active tab if set to -1.\n\n### ModifyHeaderInfo\n\nChrome 86+\n\n#### Properties\n\n  * header\n\nstring\n\nThe name of the header to be modified.\n\n  * operation\n\nHeaderOperation\n\nThe operation to be performed on a header.\n\n  * value\n\nstring optional\n\nThe new value for the header. Must be specified for `append` and `set`\noperations.\n\n### QueryKeyValue\n\n#### Properties\n\n  * key\n\nstring\n\n  * replaceOnly\n\nboolean optional\n\nChrome 94+\n\nIf true, the query key is replaced only if it's already present. Otherwise,\nthe key is also added if it's missing. Defaults to false.\n\n  * value\n\nstring\n\n### QueryTransform\n\n#### Properties\n\n  * addOrReplaceParams\n\nQueryKeyValue[] optional\n\nThe list of query key-value pairs to be added or replaced.\n\n  * removeParams\n\nstring[] optional\n\nThe list of query keys to be removed.\n\n### Redirect\n\n#### Properties\n\n  * extensionPath\n\nstring optional\n\nPath relative to the extension directory. Should start with '/'.\n\n  * regexSubstitution\n\nstring optional\n\nSubstitution pattern for rules which specify a `regexFilter`. The first match\nof `regexFilter` within the url will be replaced with this pattern. Within\n`regexSubstitution`, backslash-escaped digits (\\1 to \\9) can be used to insert\nthe corresponding capture groups. \\0 refers to the entire matching text.\n\n  * transform\n\nURLTransform optional\n\nUrl transformations to perform.\n\n  * url\n\nstring optional\n\nThe redirect url. Redirects to JavaScript urls are not allowed.\n\n### RegexOptions\n\nChrome 87+\n\n#### Properties\n\n  * isCaseSensitive\n\nboolean optional\n\nWhether the `regex` specified is case sensitive. Default is true.\n\n  * regex\n\nstring\n\nThe regular expresson to check.\n\n  * requireCapturing\n\nboolean optional\n\nWhether the `regex` specified requires capturing. Capturing is only required\nfor redirect rules which specify a `regexSubstition` action. The default is\nfalse.\n\n### RequestDetails\n\n#### Properties\n\n  * documentId\n\nstring optional\n\nChrome 106+\n\nThe unique identifier for the frame's document, if this request is for a\nframe.\n\n  * documentLifecycle\n\nDocumentLifecycle optional\n\nChrome 106+\n\nThe lifecycle of the frame's document, if this request is for a frame.\n\n  * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n  * frameType\n\nFrameType optional\n\nChrome 106+\n\nThe type of the frame, if this request is for a frame.\n\n  * initiator\n\nstring optional\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n  * method\n\nstring\n\nStandard HTTP method.\n\n  * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe unique identifier for the frame's parent document, if this request is for\na frame and has a parent.\n\n  * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n  * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session.\n\n  * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n  * type\n\nResourceType\n\nThe resource type of the request.\n\n  * url\n\nstring\n\nThe URL of the request.\n\n### RequestMethod\n\nChrome 91+\n\nThis describes the HTTP request method of a network request.\n\n#### Enum\n\n\"connect\"  \n\n\"delete\"  \n\n\"get\"  \n\n\"head\"  \n\n\"options\"  \n\n\"patch\"  \n\n\"post\"  \n\n\"put\"  \n\n\"other\"  \n\n### ResourceType\n\nThis describes the resource type of the network request.\n\n#### Enum\n\n\"main_frame\"  \n\n\"sub_frame\"  \n\n\"stylesheet\"  \n\n\"script\"  \n\n\"image\"  \n\n\"font\"  \n\n\"object\"  \n\n\"xmlhttprequest\"  \n\n\"ping\"  \n\n\"csp_report\"  \n\n\"media\"  \n\n\"websocket\"  \n\n\"webtransport\"  \n\n\"webbundle\"  \n\n\"other\"  \n\n### Rule\n\n#### Properties\n\n  * action\n\nRuleAction\n\nThe action to take if this rule is matched.\n\n  * condition\n\nRuleCondition\n\nThe condition under which this rule is triggered.\n\n  * id\n\nnumber\n\nAn id which uniquely identifies a rule. Mandatory and should be >= 1.\n\n  * priority\n\nnumber optional\n\nRule priority. Defaults to 1. When specified, should be >= 1.\n\n### RuleAction\n\n#### Properties\n\n  * redirect\n\nRedirect optional\n\nDescribes how the redirect should be performed. Only valid for redirect rules.\n\n  * requestHeaders\n\nModifyHeaderInfo[] optional\n\nChrome 86+\n\nThe request headers to modify for the request. Only valid if RuleActionType is\n\"modifyHeaders\".\n\n  * responseHeaders\n\nModifyHeaderInfo[] optional\n\nChrome 86+\n\nThe response headers to modify for the request. Only valid if RuleActionType\nis \"modifyHeaders\".\n\n  * type\n\nRuleActionType\n\nThe type of action to perform.\n\n### RuleActionType\n\nDescribes the kind of action to take if a given RuleCondition matches.\n\n#### Enum\n\n\"block\"  \nBlock the network request.\n\n\"redirect\"  \nRedirect the network request.\n\n\"allow\"  \nAllow the network request. The request won't be intercepted if there is an\nallow rule which matches it.\n\n\"upgradeScheme\"  \nUpgrade the network request url's scheme to https if the request is http or\nftp.\n\n\"modifyHeaders\"  \nModify request/response headers from the network request.\n\n\"allowAllRequests\"  \nAllow all requests within a frame hierarchy, including the frame request\nitself.\n\n### RuleCondition\n\n#### Properties\n\n  * domainType\n\nDomainType optional\n\nSpecifies whether the network request is first-party or third-party to the\ndomain from which it originated. If omitted, all requests are accepted.\n\n  * domains\n\nstring[] optional\n\nDeprecated since Chrome 101\n\nUse `initiatorDomains` instead\n\nThe rule will only match network requests originating from the list of\n`domains`.\n\n  * excludedDomains\n\nstring[] optional\n\nDeprecated since Chrome 101\n\nUse `excludedInitiatorDomains` instead\n\nThe rule will not match network requests originating from the list of\n`excludedDomains`.\n\n  * excludedInitiatorDomains\n\nstring[] optional\n\nChrome 101+\n\nThe rule will not match network requests originating from the list of\n`excludedInitiatorDomains`. If the list is empty or omitted, no domains are\nexcluded. This takes precedence over `initiatorDomains`.\n\nNotes:\n\n    * Sub-domains like \"a.example.com\" are also allowed.\n    * The entries must consist of only ascii characters.\n    * Use punycode encoding for internationalized domains.\n    * This matches against the request initiator and not the request url.\n    * Sub-domains of the listed domains are also excluded.\n  * excludedRequestDomains\n\nstring[] optional\n\nChrome 101+\n\nThe rule will not match network requests when the domains matches one from the\nlist of `excludedRequestDomains`. If the list is empty or omitted, no domains\nare excluded. This takes precedence over `requestDomains`.\n\nNotes:\n\n    * Sub-domains like \"a.example.com\" are also allowed.\n    * The entries must consist of only ascii characters.\n    * Use punycode encoding for internationalized domains.\n    * Sub-domains of the listed domains are also excluded.\n  * excludedRequestMethods\n\nRequestMethod[] optional\n\nChrome 91+\n\nList of request methods which the rule won't match. Only one of\n`requestMethods` and `excludedRequestMethods` should be specified. If neither\nof them is specified, all request methods are matched.\n\n  * excludedResourceTypes\n\nResourceType[] optional\n\nList of resource types which the rule won't match. Only one of `resourceTypes`\nand `excludedResourceTypes` should be specified. If neither of them is\nspecified, all resource types except \"main_frame\" are blocked.\n\n  * excludedResponseHeaders\n\nHeaderInfo[] optional\n\nChrome 128+\n\nRule does not match if the request matches any response header condition in\nthis list (if specified). If both `excludedResponseHeaders` and\n`responseHeaders` are specified, then the `excludedResponseHeaders` property\ntakes precedence.\n\n  * excludedTabIds\n\nnumber[] optional\n\nChrome 92+\n\nList of `tabs.Tab.id` which the rule should not match. An ID of\n`tabs.TAB_ID_NONE` excludes requests which don't originate from a tab. Only\nsupported for session-scoped rules.\n\n  * initiatorDomains\n\nstring[] optional\n\nChrome 101+\n\nThe rule will only match network requests originating from the list of\n`initiatorDomains`. If the list is omitted, the rule is applied to requests\nfrom all domains. An empty list is not allowed.\n\nNotes:\n\n    * Sub-domains like \"a.example.com\" are also allowed.\n    * The entries must consist of only ascii characters.\n    * Use punycode encoding for internationalized domains.\n    * This matches against the request initiator and not the request url.\n    * Sub-domains of the listed domains are also matched.\n  * isUrlFilterCaseSensitive\n\nboolean optional\n\nWhether the `urlFilter` or `regexFilter` (whichever is specified) is case\nsensitive. Default is false.\n\n  * regexFilter\n\nstring optional\n\nRegular expression to match against the network request url. This follows the\nRE2 syntax.\n\nNote: Only one of `urlFilter` or `regexFilter` can be specified.\n\nNote: The `regexFilter` must be composed of only ASCII characters. This is\nmatched against a url where the host is encoded in the punycode format (in\ncase of internationalized domains) and any other non-ascii characters are url\nencoded in utf-8.\n\n  * requestDomains\n\nstring[] optional\n\nChrome 101+\n\nThe rule will only match network requests when the domain matches one from the\nlist of `requestDomains`. If the list is omitted, the rule is applied to\nrequests from all domains. An empty list is not allowed.\n\nNotes:\n\n    * Sub-domains like \"a.example.com\" are also allowed.\n    * The entries must consist of only ascii characters.\n    * Use punycode encoding for internationalized domains.\n    * Sub-domains of the listed domains are also matched.\n  * requestMethods\n\nRequestMethod[] optional\n\nChrome 91+\n\nList of HTTP request methods which the rule can match. An empty list is not\nallowed.\n\nNote: Specifying a `requestMethods` rule condition will also exclude non-\nHTTP(s) requests, whereas specifying `excludedRequestMethods` will not.\n\n  * resourceTypes\n\nResourceType[] optional\n\nList of resource types which the rule can match. An empty list is not allowed.\n\nNote: this must be specified for `allowAllRequests` rules and may only include\nthe `sub_frame` and `main_frame` resource types.\n\n  * responseHeaders\n\nHeaderInfo[] optional\n\nChrome 128+\n\nRule matches if the request matches any response header condition in this list\n(if specified).\n\n  * tabIds\n\nnumber[] optional\n\nChrome 92+\n\nList of `tabs.Tab.id` which the rule should match. An ID of `tabs.TAB_ID_NONE`\nmatches requests which don't originate from a tab. An empty list is not\nallowed. Only supported for session-scoped rules.\n\n  * urlFilter\n\nstring optional\n\nThe pattern which is matched against the network request url. Supported\nconstructs:\n\n**'*'** : Wildcard: Matches any number of characters.\n\n**'|'** : Left/right anchor: If used at either end of the pattern, specifies\nthe beginning/end of the url respectively.\n\n**'||'** : Domain name anchor: If used at the beginning of the pattern,\nspecifies the start of a (sub-)domain of the URL.\n\n**'^'** : Separator character: This matches anything except a letter, a digit,\nor one of the following: `_`, `-`, `.`, or `%`. This also match the end of the\nURL.\n\nTherefore `urlFilter` is composed of the following parts: (optional\nLeft/Domain name anchor) + pattern + (optional Right anchor).\n\nIf omitted, all urls are matched. An empty string is not allowed.\n\nA pattern beginning with `||*` is not allowed. Use `*` instead.\n\nNote: Only one of `urlFilter` or `regexFilter` can be specified.\n\nNote: The `urlFilter` must be composed of only ASCII characters. This is\nmatched against a url where the host is encoded in the punycode format (in\ncase of internationalized domains) and any other non-ascii characters are url\nencoded in utf-8. For example, when the request url is http://abc.?q=, the\n`urlFilter` will be matched against the url http://abc.xn--p1ai/?q=%D1%84.\n\n### Ruleset\n\n#### Properties\n\n  * enabled\n\nboolean\n\nWhether the ruleset is enabled by default.\n\n  * id\n\nstring\n\nA non-empty string uniquely identifying the ruleset. IDs beginning with '_'\nare reserved for internal use.\n\n  * path\n\nstring\n\nThe path of the JSON ruleset relative to the extension directory.\n\n### RulesMatchedDetails\n\n#### Properties\n\n  * rulesMatchedInfo\n\nMatchedRuleInfo[]\n\nRules matching the given filter.\n\n### TabActionCountUpdate\n\nChrome 89+\n\n#### Properties\n\n  * increment\n\nnumber\n\nThe amount to increment the tab's action count by. Negative values will\ndecrement the count.\n\n  * tabId\n\nnumber\n\nThe tab for which to update the action count.\n\n### TestMatchOutcomeResult\n\nChrome 103+\n\n#### Properties\n\n  * matchedRules\n\nMatchedRule[]\n\nThe rules (if any) that match the hypothetical request.\n\n### TestMatchRequestDetails\n\nChrome 103+\n\n#### Properties\n\n  * initiator\n\nstring optional\n\nThe initiator URL (if any) for the hypothetical request.\n\n  * method\n\nRequestMethod optional\n\nStandard HTTP method of the hypothetical request. Defaults to \"get\" for HTTP\nrequests and is ignored for non-HTTP requests.\n\n  * responseHeaders\n\nobject optional\n\nChrome 129+\n\nThe headers provided by a hypothetical response if the request does not get\nblocked or redirected before it is sent. Represented as an object which maps a\nheader name to a list of string values. If not specified, the hypothetical\nresponse would return empty response headers, which can match rules which\nmatch on the non-existence of headers. E.g. `{\"content-type\": [\"text/html;\ncharset=utf-8\", \"multipart/form-data\"]}`\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab in which the hypothetical request takes place. Does not need\nto correspond to a real tab ID. Default is -1, meaning that the request isn't\nrelated to a tab.\n\n  * type\n\nResourceType\n\nThe resource type of the hypothetical request.\n\n  * url\n\nstring\n\nThe URL of the hypothetical request.\n\n### UnsupportedRegexReason\n\nChrome 87+\n\nDescribes the reason why a given regular expression isn't supported.\n\n#### Enum\n\n\"syntaxError\"  \nThe regular expression is syntactically incorrect, or uses features not\navailable in the RE2 syntax.\n\n\"memoryLimitExceeded\"  \nThe regular expression exceeds the memory limit.\n\n### UpdateRuleOptions\n\nChrome 87+\n\n#### Properties\n\n  * addRules\n\nRule[] optional\n\nRules to add.\n\n  * removeRuleIds\n\nnumber[] optional\n\nIDs of the rules to remove. Any invalid IDs will be ignored.\n\n### UpdateRulesetOptions\n\nChrome 87+\n\n#### Properties\n\n  * disableRulesetIds\n\nstring[] optional\n\nThe set of ids corresponding to a static `Ruleset` that should be disabled.\n\n  * enableRulesetIds\n\nstring[] optional\n\nThe set of ids corresponding to a static `Ruleset` that should be enabled.\n\n### UpdateStaticRulesOptions\n\nChrome 111+\n\n#### Properties\n\n  * disableRuleIds\n\nnumber[] optional\n\nSet of ids corresponding to rules in the `Ruleset` to disable.\n\n  * enableRuleIds\n\nnumber[] optional\n\nSet of ids corresponding to rules in the `Ruleset` to enable.\n\n  * rulesetId\n\nstring\n\nThe id corresponding to a static `Ruleset`.\n\n### URLTransform\n\n#### Properties\n\n  * fragment\n\nstring optional\n\nThe new fragment for the request. Should be either empty, in which case the\nexisting fragment is cleared; or should begin with '#'.\n\n  * host\n\nstring optional\n\nThe new host for the request.\n\n  * password\n\nstring optional\n\nThe new password for the request.\n\n  * path\n\nstring optional\n\nThe new path for the request. If empty, the existing path is cleared.\n\n  * port\n\nstring optional\n\nThe new port for the request. If empty, the existing port is cleared.\n\n  * query\n\nstring optional\n\nThe new query for the request. Should be either empty, in which case the\nexisting query is cleared; or should begin with '?'.\n\n  * queryTransform\n\nQueryTransform optional\n\nAdd, remove or replace query key-value pairs.\n\n  * scheme\n\nstring optional\n\nThe new scheme for the request. Allowed values are \"http\", \"https\", \"ftp\" and\n\"chrome-extension\".\n\n  * username\n\nstring optional\n\nThe new username for the request.\n\n## Properties\n\n### DYNAMIC_RULESET_ID\n\nRuleset ID for the dynamic rules added by the extension.\n\n#### Value\n\n\"_dynamic\"  \n\n### GETMATCHEDRULES_QUOTA_INTERVAL\n\nTime interval within which `MAX_GETMATCHEDRULES_CALLS_PER_INTERVAL\ngetMatchedRules` calls can be made, specified in minutes. Additional calls\nwill fail immediately and set `runtime.lastError`. Note: `getMatchedRules`\ncalls associated with a user gesture are exempt from the quota.\n\n#### Value\n\n10  \n\n### GUARANTEED_MINIMUM_STATIC_RULES\n\nChrome 89+\n\nThe minimum number of static rules guaranteed to an extension across its\nenabled static rulesets. Any rules above this limit will count towards the\nglobal static rule limit.\n\n#### Value\n\n30000  \n\n### MAX_GETMATCHEDRULES_CALLS_PER_INTERVAL\n\nThe number of times `getMatchedRules` can be called within a period of\n`GETMATCHEDRULES_QUOTA_INTERVAL`.\n\n#### Value\n\n20  \n\n### MAX_NUMBER_OF_DYNAMIC_RULES\n\nThe maximum number of dynamic rules that an extension can add.\n\n#### Value\n\n30000  \n\n### MAX_NUMBER_OF_ENABLED_STATIC_RULESETS\n\nChrome 94+\n\nThe maximum number of static `Rulesets` an extension can enable at any one\ntime.\n\n#### Value\n\n50  \n\n### MAX_NUMBER_OF_REGEX_RULES\n\nThe maximum number of regular expression rules that an extension can add. This\nlimit is evaluated separately for the set of dynamic rules and those specified\nin the rule resources file.\n\n#### Value\n\n1000  \n\n### MAX_NUMBER_OF_SESSION_RULES\n\nChrome 120+\n\nThe maximum number of session scoped rules that an extension can add.\n\n#### Value\n\n5000  \n\n### MAX_NUMBER_OF_STATIC_RULESETS\n\nThe maximum number of static `Rulesets` an extension can specify as part of\nthe `\"rule_resources\"` manifest key.\n\n#### Value\n\n100  \n\n### MAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES\n\nChrome 120+\n\nThe maximum number of \"unsafe\" dynamic rules that an extension can add.\n\n#### Value\n\n5000  \n\n### MAX_NUMBER_OF_UNSAFE_SESSION_RULES\n\nChrome 120+\n\nThe maximum number of \"unsafe\" session scoped rules that an extension can add.\n\n#### Value\n\n5000  \n\n### SESSION_RULESET_ID\n\nChrome 90+\n\nRuleset ID for the session-scoped rules added by the extension.\n\n#### Value\n\n\"_session\"  \n\n## Methods\n\n### getAvailableStaticRuleCount()\n\nPromise Chrome 89+\n\n    \n    \n    chrome.declarativeNetRequest.getAvailableStaticRuleCount(  \n      callback?: function,  \n    )\n\nReturns the number of static rules an extension can enable before the global\nstatic rule limit is reached.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (count: number) => void\n\n    * count\n\nnumber\n\n#### Returns\n\n  * Promise<number>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDisabledRuleIds()\n\nPromise Chrome 111+\n\n    \n    \n    chrome.declarativeNetRequest.getDisabledRuleIds(  \n      options: GetDisabledRuleIdsOptions,  \n      callback?: function,  \n    )\n\nReturns the list of static rules in the given `Ruleset` that are currently\ndisabled.\n\n#### Parameters\n\n  * options\n\nGetDisabledRuleIdsOptions\n\nSpecifies the ruleset to query.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (disabledRuleIds: number[]) => void\n\n    * disabledRuleIds\n\nnumber[]\n\n#### Returns\n\n  * Promise<number[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDynamicRules()\n\nPromise\n\n    \n    \n    chrome.declarativeNetRequest.getDynamicRules(  \n      filter?: GetRulesFilter,  \n      callback?: function,  \n    )\n\nReturns the current set of dynamic rules for the extension. Callers can\noptionally filter the list of fetched rules by specifying a `filter`.\n\n#### Parameters\n\n  * filter\n\nGetRulesFilter optional\n\nChrome 111+\n\nAn object to filter the list of fetched rules.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (rules: Rule[]) => void\n\n    * rules\n\nRule[]\n\n#### Returns\n\n  * Promise<Rule[]>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getEnabledRulesets()\n\nPromise\n\n    \n    \n    chrome.declarativeNetRequest.getEnabledRulesets(  \n      callback?: function,  \n    )\n\nReturns the ids for the current set of enabled static rulesets.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (rulesetIds: string[]) => void\n\n    * rulesetIds\n\nstring[]\n\n#### Returns\n\n  * Promise<string[]>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getMatchedRules()\n\nPromise\n\n    \n    \n    chrome.declarativeNetRequest.getMatchedRules(  \n      filter?: MatchedRulesFilter,  \n      callback?: function,  \n    )\n\nReturns all rules matched for the extension. Callers can optionally filter the\nlist of matched rules by specifying a `filter`. This method is only available\nto extensions with the `\"declarativeNetRequestFeedback\"` permission or having\nthe `\"activeTab\"` permission granted for the `tabId` specified in `filter`.\nNote: Rules not associated with an active document that were matched more than\nfive minutes ago will not be returned.\n\n#### Parameters\n\n  * filter\n\nMatchedRulesFilter optional\n\nAn object to filter the list of matched rules.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details: RulesMatchedDetails) => void\n\n    * details\n\nRulesMatchedDetails\n\n#### Returns\n\n  * Promise<RulesMatchedDetails>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getSessionRules()\n\nPromise Chrome 90+\n\n    \n    \n    chrome.declarativeNetRequest.getSessionRules(  \n      filter?: GetRulesFilter,  \n      callback?: function,  \n    )\n\nReturns the current set of session scoped rules for the extension. Callers can\noptionally filter the list of fetched rules by specifying a `filter`.\n\n#### Parameters\n\n  * filter\n\nGetRulesFilter optional\n\nChrome 111+\n\nAn object to filter the list of fetched rules.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (rules: Rule[]) => void\n\n    * rules\n\nRule[]\n\n#### Returns\n\n  * Promise<Rule[]>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### isRegexSupported()\n\nPromise Chrome 87+\n\n    \n    \n    chrome.declarativeNetRequest.isRegexSupported(  \n      regexOptions: RegexOptions,  \n      callback?: function,  \n    )\n\nChecks if the given regular expression will be supported as a `regexFilter`\nrule condition.\n\n#### Parameters\n\n  * regexOptions\n\nRegexOptions\n\nThe regular expression to check.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: IsRegexSupportedResult) => void\n\n    * result\n\nIsRegexSupportedResult\n\n#### Returns\n\n  * Promise<IsRegexSupportedResult>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setExtensionActionOptions()\n\nPromise Chrome 88+\n\n    \n    \n    chrome.declarativeNetRequest.setExtensionActionOptions(  \n      options: ExtensionActionOptions,  \n      callback?: function,  \n    )\n\nConfigures if the action count for tabs should be displayed as the extension\naction's badge text and provides a way for that action count to be\nincremented.\n\n#### Parameters\n\n  * options\n\nExtensionActionOptions\n\n  * callback\n\nfunction optional\n\nChrome 89+\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### testMatchOutcome()\n\nPromise Chrome 103+\n\n    \n    \n    chrome.declarativeNetRequest.testMatchOutcome(  \n      request: TestMatchRequestDetails,  \n      callback?: function,  \n    )\n\nChecks if any of the extension's declarativeNetRequest rules would match a\nhypothetical request. Note: Only available for unpacked extensions as this is\nonly intended to be used during extension development.\n\n#### Parameters\n\n  * request\n\nTestMatchRequestDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: TestMatchOutcomeResult) => void\n\n    * result\n\nTestMatchOutcomeResult\n\n#### Returns\n\n  * Promise<TestMatchOutcomeResult>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### updateDynamicRules()\n\nPromise\n\n    \n    \n    chrome.declarativeNetRequest.updateDynamicRules(  \n      options: UpdateRuleOptions,  \n      callback?: function,  \n    )\n\nModifies the current set of dynamic rules for the extension. The rules with\nIDs listed in `options.removeRuleIds` are first removed, and then the rules\ngiven in `options.addRules` are added. Notes:\n\n  * This update happens as a single atomic operation: either all specified rules are added and removed, or an error is returned.\n  * These rules are persisted across browser sessions and across extension updates.\n  * Static rules specified as part of the extension package can not be removed using this function.\n  * `MAX_NUMBER_OF_DYNAMIC_RULES` is the maximum number of dynamic rules an extension can add. The number of unsafe rules must not exceed `MAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES`.\n\n#### Parameters\n\n  * options\n\nUpdateRuleOptions\n\nChrome 87+\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### updateEnabledRulesets()\n\nPromise\n\n    \n    \n    chrome.declarativeNetRequest.updateEnabledRulesets(  \n      options: UpdateRulesetOptions,  \n      callback?: function,  \n    )\n\nUpdates the set of enabled static rulesets for the extension. The rulesets\nwith IDs listed in `options.disableRulesetIds` are first removed, and then the\nrulesets listed in `options.enableRulesetIds` are added. Note that the set of\nenabled static rulesets is persisted across sessions but not across extension\nupdates, i.e. the `rule_resources` manifest key will determine the set of\nenabled static rulesets on each extension update.\n\n#### Parameters\n\n  * options\n\nUpdateRulesetOptions\n\nChrome 87+\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### updateSessionRules()\n\nPromise Chrome 90+\n\n    \n    \n    chrome.declarativeNetRequest.updateSessionRules(  \n      options: UpdateRuleOptions,  \n      callback?: function,  \n    )\n\nModifies the current set of session scoped rules for the extension. The rules\nwith IDs listed in `options.removeRuleIds` are first removed, and then the\nrules given in `options.addRules` are added. Notes:\n\n  * This update happens as a single atomic operation: either all specified rules are added and removed, or an error is returned.\n  * These rules are not persisted across sessions and are backed in memory.\n  * `MAX_NUMBER_OF_SESSION_RULES` is the maximum number of session rules an extension can add.\n\n#### Parameters\n\n  * options\n\nUpdateRuleOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### updateStaticRules()\n\nPromise Chrome 111+\n\n    \n    \n    chrome.declarativeNetRequest.updateStaticRules(  \n      options: UpdateStaticRulesOptions,  \n      callback?: function,  \n    )\n\nDisables and enables individual static rules in a `Ruleset`. Changes to rules\nbelonging to a disabled `Ruleset` will take effect the next time that it\nbecomes enabled.\n\n#### Parameters\n\n  * options\n\nUpdateStaticRulesOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onRuleMatchedDebug\n\n    \n    \n    chrome.declarativeNetRequest.onRuleMatchedDebug.addListener(  \n      callback: function,  \n    )\n\nFired when a rule is matched with a request. Only available for unpacked\nextensions with the `\"declarativeNetRequestFeedback\"` permission as this is\nintended to be used for debugging purposes only.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (info: MatchedRuleInfoDebug) => void\n\n    * info\n\nMatchedRuleInfoDebug\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/desktopCapture": "#  chrome.desktopCapture\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe Desktop Capture API captures the content of the screen, individual\nwindows, or individual tabs.\n\n## Permissions\n\n`desktopCapture`  \n\n## Types\n\n### DesktopCaptureSourceType\n\nEnum used to define set of desktop media sources used in chooseDesktopMedia().\n\n#### Enum\n\n\"screen\"  \n\n\"window\"  \n\n\"tab\"  \n\n\"audio\"  \n\n### SelfCapturePreferenceEnum\n\nChrome 107+\n\nMirrors SelfCapturePreferenceEnum.\n\n#### Enum\n\n\"include\"  \n\n\"exclude\"  \n\n### SystemAudioPreferenceEnum\n\nChrome 105+\n\nMirrors SystemAudioPreferenceEnum.\n\n#### Enum\n\n\"include\"  \n\n\"exclude\"  \n\n## Methods\n\n### cancelChooseDesktopMedia()\n\n    \n    \n    chrome.desktopCapture.cancelChooseDesktopMedia(  \n      desktopMediaRequestId: number,  \n    )\n\nHides desktop media picker dialog shown by chooseDesktopMedia().\n\n#### Parameters\n\n  * desktopMediaRequestId\n\nnumber\n\nId returned by chooseDesktopMedia()\n\n### chooseDesktopMedia()\n\n    \n    \n    chrome.desktopCapture.chooseDesktopMedia(  \n      sources: DesktopCaptureSourceType[],  \n      targetTab?: Tab,  \n      callback: function,  \n    )\n\nShows desktop media picker UI with the specified set of sources.\n\n#### Parameters\n\n  * sources\n\nDesktopCaptureSourceType[]\n\nSet of sources that should be shown to the user. The sources order in the set\ndecides the tab order in the picker.\n\n  * targetTab\n\nTab optional\n\nOptional tab for which the stream is created. If not specified then the\nresulting stream can be used only by the calling extension. The stream can\nonly be used by frames in the given tab whose security origin matches\n`tab.url`. The tab's origin must be a secure origin, e.g. HTTPS.\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (streamId: string, options: object) => void\n\n    * streamId\n\nstring\n\nAn opaque string that can be passed to `getUserMedia()` API to generate media\nstream that corresponds to the source selected by the user. If user didn't\nselect any source (i.e. canceled the prompt) then the callback is called with\nan empty `streamId`. The created `streamId` can be used only once and expires\nafter a few seconds when it is not used.\n\n    * options\n\nobject\n\nChrome 57+\n\nContains properties that describe the stream.\n\n      * canRequestAudioTrack\n\nboolean\n\nTrue if \"audio\" is included in parameter sources, and the end user does not\nuncheck the \"Share audio\" checkbox. Otherwise false, and in this case, one\nshould not ask for audio stream through getUserMedia call.\n\n#### Returns\n\n  * number\n\nAn id that can be passed to cancelChooseDesktopMedia() in case the prompt need\nto be canceled.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/devtools/inspectedWindow": "#  chrome.devtools.inspectedWindow\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.devtools.inspectedWindow` API to interact with the inspected\nwindow: obtain the tab ID for the inspected page, evaluate the code in the\ncontext of the inspected window, reload the page, or obtain the list of\nresources within the page.\n\nSee DevTools APIs summary for general introduction to using Developer Tools\nAPIs.\n\nThe `tabId` property provides the tab identifier that you can use with the\n`chrome.tabs.*` API calls. However, please note that `chrome.tabs.*` API is\nnot exposed to the Developer Tools extension pages due to security\nconsiderationsyou will need to pass the tab ID to the background page and\ninvoke the `chrome.tabs.*` API functions from there.\n\nThe `reload` method may be used to reload the inspected page. Additionally,\nthe caller can specify an override for the user agent string, a script that\nwill be injected early upon page load, or an option to force reload of cached\nresources.\n\nUse the `getResources` call and the `onResourceContent` event to obtain the\nlist of resources (documents, stylesheets, scripts, images etc) within the\ninspected page. The `getContent` and `setContent` methods of the `Resource`\nclass along with the `onResourceContentCommitted` event may be used to support\nmodification of the resource content, for example, by an external editor.\n\n## Manifest\n\nThe following keys must be declared in the manifest to use this API.\n\n`\"devtools_page\"`  \n\n## Execute code in the inspected window\n\nThe `eval` method provides the ability for extensions to execute JavaScript\ncode in the context of the inspected page. This method is powerful when used\nin the right context and dangerous when used inappropriately. Use the\n`tabs.executeScript` method unless you need the specific functionality that\nthe `eval` method provides.\n\nHere are the main differences between the `eval` and `tabs.executeScript`\nmethods:\n\n  * The `eval` method does not use an isolated world for the code being evaluated, so the JavaScript state of the inspected window is accessible to the code. Use this method when access to the JavaScript state of the inspected page is required.\n  * The execution context of the code being evaluated includes the Developer Tools console API. For example, the code can use `inspect` and `$0`.\n  * The evaluated code may return a value that is passed to the extension callback. The returned value has to be a valid JSON object (it may contain only primitive JavaScript types and acyclic references to other JSON objects). _Please observe extra care while processing the data received from the inspected pagethe execution context is essentially controlled by the inspected page; a malicious page may affect the data being returned to the extension._\n\n**Caution:** Due to the security considerations explained above, the\n`scripting.executeScript` method is the preferred way for an extension to\naccess DOM data of the inspected page in cases where the access to JavaScript\nstate of the inspected page is not required.\n\nNote that a page can include multiple different JavaScript execution contexts.\nEach frame has its own context, plus an additional context for each extension\nthat has content scripts running in that frame.\n\nBy default, the `eval` method executes in the context of the main frame of the\ninspected page.\n\nThe `eval` method takes an optional second argument that you can use to\nspecify the context in which the code is evaluated. This _options_ object can\ncontain one or more of the following keys:\n\n`frameURL`\n\n    Use to specify a frame other than the inspected page's main frame.\n`contextSecurityOrigin`\n\n    Use to select a context within the specified frame according to its web origin.\n`useContentScriptContext`\n\n    If true, execute the script in the same context as the extensions's content scripts. (Equivalent to specifying the extensions's own web orgin as the context security origin.) This can be used to exchange data with the content script.\n\n## Examples\n\nThe following code checks for the version of jQuery used by the inspected\npage:\n\n    \n    \n    chrome.devtools.inspectedWindow.eval(\n      \"jQuery.fn.jquery\",\n      function(result, isException) {\n        if (isException) {\n          console.log(\"the page is not using jQuery\");\n        } else {\n          console.log(\"The page is using jQuery v\" + result);\n        }\n      }\n    );\n    \n\nTo try this API, install the devtools API examples from the chrome-extension-\nsamples repository.\n\n## Types\n\n### Resource\n\nA resource within the inspected page, such as a document, a script, or an\nimage.\n\n#### Properties\n\n  * url\n\nstring\n\nThe URL of the resource.\n\n  * getContent\n\nvoid\n\nGets the content of the resource.\n\nThe `getContent` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (content: string, encoding: string) => void\n\n      * content\n\nstring\n\nContent of the resource (potentially encoded).\n\n      * encoding\n\nstring\n\nEmpty if the content is not encoded, encoding name otherwise. Currently, only\nbase64 is supported.\n\n  * setContent\n\nvoid\n\nSets the content of the resource.\n\nThe `setContent` function looks like:\n\n        \n        (content: string, commit: boolean, callback?: function) => {...}\n\n    * content\n\nstring\n\nNew content of the resource. Only resources with the text type are currently\nsupported.\n\n    * commit\n\nboolean\n\nTrue if the user has finished editing the resource, and the new content of the\nresource should be persisted; false if this is a minor change sent in progress\nof the user editing the resource.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (error?: object) => void\n\n      * error\n\nobject optional\n\nSet to undefined if the resource content was set successfully; describes error\notherwise.\n\n## Properties\n\n### tabId\n\nThe ID of the tab being inspected. This ID may be used with chrome.tabs.* API.\n\n#### Type\n\nnumber\n\n## Methods\n\n### eval()\n\n    \n    \n    chrome.devtools.inspectedWindow.eval(  \n      expression: string,  \n      options?: object,  \n      callback?: function,  \n    )\n\nEvaluates a JavaScript expression in the context of the main frame of the\ninspected page. The expression must evaluate to a JSON-compliant object,\notherwise an exception is thrown. The eval function can report either a\nDevTools-side error or a JavaScript exception that occurs during evaluation.\nIn either case, the `result` parameter of the callback is `undefined`. In the\ncase of a DevTools-side error, the `isException` parameter is non-null and has\n`isError` set to true and `code` set to an error code. In the case of a\nJavaScript error, `isException` is set to true and `value` is set to the\nstring value of thrown object.\n\n#### Parameters\n\n  * expression\n\nstring\n\nAn expression to evaluate.\n\n  * options\n\nobject optional\n\nThe options parameter can contain one or more options.\n\n    * frameURL\n\nstring optional\n\nIf specified, the expression is evaluated on the iframe whose URL matches the\none specified. By default, the expression is evaluated in the top frame of the\ninspected page.\n\n    * scriptExecutionContext\n\nstring optional\n\nChrome 107+\n\nEvaluate the expression in the context of a content script of an extension\nthat matches the specified origin. If given, scriptExecutionContext overrides\nthe 'true' setting on useContentScriptContext.\n\n    * useContentScriptContext\n\nboolean optional\n\nEvaluate the expression in the context of the content script of the calling\nextension, provided that the content script is already injected into the\ninspected page. If not, the expression is not evaluated and the callback is\ninvoked with the exception parameter set to an object that has the `isError`\nfield set to true and the `code` field set to `E_NOTFOUND`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: object, exceptionInfo: object) => void\n\n    * result\n\nobject\n\nThe result of evaluation.\n\n    * exceptionInfo\n\nobject\n\nAn object providing details if an exception occurred while evaluating the\nexpression.\n\n      * code\n\nstring\n\nSet if the error occurred on the DevTools side before the expression is\nevaluated.\n\n      * description\n\nstring\n\nSet if the error occurred on the DevTools side before the expression is\nevaluated.\n\n      * details\n\nany[]\n\nSet if the error occurred on the DevTools side before the expression is\nevaluated, contains the array of the values that may be substituted into the\ndescription string to provide more information about the cause of the error.\n\n      * isError\n\nboolean\n\nSet if the error occurred on the DevTools side before the expression is\nevaluated.\n\n      * isException\n\nboolean\n\nSet if the evaluated code produces an unhandled exception.\n\n      * value\n\nstring\n\nSet if the evaluated code produces an unhandled exception.\n\n### getResources()\n\n    \n    \n    chrome.devtools.inspectedWindow.getResources(  \n      callback: function,  \n    )\n\nRetrieves the list of resources from the inspected page.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (resources: Resource[]) => void\n\n    * resources\n\nResource[]\n\nThe resources within the page.\n\n### reload()\n\n    \n    \n    chrome.devtools.inspectedWindow.reload(  \n      reloadOptions?: object,  \n    )\n\nReloads the inspected page.\n\n#### Parameters\n\n  * reloadOptions\n\nobject optional\n\n    * ignoreCache\n\nboolean optional\n\nWhen true, the loader will bypass the cache for all inspected page resources\nloaded before the `load` event is fired. The effect is similar to pressing\nCtrl+Shift+R in the inspected window or within the Developer Tools window.\n\n    * injectedScript\n\nstring optional\n\nIf specified, the script will be injected into every frame of the inspected\npage immediately upon load, before any of the frame's scripts. The script will\nnot be injected after subsequent reloadsfor example, if the user presses\nCtrl+R.\n\n    * userAgent\n\nstring optional\n\nIf specified, the string will override the value of the `User-Agent` HTTP\nheader that's sent while loading the resources of the inspected page. The\nstring will also override the value of the `navigator.userAgent` property\nthat's returned to any scripts that are running within the inspected page.\n\n## Events\n\n### onResourceAdded\n\n    \n    \n    chrome.devtools.inspectedWindow.onResourceAdded.addListener(  \n      callback: function,  \n    )\n\nFired when a new resource is added to the inspected page.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (resource: Resource) => void\n\n    * resource\n\nResource\n\n### onResourceContentCommitted\n\n    \n    \n    chrome.devtools.inspectedWindow.onResourceContentCommitted.addListener(  \n      callback: function,  \n    )\n\nFired when a new revision of the resource is committed (e.g. user saves an\nedited version of the resource in the Developer Tools).\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (resource: Resource, content: string) => void\n\n    * resource\n\nResource\n\n    * content\n\nstring\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/devtools/network": "#  chrome.devtools.network\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.devtools.network` API to retrieve the information about\nnetwork requests displayed by the Developer Tools in the Network panel.\n\nNetwork requests information is represented in the HTTP Archive format\n(_HAR_). The description of HAR is outside of scope of this document, refer to\nHAR v1.2 Specification.\n\nIn terms of HAR, the `chrome.devtools.network.getHAR()` method returns entire\n_HAR log_ , while `chrome.devtools.network.onRequestFinished` event provides\n_HAR entry_ as an argument to the event callback.\n\nNote that request content is not provided as part of HAR for efficiency\nreasons. You may call request's `getContent()` method to retrieve content.\n\nIf the Developer Tools window is opened after the page is loaded, some\nrequests may be missing in the array of entries returned by `getHAR()`. Reload\nthe page to get all requests. In general, the list of requests returned by\n`getHAR()` should match that displayed in the Network panel.\n\nSee DevTools APIs summary for general introduction to using Developer Tools\nAPIs.\n\n## Manifest\n\nThe following keys must be declared in the manifest to use this API.\n\n`\"devtools_page\"`  \n\n## Examples\n\nThe following code logs URLs of all images larger than 40KB as they are\nloaded:\n\n    \n    \n    chrome.devtools.network.onRequestFinished.addListener(\n      function(request) {\n        if (request.response.bodySize > 40*1024) {\n          chrome.devtools.inspectedWindow.eval(\n              'console.log(\"Large image: \" + unescape(\"' +\n              escape(request.request.url) + '\"))');\n        }\n      }\n    );\n    \n\nTo try this API, install the devtools API examples from the chrome-extension-\nsamples repository.\n\n## Types\n\n### Request\n\nRepresents a network request for a document resource (script, image and so\non). See HAR Specification for reference.\n\n#### Properties\n\n  * getContent\n\nvoid\n\nReturns content of the response body.\n\nThe `getContent` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (content: string, encoding: string) => void\n\n      * content\n\nstring\n\nContent of the response body (potentially encoded).\n\n      * encoding\n\nstring\n\nEmpty if content is not encoded, encoding name otherwise. Currently, only\nbase64 is supported.\n\n## Methods\n\n### getHAR()\n\n    \n    \n    chrome.devtools.network.getHAR(  \n      callback: function,  \n    )\n\nReturns HAR log that contains all known network requests.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (harLog: object) => void\n\n    * harLog\n\nobject\n\nA HAR log. See HAR specification for details.\n\n## Events\n\n### onNavigated\n\n    \n    \n    chrome.devtools.network.onNavigated.addListener(  \n      callback: function,  \n    )\n\nFired when the inspected window navigates to a new page.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (url: string) => void\n\n    * url\n\nstring\n\n### onRequestFinished\n\n    \n    \n    chrome.devtools.network.onRequestFinished.addListener(  \n      callback: function,  \n    )\n\nFired when a network request is finished and all request data are available.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (request: Request) => void\n\n    * request\n\nRequest\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/devtools/panels": "#  chrome.devtools.panels\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.devtools.panels` API to integrate your extension into\nDeveloper Tools window UI: create your own panels, access existing panels, and\nadd sidebars.\n\nEach extension panel and sidebar is displayed as a separate HTML page. All\nextension pages displayed in the Developer Tools window have access to all\nparts of the `chrome.devtools` API, as well as all other extension APIs.\n\nYou can use the `devtools.panels.setOpenResourceHandler` method to install a\ncallback function that handles user requests to open a resource (typically, a\nclick a resource link in the Developer Tools window). At most one of the\ninstalled handlers gets called; users can specify (using the Developer Tools\nSettings dialog) either the default behavior or an extension to handle\nresource open requests. If an extension calls `setOpenResourceHandler()`\nmultiple times, only the last handler is retained.\n\nSee DevTools APIs summary for general introduction to using Developer Tools\nAPIs.\n\n## Manifest\n\nThe following keys must be declared in the manifest to use this API.\n\n`\"devtools_page\"`  \n\n## Example\n\nThe following code adds a panel contained in `Panel.html`, represented by\n`FontPicker.png` on the Developer Tools toolbar and labeled as _Font Picker_ :\n\n    \n    \n    chrome.devtools.panels.create(\"Font Picker\",\n                                  \"FontPicker.png\",\n                                  \"Panel.html\",\n                                  function(panel) { ... });\n    \n\nThe following code adds a sidebar pane contained in `Sidebar.html` and titled\n_Font Properties_ to the Elements panel, then sets its height to `8ex`:\n\n    \n    \n    chrome.devtools.panels.elements.createSidebarPane(\"Font Properties\",\n      function(sidebar) {\n        sidebar.setPage(\"Sidebar.html\");\n        sidebar.setHeight(\"8ex\");\n      }\n    );\n    \n\nThe screenshot illustrates the effect this example would have on Developer\nTools window:\n\n![Extension icon panel on DevTools\ntoolbar](/static/docs/extensions/reference/api/devtools/panels/images/devtools-\npanels.png) Extension icon panel on DevTools toolbar.\n\nTo try this API, install the devtools panels API example from the chrome-\nextension-samples repository.\n\n## Types\n\n### Button\n\nA button created by the extension.\n\n#### Properties\n\n  * onClicked\n\nEvent<functionvoidvoid>\n\nFired when the button is clicked.\n\nThe `onClicked.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * update\n\nvoid\n\nUpdates the attributes of the button. If some of the arguments are omitted or\n`null`, the corresponding attributes are not updated.\n\nThe `update` function looks like:\n\n        \n        (iconPath?: string, tooltipText?: string, disabled?: boolean) => {...}\n\n    * iconPath\n\nstring optional\n\nPath to the new icon of the button.\n\n    * tooltipText\n\nstring optional\n\nText shown as a tooltip when user hovers the mouse over the button.\n\n    * disabled\n\nboolean optional\n\nWhether the button is disabled.\n\n### ElementsPanel\n\nRepresents the Elements panel.\n\n#### Properties\n\n  * onSelectionChanged\n\nEvent<functionvoidvoid>\n\nFired when an object is selected in the panel.\n\nThe `onSelectionChanged.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * createSidebarPane\n\nvoid\n\nCreates a pane within panel's sidebar.\n\nThe `createSidebarPane` function looks like:\n\n        \n        (title: string, callback?: function) => {...}\n\n    * title\n\nstring\n\nText that is displayed in sidebar caption.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (result: ExtensionSidebarPane) => void\n\n      * result\n\nExtensionSidebarPane\n\nAn ExtensionSidebarPane object for created sidebar pane.\n\n### ExtensionPanel\n\nRepresents a panel created by extension.\n\n#### Properties\n\n  * onHidden\n\nEvent<functionvoidvoid>\n\nFired when the user switches away from the panel.\n\nThe `onHidden.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * onSearch\n\nEvent<functionvoidvoid>\n\nFired upon a search action (start of a new search, search result navigation,\nor search being canceled).\n\nThe `onSearch.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (action: string, queryString?: string) => void\n\n      * action\n\nstring\n\n      * queryString\n\nstring optional\n\n  * onShown\n\nEvent<functionvoidvoid>\n\nFired when the user switches to the panel.\n\nThe `onShown.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (window: Window) => void\n\n      * window\n\nWindow\n\n  * createStatusBarButton\n\nvoid\n\nAppends a button to the status bar of the panel.\n\nThe `createStatusBarButton` function looks like:\n\n        \n        (iconPath: string, tooltipText: string, disabled: boolean) => {...}\n\n    * iconPath\n\nstring\n\nPath to the icon of the button. The file should contain a 64x24-pixel image\ncomposed of two 32x24 icons. The left icon is used when the button is\ninactive; the right icon is displayed when the button is pressed.\n\n    * tooltipText\n\nstring\n\nText shown as a tooltip when user hovers the mouse over the button.\n\n    * disabled\n\nboolean\n\nWhether the button is disabled.\n\n    * returns\n\nButton\n\n### ExtensionSidebarPane\n\nA sidebar created by the extension.\n\n#### Properties\n\n  * onHidden\n\nEvent<functionvoidvoid>\n\nFired when the sidebar pane becomes hidden as a result of the user switching\naway from the panel that hosts the sidebar pane.\n\nThe `onHidden.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * onShown\n\nEvent<functionvoidvoid>\n\nFired when the sidebar pane becomes visible as a result of user switching to\nthe panel that hosts it.\n\nThe `onShown.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (window: Window) => void\n\n      * window\n\nWindow\n\n  * setExpression\n\nvoid\n\nSets an expression that is evaluated within the inspected page. The result is\ndisplayed in the sidebar pane.\n\nThe `setExpression` function looks like:\n\n        \n        (expression: string, rootTitle?: string, callback?: function) => {...}\n\n    * expression\n\nstring\n\nAn expression to be evaluated in context of the inspected page. JavaScript\nobjects and DOM nodes are displayed in an expandable tree similar to the\nconsole/watch.\n\n    * rootTitle\n\nstring optional\n\nAn optional title for the root of the expression tree.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * setHeight\n\nvoid\n\nSets the height of the sidebar.\n\nThe `setHeight` function looks like:\n\n        \n        (height: string) => {...}\n\n    * height\n\nstring\n\nA CSS-like size specification, such as `'100px'` or `'12ex'`.\n\n  * setObject\n\nvoid\n\nSets a JSON-compliant object to be displayed in the sidebar pane.\n\nThe `setObject` function looks like:\n\n        \n        (jsonObject: string, rootTitle?: string, callback?: function) => {...}\n\n    * jsonObject\n\nstring\n\nAn object to be displayed in context of the inspected page. Evaluated in the\ncontext of the caller (API client).\n\n    * rootTitle\n\nstring optional\n\nAn optional title for the root of the expression tree.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * setPage\n\nvoid\n\nSets an HTML page to be displayed in the sidebar pane.\n\nThe `setPage` function looks like:\n\n        \n        (path: string) => {...}\n\n    * path\n\nstring\n\nRelative path of an extension page to display within the sidebar.\n\n### SourcesPanel\n\nRepresents the Sources panel.\n\n#### Properties\n\n  * onSelectionChanged\n\nEvent<functionvoidvoid>\n\nFired when an object is selected in the panel.\n\nThe `onSelectionChanged.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * createSidebarPane\n\nvoid\n\nCreates a pane within panel's sidebar.\n\nThe `createSidebarPane` function looks like:\n\n        \n        (title: string, callback?: function) => {...}\n\n    * title\n\nstring\n\nText that is displayed in sidebar caption.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (result: ExtensionSidebarPane) => void\n\n      * result\n\nExtensionSidebarPane\n\nAn ExtensionSidebarPane object for created sidebar pane.\n\n## Properties\n\n### elements\n\nElements panel.\n\n#### Type\n\nElementsPanel\n\n### sources\n\nSources panel.\n\n#### Type\n\nSourcesPanel\n\n### themeName\n\nChrome 59+\n\nThe name of the color theme set in user's DevTools settings. Possible values:\n`default` (the default) and `dark`.\n\n#### Type\n\nstring\n\n## Methods\n\n### create()\n\n    \n    \n    chrome.devtools.panels.create(  \n      title: string,  \n      iconPath: string,  \n      pagePath: string,  \n      callback?: function,  \n    )\n\nCreates an extension panel.\n\n#### Parameters\n\n  * title\n\nstring\n\nTitle that is displayed next to the extension icon in the Developer Tools\ntoolbar.\n\n  * iconPath\n\nstring\n\nPath of the panel's icon relative to the extension directory.\n\n  * pagePath\n\nstring\n\nPath of the panel's HTML page relative to the extension directory.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (panel: ExtensionPanel) => void\n\n    * panel\n\nExtensionPanel\n\nAn ExtensionPanel object representing the created panel.\n\n### openResource()\n\n    \n    \n    chrome.devtools.panels.openResource(  \n      url: string,  \n      lineNumber: number,  \n      columnNumber?: number,  \n      callback?: function,  \n    )\n\nRequests DevTools to open a URL in a Developer Tools panel.\n\n#### Parameters\n\n  * url\n\nstring\n\nThe URL of the resource to open.\n\n  * lineNumber\n\nnumber\n\nSpecifies the line number to scroll to when the resource is loaded.\n\n  * columnNumber\n\nnumber optional\n\nChrome 114+\n\nSpecifies the column number to scroll to when the resource is loaded.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### setOpenResourceHandler()\n\n    \n    \n    chrome.devtools.panels.setOpenResourceHandler(  \n      callback?: function,  \n    )\n\nSpecifies the function to be called when the user clicks a resource link in\nthe Developer Tools window. To unset the handler, either call the method with\nno parameters or pass null as the parameter.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (resource: Resource) => void\n\n    * resource\n\nResource\n\nA `devtools.inspectedWindow.Resource` object for the resource that was\nclicked.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/devtools/performance": "#  chrome.devtools.performance\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.devtools.performance` API to listen to recording status\nupdates in the Performance panel in DevTools.\n\nSee DevTools APIs summary for general introduction to using Developer Tools\nAPIs.\n\n## Availability\n\nChrome 129+\n\nStarting from Chrome 128, you can listen to notifications of the recording\nstatus of the Performance panel.\n\n## Concepts and usage\n\nThe chrome.devtools.performance API allows developers to interact with the\nrecording features of the **Performance panel** panel in Chrome DevTools. You\ncan use this API to get notifications when recording starts or stops.\n\nTwo events are available:\n\n  * onProfilingStarted: This event is fired when the **Performance** panel begins recording performance data.\n  * onProfilingStopped: This event is fired when the **Performance** panel stops recording performance data. stance that associates the current stack trace with the cre Both events don't have any associated parameters.\n\nBy listening to these events, developers can create extensions that react to\nthe recording status in the **Performance** panel, providing additional\nautomation during performance profiling.\n\n## Examples\n\nThis is how you can use the API to listen to recording status updates\n\n    \n    \n    chrome.devtools.performance.onProfilingStarted.addListener(() => {\n      // Profiling started listener implementation\n    });\n    \n    chrome.devtools.performance.onProfilingStopped.addListener(() => {\n      // Profiling stopped listener implementation\n    })\n    \n\n## Events\n\n### onProfilingStarted\n\n    \n    \n    chrome.devtools.performance.onProfilingStarted.addListener(  \n      callback: function,  \n    )\n\nFired when the Performance panel starts recording.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onProfilingStopped\n\n    \n    \n    chrome.devtools.performance.onProfilingStopped.addListener(  \n      callback: function,  \n    )\n\nFired when the Performance panel stops recording.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/devtools/recorder": "#  chrome.devtools.recorder\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.devtools.recorder` API to customize the Recorder panel in\nDevTools.\n\n`devtools.recorder` API is a preview feature that allows you to extend the\nRecorder panel in Chrome DevTools.\n\nSee DevTools APIs summary for general introduction to using Developer Tools\nAPIs.\n\n## Availability\n\nChrome 105+\n\nStarting from Chrome 105, you can extend the export functionality. Starting\nfrom Chrome 112, you can extend the replay button.\n\n## Concepts and usage\n\n### Customizing the export feature\n\nTo register an extension plugin, use the `registerRecorderExtensionPlugin`\nfunction. This function requires a plugin instance, a `name` and a `mediaType`\nas parameters. The plugin instance must implement two methods: `stringify` and\n`stringifyStep`.\n\nThe `name` provided by the extension shows up in the **Export** menu in the\n**Recorder** panel.\n\nDepending on the export context, when the user clicks the export option\nprovided by the extension, the **Recorder** panel invokes one of the two\nfunctions:\n\n  * `stringify` that receives an entire user flow recording\n  * `stringifyStep` that receives a single recorded step\n\nThe `mediaType` parameter allows the extension to specify the kind of output\nit generates with the `stringify` and `stringifyStep` functions. For example,\n`application/javascript` if the result is a JavaScript program.\n\n### Customizing the replay button\n\nTo customize the replay button in the **Recorder** , use the\n`registerRecorderExtensionPlugin` function. The plugin must implement the\n`replay` method for the customization to take effect. If the method is\ndetected, a replay button will appear in the **Recorder**. Upon clicking the\nbutton, the current recording object will be passed as the first argument to\nthe `replay` method.\n\nAt this point, the extension can display a `RecorderView` for handling the\nreplay or use other extension APIs to process the replay request. To create a\nnew `RecorderView`, invoke `chrome.devtools.recorder.createView`.\n\n## Examples\n\n### Export plugin\n\nThe following code implements an extension plugin that stringifes a recording\nusing `JSON.stringify`:\n\n    \n    \n    class MyPlugin {\n      stringify(recording) {\n        return Promise.resolve(JSON.stringify(recording));\n      }\n      stringifyStep(step) {\n        return Promise.resolve(JSON.stringify(step));\n      }\n    }\n    \n    chrome.devtools.recorder.registerRecorderExtensionPlugin(\n      new MyPlugin(),\n      /*name=*/'MyPlugin',\n      /*mediaType=*/'application/json'\n    );\n    \n\n### Replay plugin\n\nThe following code implements an extension plugin that creates a dummy\nRecorder view and displays it upon a replay request:\n\n    \n    \n    const view = await chrome.devtools.recorder.createView(\n      /* name= */ 'ExtensionName',\n      /* pagePath= */ 'Replay.html'\n    );\n    \n    let latestRecording;\n    \n    view.onShown.addListener(() => {\n      // Recorder has shown the view. Send additional data to the view if needed.\n      chrome.runtime.sendMessage(JSON.stringify(latestRecording));\n    });\n    \n    view.onHidden.addListener(() => {\n      // Recorder has hidden the view.\n    });\n    \n    export class RecorderPlugin {\n      replay(recording) {\n        // Share the data with the view.\n        latestRecording = recording;\n        // Request to show the view.\n        view.show();\n      }\n    }\n    \n    chrome.devtools.recorder.registerRecorderExtensionPlugin(\n      new RecorderPlugin(),\n      /* name=*/ 'CoffeeTest'\n    );\n    \n\nFind a complete extension example on GitHub.\n\n## Types\n\n### RecorderExtensionPlugin\n\nA plugin interface that the Recorder panel invokes to customize the Recorder\npanel.\n\n#### Properties\n\n  * replay\n\nvoid\n\nChrome 112+\n\nAllows the extension to implement custom replay functionality.\n\nThe `replay` function looks like:\n\n        \n        (recording: object) => {...}\n\n    * recording\n\nobject\n\nA recording of the user interaction with the page. This should match\nPuppeteer's recording schema.\n\n  * stringify\n\nvoid\n\nConverts a recording from the Recorder panel format into a string.\n\nThe `stringify` function looks like:\n\n        \n        (recording: object) => {...}\n\n    * recording\n\nobject\n\nA recording of the user interaction with the page. This should match\nPuppeteer's recording schema.\n\n  * stringifyStep\n\nvoid\n\nConverts a step of the recording from the Recorder panel format into a string.\n\nThe `stringifyStep` function looks like:\n\n        \n        (step: object) => {...}\n\n    * step\n\nobject\n\nA step of the recording of a user interaction with the page. This should match\nPuppeteer's step schema.\n\n### RecorderView\n\nChrome 112+\n\nRepresents a view created by extension to be embedded inside the Recorder\npanel.\n\n#### Properties\n\n  * onHidden\n\nEvent<functionvoidvoid>\n\nFired when the view is hidden.\n\nThe `onHidden.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * onShown\n\nEvent<functionvoidvoid>\n\nFired when the view is shown.\n\nThe `onShown.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * show\n\nvoid\n\nIndicates that the extension wants to show this view in the Recorder panel.\n\nThe `show` function looks like:\n\n        \n        () => {...}\n\n## Methods\n\n### createView()\n\nChrome 112+\n\n    \n    \n    chrome.devtools.recorder.createView(  \n      title: string,  \n      pagePath: string,  \n    )\n\nCreates a view that can handle the replay. This view will be embedded inside\nthe Recorder panel.\n\n#### Parameters\n\n  * title\n\nstring\n\nTitle that is displayed next to the extension icon in the Developer Tools\ntoolbar.\n\n  * pagePath\n\nstring\n\nPath of the panel's HTML page relative to the extension directory.\n\n#### Returns\n\n  * RecorderView\n\n### registerRecorderExtensionPlugin()\n\n    \n    \n    chrome.devtools.recorder.registerRecorderExtensionPlugin(  \n      plugin: RecorderExtensionPlugin,  \n      name: string,  \n      mediaType: string,  \n    )\n\nRegisters a Recorder extension plugin.\n\n#### Parameters\n\n  * plugin\n\nRecorderExtensionPlugin\n\nAn instance implementing the RecorderExtensionPlugin interface.\n\n  * name\n\nstring\n\nThe name of the plugin.\n\n  * mediaType\n\nstring\n\nThe media type of the string content that the plugin produces.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/dns": "#  chrome.dns\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.dns` API for dns resolution.\n\n## Permissions\n\n`dns`  \n\n## Availability\n\nDev channel\n\nTo use this API, you must declare the `\"dns\"` permission in the manifest.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"dns\"\n      ],\n      ...\n    }\n    \n\n**Note:** This API is only available in Chrome Dev. There are no foreseeable\nplans to move this API from the dev channel into Chrome stable.\n\n## Usage\n\nThe following code calls `resolve()` to retrieve the IP address of\n`example.com`.\n\nservice-worker.js:\n\n    \n    \n    const resolveDNS = async () => {\n        let record = await chrome.dns.resolve('example.com');\n        console.log(record.address); // \"192.0.2.172\"\n    };\n    \n    resolveDNS();\n    \n\n**Key point:** Do not include the scheme or trailing slash in the hostname.\nFor example, `https://example.com/` is invalid.\n\n## Types\n\n### ResolveCallbackResolveInfo\n\n#### Properties\n\n  * address\n\nstring optional\n\nA string representing the IP address literal. Supplied only if resultCode\nindicates success.\n\n  * resultCode\n\nnumber\n\nThe result code. Zero indicates success.\n\n## Methods\n\n### resolve()\n\nPromise\n\n    \n    \n    chrome.dns.resolve(  \n      hostname: string,  \n      callback?: function,  \n    )\n\nResolves the given hostname or IP address literal.\n\n#### Parameters\n\n  * hostname\n\nstring\n\nThe hostname to resolve.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (resolveInfo: ResolveCallbackResolveInfo) => void\n\n    * resolveInfo\n\nResolveCallbackResolveInfo\n\n#### Returns\n\n  * Promise<ResolveCallbackResolveInfo>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/documentScan": "#  chrome.documentScan\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.documentScan` API to discover and retrieve images from\nattached document scanners.\n\nThe Document Scan API is designed to allow apps and extensions to view the\ncontent of paper documents on an attached document scanner.\n\n## Permissions\n\n`documentScan`  \n\n## Availability\n\nChrome 44+  ChromeOS only\n\nAvailability for API members added later is shown with those members.\n\n## Concepts and usage\n\nThis API supports two means of scanning documents. If your use case can work\nwith any scanner and doesn't require control of the configuration, use the\n`scan()` method. More complicated use cases require a combination of methods,\nwhich are only supported in Chrome 124 and later.\n\n### Simple scanning\n\nFor simple use cases, meaning those that can work with any scanner and don't\nrequire control of configuration, call `scan()`. This method takes a\n`ScanOptions` object and returns a Promise that resolves with a `ScanResults`\nobject. The capabilities of this option are limited to the number of scans and\nthe MIME types that will be accepted by the caller. Scans are returned as URLs\nfor display in an `<img>` tag for a user interface.\n\n### Complex scanning\n\nComplex scans are accomplished in three phases as described in this section.\nThis outline does not describe every method argument or every property\nreturned in a response. It is only intended to give you a general guide to\nwriting scanner code.\n\n**Note:** Calling `openScanner()`, `getScannerList()`, or `startScan()` more\nthan once will cancel operations initiated by previous calls to these methods.\nSee the descriptions of these methods for specifics.\n\n#### Discovery\n\n  1. Call `getScannerList()`. Available scanners are returned in a Promise that resolves with a `GetScannerListResponse`.\n\n     * The response object contains an array of `ScannerInfo` objects.\n     * The array may contain multiple entries for a single scanner if that scanner supports multiple protocols or connection methods.\n  2. Select a scanner from the returned array and save the value of its `scannerId` property.\n\nUse the properties of individual `ScannerInfo` objects to distinguish among\nmultiple objects for the same scanner. Objects from the same scanner will have\nthe same value for the `deviceUuid` property. `ScannerInfo` also contains an\n`imageFormats` property containing an array of supported image types.\n\n#### Scanner configuration\n\n  1. Call `openScanner()`, passing in the saved scanner ID. It returns a Promise that resolves with an `OpenScannerResponse`. The response object contains:\n\n     * A `scannerHandle` property, which you'll need to save.\n\n     * An options property containing scanner-specific properties, which you'll need to set. See Retrieve scanner options for more information.\n\n  2. (Optional) If you need the user to provide values for scanner options, construct a user interface. You will need the scanner options provided by the previous step, and you'll need to retrieve option groups provided by the scanner. See Construct a user interface for more information.\n\n  3. Construct an array of `OptionSetting` objects using programmatic or user-provided values. See Set scanner options for more information.\n\n  4. Pass the array of `OptionSetting` objects to `setOptions()` to set options for the scanner. It returns a Promise that resolves with a `SetOptionsResponse`. This object contains an updated version of the scanner options retrieved in step 1 of scanner configuration.\n\nSince changing one option can alter constraints on another option, you may\nneed to repeat these steps several times.\n\n#### Scanning\n\n  1. Construct a `StartScanOptions` object and pass it to `startScan()`. It returns a Promise that resolves with a `StartScanResponse`. Its `job` property is a handle that you will use to either read scan data or cancel the scan.\n\n  2. Pass the job handle to `readScanData()`. It returns a Promise that resolves with a `ReadScanDataResponse` object. If data was read successfully, its `result` property equals `SUCCESS` and its `data` property contains an `ArrayBuffer` with part of the scan. Note that `estimatedCompletion` contains an estimated percentage of the total data that has been delivered so far.\n\n**Note:** If `result` is `SUCCESS`, but `data` is empty, delay briefly before\ncalling `readScanData()` again.\n\n  3. Repeat the previous step until the `result` property equals `EOF` or an error.\n\nWhen the end of the scan is reached, call `closeScanner()` with the scanner\nhandle saved in step 3\\. It returns a Promise that resolves with a\n`CloseScannerResponse`. Calling `cancelScan()` at any time after the job is\ncreated will end scanning.\n\n### Response objects\n\nAll methods return a Promise that resolves with a response object of some\nkind. Most of these contain a `result` property whose value is a member of\n`OperationResult`. Some properties of response objects won't contain values\nunless the value of `result` has a specific value. These relationships are\ndescribed in the reference for each response object.\n\nFor example, `OpenScannerResponse.scannerHandle` will only have a value when\n`OpenScannerResponse.result` equals `SUCCESS`.\n\n### Scanner options\n\nScanner options vary considerably by device. Consequently, it's not possible\nto reflect scanner options directly within the documentScan API. To get around\nthis, the `OpenScannerResponse` (retrieved using `openScanner()`) and the\n`SetOptionsResponse` (the response object for `setOptions()`) contain an\n`options` property which is an object containing scanner-specific options.\nEach option is a key-value mapping where the key is a device-specific option\nand the value is an instance of `ScannerOption`.\n\nThe structure generally looks like this:\n\n    \n    \n    {\n      \"key1\": { scannerOptionInstance }\n      \"key2\": { scannerOptionInstance }\n    }\n    \n\nFor example, imagine a scanner that returns options named \"source\" and\n\"resolution\". The structure of the returned `options` object will look\nsomething like the following example. For simplicity, only partial\n`ScannerOption` responses are shown.\n\n    \n    \n    {\n      \"source\": {\n        \"name\": \"source\",\n        \"type\": OptionType.STRING,\n    ...\n    },\n      \"resolution\": {\n        \"name\": \"resolution\",\n        \"type\": OptionType.INT,\n    ...\n      },\n    ...\n    }\n    \n\n### Construct a user interface\n\nThough not required to use this API, you may want a user to choose the value\nfor a particular option. This requires a user interface. Use the\n`OpenScannerResponse` (opened by `openScanner()`) to retrieve the options for\nthe attached scanner as described in the previous section.\n\nSome scanners group options in device-specific ways. They don't affect option\nbehaviors, but since these groups may be mentioned in a scanner's product\ndocumentation, such groups should be shown to the user. You can retrieve these\ngroups by calling `getOptionGroups()`. This returns a Promise that resolves\nwith a `GetOptionGroupsResponse` object. Its `groups` property contains a\nscanner-specific array of groups. Use the information in these groups to\norganize the options in the `OpenScannerResponse` for display.\n\n    \n    \n    {\n      scannerHandle: \"123456\",\n      result: SUCCESS,\n      groups: [\n        {\n          title: \"Standard\",\n          members: [ \"resolution\", \"mode\", \"source\" ]\n        }\n      ]\n    }\n    \n\nAs stated under Scanner configuration, changing one option can alter\nconstraints on another option. This is why `setOptionsResponse` (the response\nobject for `setOptions()`) contains another `options` property. Use this to\nupdate the user interface. Then repeat as needed until all options are set.\n\n### Set scanner options\n\nSet scanner options by passing an array of `OptionSetting` objects to\n`setOptions()`. For an example, see the following Scan one letter-size page\nsection.\n\n## Examples\n\n### Retrieve a page as a blob\n\nThis example shows one way to retrieve a page from the scanner as a blob and\ndemonstrates use of `startScan()` and `readScanData()` using the value of\n`OperationResult`.\n\n    \n    \n    async function pageAsBlob(handle) {\n      let response = await chrome.documentScan.startScan(\n          handle, {format: \"image/jpeg\"});\n      if (response.result != chrome.documentScan.OperationResult.SUCCESS) {\n        return null;\n      }\n      const job = response.job;\n    \n      let imgParts = [];\n      response = await chrome.documentScan.readScanData(job);\n      while (response.result == chrome.documentScan.OperationResult.SUCCESS) {\n        if (response.data && response.data.byteLength > 0) {\n            imgParts.push(response.data);\n        } else {\n          // Delay so hardware can make progress.\n          await new Promise(r => setTimeout(r, 100));\n        }\n        response = await chrome.documentScan.readScanData(job);\n      }\n      if (response.result != chrome.documentScan.OperationResult.EOF) {\n        return null;\n      }\n      if (response.data && response.data.byteLength > 0) {\n        imgParts.push(response.data);\n      }\n      return new Blob(imgParts, { type: \"image/jpeg\" });\n    }\n    \n\n### Scan one letter-size page\n\nThis example shows how to select a scanner, set its options, and open it. It\nthen retrieves the contents of a single page and closes the scanner. This\nprocess demonstrates using `getScannerList()`, `openScanner()`,\n`setOptions()`, and `closeScanner()`. Note that the contents of the page are\nretrieved by calling the `pageAsBlob()` function from the previous example.\n\n    \n    \n    async function scan() {\n        let response = await chrome.documentScan.getScannerList({ secure: true });\n        let scanner = await chrome.documentScan.openScanner(\n            response.scanners[0].scannerId);\n        const handle = scanner.scannerHandle;\n    \n        let options = [];\n        for (source of scanner.options[\"source\"].constraint.list) {\n            if (source.includes(\"ADF\")) {\n                options.push({\n                    name: \"source\",\n                    type: chrome.documentScan.OptionType.STRING,\n                    value: { value: source }\n                });\n                break;\n            }\n        }\n        options.push({\n            name: \"tl-x\",\n            type: chrome.documentScan.OptionType.FIXED,\n            value: 0.0\n        });\n        options.push({\n            name: \"br-x\",\n            type: chrome.documentScan.OptionType.FIXED,\n            value: 215.9  // 8.5\" in mm\n        });\n        options.push({\n            name: \"tl-y\",\n            type: chrome.documentScan.OptionType.FIXED,\n            value: 0.0\n        });\n        options.push({\n            name: \"br-y\",\n            type: chrome.documentScan.OptionType.FIXED,\n            value: 279.4  // 11\" in mm\n        });\n        response = await chrome.documentScan.setOptions(handle, options);\n    \n        let imgBlob = await pageAsBlob(handle);\n        if (imgBlob != null) {\n            // Insert imgBlob into DOM, save to disk, etc\n        }\n        await chrome.documentScan.closeScanner(handle);\n    }\n    \n\n### Show the configuration\n\nAs stated elsewhere, showing a scanner's configuration options to a user\nrequires calling `getOptionGroups()` in addition to the scanner options\nreturned from a call to `openScanner()`. This is so that options can be shown\nto users in manufacturer-defined groups. This example shows how to do that.\n\n    \n    \n    async function showConfig() {\n      let response = await chrome.documentScan.getScannerList({ secure: true });\n      let scanner = await chrome.documentScan.openScanner(\n          response.scanners[0].scannerId);\n      let groups = await chrome.documentScan.getOptionGroups(scanner.scannerHandle);\n    \n      for (const group of groups.groups) {\n        console.log(\"=== \" + group.title + \" ===\");\n        for (const member of group.members) {\n          const option = scanner.options[member];\n          if (option.isActive) {\n            console.log(\"  \" + option.name + \" = \" + option.value);\n          } else {\n            console.log(\"  \" + option.name + \" is inactive\");\n          }\n        }\n      }\n    }\n    \n\n## Types\n\n### CancelScanResponse\n\nChrome 125+\n\n#### Properties\n\n  * job\n\nstring\n\nProvides the same job handle that was passed to `cancelScan()`.\n\n  * result\n\nOperationResult\n\nThe backend's cancel scan result. If the result is `OperationResult.SUCCESS`\nor `OperationResult.CANCELLED`, the scan has been cancelled and the scanner is\nready to start a new scan. If the result is `OperationResult.DEVICE_BUSY` ,\nthe scanner is still processing the requested cancellation; the caller should\nwait a short time and try the request again. Other result values indicate a\npermanent error that should not be retried.\n\n### CloseScannerResponse\n\nChrome 125+\n\n#### Properties\n\n  * result\n\nOperationResult\n\nThe result of closing the scanner. Even if this value is not `SUCCESS`, the\nhandle will be invalid and should not be used for any further operations.\n\n  * scannerHandle\n\nstring\n\nThe same scanner handle as was passed to `closeScanner`.\n\n### Configurability\n\nChrome 125+\n\nHow an option can be changed.\n\n#### Enum\n\n\"NOT_CONFIGURABLE\"  \nThe option is read-only.\n\n\"SOFTWARE_CONFIGURABLE\"  \nThe option can be set in software.\n\n\"HARDWARE_CONFIGURABLE\"  \nThe option can be set by the user toggling or pushing a button on the scanner.\n\n### ConnectionType\n\nChrome 125+\n\nIndicates how the scanner is connected to the computer.\n\n#### Enum\n\n\"UNSPECIFIED\"  \n\n\"USB\"  \n\n\"NETWORK\"  \n\n### ConstraintType\n\nChrome 125+\n\nThe data type of constraint represented by an `OptionConstraint`.\n\n#### Enum\n\n\"INT_RANGE\"  \nThe constraint on a range of `OptionType.INT` values. The `min`, `max`, and\n`quant` properties of `OptionConstraint` will be `long`, and its `list`\npropety will be unset.\n\n\"FIXED_RANGE\"  \nThe constraint on a range of `OptionType.FIXED` values. The `min`, `max`, and\n`quant` properties of `OptionConstraint` will be `double`, and its `list`\nproperty will be unset.\n\n\"INT_LIST\"  \nThe constraint on a specific list of `OptionType.INT` values. The\n`OptionConstraint.list` property will contain `long` values, and the other\nproperties will be unset.\n\n\"FIXED_LIST\"  \nThe constraint on a specific list of `OptionType.FIXED` values. The\n`OptionConstraint.list` property will contain `double` values, and the other\nproperties will be unset.\n\n\"STRING_LIST\"  \nThe constraint on a specific list of `OptionType.STRING` values. The\n`OptionConstraint.list` property will contain `DOMString` values, and the\nother properties will be unset.\n\n### DeviceFilter\n\nChrome 125+\n\n#### Properties\n\n  * local\n\nboolean optional\n\nOnly return scanners that are directly attached to the computer.\n\n  * secure\n\nboolean optional\n\nOnly return scanners that use a secure transport, such as USB or TLS.\n\n### GetOptionGroupsResponse\n\nChrome 125+\n\n#### Properties\n\n  * groups\n\nOptionGroup[] optional\n\nIf `result` is `SUCCESS`, provides a list of option groups in the order\nsupplied by the scanner driver.\n\n  * result\n\nOperationResult\n\nThe result of getting the option groups. If the value of this is `SUCCESS`,\nthe `groups` property will be populated.\n\n  * scannerHandle\n\nstring\n\nThe same scanner handle as was passed to `getOptionGroups`.\n\n### GetScannerListResponse\n\nChrome 125+\n\n#### Properties\n\n  * result\n\nOperationResult\n\nThe enumeration result. Note that partial results could be returned even if\nthis indicates an error.\n\n  * scanners\n\nScannerInfo[]\n\nA possibly-empty list of scanners that match the provided `DeviceFilter`.\n\n### OpenScannerResponse\n\nChrome 125+\n\n#### Properties\n\n  * options\n\nobject optional\n\nIf `result` is `SUCCESS`, provides a key-value mapping where the key is a\ndevice-specific option and the value is an instance of `ScannerOption`.\n\n  * result\n\nOperationResult\n\nThe result of opening the scanner. If the value of this is `SUCCESS`, the\n`scannerHandle` and `options` properties will be populated.\n\n  * scannerHandle\n\nstring optional\n\nIf `result` is `SUCCESS`, a handle to the scanner that can be used for further\noperations.\n\n  * scannerId\n\nstring\n\nThe scanner ID passed to `openScanner()`.\n\n### OperationResult\n\nChrome 125+\n\nAn enum that indicates the result of each operation.\n\n#### Enum\n\n\"UNKNOWN\"  \nAn unknown or generic failure occurred.\n\n\"SUCCESS\"  \nThe operation succeeded.\n\n\"UNSUPPORTED\"  \nThe operation is not supported.\n\n\"CANCELLED\"  \nThe operation was cancelled.\n\n\"DEVICE_BUSY\"  \nThe device is busy.\n\n\"INVALID\"  \nEither the data or an argument passed to the method is not valid.\n\n\"WRONG_TYPE\"  \nThe supplied value is the wrong data type for the underlying option.\n\n\"EOF\"  \nNo more data is available.\n\n\"ADF_JAMMED\"  \nThe document feeder is jammed.\n\n\"ADF_EMPTY\"  \nThe document feeder is empty.\n\n\"COVER_OPEN\"  \nThe flatbed cover is open.\n\n\"IO_ERROR\"  \nAn error occurred while communicating with the device.\n\n\"ACCESS_DENIED\"  \nThe device requires authentication.\n\n\"NO_MEMORY\"  \nNot enough memory is available on the Chromebook to complete the operation.\n\n\"UNREACHABLE\"  \nThe device is not reachable.\n\n\"MISSING\"  \nThe device is disconnected.\n\n\"INTERNAL_ERROR\"  \nAn error has occurred somewhere other than the calling application.\n\n### OptionConstraint\n\nChrome 125+\n\n#### Properties\n\n  * list\n\nstring[] | number[] optional\n\n  * max\n\nnumber optional\n\n  * min\n\nnumber optional\n\n  * quant\n\nnumber optional\n\n  * type\n\nConstraintType\n\n### OptionGroup\n\nChrome 125+\n\n#### Properties\n\n  * members\n\nstring[]\n\nAn array of option names in driver-provided order.\n\n  * title\n\nstring\n\nProvides a printable title, for example \"Geometry options\".\n\n### OptionSetting\n\nChrome 125+\n\n#### Properties\n\n  * name\n\nstring\n\nIndicates the name of the option to set.\n\n  * type\n\nOptionType\n\nIndicates the data type of the option. The requested data type must match the\nreal data type of the underlying option.\n\n  * value\n\nstring | number | boolean | number[] optional\n\nIndicates the value to set. Leave unset to request automatic setting for\noptions that have `autoSettable` enabled. The data type supplied for `value`\nmust match `type`.\n\n### OptionType\n\nChrome 125+\n\nThe data type of an option.\n\n#### Enum\n\n\"UNKNOWN\"  \nThe option's data type is unknown. The `value` property will be unset.\n\n\"BOOL\"  \nThe `value` property will be one of `true`false.\n\n\"INT\"  \nA signed 32-bit integer. The `value` property will be long or long[],\ndepending on whether the option takes more than one value.\n\n\"FIXED\"  \nA double in the range -32768-32767.9999 with a resolution of 1/65535. The\n`value` property will be double or double[] depending on whether the option\ntakes more than one value. Double values that can't be exactly represented\nwill be rounded to the available range and precision.\n\n\"STRING\"  \nA sequence of any bytes except NUL ('\\0'). The `value` property will be a\nDOMString.\n\n\"BUTTON\"  \nAn option of this type has no value. Instead, setting an option of this type\ncauses an option-specific side effect in the scanner driver. For example, a\nbutton-typed option could be used by a scanner driver to provide a means to\nselect default values or to tell an automatic document feeder to advance to\nthe next sheet of paper.\n\n\"GROUP\"  \nGrouping option. No value. This is included for compatibility, but will not\nnormally be returned in `ScannerOption` values. Use `getOptionGroups()` to\nretrieve the list of groups with their member options.\n\n### OptionUnit\n\nChrome 125+\n\nIndicates the data type for `ScannerOption.unit`.\n\n#### Enum\n\n\"UNITLESS\"  \nThe value is a unitless number. For example, it can be a threshold.\n\n\"PIXEL\"  \nThe value is a number of pixels, for example, scan dimensions.\n\n\"BIT\"  \nThe value is the number of bits, for example, color depth.\n\n\"MM\"  \nThe value is measured in millimeters, for example, scan dimensions.\n\n\"DPI\"  \nThe value is measured in dots per inch, for example, resolution.\n\n\"PERCENT\"  \nThe value is a percent, for example, brightness.\n\n\"MICROSECOND\"  \nThe value is measured in microseconds, for example, exposure time.\n\n### ReadScanDataResponse\n\nChrome 125+\n\n#### Properties\n\n  * data\n\nArrayBuffer optional\n\nIf `result` is `SUCCESS`, contains the _next_ chunk of scanned image data. If\n`result` is `EOF`, contains the _last_ chunk of scanned image data.\n\n  * estimatedCompletion\n\nnumber optional\n\nIf `result` is `SUCCESS`, an estimate of how much of the total scan data has\nbeen delivered so far, in the range 0 to 100.\n\n  * job\n\nstring\n\nProvides the job handle passed to `readScanData()`.\n\n  * result\n\nOperationResult\n\nThe result of reading data. If its value is `SUCCESS`, then `data` contains\nthe _next_ (possibly zero-length) chunk of image data that is ready for\nreading. If its value is `EOF`, the `data` contains the _last_ chunk of image\ndata.\n\n### ScannerInfo\n\nChrome 125+\n\n#### Properties\n\n  * connectionType\n\nConnectionType\n\nIndicates how the scanner is connected to the computer.\n\n  * deviceUuid\n\nstring\n\nFor matching against other `ScannerInfo` entries that point to the same\nphysical device.\n\n  * imageFormats\n\nstring[]\n\nAn array of MIME types that can be requested for returned scans.\n\n  * manufacturer\n\nstring\n\nThe scanner manufacturer.\n\n  * model\n\nstring\n\nThe scanner model if it is available, or a generic description.\n\n  * name\n\nstring\n\nA human-readable name for the scanner to display in the UI.\n\n  * protocolType\n\nstring\n\nA human-readable description of the protocol or driver used to access the\nscanner, such as Mopria, WSD, or epsonds. This is primarily useful for\nallowing a user to choose between protocols if a device supports multiple\nprotocols.\n\n  * scannerId\n\nstring\n\nThe ID of a specific scanner.\n\n  * secure\n\nboolean\n\nIf true, the scanner connection's transport cannot be intercepted by a passive\nlistener, such as TLS or USB.\n\n### ScannerOption\n\nChrome 125+\n\n#### Properties\n\n  * configurability\n\nConfigurability\n\nIndicates whether and how the option can be changed.\n\n  * constraint\n\nOptionConstraint optional\n\nDefines `OptionConstraint` on the current scanner option.\n\n  * description\n\nstring\n\nA longer description of the option.\n\n  * isActive\n\nboolean\n\nIndicates the option is active and can be set or retrieved. If false, the\n`value` property will not be set.\n\n  * isAdvanced\n\nboolean\n\nIndicates that the UI should not display this option by default.\n\n  * isAutoSettable\n\nboolean\n\nCan be automatically set by the scanner driver.\n\n  * isDetectable\n\nboolean\n\nIndicates that this option can be detected from software.\n\n  * isEmulated\n\nboolean\n\nEmulated by the scanner driver if true.\n\n  * name\n\nstring\n\nThe option name using lowercase ASCII letters, numbers, and dashes. Diacritics\nare not allowed.\n\n  * title\n\nstring\n\nA printable one-line title.\n\n  * type\n\nOptionType\n\nThe data type contained in the `value` property, which is needed for setting\nthis option.\n\n  * unit\n\nOptionUnit\n\nThe unit of measurement for this option.\n\n  * value\n\nstring | number | boolean | number[] optional\n\nThe current value of the option, if relevant. Note that the data type of this\nproperty must match the data type specified in `type`.\n\n### ScanOptions\n\n#### Properties\n\n  * maxImages\n\nnumber optional\n\nThe number of scanned images allowed. The default is 1.\n\n  * mimeTypes\n\nstring[] optional\n\nThe MIME types that are accepted by the caller.\n\n### ScanResults\n\n#### Properties\n\n  * dataUrls\n\nstring[]\n\nAn array of data image URLs in a form that can be passed as the \"src\" value to\nan image tag.\n\n  * mimeType\n\nstring\n\nThe MIME type of the `dataUrls`.\n\n### SetOptionResult\n\nChrome 125+\n\n#### Properties\n\n  * name\n\nstring\n\nIndicates the name of the option that was set.\n\n  * result\n\nOperationResult\n\nIndicates the result of setting the option.\n\n### SetOptionsResponse\n\nChrome 125+\n\n#### Properties\n\n  * options\n\nobject optional\n\nAn updated key-value mapping from option names to `ScannerOption` values\ncontaining the new configuration after attempting to set all supplied options.\nThis has the same structure as the `options` property in\n`OpenScannerResponse`.\n\nThis property will be set even if some options were not set successfully, but\nwill be unset if retrieving the updated configuration fails (for example, if\nthe scanner is disconnected in the middle of scanning).\n\n  * results\n\nSetOptionResult[]\n\nAn array of results, one each for every passed-in `OptionSetting`.\n\n  * scannerHandle\n\nstring\n\nProvides the scanner handle passed to `setOptions()`.\n\n### StartScanOptions\n\nChrome 125+\n\n#### Properties\n\n  * format\n\nstring\n\nSpecifies the MIME type to return scanned data in.\n\n  * maxReadSize\n\nnumber optional\n\nIf a non-zero value is specified, limits the maximum scanned bytes returned in\na single `readScanData` response to that value. The smallest allowed value is\n32768 (32 KB). If this property is not specified, the size of a returned chunk\nmay be as large as the entire scanned image.\n\n### StartScanResponse\n\nChrome 125+\n\n#### Properties\n\n  * job\n\nstring optional\n\nIf `result` is `SUCCESS`, provides a handle that can be used to read scan data\nor cancel the job.\n\n  * result\n\nOperationResult\n\nThe result of starting a scan. If the value of this is `SUCCESS`, the `job`\nproperty will be populated.\n\n  * scannerHandle\n\nstring\n\nProvides the same scanner handle that was passed to `startScan()`.\n\n## Methods\n\n### cancelScan()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.cancelScan(  \n      job: string,  \n      callback?: function,  \n    )\n\nCancels a started scan and returns a Promise that resolves with a\n`CancelScanResponse` object. If a callback is used, the object is passed to it\ninstead.\n\n#### Parameters\n\n  * job\n\nstring\n\nThe handle of an active scan job previously returned from a call to\n`startScan`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: CancelScanResponse) => void\n\n    * response\n\nCancelScanResponse\n\n#### Returns\n\n  * Promise<CancelScanResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### closeScanner()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.closeScanner(  \n      scannerHandle: string,  \n      callback?: function,  \n    )\n\nCloses the scanner with the passed in handle and returns a Promise that\nresolves with a `CloseScannerResponse` object. If a callback is used, the\nobject is passed to it instead. Even if the response is not a success, the\nsupplied handle becomes invalid and should not be used for further operations.\n\n#### Parameters\n\n  * scannerHandle\n\nstring\n\nSpecifies the handle of an open scanner that was previously returned from a\ncall to `openScanner`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: CloseScannerResponse) => void\n\n    * response\n\nCloseScannerResponse\n\n#### Returns\n\n  * Promise<CloseScannerResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getOptionGroups()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.getOptionGroups(  \n      scannerHandle: string,  \n      callback?: function,  \n    )\n\nGets the group names and member options from a scanner previously opened by\n`openScanner`. This method returns a Promise that resolves with a\n`GetOptionGroupsResponse` object. If a callback is passed to this function,\nreturned data is passed to it instead.\n\n#### Parameters\n\n  * scannerHandle\n\nstring\n\nThe handle of an open scanner returned from a call to `openScanner`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: GetOptionGroupsResponse) => void\n\n    * response\n\nGetOptionGroupsResponse\n\n#### Returns\n\n  * Promise<GetOptionGroupsResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getScannerList()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.getScannerList(  \n      filter: DeviceFilter,  \n      callback?: function,  \n    )\n\nGets the list of available scanners and returns a Promise that resolves with a\n`GetScannerListResponse` object. If a callback is passed to this function,\nreturned data is passed to it instead.\n\n#### Parameters\n\n  * filter\n\nDeviceFilter\n\nA `DeviceFilter` indicating which types of scanners should be returned.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: GetScannerListResponse) => void\n\n    * response\n\nGetScannerListResponse\n\n#### Returns\n\n  * Promise<GetScannerListResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### openScanner()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.openScanner(  \n      scannerId: string,  \n      callback?: function,  \n    )\n\nOpens a scanner for exclusive access and returns a Promise that resolves with\nan `OpenScannerResponse` object. If a callback is passed to this function,\nreturned data is passed to it instead.\n\n#### Parameters\n\n  * scannerId\n\nstring\n\nThe ID of a scanner to be opened. This value is one returned from a previous\ncall to `getScannerList`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: OpenScannerResponse) => void\n\n    * response\n\nOpenScannerResponse\n\n#### Returns\n\n  * Promise<OpenScannerResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### readScanData()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.readScanData(  \n      job: string,  \n      callback?: function,  \n    )\n\nReads the next chunk of available image data from an active job handle, and\nreturns a Promise that resolves with a `ReadScanDataResponse` object. If a\ncallback is used, the object is passed to it instead.\n\n**Note:**It is valid for a response result to be `SUCCESS` with a zero-length\n`data` member. This means the scanner is still working but does not yet have\nadditional data ready. The caller should wait a short time and try again.\n\nWhen the scan job completes, the response will have the result value of `EOF`.\nThis response may contain a final non-zero `data` member.\n\n#### Parameters\n\n  * job\n\nstring\n\nActive job handle previously returned from `startScan`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: ReadScanDataResponse) => void\n\n    * response\n\nReadScanDataResponse\n\n#### Returns\n\n  * Promise<ReadScanDataResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### scan()\n\nPromise\n\n    \n    \n    chrome.documentScan.scan(  \n      options: ScanOptions,  \n      callback?: function,  \n    )\n\nPerforms a document scan and returns a Promise that resolves with a\n`ScanResults` object. If a callback is passed to this function, the returned\ndata is passed to it instead.\n\n#### Parameters\n\n  * options\n\nScanOptions\n\nAn object containing scan parameters.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ScanResults) => void\n\n    * result\n\nScanResults\n\n#### Returns\n\n  * Promise<ScanResults>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setOptions()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.setOptions(  \n      scannerHandle: string,  \n      options: OptionSetting[],  \n      callback?: function,  \n    )\n\nSets options on the specified scanner and returns a Promise that resolves with\na `SetOptionsResponse` object containing the result of trying to set every\nvalue in the order of the passed-in `OptionSetting` object. If a callback is\nused, the object is passed to it instead.\n\n#### Parameters\n\n  * scannerHandle\n\nstring\n\nThe handle of the scanner to set options on. This should be a value previously\nreturned from a call to `openScanner`.\n\n  * options\n\nOptionSetting[]\n\nA list of `OptionSetting` objects to be applied to the scanner.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: SetOptionsResponse) => void\n\n    * response\n\nSetOptionsResponse\n\n#### Returns\n\n  * Promise<SetOptionsResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### startScan()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.startScan(  \n      scannerHandle: string,  \n      options: StartScanOptions,  \n      callback?: function,  \n    )\n\nStarts a scan on the specified scanner and returns a Promise that resolves\nwith a `StartScanResponse`. If a callback is used, the object is passed to it\ninstead. If the call was successful, the response includes a job handle that\ncan be used in subsequent calls to read scan data or cancel a scan.\n\n#### Parameters\n\n  * scannerHandle\n\nstring\n\nThe handle of an open scanner. This should be a value previously returned from\na call to `openScanner`.\n\n  * options\n\nStartScanOptions\n\nA `StartScanOptions` object indicating the options to be used for the scan.\nThe `StartScanOptions.format` property must match one of the entries returned\nin the scanner's `ScannerInfo`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: StartScanResponse) => void\n\n    * response\n\nStartScanResponse\n\n#### Returns\n\n  * Promise<StartScanResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/dom": "#  chrome.dom\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.dom` API to access special DOM APIs for Extensions\n\n## Availability\n\nChrome 88+\n\n## Methods\n\n### openOrClosedShadowRoot()\n\n    \n    \n    chrome.dom.openOrClosedShadowRoot(  \n      element: HTMLElement,  \n    )\n\nGets the open shadow root or the closed shadow root hosted by the specified\nelement. If the element doesn't attach the shadow root, it will return null.\n\n#### Parameters\n\n  * element\n\nHTMLElement\n\n#### Returns\n\n  * object\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/downloads": "#  chrome.downloads\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.downloads` API to programmatically initiate, monitor,\nmanipulate, and search for downloads.\n\n## Permissions\n\n`downloads`  \n\nYou must declare the `\"downloads\"` permission in the extension manifest to use\nthis API.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"downloads\"\n      ],\n    }\n    \n\n## Examples\n\nYou can find simple examples of using the `chrome.downloads` API in the\nexamples/api/downloads directory. For other examples and for help in viewing\nthe source code, see Samples.\n\n## Types\n\n### BooleanDelta\n\n#### Properties\n\n  * current\n\nboolean optional\n\n  * previous\n\nboolean optional\n\n### DangerType\n\nfile\n\nThe download's filename is suspicious.\n\nurl\n\nThe download's URL is known to be malicious.\n\ncontent\n\nThe downloaded file is known to be malicious.\n\nuncommon\n\nThe download's URL is not commonly downloaded and could be dangerous.\n\nhost\n\nThe download came from a host known to distribute malicious binaries and is\nlikely dangerous.\n\nunwanted\n\nThe download is potentially unwanted or unsafe. E.g. it could make changes to\nbrowser or computer settings.\n\nsafe\n\nThe download presents no known danger to the user's computer.\n\naccepted\n\nThe user has accepted the dangerous download.\n\n#### Enum\n\n\"file\"  \n\n\"url\"  \n\n\"content\"  \n\n\"uncommon\"  \n\n\"host\"  \n\n\"unwanted\"  \n\n\"safe\"  \n\n\"accepted\"  \n\n\"allowlistedByPolicy\"  \n\n\"asyncScanning\"  \n\n\"asyncLocalPasswordScanning\"  \n\n\"passwordProtected\"  \n\n\"blockedTooLarge\"  \n\n\"sensitiveContentWarning\"  \n\n\"sensitiveContentBlock\"  \n\n\"deepScannedFailed\"  \n\n\"deepScannedSafe\"  \n\n\"deepScannedOpenedDangerous\"  \n\n\"promptForScanning\"  \n\n\"promptForLocalPasswordScanning\"  \n\n\"accountCompromise\"  \n\n\"blockedScanFailed\"  \n\n### DoubleDelta\n\n#### Properties\n\n  * current\n\nnumber optional\n\n  * previous\n\nnumber optional\n\n### DownloadDelta\n\n#### Properties\n\n  * canResume\n\nBooleanDelta optional\n\nThe change in `canResume`, if any.\n\n  * danger\n\nStringDelta optional\n\nThe change in `danger`, if any.\n\n  * endTime\n\nStringDelta optional\n\nThe change in `endTime`, if any.\n\n  * error\n\nStringDelta optional\n\nThe change in `error`, if any.\n\n  * exists\n\nBooleanDelta optional\n\nThe change in `exists`, if any.\n\n  * fileSize\n\nDoubleDelta optional\n\nThe change in `fileSize`, if any.\n\n  * filename\n\nStringDelta optional\n\nThe change in `filename`, if any.\n\n  * finalUrl\n\nStringDelta optional\n\nChrome 54+\n\nThe change in `finalUrl`, if any.\n\n  * id\n\nnumber\n\nThe `id` of the `DownloadItem` that changed.\n\n  * mime\n\nStringDelta optional\n\nThe change in `mime`, if any.\n\n  * paused\n\nBooleanDelta optional\n\nThe change in `paused`, if any.\n\n  * startTime\n\nStringDelta optional\n\nThe change in `startTime`, if any.\n\n  * state\n\nStringDelta optional\n\nThe change in `state`, if any.\n\n  * totalBytes\n\nDoubleDelta optional\n\nThe change in `totalBytes`, if any.\n\n  * url\n\nStringDelta optional\n\nThe change in `url`, if any.\n\n### DownloadItem\n\n#### Properties\n\n  * byExtensionId\n\nstring optional\n\nThe identifier for the extension that initiated this download if this download\nwas initiated by an extension. Does not change once it is set.\n\n  * byExtensionName\n\nstring optional\n\nThe localized name of the extension that initiated this download if this\ndownload was initiated by an extension. May change if the extension changes\nits name or if the user changes their locale.\n\n  * bytesReceived\n\nnumber\n\nNumber of bytes received so far from the host, without considering file\ncompression.\n\n  * canResume\n\nboolean\n\nTrue if the download is in progress and paused, or else if it is interrupted\nand can be resumed starting from where it was interrupted.\n\n  * danger\n\nDangerType\n\nIndication of whether this download is thought to be safe or known to be\nsuspicious.\n\n  * endTime\n\nstring optional\n\nThe time when the download ended in ISO 8601 format. May be passed directly to\nthe Date constructor: `chrome.downloads.search({},\nfunction(items){items.forEach(function(item){if (item.endTime) console.log(new\nDate(item.endTime))})})`\n\n  * error\n\nInterruptReason optional\n\nWhy the download was interrupted. Several kinds of HTTP errors may be grouped\nunder one of the errors beginning with `SERVER_`. Errors relating to the\nnetwork begin with `NETWORK_`, errors relating to the process of writing the\nfile to the file system begin with `FILE_`, and interruptions initiated by the\nuser begin with `USER_`.\n\n  * estimatedEndTime\n\nstring optional\n\nEstimated time when the download will complete in ISO 8601 format. May be\npassed directly to the Date constructor: `chrome.downloads.search({},\nfunction(items){items.forEach(function(item){if (item.estimatedEndTime)\nconsole.log(new Date(item.estimatedEndTime))})})`\n\n  * exists\n\nboolean\n\nWhether the downloaded file still exists. This information may be out of date\nbecause Chrome does not automatically watch for file removal. Call `search`()\nin order to trigger the check for file existence. When the existence check\ncompletes, if the file has been deleted, then an `onChanged` event will fire.\nNote that `search`() does not wait for the existence check to finish before\nreturning, so results from `search`() may not accurately reflect the file\nsystem. Also, `search`() may be called as often as necessary, but will not\ncheck for file existence any more frequently than once every 10 seconds.\n\n  * fileSize\n\nnumber\n\nNumber of bytes in the whole file post-decompression, or -1 if unknown.\n\n  * filename\n\nstring\n\nAbsolute local path.\n\n  * finalUrl\n\nstring\n\nChrome 54+\n\nThe absolute URL that this download is being made from, after all redirects.\n\n  * id\n\nnumber\n\nAn identifier that is persistent across browser sessions.\n\n  * incognito\n\nboolean\n\nFalse if this download is recorded in the history, true if it is not recorded.\n\n  * mime\n\nstring\n\nThe file's MIME type.\n\n  * paused\n\nboolean\n\nTrue if the download has stopped reading data from the host, but kept the\nconnection open.\n\n  * referrer\n\nstring\n\nAbsolute URL.\n\n  * startTime\n\nstring\n\nThe time when the download began in ISO 8601 format. May be passed directly to\nthe Date constructor: `chrome.downloads.search({},\nfunction(items){items.forEach(function(item){console.log(new\nDate(item.startTime))})})`\n\n  * state\n\nState\n\nIndicates whether the download is progressing, interrupted, or complete.\n\n  * totalBytes\n\nnumber\n\nNumber of bytes in the whole file, without considering file compression, or -1\nif unknown.\n\n  * url\n\nstring\n\nThe absolute URL that this download initiated from, before any redirects.\n\n### DownloadOptions\n\n#### Properties\n\n  * body\n\nstring optional\n\nPost body.\n\n  * conflictAction\n\nFilenameConflictAction optional\n\nThe action to take if `filename` already exists.\n\n  * filename\n\nstring optional\n\nA file path relative to the Downloads directory to contain the downloaded\nfile, possibly containing subdirectories. Absolute paths, empty paths, and\npaths containing back-references \"..\" will cause an error.\n`onDeterminingFilename` allows suggesting a filename after the file's MIME\ntype and a tentative filename have been determined.\n\n  * headers\n\nHeaderNameValuePair[] optional\n\nExtra HTTP headers to send with the request if the URL uses the HTTP[s]\nprotocol. Each header is represented as a dictionary containing the keys\n`name` and either `value` or `binaryValue`, restricted to those allowed by\nXMLHttpRequest.\n\n  * method\n\nHttpMethod optional\n\nThe HTTP method to use if the URL uses the HTTP[S] protocol.\n\n  * saveAs\n\nboolean optional\n\nUse a file-chooser to allow the user to select a filename regardless of\nwhether `filename` is set or already exists.\n\n  * url\n\nstring\n\nThe URL to download.\n\n### DownloadQuery\n\n#### Properties\n\n  * bytesReceived\n\nnumber optional\n\nNumber of bytes received so far from the host, without considering file\ncompression.\n\n  * danger\n\nDangerType optional\n\nIndication of whether this download is thought to be safe or known to be\nsuspicious.\n\n  * endTime\n\nstring optional\n\nThe time when the download ended in ISO 8601 format.\n\n  * endedAfter\n\nstring optional\n\nLimits results to `DownloadItem` that ended after the given ms in ISO 8601\nformat\n\n  * endedBefore\n\nstring optional\n\nLimits results to `DownloadItem` that ended before the given ms in ISO 8601\nformat.\n\n  * error\n\nInterruptReason optional\n\nWhy a download was interrupted.\n\n  * exists\n\nboolean optional\n\nWhether the downloaded file exists;\n\n  * fileSize\n\nnumber optional\n\nNumber of bytes in the whole file post-decompression, or -1 if unknown.\n\n  * filename\n\nstring optional\n\nAbsolute local path.\n\n  * filenameRegex\n\nstring optional\n\nLimits results to `DownloadItem` whose `filename` matches the given regular\nexpression.\n\n  * finalUrl\n\nstring optional\n\nChrome 54+\n\nThe absolute URL that this download is being made from, after all redirects.\n\n  * finalUrlRegex\n\nstring optional\n\nChrome 54+\n\nLimits results to `DownloadItem` whose `finalUrl` matches the given regular\nexpression.\n\n  * id\n\nnumber optional\n\nThe `id` of the `DownloadItem` to query.\n\n  * limit\n\nnumber optional\n\nThe maximum number of matching `DownloadItem` returned. Defaults to 1000. Set\nto 0 in order to return all matching `DownloadItem`. See `search` for how to\npage through results.\n\n  * mime\n\nstring optional\n\nThe file's MIME type.\n\n  * orderBy\n\nstring[] optional\n\nSet elements of this array to `DownloadItem` properties in order to sort\nsearch results. For example, setting `orderBy=['startTime']` sorts the\n`DownloadItem` by their start time in ascending order. To specify descending\norder, prefix with a hyphen: '-startTime'.\n\n  * paused\n\nboolean optional\n\nTrue if the download has stopped reading data from the host, but kept the\nconnection open.\n\n  * query\n\nstring[] optional\n\nThis array of search terms limits results to `DownloadItem` whose `filename`\nor `url` or `finalUrl` contain all of the search terms that do not begin with\na dash '-' and none of the search terms that do begin with a dash.\n\n  * startTime\n\nstring optional\n\nThe time when the download began in ISO 8601 format.\n\n  * startedAfter\n\nstring optional\n\nLimits results to `DownloadItem` that started after the given ms in ISO 8601\nformat.\n\n  * startedBefore\n\nstring optional\n\nLimits results to `DownloadItem` that started before the given ms in ISO 8601\nformat.\n\n  * state\n\nState optional\n\nIndicates whether the download is progressing, interrupted, or complete.\n\n  * totalBytes\n\nnumber optional\n\nNumber of bytes in the whole file, without considering file compression, or -1\nif unknown.\n\n  * totalBytesGreater\n\nnumber optional\n\nLimits results to `DownloadItem` whose `totalBytes` is greater than the given\ninteger.\n\n  * totalBytesLess\n\nnumber optional\n\nLimits results to `DownloadItem` whose `totalBytes` is less than the given\ninteger.\n\n  * url\n\nstring optional\n\nThe absolute URL that this download initiated from, before any redirects.\n\n  * urlRegex\n\nstring optional\n\nLimits results to `DownloadItem` whose `url` matches the given regular\nexpression.\n\n### FilenameConflictAction\n\nuniquify\n\nTo avoid duplication, the `filename` is changed to include a counter before\nthe filename extension.\n\noverwrite\n\nThe existing file will be overwritten with the new file.\n\nprompt\n\nThe user will be prompted with a file chooser dialog.\n\n#### Enum\n\n\"uniquify\"  \n\n\"overwrite\"  \n\n\"prompt\"  \n\n### FilenameSuggestion\n\n#### Properties\n\n  * conflictAction\n\nFilenameConflictAction optional\n\nThe action to take if `filename` already exists.\n\n  * filename\n\nstring\n\nThe `DownloadItem`'s new target `DownloadItem.filename`, as a path relative to\nthe user's default Downloads directory, possibly containing subdirectories.\nAbsolute paths, empty paths, and paths containing back-references \"..\" will be\nignored. `filename` is ignored if there are any `onDeterminingFilename`\nlisteners registered by any extensions.\n\n### GetFileIconOptions\n\n#### Properties\n\n  * size\n\nnumber optional\n\nThe size of the returned icon. The icon will be square with dimensions size *\nsize pixels. The default and largest size for the icon is 32x32 pixels. The\nonly supported sizes are 16 and 32. It is an error to specify any other size.\n\n### HeaderNameValuePair\n\n#### Properties\n\n  * name\n\nstring\n\nName of the HTTP header.\n\n  * value\n\nstring\n\nValue of the HTTP header.\n\n### HttpMethod\n\n#### Enum\n\n\"GET\"  \n\n\"POST\"  \n\n### InterruptReason\n\n#### Enum\n\n\"FILE_FAILED\"  \n\n\"FILE_ACCESS_DENIED\"  \n\n\"FILE_NO_SPACE\"  \n\n\"FILE_NAME_TOO_LONG\"  \n\n\"FILE_TOO_LARGE\"  \n\n\"FILE_VIRUS_INFECTED\"  \n\n\"FILE_TRANSIENT_ERROR\"  \n\n\"FILE_BLOCKED\"  \n\n\"FILE_SECURITY_CHECK_FAILED\"  \n\n\"FILE_TOO_SHORT\"  \n\n\"FILE_HASH_MISMATCH\"  \n\n\"FILE_SAME_AS_SOURCE\"  \n\n\"NETWORK_FAILED\"  \n\n\"NETWORK_TIMEOUT\"  \n\n\"NETWORK_DISCONNECTED\"  \n\n\"NETWORK_SERVER_DOWN\"  \n\n\"NETWORK_INVALID_REQUEST\"  \n\n\"SERVER_FAILED\"  \n\n\"SERVER_NO_RANGE\"  \n\n\"SERVER_BAD_CONTENT\"  \n\n\"SERVER_UNAUTHORIZED\"  \n\n\"SERVER_CERT_PROBLEM\"  \n\n\"SERVER_FORBIDDEN\"  \n\n\"SERVER_UNREACHABLE\"  \n\n\"SERVER_CONTENT_LENGTH_MISMATCH\"  \n\n\"SERVER_CROSS_ORIGIN_REDIRECT\"  \n\n\"USER_CANCELED\"  \n\n\"USER_SHUTDOWN\"  \n\n\"CRASH\"  \n\n### State\n\nin_progress\n\nThe download is currently receiving data from the server.\n\ninterrupted\n\nAn error broke the connection with the file host.\n\ncomplete\n\nThe download completed successfully.\n\n#### Enum\n\n\"in_progress\"  \n\n\"interrupted\"  \n\n\"complete\"  \n\n### StringDelta\n\n#### Properties\n\n  * current\n\nstring optional\n\n  * previous\n\nstring optional\n\n### UiOptions\n\nChrome 105+\n\n#### Properties\n\n  * enabled\n\nboolean\n\nEnable or disable the download UI.\n\n## Methods\n\n### acceptDanger()\n\nPromise\n\n    \n    \n    chrome.downloads.acceptDanger(  \n      downloadId: number,  \n      callback?: function,  \n    )\n\nPrompt the user to accept a dangerous download. Can only be called from a\nvisible context (tab, window, or page/browser action popup). Does not\nautomatically accept dangerous downloads. If the download is accepted, then an\n`onChanged` event will fire, otherwise nothing will happen. When all the data\nis fetched into a temporary file and either the download is not dangerous or\nthe danger has been accepted, then the temporary file is renamed to the target\nfilename, the `state` changes to 'complete', and `onChanged` fires.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\nThe identifier for the `DownloadItem`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### cancel()\n\nPromise\n\n    \n    \n    chrome.downloads.cancel(  \n      downloadId: number,  \n      callback?: function,  \n    )\n\nCancel a download. When `callback` is run, the download is cancelled,\ncompleted, interrupted or doesn't exist anymore.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\nThe id of the download to cancel.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### download()\n\nPromise\n\n    \n    \n    chrome.downloads.download(  \n      options: DownloadOptions,  \n      callback?: function,  \n    )\n\nDownload a URL. If the URL uses the HTTP[S] protocol, then the request will\ninclude all cookies currently set for its hostname. If both `filename` and\n`saveAs` are specified, then the Save As dialog will be displayed, pre-\npopulated with the specified `filename`. If the download started successfully,\n`callback` will be called with the new `DownloadItem`'s `downloadId`. If there\nwas an error starting the download, then `callback` will be called with\n`downloadId=undefined` and `runtime.lastError` will contain a descriptive\nstring. The error strings are not guaranteed to remain backwards compatible\nbetween releases. Extensions must not parse it.\n\n#### Parameters\n\n  * options\n\nDownloadOptions\n\nWhat to download and how.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (downloadId: number) => void\n\n    * downloadId\n\nnumber\n\n#### Returns\n\n  * Promise<number>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### erase()\n\nPromise\n\n    \n    \n    chrome.downloads.erase(  \n      query: DownloadQuery,  \n      callback?: function,  \n    )\n\nErase matching `DownloadItem` from history without deleting the downloaded\nfile. An `onErased` event will fire for each `DownloadItem` that matches\n`query`, then `callback` will be called.\n\n#### Parameters\n\n  * query\n\nDownloadQuery\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (erasedIds: number[]) => void\n\n    * erasedIds\n\nnumber[]\n\n#### Returns\n\n  * Promise<number[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getFileIcon()\n\nPromise\n\n    \n    \n    chrome.downloads.getFileIcon(  \n      downloadId: number,  \n      options?: GetFileIconOptions,  \n      callback?: function,  \n    )\n\nRetrieve an icon for the specified download. For new downloads, file icons are\navailable after the `onCreated` event has been received. The image returned by\nthis function while a download is in progress may be different from the image\nreturned after the download is complete. Icon retrieval is done by querying\nthe underlying operating system or toolkit depending on the platform. The icon\nthat is returned will therefore depend on a number of factors including state\nof the download, platform, registered file types and visual theme. If a file\nicon cannot be determined, `runtime.lastError` will contain an error message.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\nThe identifier for the download.\n\n  * options\n\nGetFileIconOptions optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (iconURL?: string) => void\n\n    * iconURL\n\nstring optional\n\n#### Returns\n\n  * Promise<string | undefined>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### open()\n\nPromise\n\n    \n    \n    chrome.downloads.open(  \n      downloadId: number,  \n      callback?: function,  \n    )\n\nOpens the downloaded file now if the `DownloadItem` is complete; otherwise\nreturns an error through `runtime.lastError`. This method requires the\n`\"downloads.open\"` permission in addition to the `\"downloads\"` permission. An\n`onChanged` event fires when the item is opened for the first time. This\nmethod can only be called in response to a user gesture.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\nThe identifier for the downloaded file.\n\n  * callback\n\nfunction optional\n\nChrome 123+\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 123+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### pause()\n\nPromise\n\n    \n    \n    chrome.downloads.pause(  \n      downloadId: number,  \n      callback?: function,  \n    )\n\nPause the download. If the request was successful the download is in a paused\nstate. Otherwise `runtime.lastError` contains an error message. The request\nwill fail if the download is not active.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\nThe id of the download to pause.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeFile()\n\nPromise\n\n    \n    \n    chrome.downloads.removeFile(  \n      downloadId: number,  \n      callback?: function,  \n    )\n\nRemove the downloaded file if it exists and the `DownloadItem` is complete;\notherwise return an error through `runtime.lastError`.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### resume()\n\nPromise\n\n    \n    \n    chrome.downloads.resume(  \n      downloadId: number,  \n      callback?: function,  \n    )\n\nResume a paused download. If the request was successful the download is in\nprogress and unpaused. Otherwise `runtime.lastError` contains an error\nmessage. The request will fail if the download is not active.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\nThe id of the download to resume.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### search()\n\nPromise\n\n    \n    \n    chrome.downloads.search(  \n      query: DownloadQuery,  \n      callback?: function,  \n    )\n\nFind `DownloadItem`. Set `query` to the empty object to get all\n`DownloadItem`. To get a specific `DownloadItem`, set only the `id` field. To\npage through a large number of items, set `orderBy: ['-startTime']`, set\n`limit` to the number of items per page, and set `startedAfter` to the\n`startTime` of the last item from the last page.\n\n#### Parameters\n\n  * query\n\nDownloadQuery\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: DownloadItem[]) => void\n\n    * results\n\nDownloadItem[]\n\n#### Returns\n\n  * Promise<DownloadItem[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setShelfEnabled()\n\nDeprecated since Chrome 117\n\n    \n    \n    chrome.downloads.setShelfEnabled(  \n      enabled: boolean,  \n    )\n\nUse `setUiOptions` instead.\n\nEnable or disable the gray shelf at the bottom of every window associated with\nthe current browser profile. The shelf will be disabled as long as at least\none extension has disabled it. Enabling the shelf while at least one other\nextension has disabled it will return an error through `runtime.lastError`.\nRequires the `\"downloads.shelf\"` permission in addition to the `\"downloads\"`\npermission.\n\n#### Parameters\n\n  * enabled\n\nboolean\n\n### setUiOptions()\n\nPromise Chrome 105+\n\n    \n    \n    chrome.downloads.setUiOptions(  \n      options: UiOptions,  \n      callback?: function,  \n    )\n\nChange the download UI of every window associated with the current browser\nprofile. As long as at least one extension has set `UiOptions.enabled` to\nfalse, the download UI will be hidden. Setting `UiOptions.enabled` to true\nwhile at least one other extension has disabled it will return an error\nthrough `runtime.lastError`. Requires the `\"downloads.ui\"` permission in\naddition to the `\"downloads\"` permission.\n\n#### Parameters\n\n  * options\n\nUiOptions\n\nEncapsulate a change to the download UI.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### show()\n\n    \n    \n    chrome.downloads.show(  \n      downloadId: number,  \n    )\n\nShow the downloaded file in its folder in a file manager.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\nThe identifier for the downloaded file.\n\n### showDefaultFolder()\n\n    \n    \n    chrome.downloads.showDefaultFolder()\n\nShow the default Downloads folder in a file manager.\n\n## Events\n\n### onChanged\n\n    \n    \n    chrome.downloads.onChanged.addListener(  \n      callback: function,  \n    )\n\nWhen any of a `DownloadItem`'s properties except `bytesReceived` and\n`estimatedEndTime` changes, this event fires with the `downloadId` and an\nobject containing the properties that changed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (downloadDelta: DownloadDelta) => void\n\n    * downloadDelta\n\nDownloadDelta\n\n### onCreated\n\n    \n    \n    chrome.downloads.onCreated.addListener(  \n      callback: function,  \n    )\n\nThis event fires with the `DownloadItem` object when a download begins.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (downloadItem: DownloadItem) => void\n\n    * downloadItem\n\nDownloadItem\n\n### onDeterminingFilename\n\n    \n    \n    chrome.downloads.onDeterminingFilename.addListener(  \n      callback: function,  \n    )\n\nDuring the filename determination process, extensions will be given the\nopportunity to override the target `DownloadItem.filename`. Each extension may\nnot register more than one listener for this event. Each listener must call\n`suggest` exactly once, either synchronously or asynchronously. If the\nlistener calls `suggest` asynchronously, then it must return `true`. If the\nlistener neither calls `suggest` synchronously nor returns `true`, then\n`suggest` will be called automatically. The `DownloadItem` will not complete\nuntil all listeners have called `suggest`. Listeners may call `suggest`\nwithout any arguments in order to allow the download to use\n`downloadItem.filename` for its filename, or pass a `suggestion` object to\n`suggest` in order to override the target filename. If more than one extension\noverrides the filename, then the last extension installed whose listener\npasses a `suggestion` object to `suggest` wins. In order to avoid confusion\nregarding which extension will win, users should not install extensions that\nmay conflict. If the download is initiated by `download` and the target\nfilename is known before the MIME type and tentative filename have been\ndetermined, pass `filename` to `download` instead.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (downloadItem: DownloadItem, suggest: function) => void\n\n    * downloadItem\n\nDownloadItem\n\n    * suggest\n\nfunction\n\nThe `suggest` parameter looks like:\n\n          \n          (suggestion?: FilenameSuggestion) => void\n\n      * suggestion\n\nFilenameSuggestion optional\n\n### onErased\n\n    \n    \n    chrome.downloads.onErased.addListener(  \n      callback: function,  \n    )\n\nFires with the `downloadId` when a download is erased from history.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (downloadId: number) => void\n\n    * downloadId\n\nnumber\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/enterprise/deviceAttributes": "#  chrome.enterprise.deviceAttributes\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\nThis API is only for extensions installed by a policy.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.enterprise.deviceAttributes` API to read device attributes.\nNote: This API is only available to extensions force-installed by enterprise\npolicy.\n\n## Permissions\n\n`enterprise.deviceAttributes`  \n\n## Availability\n\nChrome 46+  ChromeOS only  Requires policy\n\n## Methods\n\n### getDeviceAnnotatedLocation()\n\nPromise Chrome 66+\n\n    \n    \n    chrome.enterprise.deviceAttributes.getDeviceAnnotatedLocation(  \n      callback?: function,  \n    )\n\nFetches the administrator-annotated Location. If the current user is not\naffiliated or no Annotated Location has been set by the administrator, returns\nan empty string.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (annotatedLocation: string) => void\n\n    * annotatedLocation\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDeviceAssetId()\n\nPromise Chrome 66+\n\n    \n    \n    chrome.enterprise.deviceAttributes.getDeviceAssetId(  \n      callback?: function,  \n    )\n\nFetches the administrator-annotated Asset Id. If the current user is not\naffiliated or no Asset Id has been set by the administrator, returns an empty\nstring.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (assetId: string) => void\n\n    * assetId\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDeviceHostname()\n\nPromise Chrome 82+\n\n    \n    \n    chrome.enterprise.deviceAttributes.getDeviceHostname(  \n      callback?: function,  \n    )\n\nFetches the device's hostname as set by DeviceHostnameTemplate policy. If the\ncurrent user is not affiliated or no hostname has been set by the enterprise\npolicy, returns an empty string.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (hostname: string) => void\n\n    * hostname\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDeviceSerialNumber()\n\nPromise Chrome 66+\n\n    \n    \n    chrome.enterprise.deviceAttributes.getDeviceSerialNumber(  \n      callback?: function,  \n    )\n\nFetches the device's serial number. Please note the purpose of this API is to\nadministrate the device (e.g. generating Certificate Sign Requests for device-\nwide certificates). This API may not be used for tracking devices without the\nconsent of the device's administrator. If the current user is not affiliated,\nreturns an empty string.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (serialNumber: string) => void\n\n    * serialNumber\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDirectoryDeviceId()\n\nPromise\n\n    \n    \n    chrome.enterprise.deviceAttributes.getDirectoryDeviceId(  \n      callback?: function,  \n    )\n\nFetches the value of the device identifier of the directory API, that is\ngenerated by the server and identifies the cloud record of the device for\nquerying in the cloud directory API. If the current user is not affiliated,\nreturns an empty string.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (deviceId: string) => void\n\n    * deviceId\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/enterprise/hardwarePlatform": "#  chrome.enterprise.hardwarePlatform\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\nThis API is only for extensions installed by a policy. The\n`EnterpriseHardwarePlatformAPIEnabled` key must also be set.\n\n## Description\n\nUse the `chrome.enterprise.hardwarePlatform` API to get the manufacturer and\nmodel of the hardware platform where the browser runs. Note: This API is only\navailable to extensions installed by enterprise policy.\n\n## Permissions\n\n`enterprise.hardwarePlatform`  \n\n## Availability\n\nChrome 71+  Requires policy\n\n## Types\n\n### HardwarePlatformInfo\n\n#### Properties\n\n  * manufacturer\n\nstring\n\n  * model\n\nstring\n\n## Methods\n\n### getHardwarePlatformInfo()\n\nPromise\n\n    \n    \n    chrome.enterprise.hardwarePlatform.getHardwarePlatformInfo(  \n      callback?: function,  \n    )\n\nObtains the manufacturer and model for the hardware platform and, if the\nextension is authorized, returns it via `callback`.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (info: HardwarePlatformInfo) => void\n\n    * info\n\nHardwarePlatformInfo\n\n#### Returns\n\n  * Promise<HardwarePlatformInfo>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/enterprise/networkingAttributes": "#  chrome.enterprise.networkingAttributes\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\nThis API is only for extensions installed by a policy.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.enterprise.networkingAttributes` API to read information about\nyour current network. Note: This API is only available to extensions force-\ninstalled by enterprise policy.\n\n## Permissions\n\n`enterprise.networkingAttributes`  \n\n## Availability\n\nChrome 85+  ChromeOS only  Requires policy\n\n## Types\n\n### NetworkDetails\n\n#### Properties\n\n  * ipv4\n\nstring optional\n\nThe device's local IPv4 address (undefined if not configured).\n\n  * ipv6\n\nstring optional\n\nThe device's local IPv6 address (undefined if not configured).\n\n  * macAddress\n\nstring\n\nThe device's MAC address.\n\n## Methods\n\n### getNetworkDetails()\n\nPromise\n\n    \n    \n    chrome.enterprise.networkingAttributes.getNetworkDetails(  \n      callback?: function,  \n    )\n\nRetrieves the network details of the device's default network. If the user is\nnot affiliated or the device is not connected to a network,\n`runtime.lastError` will be set with a failure reason.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (networkAddresses: NetworkDetails) => void\n\n    * networkAddresses\n\nNetworkDetails\n\n#### Returns\n\n  * Promise<NetworkDetails>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/enterprise/platformKeys": "#  chrome.enterprise.platformKeys\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\nThis API is only for extensions installed by a policy.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.enterprise.platformKeys` API to generate keys and install\ncertificates for these keys. The certificates will be managed by the platform\nand can be used for TLS authentication, network access or by other extension\nthrough chrome.platformKeys.\n\n## Permissions\n\n`enterprise.platformKeys`  \n\n## Availability\n\nChromeOS only  Requires policy\n\n## Concepts and usage\n\nTypical usage of this API to enroll a client certificate follows these steps:\n\n  * Get all available tokens using `enterprise.platformKeys.getTokens()`.\n\n  * Find the Token with `id` equal to `\"user\"`. Use this Token subsequently.\n\n  * Generate a key pair using the `generateKey()` Token method (defined in SubtleCrypto). This will return handle to the key.\n\n  * Export the public key using the `exportKey()` Token method (defined in SubtleCrypto).\n\n  * Create the signature of the certification request's data using the `sign()` Token method (defined in SubtleCrypto).\n\n  * Complete the certification request and send it to the certification authority.\n\n  * If a certificate is received, import it using [`enterprise.platformKeys.importCertificate()``[3]\n\nHere's an example that shows the major API interaction except the building and\nsending of the certification request:\n\n    \n    \n    function getUserToken(callback) {\n      chrome.enterprise.platformKeys.getTokens(function(tokens) {\n        for (var i = 0; i < tokens.length; i++) {\n          if (tokens[i].id == \"user\") {\n            callback(tokens[i]);\n            return;\n          }\n        }\n        callback(undefined);\n      });\n    }\n    \n    function generateAndSign(userToken) {\n      var data = new Uint8Array([0, 5, 1, 2, 3, 4, 5, 6]);\n      var algorithm = {\n        name: \"RSASSA-PKCS1-v1_5\",\n        // RsaHashedKeyGenParams\n        modulusLength: 2048,\n        publicExponent:\n            new Uint8Array([0x01, 0x00, 0x01]),  // Equivalent to 65537\n        hash: {\n          name: \"SHA-256\",\n        }\n      };\n      var cachedKeyPair;\n      userToken.subtleCrypto.generateKey(algorithm, false, [\"sign\"])\n        .then(function(keyPair) {\n                cachedKeyPair = keyPair;\n                return userToken.subtleCrypto.exportKey(\"spki\", keyPair.publicKey);\n              },\n              console.log.bind(console))\n        .then(function(publicKeySpki) {\n                // Build the Certification Request using the public key.\n                return userToken.subtleCrypto.sign(\n                    {name : \"RSASSA-PKCS1-v1_5\"}, cachedKeyPair.privateKey, data);\n              },\n              console.log.bind(console))\n        .then(function(signature) {\n                  // Complete the Certification Request with |signature|.\n                  // Send out the request to the CA, calling back\n                  // onClientCertificateReceived.\n              },\n              console.log.bind(console));\n    }\n    \n    function onClientCertificateReceived(userToken, certificate) {\n      chrome.enterprise.platformKeys.importCertificate(userToken.id, certificate);\n    }\n    \n    getUserToken(generateAndSign);\n    \n\n## Types\n\n### Algorithm\n\nChrome 110+\n\nType of key to generate.\n\n#### Enum\n\n\"RSA\"  \n\n\"ECDSA\"  \n\n### ChallengeKeyOptions\n\nChrome 110+\n\n#### Properties\n\n  * challenge\n\nArrayBuffer\n\nA challenge as emitted by the Verified Access Web API.\n\n  * registerKey\n\nRegisterKeyOptions optional\n\nIf present, registers the challenged key with the specified `scope`'s token.\nThe key can then be associated with a certificate and used like any other\nsigning key. Subsequent calls to this function will then generate a new\nEnterprise Key in the specified `scope`.\n\n  * scope\n\nScope\n\nWhich Enterprise Key to challenge.\n\n### RegisterKeyOptions\n\nChrome 110+\n\n#### Properties\n\n  * algorithm\n\nAlgorithm\n\nWhich algorithm the registered key should use.\n\n### Scope\n\nChrome 110+\n\nWhether to use the Enterprise User Key or the Enterprise Machine Key.\n\n#### Enum\n\n\"USER\"  \n\n\"MACHINE\"  \n\n### Token\n\n#### Properties\n\n  * id\n\nstring\n\nUniquely identifies this `Token`.\n\nStatic IDs are `\"user\"` and `\"system\"`, referring to the platform's user-\nspecific and the system-wide hardware token, respectively. Any other tokens\n(with other identifiers) might be returned by\n`enterprise.platformKeys.getTokens`.\n\n  * softwareBackedSubtleCrypto\n\nSubtleCrypto\n\nChrome 97+\n\nImplements the WebCrypto's SubtleCrypto interface. The cryptographic\noperations, including key generation, are software-backed. Protection of the\nkeys, and thus implementation of the non-extractable property, is done in\nsoftware, so the keys are less protected than hardware-backed keys.\n\nOnly non-extractable keys can be generated. The supported key types are\nRSASSA-PKCS1-V1_5 and RSA-OAEP (on Chrome versions 135+) with `modulusLength`\nup to 2048. Each RSASSA-PKCS1-V1_5 key can be used for signing data at most\nonce, unless the extension is allowlisted through the KeyPermissions policy,\nin which case the key can be used indefinitely. RSA-OAEP keys are supported\nsince Chrome version 135 and can be used by extensions allowlisted through\nthat same policy to unwrap other keys.\n\nKeys generated on a specific `Token` cannot be used with any other Tokens, nor\ncan they be used with `window.crypto.subtle`. Equally, `Key` objects created\nwith `window.crypto.subtle` cannot be used with this interface.\n\n  * subtleCrypto\n\nSubtleCrypto\n\nImplements the WebCrypto's SubtleCrypto interface. The cryptographic\noperations, including key generation, are hardware-backed.\n\nOnly non-extractable keys can be generated. The supported key types are\nRSASSA-PKCS1-V1_5 and RSA-OAEP (on Chrome versions 135+) with `modulusLength`\nup to 2048 and ECDSA with `namedCurve` P-256. Each RSASSA-PKCS1-V1_5 and ECDSA\nkey can be used for signing data at most once, unless the extension is\nallowlisted through the KeyPermissions policy, in which case the key can be\nused indefinitely. RSA-OAEP keys are supported since Chrome version 135 and\ncan be used by extensions allowlisted through that same policy to unwrap other\nkeys.\n\nKeys generated on a specific `Token` cannot be used with any other Tokens, nor\ncan they be used with `window.crypto.subtle`. Equally, `Key` objects created\nwith `window.crypto.subtle` cannot be used with this interface.\n\n## Methods\n\n### challengeKey()\n\nPromise Chrome 110+\n\n    \n    \n    chrome.enterprise.platformKeys.challengeKey(  \n      options: ChallengeKeyOptions,  \n      callback?: function,  \n    )\n\nSimilar to `challengeMachineKey` and `challengeUserKey`, but allows specifying\nthe algorithm of a registered key. Challenges a hardware-backed Enterprise\nMachine Key and emits the response as part of a remote attestation protocol.\nOnly useful on ChromeOS and in conjunction with the Verified Access Web API\nwhich both issues challenges and verifies responses.\n\nA successful verification by the Verified Access Web API is a strong signal\nthat the current device is a legitimate ChromeOS device, the current device is\nmanaged by the domain specified during verification, the current signed-in\nuser is managed by the domain specified during verification, and the current\ndevice state complies with enterprise device policy. For example, a policy may\nspecify that the device must not be in developer mode. Any device identity\nemitted by the verification is tightly bound to the hardware of the current\ndevice. If `\"user\"` Scope is specified, the identity is also tightly bound to\nthe current signed-in user.\n\nThis function is highly restricted and will fail if the current device is not\nmanaged, the current user is not managed, or if this operation has not\nexplicitly been enabled for the caller by enterprise device policy. The\nchallenged key does not reside in the `\"system\"` or `\"user\"` token and is not\naccessible by any other API.\n\n#### Parameters\n\n  * options\n\nChallengeKeyOptions\n\nObject containing the fields defined in `ChallengeKeyOptions`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: ArrayBuffer) => void\n\n    * response\n\nArrayBuffer\n\nThe challenge response.\n\n#### Returns\n\n  * Promise<ArrayBuffer>\n\nChrome 131+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### challengeMachineKey()\n\nPromise Chrome 50+  Deprecated since Chrome 110\n\n    \n    \n    chrome.enterprise.platformKeys.challengeMachineKey(  \n      challenge: ArrayBuffer,  \n      registerKey?: boolean,  \n      callback?: function,  \n    )\n\nUse `challengeKey` instead.\n\nChallenges a hardware-backed Enterprise Machine Key and emits the response as\npart of a remote attestation protocol. Only useful on ChromeOS and in\nconjunction with the Verified Access Web API which both issues challenges and\nverifies responses. A successful verification by the Verified Access Web API\nis a strong signal of all of the following: * The current device is a\nlegitimate ChromeOS device. * The current device is managed by the domain\nspecified during verification. * The current signed-in user is managed by the\ndomain specified during verification. * The current device state complies with\nenterprise device policy. For example, a policy may specify that the device\nmust not be in developer mode. * Any device identity emitted by the\nverification is tightly bound to the hardware of the current device. This\nfunction is highly restricted and will fail if the current device is not\nmanaged, the current user is not managed, or if this operation has not\nexplicitly been enabled for the caller by enterprise device policy. The\nEnterprise Machine Key does not reside in the `\"system\"` token and is not\naccessible by any other API.\n\n#### Parameters\n\n  * challenge\n\nArrayBuffer\n\nA challenge as emitted by the Verified Access Web API.\n\n  * registerKey\n\nboolean optional\n\nChrome 59+\n\nIf set, the current Enterprise Machine Key is registered with the `\"system\"`\ntoken and relinquishes the Enterprise Machine Key role. The key can then be\nassociated with a certificate and used like any other signing key. This key is\n2048-bit RSA. Subsequent calls to this function will then generate a new\nEnterprise Machine Key.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: ArrayBuffer) => void\n\n    * response\n\nArrayBuffer\n\nThe challenge response.\n\n#### Returns\n\n  * Promise<ArrayBuffer>\n\nChrome 131+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### challengeUserKey()\n\nPromise Chrome 50+  Deprecated since Chrome 110\n\n    \n    \n    chrome.enterprise.platformKeys.challengeUserKey(  \n      challenge: ArrayBuffer,  \n      registerKey: boolean,  \n      callback?: function,  \n    )\n\nUse `challengeKey` instead.\n\nChallenges a hardware-backed Enterprise User Key and emits the response as\npart of a remote attestation protocol. Only useful on ChromeOS and in\nconjunction with the Verified Access Web API which both issues challenges and\nverifies responses. A successful verification by the Verified Access Web API\nis a strong signal of all of the following: * The current device is a\nlegitimate ChromeOS device. * The current device is managed by the domain\nspecified during verification. * The current signed-in user is managed by the\ndomain specified during verification. * The current device state complies with\nenterprise user policy. For example, a policy may specify that the device must\nnot be in developer mode. * The public key emitted by the verification is\ntightly bound to the hardware of the current device and to the current signed-\nin user. This function is highly restricted and will fail if the current\ndevice is not managed, the current user is not managed, or if this operation\nhas not explicitly been enabled for the caller by enterprise user policy. The\nEnterprise User Key does not reside in the `\"user\"` token and is not\naccessible by any other API.\n\n#### Parameters\n\n  * challenge\n\nArrayBuffer\n\nA challenge as emitted by the Verified Access Web API.\n\n  * registerKey\n\nboolean\n\nIf set, the current Enterprise User Key is registered with the `\"user\"` token\nand relinquishes the Enterprise User Key role. The key can then be associated\nwith a certificate and used like any other signing key. This key is 2048-bit\nRSA. Subsequent calls to this function will then generate a new Enterprise\nUser Key.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: ArrayBuffer) => void\n\n    * response\n\nArrayBuffer\n\nThe challenge response.\n\n#### Returns\n\n  * Promise<ArrayBuffer>\n\nChrome 131+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getCertificates()\n\nPromise\n\n    \n    \n    chrome.enterprise.platformKeys.getCertificates(  \n      tokenId: string,  \n      callback?: function,  \n    )\n\nReturns the list of all client certificates available from the given token.\nCan be used to check for the existence and expiration of client certificates\nthat are usable for a certain authentication.\n\n#### Parameters\n\n  * tokenId\n\nstring\n\nThe id of a Token returned by `getTokens`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (certificates: ArrayBuffer[]) => void\n\n    * certificates\n\nArrayBuffer[]\n\nThe list of certificates, each in DER encoding of a X.509 certificate.\n\n#### Returns\n\n  * Promise<ArrayBuffer[]>\n\nChrome 131+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getTokens()\n\nPromise\n\n    \n    \n    chrome.enterprise.platformKeys.getTokens(  \n      callback?: function,  \n    )\n\nReturns the available Tokens. In a regular user's session the list will always\ncontain the user's token with `id` `\"user\"`. If a system-wide TPM token is\navailable, the returned list will also contain the system-wide token with `id`\n`\"system\"`. The system-wide token will be the same for all sessions on this\ndevice (device in the sense of e.g. a Chromebook).\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tokens: Token[]) => void\n\n    * tokens\n\nToken[]\n\nThe list of available tokens.\n\n#### Returns\n\n  * Promise<Token[]>\n\nChrome 131+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### importCertificate()\n\nPromise\n\n    \n    \n    chrome.enterprise.platformKeys.importCertificate(  \n      tokenId: string,  \n      certificate: ArrayBuffer,  \n      callback?: function,  \n    )\n\nImports `certificate` to the given token if the certified key is already\nstored in this token. After a successful certification request, this function\nshould be used to store the obtained certificate and to make it available to\nthe operating system and browser for authentication.\n\n#### Parameters\n\n  * tokenId\n\nstring\n\nThe id of a Token returned by `getTokens`.\n\n  * certificate\n\nArrayBuffer\n\nThe DER encoding of a X.509 certificate.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 131+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeCertificate()\n\nPromise\n\n    \n    \n    chrome.enterprise.platformKeys.removeCertificate(  \n      tokenId: string,  \n      certificate: ArrayBuffer,  \n      callback?: function,  \n    )\n\nRemoves `certificate` from the given token if present. Should be used to\nremove obsolete certificates so that they are not considered during\nauthentication and do not clutter the certificate choice. Should be used to\nfree storage in the certificate store.\n\n#### Parameters\n\n  * tokenId\n\nstring\n\nThe id of a Token returned by `getTokens`.\n\n  * certificate\n\nArrayBuffer\n\nThe DER encoding of a X.509 certificate.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 131+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/events": "#  chrome.events\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.events` namespace contains common types used by APIs dispatching\nevents to notify you when something interesting happens.\n\n## Concepts and usage\n\nAn `Event` is an object that lets you be notified when something interesting\nhappens. Here's an example of using the `chrome.alarms.onAlarm` event to be\nnotified whenever an alarm has elapsed:\n\n    \n    \n    chrome.alarms.onAlarm.addListener((alarm) => {\n      appendToLog(`alarms.onAlarm -- name: ${alarm.name}, scheduledTime: ${alarm.scheduledTime}`);\n    });\n    \n\nAs the example shows, you register for notification using `addListener()`. The\nargument to `addListener()` is always a function that you define to handle the\nevent, but the parameters to the function depend on which event you're\nhandling. Checking the documentation for `alarms.onAlarm`, you can see that\nthe function has a single parameter: an `alarms.Alarm` object that has details\nabout the elapsed alarm.\n\nExample APIs using Events: alarms, i18n, identity, runtime. Most chrome APIs\ndo.\n\n### Declarative Event Handlers\n\nThe declarative event handlers provide a means to define rules consisting of\ndeclarative conditions and actions. Conditions are evaluated in the browser\nrather than the JavaScript engine which reduces roundtrip latencies and allows\nfor very high efficiency.\n\nDeclarative event handlers are used for example in the Declarative Content\nAPI. This page describes the underlying concepts of all declarative event\nhandlers.\n\n#### Rules\n\nThe simplest possible rule consists of one or more conditions and one or more\nactions:\n\n    \n    \n    const rule = {\n      conditions: [ /* my conditions */ ],\n      actions: [ /* my actions */ ]\n    };\n    \n\nIf any of the conditions is fulfilled, all actions are executed.\n\nIn addition to conditions and actions you may give each rule an identifier,\nwhich simplifies unregistering previously registered rules, and a priority to\ndefine precedences among rules. Priorities are only considered if rules\nconflict each other or need to be executed in a specific order. Actions are\nexecuted in descending order of the priority of their rules.\n\n    \n    \n    const rule = {\n      id: \"my rule\",  // optional, will be generated if not set.\n      priority: 100,  // optional, defaults to 100.\n      conditions: [ /* my conditions */ ],\n      actions: [ /* my actions */ ]\n    };\n    \n\n#### Event objects\n\nEvent objects may support rules. These event objects don't call a callback\nfunction when events happen but test whether any registered rule has at least\none fulfilled condition and execute the actions associated with this rule.\nEvent objects supporting the declarative API have three relevant methods:\n`events.Event.addRules()`, `events.Event.removeRules()`, and\n`events.Event.getRules()`.\n\n#### Add rules\n\nTo add rules call the `addRules()` function of the event object. It takes an\narray of rule instances as its first parameter and a callback function that is\ncalled on completion.\n\n    \n    \n    const rule_list = [rule1, rule2, ...];\n    addRules(rule_list, (details) => {...});\n    \n\nIf the rules were inserted successfully, the `details` parameter contains an\narray of inserted rules appearing in the same order as in the passed\n`rule_list` where the optional parameters `id` and `priority` were filled with\nthe generated values. If any rule is invalid, for example, because it\ncontained an invalid condition or action, none of the rules are added and the\nruntime.lastError variable is set when the callback function is called. Each\nrule in `rule_list` must contain a unique identifier that is not already used\nby another rule or an empty identifier.\n\n**Note:** Rules are persistent across browsing sessions. Therefore, you should\ninstall rules during extension installation time using the\n`runtime.onInstalled` event. Note that this event is also triggered when an\nextension is updated. Therefore, you should first clear previously installed\nrules and then register new rules.\n\n#### Remove rules\n\nTo remove rules call the `removeRules()` function. It accepts an optional\narray of rule identifiers as its first parameter and a callback function as\nits second parameter.\n\n    \n    \n    const rule_ids = [\"id1\", \"id2\", ...];\n    removeRules(rule_ids, () => {...});\n    \n\nIf `rule_ids` is an array of identifiers, all rules having identifiers listed\nin the array are removed. If `rule_ids` lists an identifier, that is unknown,\nthis identifier is silently ignored. If `rule_ids` is `undefined`, all\nregistered rules of this extension are removed. The `callback()` function is\ncalled when the rules were removed.\n\n#### Retrieve rules\n\nTo retrieve a list of registered rules, call the `getRules()` function. It\naccepts an optional array of rule identifiers with the same semantics as\n`removeRules()` and a callback function.\n\n    \n    \n    const rule_ids = [\"id1\", \"id2\", ...];\n    getRules(rule_ids, (details) => {...});\n    \n\nThe `details` parameter passed to the `callback()` function refers to an array\nof rules including filled optional parameters.\n\n#### Performance\n\nTo achieve maximum performance, you should keep the following guidelines in\nmind.\n\n**Register and unregister rules in bulk.** After each registration or\nunregistration, Chrome needs to update internal data structures. This update\nis an expensive operation.\n\nInstead of\n\n    \n    \n    const rule1 = {...};\n    const rule2 = {...};\n    chrome.declarativeWebRequest.onRequest.addRules([rule1]);\n    chrome.declarativeWebRequest.onRequest.addRules([rule2]);\n\nPrefer\n\n    \n    \n    const rule1 = {...};\n    const rule2 = {...};\n    chrome.declarativeWebRequest.onRequest.addRules([rule1, rule2]);\n\n**Prefer substring matching over regular expressions in anevents.UrlFilter.**\nSubstring based matching is extremely fast.\n\nInstead of\n\n    \n    \n    const match = new chrome.declarativeWebRequest.RequestMatcher({\n      url: {urlMatches: \"example.com/[^?]*foo\" }\n    });\n\nPrefer\n\n    \n    \n    const match = new chrome.declarativeWebRequest.RequestMatcher({\n      url: {hostSuffix: \"example.com\", pathContains: \"foo\"}\n    });\n\nIf there are many rules that share the same actions, merge the rules into one.\nRules trigger their actions as soon as a single condition is fulfilled. This\nspeeds up the matching and reduces memory consumption for duplicate action\nsets.\n\nInstead of\n\n    \n    \n    const condition1 = new chrome.declarativeWebRequest.RequestMatcher({\n      url: { hostSuffix: 'example.com' }\n    });\n    const condition2 = new chrome.declarativeWebRequest.RequestMatcher({\n      url: { hostSuffix: 'foobar.com' }\n    });\n    const rule1 = { conditions: [condition1],\n                    actions: [new chrome.declarativeWebRequest.CancelRequest()]\n                  };\n    const rule2 = { conditions: [condition2],\n                    actions: [new chrome.declarativeWebRequest.CancelRequest()]\n                  };\n    chrome.declarativeWebRequest.onRequest.addRules([rule1, rule2]);\n\nPrefer\n\n    \n    \n    const condition1 = new chrome.declarativeWebRequest.RequestMatcher({\n      url: { hostSuffix: 'example.com' }\n    });\n    const condition2 = new chrome.declarativeWebRequest.RequestMatcher({\n      url: { hostSuffix: 'foobar.com' }\n    });\n    const rule = { conditions: [condition1, condition2],\n                  actions: [new chrome.declarativeWebRequest.CancelRequest()]\n                 };\n    chrome.declarativeWebRequest.onRequest.addRules([rule]);\n\n### Filtered events\n\nFiltered events are a mechanism that allows listeners to specify a subset of\nevents that they are interested in. A listener that uses a filter won't be\ninvoked for events that don't pass the filter, which makes the listening code\nmore declarative and efficient. A service worker need not be woken up to\nhandle events it doesn't care about.\n\nFiltered events are intended to allow a transition from manual filtering code.\n\nInstead of\n\n    \n    \n    chrome.webNavigation.onCommitted.addListener((event) => {\n      if (hasHostSuffix(event.url, 'google.com') ||\n          hasHostSuffix(event.url, 'google.com.au')) {\n        // ...\n      }\n    });\n\nPrefer\n\n    \n    \n    chrome.webNavigation.onCommitted.addListener((event) => {\n      // ...\n    }, {url: [{hostSuffix: 'google.com'},\n              {hostSuffix: 'google.com.au'}]});\n\nEvents support specific filters that are meaningful to that event. The list of\nfilters that an event supports will be listed in the documentation for that\nevent in the \"filters\" section.\n\nWhen matching URLs (as in the example above), event filters support the same\nURL matching capabilities as expressible with a `events.UrlFilter`, except for\nscheme and port matching.\n\n## Types\n\n### Event\n\nAn object which allows the addition and removal of listeners for a Chrome\nevent.\n\n#### Properties\n\n  * addListener\n\nvoid\n\nRegisters an event listener _callback_ to an event.\n\nThe `addListener` function looks like:\n\n        \n        (callback: H) => {...}\n\n    * callback\n\nH\n\nCalled when an event occurs. The parameters of this function depend on the\ntype of event.\n\n  * addRules\n\nvoid\n\nRegisters rules to handle events.\n\nThe `addRules` function looks like:\n\n        \n        (rules: Rule<anyany>[], callback?: function) => {...}\n\n    * rules\n\nRule<anyany>[]\n\nRules to be registered. These do not replace previously registered rules.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (rules: Rule<anyany>[]) => void\n\n      * rules\n\nRule<anyany>[]\n\nRules that were registered, the optional parameters are filled with values.\n\n  * getRules\n\nvoid\n\nReturns currently registered rules.\n\nThe `getRules` function looks like:\n\n        \n        (ruleIdentifiers?: string[], callback: function) => {...}\n\n    * ruleIdentifiers\n\nstring[] optional\n\nIf an array is passed, only rules with identifiers contained in this array are\nreturned.\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (rules: Rule<anyany>[]) => void\n\n      * rules\n\nRule<anyany>[]\n\nRules that were registered, the optional parameters are filled with values.\n\n  * hasListener\n\nvoid\n\nThe `hasListener` function looks like:\n\n        \n        (callback: H) => {...}\n\n    * callback\n\nH\n\nListener whose registration status shall be tested.\n\n    * returns\n\nboolean\n\nTrue if _callback_ is registered to the event.\n\n  * hasListeners\n\nvoid\n\nThe `hasListeners` function looks like:\n\n        \n        () => {...}\n\n    * returns\n\nboolean\n\nTrue if any event listeners are registered to the event.\n\n  * removeListener\n\nvoid\n\nDeregisters an event listener _callback_ from an event.\n\nThe `removeListener` function looks like:\n\n        \n        (callback: H) => {...}\n\n    * callback\n\nH\n\nListener that shall be unregistered.\n\n  * removeRules\n\nvoid\n\nUnregisters currently registered rules.\n\nThe `removeRules` function looks like:\n\n        \n        (ruleIdentifiers?: string[], callback?: function) => {...}\n\n    * ruleIdentifiers\n\nstring[] optional\n\nIf an array is passed, only rules with identifiers contained in this array are\nunregistered.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n### Rule\n\nDescription of a declarative rule for handling events.\n\n#### Properties\n\n  * actions\n\nany[]\n\nList of actions that are triggered if one of the conditions is fulfilled.\n\n  * conditions\n\nany[]\n\nList of conditions that can trigger the actions.\n\n  * id\n\nstring optional\n\nOptional identifier that allows referencing this rule.\n\n  * priority\n\nnumber optional\n\nOptional priority of this rule. Defaults to 100.\n\n  * tags\n\nstring[] optional\n\nTags can be used to annotate rules and perform operations on sets of rules.\n\n### UrlFilter\n\nFilters URLs for various criteria. See event filtering. All criteria are case\nsensitive.\n\n#### Properties\n\n  * cidrBlocks\n\nstring[] optional\n\nChrome 123+\n\nMatches if the host part of the URL is an IP address and is contained in any\nof the CIDR blocks specified in the array.\n\n  * hostContains\n\nstring optional\n\nMatches if the host name of the URL contains a specified string. To test\nwhether a host name component has a prefix 'foo', use hostContains: '.foo'.\nThis matches 'www.foobar.com' and 'foo.com', because an implicit dot is added\nat the beginning of the host name. Similarly, hostContains can be used to\nmatch against component suffix ('foo.') and to exactly match against\ncomponents ('.foo.'). Suffix- and exact-matching for the last components need\nto be done separately using hostSuffix, because no implicit dot is added at\nthe end of the host name.\n\n  * hostEquals\n\nstring optional\n\nMatches if the host name of the URL is equal to a specified string.\n\n  * hostPrefix\n\nstring optional\n\nMatches if the host name of the URL starts with a specified string.\n\n  * hostSuffix\n\nstring optional\n\nMatches if the host name of the URL ends with a specified string.\n\n  * originAndPathMatches\n\nstring optional\n\nMatches if the URL without query segment and fragment identifier matches a\nspecified regular expression. Port numbers are stripped from the URL if they\nmatch the default port number. The regular expressions use the RE2 syntax.\n\n  * pathContains\n\nstring optional\n\nMatches if the path segment of the URL contains a specified string.\n\n  * pathEquals\n\nstring optional\n\nMatches if the path segment of the URL is equal to a specified string.\n\n  * pathPrefix\n\nstring optional\n\nMatches if the path segment of the URL starts with a specified string.\n\n  * pathSuffix\n\nstring optional\n\nMatches if the path segment of the URL ends with a specified string.\n\n  * ports\n\n(number | number[])[] optional\n\nMatches if the port of the URL is contained in any of the specified port\nlists. For example `[80, 443, [1000, 1200]]` matches all requests on port 80,\n443 and in the range 1000-1200.\n\n  * queryContains\n\nstring optional\n\nMatches if the query segment of the URL contains a specified string.\n\n  * queryEquals\n\nstring optional\n\nMatches if the query segment of the URL is equal to a specified string.\n\n  * queryPrefix\n\nstring optional\n\nMatches if the query segment of the URL starts with a specified string.\n\n  * querySuffix\n\nstring optional\n\nMatches if the query segment of the URL ends with a specified string.\n\n  * schemes\n\nstring[] optional\n\nMatches if the scheme of the URL is equal to any of the schemes specified in\nthe array.\n\n  * urlContains\n\nstring optional\n\nMatches if the URL (without fragment identifier) contains a specified string.\nPort numbers are stripped from the URL if they match the default port number.\n\n  * urlEquals\n\nstring optional\n\nMatches if the URL (without fragment identifier) is equal to a specified\nstring. Port numbers are stripped from the URL if they match the default port\nnumber.\n\n  * urlMatches\n\nstring optional\n\nMatches if the URL (without fragment identifier) matches a specified regular\nexpression. Port numbers are stripped from the URL if they match the default\nport number. The regular expressions use the RE2 syntax.\n\n  * urlPrefix\n\nstring optional\n\nMatches if the URL (without fragment identifier) starts with a specified\nstring. Port numbers are stripped from the URL if they match the default port\nnumber.\n\n  * urlSuffix\n\nstring optional\n\nMatches if the URL (without fragment identifier) ends with a specified string.\nPort numbers are stripped from the URL if they match the default port number.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/extension": "#  chrome.extension\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.extension` API has utilities that can be used by any extension\npage. It includes support for exchanging messages between an extension and its\ncontent scripts or between extensions, as described in detail in Message\nPassing.\n\n## Types\n\n### ViewType\n\nChrome 44+\n\nThe type of extension view.\n\n#### Enum\n\n\"tab\"  \n\n\"popup\"  \n\n## Properties\n\n### inIncognitoContext\n\nTrue for content scripts running inside incognito tabs, and for extension\npages running inside an incognito process. The latter only applies to\nextensions with 'split' incognito_behavior.\n\n#### Type\n\nboolean\n\n## Methods\n\n### getBackgroundPage()\n\nForeground only\n\n    \n    \n    chrome.extension.getBackgroundPage()\n\nReturns the JavaScript 'window' object for the background page running inside\nthe current extension. Returns null if the extension has no background page.\n\n#### Returns\n\n  * Window | undefined\n\n### getViews()\n\nForeground only\n\n    \n    \n    chrome.extension.getViews(  \n      fetchProperties?: object,  \n    )\n\nReturns an array of the JavaScript 'window' objects for each of the pages\nrunning inside the current extension.\n\n#### Parameters\n\n  * fetchProperties\n\nobject optional\n\n    * tabId\n\nnumber optional\n\nChrome 54+\n\nFind a view according to a tab id. If this field is omitted, returns all\nviews.\n\n    * type\n\nViewType optional\n\nThe type of view to get. If omitted, returns all views (including background\npages and tabs).\n\n    * windowId\n\nnumber optional\n\nThe window to restrict the search to. If omitted, returns all views.\n\n#### Returns\n\n  * Window[]\n\nArray of global objects\n\n### isAllowedFileSchemeAccess()\n\nPromise\n\n    \n    \n    chrome.extension.isAllowedFileSchemeAccess(  \n      callback?: function,  \n    )\n\nRetrieves the state of the extension's access to the 'file://' scheme. This\ncorresponds to the user-controlled per-extension 'Allow access to File URLs'\nsetting accessible via the chrome://extensions page.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (isAllowedAccess: boolean) => void\n\n    * isAllowedAccess\n\nboolean\n\nTrue if the extension can access the 'file://' scheme, false otherwise.\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### isAllowedIncognitoAccess()\n\nPromise\n\n    \n    \n    chrome.extension.isAllowedIncognitoAccess(  \n      callback?: function,  \n    )\n\nRetrieves the state of the extension's access to Incognito-mode. This\ncorresponds to the user-controlled per-extension 'Allowed in Incognito'\nsetting accessible via the chrome://extensions page.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (isAllowedAccess: boolean) => void\n\n    * isAllowedAccess\n\nboolean\n\nTrue if the extension has access to Incognito mode, false otherwise.\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setUpdateUrlData()\n\n    \n    \n    chrome.extension.setUpdateUrlData(  \n      data: string,  \n    )\n\nSets the value of the ap CGI parameter used in the extension's update URL.\nThis value is ignored for extensions that are hosted in the Chrome Extension\nGallery.\n\n#### Parameters\n\n  * data\n\nstring\n\n## Events\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/extensionTypes": "#  chrome.extensionTypes\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.extensionTypes` API contains type declarations for Chrome\nextensions.\n\n## Types\n\n### CSSOrigin\n\nChrome 66+\n\nThe origin of injected CSS.\n\n#### Enum\n\n\"author\"  \n\n\"user\"  \n\n### DeleteInjectionDetails\n\nChrome 87+\n\nDetails of the CSS to remove. Either the code or the file property must be\nset, but both may not be set at the same time.\n\n#### Properties\n\n  * allFrames\n\nboolean optional\n\nIf allFrames is `true`, implies that the CSS should be removed from all frames\nof current page. By default, it's `false` and is only removed from the top\nframe. If `true` and `frameId` is set, then the code is removed from the\nselected frame and all of its child frames.\n\n  * code\n\nstring optional\n\nCSS code to remove.\n\n  * cssOrigin\n\nCSSOrigin optional\n\nThe origin of the CSS to remove. Defaults to `\"author\"`.\n\n  * file\n\nstring optional\n\nCSS file to remove.\n\n  * frameId\n\nnumber optional\n\nThe frame from where the CSS should be removed. Defaults to 0 (the top-level\nframe).\n\n  * matchAboutBlank\n\nboolean optional\n\nIf matchAboutBlank is true, then the code is also removed from about:blank and\nabout:srcdoc frames if your extension has access to its parent document. By\ndefault it is `false`.\n\n### DocumentLifecycle\n\nChrome 106+\n\nThe document lifecycle of the frame.\n\n#### Enum\n\n\"prerender\"  \n\n\"active\"  \n\n\"cached\"  \n\n\"pending_deletion\"  \n\n### ExecutionWorld\n\nChrome 111+\n\nThe JavaScript world for a script to execute within. Can either be an isolated\nworld unique to this extension, the main world of the DOM which is shared with\nthe page's JavaScript, or a user scripts world that is only available for\nscripts registered with the User Scripts API.\n\n#### Enum\n\n\"ISOLATED\"  \n\n\"MAIN\"  \n\n\"USER_SCRIPT\"  \n\n### FrameType\n\nChrome 106+\n\nThe type of frame.\n\n#### Enum\n\n\"outermost_frame\"  \n\n\"fenced_frame\"  \n\n\"sub_frame\"  \n\n### ImageDetails\n\nDetails about the format and quality of an image.\n\n#### Properties\n\n  * format\n\nImageFormat optional\n\nThe format of the resulting image. Default is `\"jpeg\"`.\n\n  * quality\n\nnumber optional\n\nWhen format is `\"jpeg\"`, controls the quality of the resulting image. This\nvalue is ignored for PNG images. As quality is decreased, the resulting image\nwill have more visual artifacts, and the number of bytes needed to store it\nwill decrease.\n\n### ImageFormat\n\nChrome 44+\n\nThe format of an image.\n\n#### Enum\n\n\"jpeg\"  \n\n\"png\"  \n\n### InjectDetails\n\nDetails of the script or CSS to inject. Either the code or the file property\nmust be set, but both may not be set at the same time.\n\n#### Properties\n\n  * allFrames\n\nboolean optional\n\nIf allFrames is `true`, implies that the JavaScript or CSS should be injected\ninto all frames of current page. By default, it's `false` and is only injected\ninto the top frame. If `true` and `frameId` is set, then the code is inserted\nin the selected frame and all of its child frames.\n\n  * code\n\nstring optional\n\nJavaScript or CSS code to inject.\n\n**Warning:** Be careful using the `code` parameter. Incorrect use of it may\nopen your extension to cross site scripting attacks\n\n  * cssOrigin\n\nCSSOrigin optional\n\nChrome 66+\n\nThe origin of the CSS to inject. This may only be specified for CSS, not\nJavaScript. Defaults to `\"author\"`.\n\n  * file\n\nstring optional\n\nJavaScript or CSS file to inject.\n\n  * frameId\n\nnumber optional\n\nChrome 50+\n\nThe frame where the script or CSS should be injected. Defaults to 0 (the top-\nlevel frame).\n\n  * matchAboutBlank\n\nboolean optional\n\nIf matchAboutBlank is true, then the code is also injected in about:blank and\nabout:srcdoc frames if your extension has access to its parent document. Code\ncannot be inserted in top-level about:-frames. By default it is `false`.\n\n  * runAt\n\nRunAt optional\n\nThe soonest that the JavaScript or CSS will be injected into the tab. Defaults\nto \"document_idle\".\n\n### RunAt\n\nChrome 44+\n\nThe soonest that the JavaScript or CSS will be injected into the tab.\n\n#### Enum\n\n\"document_start\"  \nScript is injected after any files from css, but before any other DOM is\nconstructed or any other script is run.\n\n\"document_end\"  \nScript is injected immediately after the DOM is complete, but before\nsubresources like images and frames have loaded.\n\n\"document_idle\"  \nThe browser chooses a time to inject the script between \"document_end\" and\nimmediately after the `window.onload` event fires. The exact moment of\ninjection depends on how complex the document is and how long it is taking to\nload, and is optimized for page load speed. Content scripts running at\n\"document_idle\" don't need to listen for the `window.onload` event; they are\nguaranteed to run after the DOM completes. If a script definitely needs to run\nafter `window.onload`, the extension can check if `onload` has already fired\nby using the `document.readyState` property.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/fileBrowserHandler": "#  chrome.fileBrowserHandler\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.fileBrowserHandler` API to extend the Chrome OS file browser.\nFor example, you can use this API to enable users to upload files to your\nwebsite.\n\n## Concepts and usage\n\nThe ChromeOS file browser comes up when the user either presses Alt+Shift+M or\nconnects an external storage device, such as an SD card, USB key, external\ndrive, or digital camera. Besides showing the files on external devices, the\nfile browser can also display files that the user has previously saved to the\nsystem.\n\nWhen the user selects one or more files, the file browser adds buttons\nrepresenting the valid handlers for those files. For example, in the following\nscreenshot, selecting a file with a \".png\" suffix results in an \"Save to\nGallery\" button that the user can click.\n\n![A ChromeOS file\nbrowser.](/static/docs/extensions/reference/api/fileBrowserHandler/images/filebrowserhandler.png)\nA ChromeOS file browser.\n\n## Permissions\n\n`fileBrowserHandler`  \n\nYou must declare the `\"fileBrowserHandler\"` permission in the extension\nmanifest.\n\n## Availability\n\nChromeOS only  Foreground only\n\nYou must use the `\"file_browser_handlers\"` field to register the extension as\na handler of at least one file type. You should also provide a 16 by 16 icon\nto be displayed on the button. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"file_browser_handlers\": [\n        {\n          \"id\": \"upload\",\n          \"default_title\": \"Save to Gallery\", // What the button will display\n          \"file_filters\": [\n            \"filesystem:*.jpg\",  // To match all files, use \"filesystem:*.*\"\n            \"filesystem:*.jpeg\",\n            \"filesystem:*.png\"\n          ]\n        }\n      ],\n      \"permissions\" : [\n        \"fileBrowserHandler\"\n      ],\n      \"icons\": {\n        \"16\": \"icon16.png\",\n        \"48\": \"icon48.png\",\n        \"128\": \"icon128.png\"\n      },\n      ...\n    }\n    \n\n**Note:** You can specify locale-specific strings for the value of\n\"default_title\". See Internationalization (i18n) for details.\n\n### Implement a file browser handler\n\nTo use this API, you must implement a function that handles the `onExecute`\nevent of `chrome.fileBrowserHandler`. Your function will be called whenever\nthe user clicks the button that represents your file browser handler. In your\nfunction, use the File System API to get access to the file contents. Here is\nan example:\n\n    \n    \n    chrome.fileBrowserHandler.onExecute.addListener(async (id, details) => {\n      if (id !== 'upload') {\n        return;  // check if you have multiple file_browser_handlers\n      }\n    \n      for (const entry of detail.entries) {\n        // the FileSystemFileEntry doesn't have a Promise API, wrap in one\n        const file = await new Promise((resolve, reject) => {\n          entry.file(resolve, reject);\n        });\n        const buffer = await file.arrayBuffer();\n        // do something with buffer\n      }\n    });\n    \n\nYour event handler is passed two arguments:\n\n`id`\n\n    The `id` value from the manifest file. If your extension implements multiple handlers, you can check the ID value to see which handler has been triggered.\n`details`\n\n    An object describing the event. You can get the file or files that the user has selected from the `entries` field of this object, which is an array of `FileSystemFileEntry` objects.\n\n## Types\n\n### FileHandlerExecuteEventDetails\n\nEvent details payload for fileBrowserHandler.onExecute event.\n\n#### Properties\n\n  * entries\n\nany[]\n\nArray of Entry instances representing files that are targets of this action\n(selected in ChromeOS file browser).\n\n  * tab_id\n\nnumber optional\n\nThe ID of the tab that raised this event. Tab IDs are unique within a browser\nsession.\n\n## Events\n\n### onExecute\n\n    \n    \n    chrome.fileBrowserHandler.onExecute.addListener(  \n      callback: function,  \n    )\n\nFired when file system action is executed from ChromeOS file browser.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, details: FileHandlerExecuteEventDetails) => void\n\n    * id\n\nstring\n\n    * details\n\nFileHandlerExecuteEventDetails\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/fileSystemProvider": "#  chrome.fileSystemProvider\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.fileSystemProvider` API to create file systems, that can be\naccessible from the file manager on Chrome OS.\n\n## Permissions\n\n`fileSystemProvider`  \n\n## Availability\n\nChromeOS only\n\nYou must declare the \"fileSystemProvider\" permission and section in the\nextension manifest to use the File System Provider API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"fileSystemProvider\"\n      ],\n      ...\n      \"file_system_provider_capabilities\": {\n        \"configurable\": true,\n        \"watchable\": false,\n        \"multiple_mounts\": true,\n        \"source\": \"network\"\n      },\n      ...\n    }\n    \n\nThe file_system_provider section must be declared as follows:\n\n**`configurable` (boolean)** \\- optional\n\n    Whether configuring via onConfigureRequested is supported. By default: false.\n**`multiple_mounts` (boolean)** \\- optional\n\n    Whether multiple (more than one) mounted file systems are supported. By default: false.\n**`watchable` (boolean)** \\- optional\n\n    Whether setting watchers and notifying about changes is supported. By default: false.\n**`source` (enum of \"file\", \"device\", or \"network\")** \\- required\n\n    Source of data for mounted file systems.\n\nFiles app uses above information in order to render related UI elements\nappropriately. For example, if `configurable` is set to true, then a menu item\nfor configuring volumes will be rendered. Similarly, if `multiple_mounts` is\nset to `true`, then Files app will allow to add more than one mount points\nfrom the UI. If `watchable` is `false`, then a refresh button will be\nrendered. Note, that if possible you should add support for watchers, so\nchanges on the file system can be reflected immediately and automatically.\n\n## Overview\n\nFile System Provider API allows extensions to support virtual file systems,\nwhich are available in the file manager on ChromeOS. Use cases include\ndecompressing archives and accessing files in a cloud service other than\nDrive.\n\n## Mounting file systems\n\nProviding extensions can either provide file system contents from an external\nsource (such as a remote server or a USB device), or using a local file (such\nas an archive) as its input.\n\nIn order to write file systems which are file handlers (source is `\"file\"`)\nthe provider must be a packaged app, as the `onLaunched` event is not\navailable to extensions.\n\nIf the source is network or a device, then the file system should be mounted\nwhen onMountRequested event is called.\n\nSource of the file system data | Entry point  \n---|---  \n`\"file\"` | Available to packaged apps only.  \n`\"device\"` or `\"network\"` | onMountRequested  \n  \n## Configuring file systems\n\nProvided file systems once mounted can be configured via the\nonConfigureRequested event. It's especially useful for file systems which\nprovide contents via network in order to set proper credentials. Handling this\nevent is optional.\n\n## Life cycle\n\nProvided file systems once mounted are remembered by Chrome and remounted\nautomatically after reboot or restart. Hence, once a file system is mounted by\na providing extension, it will stay until either the extension is unloaded, or\nthe extension calls the unmount method.\n\n## Types\n\n### AbortRequestedOptions\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * operationRequestId\n\nnumber\n\nAn ID of the request to be aborted.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### Action\n\nChrome 45+\n\n#### Properties\n\n  * id\n\nstring\n\nThe identifier of the action. Any string or `CommonActionId` for common\nactions.\n\n  * title\n\nstring optional\n\nThe title of the action. It may be ignored for common actions.\n\n### AddWatcherRequestedOptions\n\n#### Properties\n\n  * entryPath\n\nstring\n\nThe path of the entry to be observed.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * recursive\n\nboolean\n\nWhether observing should include all child entries recursively. It can be true\nfor directories only.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### Change\n\n#### Properties\n\n  * changeType\n\nChangeType\n\nThe type of the change which happened to the entry.\n\n  * cloudFileInfo\n\nCloudFileInfo optional\n\nChrome 125+\n\nInformation relating to the file if backed by a cloud file system.\n\n  * entryPath\n\nstring\n\nThe path of the changed entry.\n\n### ChangeType\n\nType of a change detected on the observed directory.\n\n#### Enum\n\n\"CHANGED\"  \n\n\"DELETED\"  \n\n### CloseFileRequestedOptions\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * openRequestId\n\nnumber\n\nA request ID used to open the file.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### CloudFileInfo\n\nChrome 125+\n\n#### Properties\n\n  * versionTag\n\nstring optional\n\nA tag that represents the version of the file.\n\n### CloudIdentifier\n\nChrome 117+\n\n#### Properties\n\n  * id\n\nstring\n\nThe provider's identifier for the given file/directory.\n\n  * providerName\n\nstring\n\nIdentifier for the cloud storage provider (e.g. 'drive.google.com').\n\n### CommonActionId\n\nChrome 45+\n\nList of common actions. `\"SHARE\"` is for sharing files with others.\n`\"SAVE_FOR_OFFLINE\"` for pinning (saving for offline access).\n`\"OFFLINE_NOT_NECESSARY\"` for notifying that the file doesn't need to be\nstored for offline access anymore. Used by `onGetActionsRequested` and\n`onExecuteActionRequested`.\n\n#### Enum\n\n\"SAVE_FOR_OFFLINE\"  \n\n\"OFFLINE_NOT_NECESSARY\"  \n\n\"SHARE\"  \n\n### ConfigureRequestedOptions\n\nChrome 44+\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system to be configured.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### CopyEntryRequestedOptions\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n  * sourcePath\n\nstring\n\nThe source path of the entry to be copied.\n\n  * targetPath\n\nstring\n\nThe destination path for the copy operation.\n\n### CreateDirectoryRequestedOptions\n\n#### Properties\n\n  * directoryPath\n\nstring\n\nThe path of the directory to be created.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * recursive\n\nboolean\n\nWhether the operation is recursive (for directories only).\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### CreateFileRequestedOptions\n\n#### Properties\n\n  * filePath\n\nstring\n\nThe path of the file to be created.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### DeleteEntryRequestedOptions\n\n#### Properties\n\n  * entryPath\n\nstring\n\nThe path of the entry to be deleted.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * recursive\n\nboolean\n\nWhether the operation is recursive (for directories only).\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### EntryMetadata\n\n#### Properties\n\n  * cloudFileInfo\n\nCloudFileInfo optional\n\nChrome 125+\n\nInformation that identifies a specific file in the underlying cloud file\nsystem. Must be provided if requested in `options` and the file is backed by\ncloud storage.\n\n  * cloudIdentifier\n\nCloudIdentifier optional\n\nChrome 117+\n\nCloud storage representation of this entry. Must be provided if requested in\n`options` and the file is backed by cloud storage. For local files not backed\nby cloud storage, it should be undefined when requested.\n\n  * isDirectory\n\nboolean optional\n\nTrue if it is a directory. Must be provided if requested in `options`.\n\n  * mimeType\n\nstring optional\n\nMime type for the entry. Always optional, but should be provided if requested\nin `options`.\n\n  * modificationTime\n\nDate optional\n\nThe last modified time of this entry. Must be provided if requested in\n`options`.\n\n  * name\n\nstring optional\n\nName of this entry (not full path name). Must not contain '/'. For root it\nmust be empty. Must be provided if requested in `options`.\n\n  * size\n\nnumber optional\n\nFile size in bytes. Must be provided if requested in `options`.\n\n  * thumbnail\n\nstring optional\n\nThumbnail image as a data URI in either PNG, JPEG or WEBP format, at most 32\nKB in size. Optional, but can be provided only when explicitly requested by\nthe `onGetMetadataRequested` event.\n\n### ExecuteActionRequestedOptions\n\nChrome 45+\n\n#### Properties\n\n  * actionId\n\nstring\n\nThe identifier of the action to be executed.\n\n  * entryPaths\n\nstring[]\n\nChrome 47+\n\nThe set of paths of the entries to be used for the action.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### FileSystemInfo\n\n#### Properties\n\n  * displayName\n\nstring\n\nA human-readable name for the file system.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system.\n\n  * openedFiles\n\nOpenedFile[]\n\nList of currently opened files.\n\n  * openedFilesLimit\n\nnumber\n\nThe maximum number of files that can be opened at once. If 0, then not\nlimited.\n\n  * supportsNotifyTag\n\nboolean optional\n\nChrome 45+\n\nWhether the file system supports the `tag` field for observing directories.\n\n  * watchers\n\nWatcher[]\n\nChrome 45+\n\nList of watchers.\n\n  * writable\n\nboolean\n\nWhether the file system supports operations which may change contents of the\nfile system (such as creating, deleting or writing to files).\n\n### GetActionsRequestedOptions\n\nChrome 45+\n\n#### Properties\n\n  * entryPaths\n\nstring[]\n\nChrome 47+\n\nList of paths of entries for the list of actions.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### GetMetadataRequestedOptions\n\n#### Properties\n\n  * cloudFileInfo\n\nboolean\n\nChrome 125+\n\nSet to `true` if `cloudFileInfo` value is requested.\n\n  * cloudIdentifier\n\nboolean\n\nChrome 117+\n\nSet to `true` if `cloudIdentifier` value is requested.\n\n  * entryPath\n\nstring\n\nThe path of the entry to fetch metadata about.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * isDirectory\n\nboolean\n\nChrome 49+\n\nSet to `true` if `is_directory` value is requested.\n\n  * mimeType\n\nboolean\n\nChrome 49+\n\nSet to `true` if `mimeType` value is requested.\n\n  * modificationTime\n\nboolean\n\nChrome 49+\n\nSet to `true` if `modificationTime` value is requested.\n\n  * name\n\nboolean\n\nChrome 49+\n\nSet to `true` if `name` value is requested.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n  * size\n\nboolean\n\nChrome 49+\n\nSet to `true` if `size` value is requested.\n\n  * thumbnail\n\nboolean\n\nSet to `true` if `thumbnail` value is requested.\n\n### MountOptions\n\n#### Properties\n\n  * displayName\n\nstring\n\nA human-readable name for the file system.\n\n  * fileSystemId\n\nstring\n\nThe string indentifier of the file system. Must be unique per each extension.\n\n  * openedFilesLimit\n\nnumber optional\n\nThe maximum number of files that can be opened at once. If not specified, or\n0, then not limited.\n\n  * persistent\n\nboolean optional\n\nChrome 64+\n\nWhether the framework should resume the file system at the next sign-in\nsession. True by default.\n\n  * supportsNotifyTag\n\nboolean optional\n\nChrome 45+\n\nWhether the file system supports the `tag` field for observed directories.\n\n  * writable\n\nboolean optional\n\nWhether the file system supports operations which may change contents of the\nfile system (such as creating, deleting or writing to files).\n\n### MoveEntryRequestedOptions\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n  * sourcePath\n\nstring\n\nThe source path of the entry to be moved into a new place.\n\n  * targetPath\n\nstring\n\nThe destination path for the copy operation.\n\n### NotifyOptions\n\n#### Properties\n\n  * changeType\n\nChangeType\n\nThe type of the change which happened to the observed entry. If it is DELETED,\nthen the observed entry will be automatically removed from the list of\nobserved entries.\n\n  * changes\n\nChange[] optional\n\nList of changes to entries within the observed directory (including the entry\nitself)\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this change.\n\n  * observedPath\n\nstring\n\nThe path of the observed entry.\n\n  * recursive\n\nboolean\n\nMode of the observed entry.\n\n  * tag\n\nstring optional\n\nTag for the notification. Required if the file system was mounted with the\n`supportsNotifyTag` option. Note, that this flag is necessary to provide\nnotifications about changes which changed even when the system was shutdown.\n\n### OpenedFile\n\n#### Properties\n\n  * filePath\n\nstring\n\nThe path of the opened file.\n\n  * mode\n\nOpenFileMode\n\nWhether the file was opened for reading or writing.\n\n  * openRequestId\n\nnumber\n\nA request ID to be be used by consecutive read/write and close requests.\n\n### OpenFileMode\n\nMode of opening a file. Used by `onOpenFileRequested`.\n\n#### Enum\n\n\"READ\"  \n\n\"WRITE\"  \n\n### OpenFileRequestedOptions\n\n#### Properties\n\n  * filePath\n\nstring\n\nThe path of the file to be opened.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * mode\n\nOpenFileMode\n\nWhether the file will be used for reading or writing.\n\n  * requestId\n\nnumber\n\nA request ID which will be used by consecutive read/write and close requests.\n\n### ProviderError\n\nError codes used by providing extensions in response to requests as well as in\ncase of errors when calling methods of the API. For success, `\"OK\"` must be\nused.\n\n#### Enum\n\n\"OK\"  \n\n\"FAILED\"  \n\n\"IN_USE\"  \n\n\"EXISTS\"  \n\n\"NOT_FOUND\"  \n\n\"ACCESS_DENIED\"  \n\n\"TOO_MANY_OPENED\"  \n\n\"NO_MEMORY\"  \n\n\"NO_SPACE\"  \n\n\"NOT_A_DIRECTORY\"  \n\n\"INVALID_OPERATION\"  \n\n\"SECURITY\"  \n\n\"ABORT\"  \n\n\"NOT_A_FILE\"  \n\n\"NOT_EMPTY\"  \n\n\"INVALID_URL\"  \n\n\"IO\"  \n\n### ReadDirectoryRequestedOptions\n\n#### Properties\n\n  * directoryPath\n\nstring\n\nThe path of the directory which contents are requested.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * isDirectory\n\nboolean\n\nChrome 49+\n\nSet to `true` if `is_directory` value is requested.\n\n  * mimeType\n\nboolean\n\nChrome 49+\n\nSet to `true` if `mimeType` value is requested.\n\n  * modificationTime\n\nboolean\n\nChrome 49+\n\nSet to `true` if `modificationTime` value is requested.\n\n  * name\n\nboolean\n\nChrome 49+\n\nSet to `true` if `name` value is requested.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n  * size\n\nboolean\n\nChrome 49+\n\nSet to `true` if `size` value is requested.\n\n  * thumbnail\n\nboolean\n\nChrome 49+\n\nSet to `true` if `thumbnail` value is requested.\n\n### ReadFileRequestedOptions\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * length\n\nnumber\n\nNumber of bytes to be returned.\n\n  * offset\n\nnumber\n\nPosition in the file (in bytes) to start reading from.\n\n  * openRequestId\n\nnumber\n\nA request ID used to open the file.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### RemoveWatcherRequestedOptions\n\n#### Properties\n\n  * entryPath\n\nstring\n\nThe path of the watched entry.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * recursive\n\nboolean\n\nMode of the watcher.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### TruncateRequestedOptions\n\n#### Properties\n\n  * filePath\n\nstring\n\nThe path of the file to be truncated.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * length\n\nnumber\n\nNumber of bytes to be retained after the operation completes.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### UnmountOptions\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system to be unmounted.\n\n### UnmountRequestedOptions\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system to be unmounted.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### Watcher\n\n#### Properties\n\n  * entryPath\n\nstring\n\nThe path of the entry being observed.\n\n  * lastTag\n\nstring optional\n\nTag used by the last notification for the watcher.\n\n  * recursive\n\nboolean\n\nWhether watching should include all child entries recursively. It can be true\nfor directories only.\n\n### WriteFileRequestedOptions\n\n#### Properties\n\n  * data\n\nArrayBuffer\n\nBuffer of bytes to be written to the file.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * offset\n\nnumber\n\nPosition in the file (in bytes) to start writing the bytes from.\n\n  * openRequestId\n\nnumber\n\nA request ID used to open the file.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n## Methods\n\n### get()\n\nPromise\n\n    \n    \n    chrome.fileSystemProvider.get(  \n      fileSystemId: string,  \n      callback?: function,  \n    )\n\nReturns information about a file system with the passed `fileSystemId`.\n\n#### Parameters\n\n  * fileSystemId\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (fileSystem: FileSystemInfo) => void\n\n    * fileSystem\n\nFileSystemInfo\n\n#### Returns\n\n  * Promise<FileSystemInfo>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.fileSystemProvider.getAll(  \n      callback?: function,  \n    )\n\nReturns all file systems mounted by the extension.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (fileSystems: FileSystemInfo[]) => void\n\n    * fileSystems\n\nFileSystemInfo[]\n\n#### Returns\n\n  * Promise<FileSystemInfo[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### mount()\n\nPromise\n\n    \n    \n    chrome.fileSystemProvider.mount(  \n      options: MountOptions,  \n      callback?: function,  \n    )\n\nMounts a file system with the given `fileSystemId` and `displayName`.\n`displayName` will be shown in the left panel of the Files app. `displayName`\ncan contain any characters including '/', but cannot be an empty string.\n`displayName` must be descriptive but doesn't have to be unique. The\n`fileSystemId` must not be an empty string.\n\nDepending on the type of the file system being mounted, the `source` option\nmust be set appropriately.\n\nIn case of an error, `runtime.lastError` will be set with a corresponding\nerror code.\n\n#### Parameters\n\n  * options\n\nMountOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### notify()\n\nPromise Chrome 45+\n\n    \n    \n    chrome.fileSystemProvider.notify(  \n      options: NotifyOptions,  \n      callback?: function,  \n    )\n\nNotifies about changes in the watched directory at `observedPath` in\n`recursive` mode. If the file system is mounted with `supportsNotifyTag`, then\n`tag` must be provided, and all changes since the last notification always\nreported, even if the system was shutdown. The last tag can be obtained with\n`getAll`.\n\nTo use, the `file_system_provider.notify` manifest option must be set to true.\n\nValue of `tag` can be any string which is unique per call, so it's possible to\nidentify the last registered notification. Eg. if the providing extension\nstarts after a reboot, and the last registered notification's tag is equal to\n\"123\", then it should call `notify` for all changes which happened since the\nchange tagged as \"123\". It cannot be an empty string.\n\nNot all providers are able to provide a tag, but if the file system has a\nchangelog, then the tag can be eg. a change number, or a revision number.\n\nNote that if a parent directory is removed, then all descendant entries are\nalso removed, and if they are watched, then the API must be notified about the\nfact. Also, if a directory is renamed, then all descendant entries are in fact\nremoved, as there is no entry under their original paths anymore.\n\nIn case of an error, `runtime.lastError` will be set will a corresponding\nerror code.\n\n#### Parameters\n\n  * options\n\nNotifyOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### unmount()\n\nPromise\n\n    \n    \n    chrome.fileSystemProvider.unmount(  \n      options: UnmountOptions,  \n      callback?: function,  \n    )\n\nUnmounts a file system with the given `fileSystemId`. It must be called after\n`onUnmountRequested` is invoked. Also, the providing extension can decide to\nperform unmounting if not requested (eg. in case of lost connection, or a file\nerror).\n\nIn case of an error, `runtime.lastError` will be set with a corresponding\nerror code.\n\n#### Parameters\n\n  * options\n\nUnmountOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onAbortRequested\n\n    \n    \n    chrome.fileSystemProvider.onAbortRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when aborting an operation with `operationRequestId` is requested. The\noperation executed with `operationRequestId` must be immediately stopped and\n`successCallback` of this abort request executed. If aborting fails, then\n`errorCallback` must be called. Note, that callbacks of the aborted operation\nmust not be called, as they will be ignored. Despite calling `errorCallback`,\nthe request may be forcibly aborted.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: AbortRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nAbortRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onAddWatcherRequested\n\nChrome 45+\n\n    \n    \n    chrome.fileSystemProvider.onAddWatcherRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when setting a new directory watcher is requested. If an error occurs,\nthen `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: AddWatcherRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nAddWatcherRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onCloseFileRequested\n\n    \n    \n    chrome.fileSystemProvider.onCloseFileRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when opening a file previously opened with `openRequestId` is requested\nto be closed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: CloseFileRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nCloseFileRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onConfigureRequested\n\nChrome 44+\n\n    \n    \n    chrome.fileSystemProvider.onConfigureRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when showing a configuration dialog for `fileSystemId` is requested. If\nit's handled, the `file_system_provider.configurable` manfiest option must be\nset to true.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: ConfigureRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nConfigureRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onCopyEntryRequested\n\n    \n    \n    chrome.fileSystemProvider.onCopyEntryRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when copying an entry (recursively if a directory) is requested. If an\nerror occurs, then `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: CopyEntryRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nCopyEntryRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onCreateDirectoryRequested\n\n    \n    \n    chrome.fileSystemProvider.onCreateDirectoryRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when creating a directory is requested. The operation must fail with\nthe EXISTS error if the target directory already exists. If `recursive` is\ntrue, then all of the missing directories on the directory path must be\ncreated.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: CreateDirectoryRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nCreateDirectoryRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onCreateFileRequested\n\n    \n    \n    chrome.fileSystemProvider.onCreateFileRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when creating a file is requested. If the file already exists, then\n`errorCallback` must be called with the `\"EXISTS\"` error code.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: CreateFileRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nCreateFileRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onDeleteEntryRequested\n\n    \n    \n    chrome.fileSystemProvider.onDeleteEntryRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when deleting an entry is requested. If `recursive` is true, and the\nentry is a directory, then all of the entries inside must be recursively\ndeleted as well.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: DeleteEntryRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nDeleteEntryRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onExecuteActionRequested\n\nChrome 48+\n\n    \n    \n    chrome.fileSystemProvider.onExecuteActionRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when executing an action for a set of files or directories is\\\nrequested. After the action is completed, `successCallback` must be called. On\nerror, `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: ExecuteActionRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nExecuteActionRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onGetActionsRequested\n\nChrome 48+\n\n    \n    \n    chrome.fileSystemProvider.onGetActionsRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when a list of actions for a set of files or directories at\n`entryPaths` is requested. All of the returned actions must be applicable to\neach entry. If there are no such actions, an empty array should be returned.\nThe actions must be returned with the `successCallback` call. In case of an\nerror, `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: GetActionsRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nGetActionsRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          (actions: Action[]) => void\n\n      * actions\n\nAction[]\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onGetMetadataRequested\n\n    \n    \n    chrome.fileSystemProvider.onGetMetadataRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when metadata of a file or a directory at `entryPath` is requested. The\nmetadata must be returned with the `successCallback` call. In case of an\nerror, `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: GetMetadataRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nGetMetadataRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          (metadata: EntryMetadata) => void\n\n      * metadata\n\nEntryMetadata\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onMountRequested\n\nChrome 44+\n\n    \n    \n    chrome.fileSystemProvider.onMountRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when showing a dialog for mounting a new file system is requested. If\nthe extension/app is a file handler, then this event shouldn't be handled.\nInstead `app.runtime.onLaunched` should be handled in order to mount new file\nsystems when a file is opened. For multiple mounts, the\n`file_system_provider.multiple_mounts` manifest option must be set to true.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (successCallback: function, errorCallback: function) => void\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onMoveEntryRequested\n\n    \n    \n    chrome.fileSystemProvider.onMoveEntryRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when moving an entry (recursively if a directory) is requested. If an\nerror occurs, then `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: MoveEntryRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nMoveEntryRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onOpenFileRequested\n\n    \n    \n    chrome.fileSystemProvider.onOpenFileRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when opening a file at `filePath` is requested. If the file does not\nexist, then the operation must fail. Maximum number of files opened at once\ncan be specified with `MountOptions`.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: OpenFileRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nOpenFileRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          (metadata?: EntryMetadata) => void\n\n      * metadata\n\nEntryMetadata optional\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onReadDirectoryRequested\n\n    \n    \n    chrome.fileSystemProvider.onReadDirectoryRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when contents of a directory at `directoryPath` are requested. The\nresults must be returned in chunks by calling the `successCallback` several\ntimes. In case of an error, `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: ReadDirectoryRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nReadDirectoryRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          (entries: EntryMetadata[], hasMore: boolean) => void\n\n      * entries\n\nEntryMetadata[]\n\n      * hasMore\n\nboolean\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onReadFileRequested\n\n    \n    \n    chrome.fileSystemProvider.onReadFileRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when reading contents of a file opened previously with `openRequestId`\nis requested. The results must be returned in chunks by calling\n`successCallback` several times. In case of an error, `errorCallback` must be\ncalled.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: ReadFileRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nReadFileRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          (data: ArrayBuffer, hasMore: boolean) => void\n\n      * data\n\nArrayBuffer\n\n      * hasMore\n\nboolean\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onRemoveWatcherRequested\n\nChrome 45+\n\n    \n    \n    chrome.fileSystemProvider.onRemoveWatcherRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when the watcher should be removed. If an error occurs, then\n`errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: RemoveWatcherRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nRemoveWatcherRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onTruncateRequested\n\n    \n    \n    chrome.fileSystemProvider.onTruncateRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when truncating a file to a desired length is requested. If an error\noccurs, then `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: TruncateRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nTruncateRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onUnmountRequested\n\n    \n    \n    chrome.fileSystemProvider.onUnmountRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when unmounting for the file system with the `fileSystemId` identifier\nis requested. In the response, the `unmount` API method must be called\ntogether with `successCallback`. If unmounting is not possible (eg. due to a\npending operation), then `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: UnmountRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nUnmountRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onWriteFileRequested\n\n    \n    \n    chrome.fileSystemProvider.onWriteFileRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when writing contents to a file opened previously with `openRequestId`\nis requested.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: WriteFileRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nWriteFileRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/fontSettings": "#  chrome.fontSettings\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.fontSettings` API to manage Chrome's font settings.\n\n## Permissions\n\n`fontSettings`  \n\nTo use the Font Settings API, you must declare the `\"fontSettings\"` permission\nin the extension manifest. For example:\n\n    \n    \n    {\n      \"name\": \"My Font Settings Extension\",\n      \"description\": \"Customize your fonts\",\n      \"version\": \"0.2\",\n      \"permissions\": [\n        \"fontSettings\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nChrome allows for some font settings to depend on certain generic font\nfamilies and language scripts. For example, the font used for sans-serif\nSimplified Chinese may be different than the font used for serif Japanese.\n\nThe generic font families supported by Chrome are based on CSS generic font\nfamilies and are listed under `GenericReference`. When a web page specifies a\ngeneric font family, Chrome selects the font based on the corresponding\nsetting. If no generic font family is specified, Chrome uses the setting for\nthe \"standard\" generic font family.\n\nWhen a web page specifies a language, Chrome selects the font based on the\nsetting for the corresponding language script. If no language is specified,\nChrome uses the setting for the default, or global, script.\n\nThe supported language scripts are specified by ISO 15924 script code and\nlisted under `ScriptCode`. Technically, Chrome settings are not strictly per-\nscript but also depend on language. For example, Chrome chooses the font for\nCyrillic (ISO 15924 script code \"Cyrl\") when a web page specifies the Russian\nlanguage, and uses this font not just for Cyrillic script but for everything\nthe font covers, such as Latin.\n\n## Examples\n\nThe following code gets the standard font for Arabic.\n\n    \n    \n    chrome.fontSettings.getFont(\n      { genericFamily: 'standard', script: 'Arab' },\n      function(details) { console.log(details.fontId); }\n    );\n    \n\nThe next snippet sets the sans-serif font for Japanese.\n\n    \n    \n    chrome.fontSettings.setFont(\n      { genericFamily: 'sansserif', script: 'Jpan', fontId: 'MS PGothic' }\n    );\n    \n\nTo try this API, install the fontSettings API example from the chrome-\nextension-samples repository.\n\n## Types\n\n### FontName\n\nRepresents a font name.\n\n#### Properties\n\n  * displayName\n\nstring\n\nThe display name of the font.\n\n  * fontId\n\nstring\n\nThe font ID.\n\n### GenericFamily\n\nA CSS generic font family.\n\n#### Enum\n\n\"standard\"  \n\n\"sansserif\"  \n\n\"serif\"  \n\n\"fixed\"  \n\n\"cursive\"  \n\n\"fantasy\"  \n\n\"math\"  \n\n### LevelOfControl\n\nOne of `not\\_controllable`: cannot be controlled by any extension\n`controlled\\_by\\_other\\_extensions`: controlled by extensions with higher\nprecedence `controllable\\_by\\_this\\_extension`: can be controlled by this\nextension `controlled\\_by\\_this\\_extension`: controlled by this extension\n\n#### Enum\n\n\"not_controllable\"  \n\n\"controlled_by_other_extensions\"  \n\n\"controllable_by_this_extension\"  \n\n\"controlled_by_this_extension\"  \n\n### ScriptCode\n\nAn ISO 15924 script code. The default, or global, script is represented by\nscript code \"Zyyy\".\n\n#### Enum\n\n\"Afak\"  \n\n\"Arab\"  \n\n\"Armi\"  \n\n\"Armn\"  \n\n\"Avst\"  \n\n\"Bali\"  \n\n\"Bamu\"  \n\n\"Bass\"  \n\n\"Batk\"  \n\n\"Beng\"  \n\n\"Blis\"  \n\n\"Bopo\"  \n\n\"Brah\"  \n\n\"Brai\"  \n\n\"Bugi\"  \n\n\"Buhd\"  \n\n\"Cakm\"  \n\n\"Cans\"  \n\n\"Cari\"  \n\n\"Cham\"  \n\n\"Cher\"  \n\n\"Cirt\"  \n\n\"Copt\"  \n\n\"Cprt\"  \n\n\"Cyrl\"  \n\n\"Cyrs\"  \n\n\"Deva\"  \n\n\"Dsrt\"  \n\n\"Dupl\"  \n\n\"Egyd\"  \n\n\"Egyh\"  \n\n\"Egyp\"  \n\n\"Elba\"  \n\n\"Ethi\"  \n\n\"Geor\"  \n\n\"Geok\"  \n\n\"Glag\"  \n\n\"Goth\"  \n\n\"Gran\"  \n\n\"Grek\"  \n\n\"Gujr\"  \n\n\"Guru\"  \n\n\"Hang\"  \n\n\"Hani\"  \n\n\"Hano\"  \n\n\"Hans\"  \n\n\"Hant\"  \n\n\"Hebr\"  \n\n\"Hluw\"  \n\n\"Hmng\"  \n\n\"Hung\"  \n\n\"Inds\"  \n\n\"Ital\"  \n\n\"Java\"  \n\n\"Jpan\"  \n\n\"Jurc\"  \n\n\"Kali\"  \n\n\"Khar\"  \n\n\"Khmr\"  \n\n\"Khoj\"  \n\n\"Knda\"  \n\n\"Kpel\"  \n\n\"Kthi\"  \n\n\"Lana\"  \n\n\"Laoo\"  \n\n\"Latf\"  \n\n\"Latg\"  \n\n\"Latn\"  \n\n\"Lepc\"  \n\n\"Limb\"  \n\n\"Lina\"  \n\n\"Linb\"  \n\n\"Lisu\"  \n\n\"Loma\"  \n\n\"Lyci\"  \n\n\"Lydi\"  \n\n\"Mand\"  \n\n\"Mani\"  \n\n\"Maya\"  \n\n\"Mend\"  \n\n\"Merc\"  \n\n\"Mero\"  \n\n\"Mlym\"  \n\n\"Moon\"  \n\n\"Mong\"  \n\n\"Mroo\"  \n\n\"Mtei\"  \n\n\"Mymr\"  \n\n\"Narb\"  \n\n\"Nbat\"  \n\n\"Nkgb\"  \n\n\"Nkoo\"  \n\n\"Nshu\"  \n\n\"Ogam\"  \n\n\"Olck\"  \n\n\"Orkh\"  \n\n\"Orya\"  \n\n\"Osma\"  \n\n\"Palm\"  \n\n\"Perm\"  \n\n\"Phag\"  \n\n\"Phli\"  \n\n\"Phlp\"  \n\n\"Phlv\"  \n\n\"Phnx\"  \n\n\"Plrd\"  \n\n\"Prti\"  \n\n\"Rjng\"  \n\n\"Roro\"  \n\n\"Runr\"  \n\n\"Samr\"  \n\n\"Sara\"  \n\n\"Sarb\"  \n\n\"Saur\"  \n\n\"Sgnw\"  \n\n\"Shaw\"  \n\n\"Shrd\"  \n\n\"Sind\"  \n\n\"Sinh\"  \n\n\"Sora\"  \n\n\"Sund\"  \n\n\"Sylo\"  \n\n\"Syrc\"  \n\n\"Syre\"  \n\n\"Syrj\"  \n\n\"Syrn\"  \n\n\"Tagb\"  \n\n\"Takr\"  \n\n\"Tale\"  \n\n\"Talu\"  \n\n\"Taml\"  \n\n\"Tang\"  \n\n\"Tavt\"  \n\n\"Telu\"  \n\n\"Teng\"  \n\n\"Tfng\"  \n\n\"Tglg\"  \n\n\"Thaa\"  \n\n\"Thai\"  \n\n\"Tibt\"  \n\n\"Tirh\"  \n\n\"Ugar\"  \n\n\"Vaii\"  \n\n\"Visp\"  \n\n\"Wara\"  \n\n\"Wole\"  \n\n\"Xpeo\"  \n\n\"Xsux\"  \n\n\"Yiii\"  \n\n\"Zmth\"  \n\n\"Zsym\"  \n\n\"Zyyy\"  \n\n## Methods\n\n### clearDefaultFixedFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.clearDefaultFixedFontSize(  \n      details?: object,  \n      callback?: function,  \n    )\n\nClears the default fixed font size set by this extension, if any.\n\n#### Parameters\n\n  * details\n\nobject optional\n\nThis parameter is currently unused.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### clearDefaultFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.clearDefaultFontSize(  \n      details?: object,  \n      callback?: function,  \n    )\n\nClears the default font size set by this extension, if any.\n\n#### Parameters\n\n  * details\n\nobject optional\n\nThis parameter is currently unused.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### clearFont()\n\nPromise\n\n    \n    \n    chrome.fontSettings.clearFont(  \n      details: object,  \n      callback?: function,  \n    )\n\nClears the font set by this extension, if any.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * genericFamily\n\nGenericFamily\n\nThe generic font family for which the font should be cleared.\n\n    * script\n\nScriptCode optional\n\nThe script for which the font should be cleared. If omitted, the global script\nfont setting is cleared.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### clearMinimumFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.clearMinimumFontSize(  \n      details?: object,  \n      callback?: function,  \n    )\n\nClears the minimum font size set by this extension, if any.\n\n#### Parameters\n\n  * details\n\nobject optional\n\nThis parameter is currently unused.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDefaultFixedFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.getDefaultFixedFontSize(  \n      details?: object,  \n      callback?: function,  \n    )\n\nGets the default size for fixed width fonts.\n\n#### Parameters\n\n  * details\n\nobject optional\n\nThis parameter is currently unused.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n      * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n#### Returns\n\n  * Promise<object>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDefaultFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.getDefaultFontSize(  \n      details?: object,  \n      callback?: function,  \n    )\n\nGets the default font size.\n\n#### Parameters\n\n  * details\n\nobject optional\n\nThis parameter is currently unused.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n      * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n#### Returns\n\n  * Promise<object>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getFont()\n\nPromise\n\n    \n    \n    chrome.fontSettings.getFont(  \n      details: object,  \n      callback?: function,  \n    )\n\nGets the font for a given script and generic font family.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * genericFamily\n\nGenericFamily\n\nThe generic font family for which the font should be retrieved.\n\n    * script\n\nScriptCode optional\n\nThe script for which the font should be retrieved. If omitted, the font\nsetting for the global script (script code \"Zyyy\") is retrieved.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * fontId\n\nstring\n\nThe font ID. Rather than the literal font ID preference value, this may be the\nID of the font that the system resolves the preference value to. So, `fontId`\ncan differ from the font passed to `setFont`, if, for example, the font is not\navailable on the system. The empty string signifies fallback to the global\nscript font setting.\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n#### Returns\n\n  * Promise<object>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getFontList()\n\nPromise\n\n    \n    \n    chrome.fontSettings.getFontList(  \n      callback?: function,  \n    )\n\nGets a list of fonts on the system.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: FontName[]) => void\n\n    * results\n\nFontName[]\n\n#### Returns\n\n  * Promise<FontName[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getMinimumFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.getMinimumFontSize(  \n      details?: object,  \n      callback?: function,  \n    )\n\nGets the minimum font size.\n\n#### Parameters\n\n  * details\n\nobject optional\n\nThis parameter is currently unused.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n      * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n#### Returns\n\n  * Promise<object>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setDefaultFixedFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.setDefaultFixedFontSize(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the default size for fixed width fonts.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setDefaultFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.setDefaultFontSize(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the default font size.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setFont()\n\nPromise\n\n    \n    \n    chrome.fontSettings.setFont(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the font for a given script and generic font family.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * fontId\n\nstring\n\nThe font ID. The empty string means to fallback to the global script font\nsetting.\n\n    * genericFamily\n\nGenericFamily\n\nThe generic font family for which the font should be set.\n\n    * script\n\nScriptCode optional\n\nThe script code which the font should be set. If omitted, the font setting for\nthe global script (script code \"Zyyy\") is set.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setMinimumFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.setMinimumFontSize(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the minimum font size.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onDefaultFixedFontSizeChanged\n\n    \n    \n    chrome.fontSettings.onDefaultFixedFontSizeChanged.addListener(  \n      callback: function,  \n    )\n\nFired when the default fixed font size setting changes.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n      * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n### onDefaultFontSizeChanged\n\n    \n    \n    chrome.fontSettings.onDefaultFontSizeChanged.addListener(  \n      callback: function,  \n    )\n\nFired when the default font size setting changes.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n      * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n### onFontChanged\n\n    \n    \n    chrome.fontSettings.onFontChanged.addListener(  \n      callback: function,  \n    )\n\nFired when a font setting changes.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * fontId\n\nstring\n\nThe font ID. See the description in `getFont`.\n\n      * genericFamily\n\nGenericFamily\n\nThe generic font family for which the font setting has changed.\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n      * script\n\nScriptCode optional\n\nThe script code for which the font setting has changed.\n\n### onMinimumFontSizeChanged\n\n    \n    \n    chrome.fontSettings.onMinimumFontSizeChanged.addListener(  \n      callback: function,  \n    )\n\nFired when the minimum font size setting changes.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n      * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/gcm": "#  chrome.gcm\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse `chrome.gcm` to enable apps and extensions to send and receive messages\nthrough Firebase Cloud Messaging (FCM).\n\n## Permissions\n\n`gcm`  \n\n## Properties\n\n### MAX_MESSAGE_SIZE\n\nThe maximum size (in bytes) of all key/value pairs in a message.\n\n#### Value\n\n4096  \n\n## Methods\n\n### register()\n\nPromise\n\n    \n    \n    chrome.gcm.register(  \n      senderIds: string[],  \n      callback?: function,  \n    )\n\nRegisters the application with FCM. The registration ID will be returned by\nthe `callback`. If `register` is called again with the same list of\n`senderIds`, the same registration ID will be returned.\n\n#### Parameters\n\n  * senderIds\n\nstring[]\n\nA list of server IDs that are allowed to send messages to the application. It\nshould contain at least one and no more than 100 sender IDs.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (registrationId: string) => void\n\n    * registrationId\n\nstring\n\nA registration ID assigned to the application by the FCM.\n\n#### Returns\n\n  * Promise<string>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### send()\n\nPromise\n\n    \n    \n    chrome.gcm.send(  \n      message: object,  \n      callback?: function,  \n    )\n\nSends a message according to its contents.\n\n#### Parameters\n\n  * message\n\nobject\n\nA message to send to the other party via FCM.\n\n    * data\n\nobject\n\nMessage data to send to the server. Case-insensitive `goog.` and `google`, as\nwell as case-sensitive `collapse_key` are disallowed as key prefixes. Sum of\nall key/value pairs should not exceed `gcm.MAX_MESSAGE_SIZE`.\n\n    * destinationId\n\nstring\n\nThe ID of the server to send the message to as assigned by Google API Console.\n\n    * messageId\n\nstring\n\nThe ID of the message. It must be unique for each message in scope of the\napplications. See the Cloud Messaging documentation for advice for picking and\nhandling an ID.\n\n    * timeToLive\n\nnumber optional\n\nTime-to-live of the message in seconds. If it is not possible to send the\nmessage within that time, an onSendError event will be raised. A time-to-live\nof 0 indicates that the message should be sent immediately or fail if it's not\npossible. The default value of time-to-live is 86,400 seconds (1 day) and the\nmaximum value is 2,419,200 seconds (28 days).\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (messageId: string) => void\n\n    * messageId\n\nstring\n\nThe ID of the message that the callback was issued for.\n\n#### Returns\n\n  * Promise<string>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### unregister()\n\nPromise\n\n    \n    \n    chrome.gcm.unregister(  \n      callback?: function,  \n    )\n\nUnregisters the application from FCM.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onMessage\n\n    \n    \n    chrome.gcm.onMessage.addListener(  \n      callback: function,  \n    )\n\nFired when a message is received through FCM.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (message: object) => void\n\n    * message\n\nobject\n\n      * collapseKey\n\nstring optional\n\nThe collapse key of a message. See the Non-collapsible and collapsible\nmessages for details.\n\n      * data\n\nobject\n\nThe message data.\n\n      * from\n\nstring optional\n\nThe sender who issued the message.\n\n### onMessagesDeleted\n\n    \n    \n    chrome.gcm.onMessagesDeleted.addListener(  \n      callback: function,  \n    )\n\nFired when a FCM server had to delete messages sent by an app server to the\napplication. See Lifetime of a message for details on handling this event.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onSendError\n\n    \n    \n    chrome.gcm.onSendError.addListener(  \n      callback: function,  \n    )\n\nFired when it was not possible to send a message to the FCM server.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (error: object) => void\n\n    * error\n\nobject\n\n      * details\n\nobject\n\nAdditional details related to the error, when available.\n\n      * errorMessage\n\nstring\n\nThe error message describing the problem.\n\n      * messageId\n\nstring optional\n\nThe ID of the message with this error, if error is related to a specific\nmessage.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/history": "#  chrome.history\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.history` API to interact with the browser's record of visited\npages. You can add, remove, and query for URLs in the browser's history. To\noverride the history page with your own version, see Override Pages.\n\n## Permissions\n\n`history`  \n\nTo interact with the user's browser history, use the history API.\n\nTo use the history API, declare the `\"history\"` permission in the extension\nmanifest. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"history\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\n### Transition types\n\nThe history API uses transition types to describe how the browser navigated to\na particular URL on a particular visit. For example, if a user visits a page\nby clicking a link on another page, the transition type is \"link\". See the\nreference content for a list of transition types.\n\n## Examples\n\nTo try this API, install the history API example from the chrome-extension-\nsamples repository.\n\n## Types\n\n### HistoryItem\n\nAn object encapsulating one result of a history query.\n\n#### Properties\n\n  * id\n\nstring\n\nThe unique identifier for the item.\n\n  * lastVisitTime\n\nnumber optional\n\nWhen this page was last loaded, represented in milliseconds since the epoch.\n\n  * title\n\nstring optional\n\nThe title of the page when it was last loaded.\n\n  * typedCount\n\nnumber optional\n\nThe number of times the user has navigated to this page by typing in the\naddress.\n\n  * url\n\nstring optional\n\nThe URL navigated to by a user.\n\n  * visitCount\n\nnumber optional\n\nThe number of times the user has navigated to this page.\n\n### TransitionType\n\nChrome 44+\n\nThe transition type for this visit from its referrer.\n\n#### Enum\n\n\"link\"  \nThe user arrived at this page by clicking a link on another page.\n\n\"typed\"  \nThe user arrived at this page by typing the URL in the address bar. This is\nalso used for other explicit navigation actions.\n\n\"auto_bookmark\"  \nThe user arrived at this page through a suggestion in the UI, for example,\nthrough a menu item.\n\n\"auto_subframe\"  \nThe user arrived at this page through subframe navigation that they didn't\nrequest, such as through an ad loading in a frame on the previous page. These\ndon't always generate new navigation entries in the back and forward menus.\n\n\"manual_subframe\"  \nThe user arrived at this page by selecting something in a subframe.\n\n\"generated\"  \nThe user arrived at this page by typing in the address bar and selecting an\nentry that didn't look like a URL, such as a Google Search suggestion. For\nexample, a match might have the URL of a Google Search result page, but it\nmight appear to the user as \"Search Google for ...\". These are different from\ntyped navigations because the user didn't type or see the destination URL.\nThey're also related to keyword navigations.\n\n\"auto_toplevel\"  \nThe page was specified in the command line or is the start page.\n\n\"form_submit\"  \nThe user arrived at this page by filling out values in a form and submitting\nthe form. Not all form submissions use this transition type.\n\n\"reload\"  \nThe user reloaded the page, either by clicking the reload button or by\npressing Enter in the address bar. Session restore and Reopen closed tab also\nuse this transition type.\n\n\"keyword\"  \nThe URL for this page was generated from a replaceable keyword other than the\ndefault search provider.\n\n\"keyword_generated\"  \nCorresponds to a visit generated for a keyword.\n\n### UrlDetails\n\nChrome 88+\n\n#### Properties\n\n  * url\n\nstring\n\nThe URL for the operation. It must be in the format as returned from a call to\n`history.search()`.\n\n### VisitItem\n\nAn object encapsulating one visit to a URL.\n\n#### Properties\n\n  * id\n\nstring\n\nThe unique identifier for the corresponding `history.HistoryItem`.\n\n  * isLocal\n\nboolean\n\nChrome 115+\n\nTrue if the visit originated on this device. False if it was synced from a\ndifferent device.\n\n  * referringVisitId\n\nstring\n\nThe visit ID of the referrer.\n\n  * transition\n\nTransitionType\n\nThe transition type for this visit from its referrer.\n\n  * visitId\n\nstring\n\nThe unique identifier for this visit.\n\n  * visitTime\n\nnumber optional\n\nWhen this visit occurred, represented in milliseconds since the epoch.\n\n## Methods\n\n### addUrl()\n\nPromise\n\n    \n    \n    chrome.history.addUrl(  \n      details: UrlDetails,  \n      callback?: function,  \n    )\n\nAdds a URL to the history at the current time with a transition type of\n\"link\".\n\n#### Parameters\n\n  * details\n\nUrlDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### deleteAll()\n\nPromise\n\n    \n    \n    chrome.history.deleteAll(  \n      callback?: function,  \n    )\n\nDeletes all items from the history.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### deleteRange()\n\nPromise\n\n    \n    \n    chrome.history.deleteRange(  \n      range: object,  \n      callback?: function,  \n    )\n\nRemoves all items within the specified date range from the history. Pages will\nnot be removed from the history unless all visits fall within the range.\n\n#### Parameters\n\n  * range\n\nobject\n\n    * endTime\n\nnumber\n\nItems added to history before this date, represented in milliseconds since the\nepoch.\n\n    * startTime\n\nnumber\n\nItems added to history after this date, represented in milliseconds since the\nepoch.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### deleteUrl()\n\nPromise\n\n    \n    \n    chrome.history.deleteUrl(  \n      details: UrlDetails,  \n      callback?: function,  \n    )\n\nRemoves all occurrences of the given URL from the history.\n\n#### Parameters\n\n  * details\n\nUrlDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getVisits()\n\nPromise\n\n    \n    \n    chrome.history.getVisits(  \n      details: UrlDetails,  \n      callback?: function,  \n    )\n\nRetrieves information about visits to a URL.\n\n#### Parameters\n\n  * details\n\nUrlDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: VisitItem[]) => void\n\n    * results\n\nVisitItem[]\n\n#### Returns\n\n  * Promise<VisitItem[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### search()\n\nPromise\n\n    \n    \n    chrome.history.search(  \n      query: object,  \n      callback?: function,  \n    )\n\nSearches the history for the last visit time of each page matching the query.\n\n#### Parameters\n\n  * query\n\nobject\n\n    * endTime\n\nnumber optional\n\nLimit results to those visited before this date, represented in milliseconds\nsince the epoch.\n\n    * maxResults\n\nnumber optional\n\nThe maximum number of results to retrieve. Defaults to 100.\n\n    * startTime\n\nnumber optional\n\nLimit results to those visited after this date, represented in milliseconds\nsince the epoch. If property is not specified, it will default to 24 hours.\n\n    * text\n\nstring\n\nA free-text query to the history service. Leave this empty to retrieve all\npages.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: HistoryItem[]) => void\n\n    * results\n\nHistoryItem[]\n\n#### Returns\n\n  * Promise<HistoryItem[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onVisited\n\n    \n    \n    chrome.history.onVisited.addListener(  \n      callback: function,  \n    )\n\nFired when a URL is visited, providing the `HistoryItem` data for that URL.\nThis event fires before the page has loaded.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (result: HistoryItem) => void\n\n    * result\n\nHistoryItem\n\n### onVisitRemoved\n\n    \n    \n    chrome.history.onVisitRemoved.addListener(  \n      callback: function,  \n    )\n\nFired when one or more URLs are removed from history. When all visits have\nbeen removed the URL is purged from history.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (removed: object) => void\n\n    * removed\n\nobject\n\n      * allHistory\n\nboolean\n\nTrue if all history was removed. If true, then urls will be empty.\n\n      * urls\n\nstring[] optional\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/i18n": "#  chrome.i18n\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.i18n` infrastructure to implement internationalization across\nyour whole app or extension.\n\n## Manifest\n\nIf an extension has a `/_locales` directory, the manifest must define\n`\"default_locale\"`.\n\n## Concepts and usage\n\nYou need to put all of its user-visible strings into a file named\n`messages.json`. Each time you add a new locale, you add a messages file under\na directory named `/_locales/_localeCode_`, where _localeCode_ is a code such\nas `en` for English.\n\nHere's the file hierarchy for an internationalized extension that supports\nEnglish (`en`), Spanish (`es`), and Korean (`ko`):\n\n![In the extension directory: manifest.json, *.html, *.js, /_locales\ndirectory. In the /_locales directory: en, es, and ko directories, each with a\nmessages.json\nfile.](/static/docs/extensions/mv2/reference/i18n/images/i18n-hierarchy.gif)\n\n### Support multiple languages\n\nSay you have an extension with the files shown in the following figure:\n\n![A manifest.json file and a file with JavaScript. The .json file has 'Hello\nWorld'. The JavaScript file has title = 'Hello\nWorld'.](/static/docs/extensions/mv2/reference/i18n/images/i18n-before.gif)\n\nTo internationalize this extension, you name each user-visible string and put\nit into a messages file. The extension's manifest, CSS files, and JavaScript\ncode use each string's name to get its localized version.\n\nHere's what the extension looks like when it's internationalized (note that it\nstill has only English strings):\n\n![In the manifest.json file, 'Hello World' has been changed to\n'__MSG_extName__', and a new default_locale' item has the value 'en'. In the\nJavaScript file, 'Hello World' has been changed to\nchrome.i18n.getMessage\\('extName'\\). A new file named\n/_locales/en/messages.json defines\n'extName'.](/static/docs/extensions/mv2/reference/i18n/images/i18n-after-1.gif)\n\nSome notes about internationalizing:\n\n  * You can use any of the supported locales. If you use an unsupported locale, Google Chrome ignores it.\n  * In `manifest.json` and CSS files, refer to a string named _messagename_ like this:\n        \n        __MSG_messagename__\n        \n\n  * In your extension or app's JavaScript code, refer to a string named _messagename_ like this:\n        \n        chrome.i18n.getMessage(\"messagename\")\n        \n\n  * In each call to `getMessage()`, you can supply up to 9 strings to be included in the message. See Examples: getMessage for details.\n\n  * Some messages, such as `@@bidi_dir` and `@@ui_locale`, are provided by the internationalization system. See the Predefined messages section for a full list of predefined message names.\n\n  * In `messages.json`, each user-visible string has a name, a \"message\" item, and an optional \"description\" item. The name is a key such as \"extName\" or \"search_string\" that identifies the string. The \"message\" specifies the value of the string in this locale. The optional \"description\" provides help to translators, who might not be able to see how the string is used in your extension. For example:\n        \n        {\n          \"search_string\": {\n            \"message\": \"hello%20world\",\n            \"description\": \"The string we search for. Put %20 between words that go together.\"\n          },\n          ...\n        }\n        \n\nFor more information, see Formats: Locale-Specific Messages.\n\nOnce an extension is internationalized, translating it is straightforward. You\ncopy `messages.json`, translate it, and put the copy into a new directory\nunder `/_locales`. For example, to support Spanish, just put a translated copy\nof `messages.json` under `/_locales/es`. The following figure shows the\nprevious extension with a new Spanish translation.\n\n![This looks the same as the previous figure, but with a new file at\n/_locales/es/messages.json that contains a Spanish translation of the\nmessages.](/static/docs/extensions/mv2/reference/i18n/images/i18n-after-2.gif)\n\n### Predefined messages\n\nThe internationalization system provides a few predefined messages to help you\nlocalize. These include `@@ui_locale`, so you can detect the current UI\nlocale, and a few `@@bidi_...` messages that let you detect the text\ndirection. The latter messages have similar names to constants in the gadgets\nBIDI (bi-directional) API.\n\nThe special message `@@extension_id` can be used in the CSS and JavaScript\nfiles, whether or not the extension or app is localized. This message doesn't\nwork in manifest files.\n\nThe following table describes each predefined message.\n\nMessage name| Description  \n---|---  \n`@@extension_id`| The extension or app ID; you might use this string to\nconstruct URLs for resources inside the extension. Even unlocalized extensions\ncan use this message.  \n**Note:** You can't use this message in a manifest file.  \n`@@ui_locale`| The current locale; you might use this string to construct\nlocale-specific URLs.  \n`@@bidi_dir`| The text direction for the current locale, either \"ltr\" for\nleft-to-right languages such as English or \"rtl\" for right-to-left languages\nsuch as Arabic.  \n`@@bidi_reversed_dir`| If the `@@bidi_dir` is \"ltr\", then this is \"rtl\";\notherwise, it's \"ltr\".  \n`@@bidi_start_edge`| If the `@@bidi_dir` is \"ltr\", then this is \"left\";\notherwise, it's \"right\".  \n`@@bidi_end_edge`| If the `@@bidi_dir` is \"ltr\", then this is \"right\";\notherwise, it's \"left\".  \n  \nHere's an example of using `@@extension_id` in a CSS file to construct a URL:\n\n    \n    \n    body {\n      background-image:url('chrome-extension://__MSG_@@extension_id__/background.png');\n    }\n    \n\nIf the extension ID is abcdefghijklmnopqrstuvwxyzabcdef, then the bold line in\nthe previous code snippet becomes:\n\n    \n    \n      background-image:url('chrome-extension://abcdefghijklmnopqrstuvwxyzabcdef/background.png');\n    \n\nHere's an example of using `@@bidi_*` messages in a CSS file:\n\n    \n    \n    body {\n      direction: __MSG_@@bidi_dir__;\n    }\n    \n    div#header {\n      margin-bottom: 1.05em;\n      overflow: hidden;\n      padding-bottom: 1.5em;\n      padding-__MSG_@@bidi_start_edge__: 0;\n      padding-__MSG_@@bidi_end_edge__: 1.5em;\n      position: relative;\n    }\n    \n\nFor left-to-right languages such as English, the bold lines become:\n\n    \n    \n      dir: ltr;\n      padding-left: 0;\n      padding-right: 1.5em;\n    \n\n### Locales\n\nYou can choose from many locales, including some (such as `en`) that let a\nsingle translation support multiple variations of a language (such as `en_GB`\nand `en_US`).\n\nYou can localize your extension to any locale that is supported by the Chrome\nWeb Store. If your locale is not listed here, choose the closest alternative.\nFor example, if the default locale of your extension is `\"de_CH\"`, choose\n`\"de\"` in the Chrome Web Store.\n\nLocale code | Language (region)  \n---|---  \n`ar` | Arabic  \n`am` | Amharic  \n`bg` | Bulgarian  \n`bn` | Bengali  \n`ca` | Catalan  \n`cs` | Czech  \n`da` | Danish  \n`de` | German  \n`el` | Greek  \n`en` | English  \n`en_AU` | English (Australia)  \n`en_GB` | English (Great Britain)  \n`en_US` | English (USA)  \n`es` | Spanish  \n`es_419` | Spanish (Latin America and Caribbean)  \n`et` | Estonian  \n`fa` | Persian  \n`fi` | Finnish  \n`fil` | Filipino  \n`fr` | French  \n`gu` | Gujarati  \n`he` | Hebrew  \n`hi` | Hindi  \n`hr` | Croatian  \n`hu` | Hungarian  \n`id` | Indonesian  \n`it` | Italian  \n`ja` | Japanese  \n`kn` | Kannada  \n`ko` | Korean  \n`lt` | Lithuanian  \n`lv` | Latvian  \n`ml` | Malayalam  \n`mr` | Marathi  \n`ms` | Malay  \n`nl` | Dutch  \n`no` | Norwegian  \n`pl` | Polish  \n`pt_BR` | Portuguese (Brazil)  \n`pt_PT` | Portuguese (Portugal)  \n`ro` | Romanian  \n`ru` | Russian  \n`sk` | Slovak  \n`sl` | Slovenian  \n`sr` | Serbian  \n`sv` | Swedish  \n`sw` | Swahili  \n`ta` | Tamil  \n`te` | Telugu  \n`th` | Thai  \n`tr` | Turkish  \n`uk` | Ukrainian  \n`vi` | Vietnamese  \n`zh_CN` | Chinese (China)  \n`zh_TW` | Chinese (Taiwan)  \n  \n### Search for messages\n\nYou don't have to define every string for every supported locale. As long as\nthe default locale's `messages.json` file has a value for every string, your\nextension or app will run no matter how sparse a translation is. Here's how\nthe extension system searches for a message:\n\n  1. Search the messages file (if any) for the user's preferred locale. For example, when Google Chrome's locale is set to British English (`en_GB`), the system first looks for the message in `/_locales/en_GB/messages.json`. If that file exists and the message is there, the system looks no further.\n  2. If the user's preferred locale has a region (that is, the locale has an underscore: _), search the locale without that region. For example, if the `en_GB` messages file doesn't exist or doesn't contain the message, the system looks in the `en` messages file. If that file exists and the message is there, the system looks no further.\n  3. Search the messages file for the default locale. For example, if the extension's \"default_locale\" is set to \"es\", and neither `/_locales/en_GB/messages.json` nor `/_locales/en/messages.json` contains the message, the extension uses the message from `/_locales/es/messages.json`.\n\nIn the following figure, the message named \"colores\" is in all three locales\nthat the extension supports, but \"extName\" is in only two of the locales.\nWherever a user running Google Chrome in US English sees the label \"Colors\", a\nuser of British English sees \"Colours\". Both US English and British English\nusers see the extension name \"Hello World\". Because the default language is\nSpanish, users running Google Chrome in any non-English language see the label\n\"Colores\" and the extension name \"Hola mundo\".\n\n![Four files: manifest.json and three messages.json files \\(for es, en, and\nen_GB\\). The es and en files show entries for messages named 'extName' and\n'colores'; the en_GB file has just one entry \\(for\n'colores'\\).](/static/docs/extensions/mv2/reference/i18n/images/i18n-strings.gif)\n\n### Set your browser's locale\n\nTo test translations, you might want to set your browser's locale. This\nsection tells you how to set the locale in Windows, Mac OS, Linux, and\nChromeOS.\n\n#### Windows\n\nYou can change the locale using either a locale-specific shortcut or the\nGoogle Chrome UI. The shortcut approach is quicker, once you've set it up, and\nit lets you use several languages at once.\n\n##### Use a locale-specific shortcut\n\nTo create and use a shortcut that launches Google Chrome with a particular\nlocale:\n\n  1. Make a copy of the Google Chrome shortcut that's already on your desktop.\n  2. Rename the new shortcut to match the new locale.\n  3. Change the shortcut's properties so that the Target field specifies the `--lang` and `--user-data-dir` flags. The target should look something like this:\n         \n         path_to_chrome.exe --lang=locale --user-data-dir=c:\\locale_profile_dir\n         \n\n  4. Launch Google Chrome by double-clicking the shortcut.\n\nFor example, to create a shortcut that launches Google Chrome in Spanish\n(`es`), you might create a shortcut named `chrome-es` that has the following\ntarget:\n\n    \n    \n    path_to_chrome.exe --lang=es --user-data-dir=c:\\chrome-profile-es\n    \n\nYou can create as many shortcuts as you like, making it straightforward to\ntest in multiple languages. For example:\n\n    \n    \n    path_to_chrome.exe --lang=en --user-data-dir=c:\\chrome-profile-en\n    path_to_chrome.exe --lang=en_GB --user-data-dir=c:\\chrome-profile-en_GB\n    path_to_chrome.exe --lang=ko --user-data-dir=c:\\chrome-profile-ko\n    \n\n**Note:** Specifying `--user-data-dir` is optional but handy. Having one data\ndirectory per locale lets you run the browser in several languages at the same\ntime. A disadvantage is that because the locales' data isn't shared, you have\nto install your extension multiple timesonce per locale, which can be\nchallenging when you don't speak the language. For more information, see\nCreating and Using Profiles.\n\n##### Use the UI\n\nHere's how to change the locale using the UI on Google Chrome for Windows:\n\n  1. App icon > **Options**\n  2. Choose the **Under the Hood** tab\n  3. Scroll to **Web Content**\n  4. Click **Change font and language settings**\n  5. Choose the **Languages** tab\n  6. Use the drop down to set the **Google Chrome language**\n  7. Restart Chrome\n\n#### Mac OS\n\nTo change the locale on Mac, you use the system preferences.\n\n  1. From the Apple menu, choose **System Preferences**\n  2. Under the **Personal** section, choose **International**\n  3. Choose your language and location\n  4. Restart Chrome\n\n#### Linux\n\nTo change the locale on Linux, first quit Google Chrome. Then, all in one\nline, set the LANGUAGE environment variable and launch Google Chrome. For\nexample:\n\n    \n    \n    LANGUAGE=es ./chrome\n    \n\n#### ChromeOS\n\nTo change the locale on ChromeOS:\n\n  1. From the system tray, choose **Settings**.\n  2. Under the **Languages and input** section, choose the **Language** drop-down.\n  3. If your language is not listed, click **Add languages** and add it.\n  4. Once added, click the 3-dot **More actions** menu item next to your language and choose **Display ChromeOS in this language**.\n  5. Click the **Restart** button that appears next to the set language to restart ChromeOS.\n\n## Examples\n\nYou can find examples of internationalization in the examples/api/i18n\ndirectory. For a complete example, see examples/extensions/news. For other\nexamples and for help in viewing the source code, see Samples.\n\n### getMessage()\n\nThe following code gets a localized message from the browser and displays it\nas a string. It replaces two placeholders within the message with the strings\n\"string1\" and \"string2\".\n\n    \n    \n    function getMessage() {\n      var message = chrome.i18n.getMessage(\"click_here\", [\"string1\", \"string2\"]);\n      document.getElementById(\"languageSpan\").innerHTML = message;\n    }\n    \n\nHere's how you'd supply and use a single string:\n\n    \n    \n      // In JavaScript code\n      status.innerText = chrome.i18n.getMessage(\"error\", errorDetails);\n    \n    \n    \n    \"error\": {\n      \"message\": \"Error: $details$\",\n      \"description\": \"Generic error template. Expects error parameter to be passed in.\",\n      \"placeholders\": {\n        \"details\": {\n          \"content\": \"$1\",\n          \"example\": \"Failed to fetch RSS feed.\"\n        }\n      }\n    }\n    \n\nFor more information about placeholders, see the Locale-Specific Messages\npage. For details on calling `getMessage()`, see the API reference.\n\n### getAcceptLanguages()\n\nThe following code gets accept-languages from the browser and displays them as\na string by separating each accept-language with ','.\n\n    \n    \n    function getAcceptLanguages() {\n      chrome.i18n.getAcceptLanguages(function(languageList) {\n        var languages = languageList.join(\",\");\n        document.getElementById(\"languageSpan\").innerHTML = languages;\n      })\n    }\n    \n\nFor details on calling `getAcceptLanguages()`, see the API reference.\n\n### detectLanguage()\n\nThe following code detects up to 3 languages from the given string and\ndisplays the result as strings separated by new lines.\n\n    \n    \n    function detectLanguage(inputText) {\n      chrome.i18n.detectLanguage(inputText, function(result) {\n        var outputLang = \"Detected Language: \";\n        var outputPercent = \"Language Percentage: \";\n        for(i = 0; i < result.languages.length; i++) {\n          outputLang += result.languages[i].language + \" \";\n          outputPercent +=result.languages[i].percentage + \" \";\n        }\n        document.getElementById(\"languageSpan\").innerHTML = outputLang + \"\\n\" + outputPercent + \"\\nReliable: \" + result.isReliable;\n      });\n    }\n    \n\nFor more details on calling `detectLanguage(inputText)`, see the API\nreference.\n\n## Types\n\n### LanguageCode\n\nChrome 47+\n\nAn ISO language code such as `en` or `fr`. For a complete list of languages\nsupported by this method, see kLanguageInfoTable. For an unknown language,\n`und` will be returned, which means that [percentage] of the text is unknown\nto CLD\n\n#### Type\n\nstring\n\n## Methods\n\n### detectLanguage()\n\nPromise Chrome 47+\n\n    \n    \n    chrome.i18n.detectLanguage(  \n      text: string,  \n      callback?: function,  \n    )\n\nDetects the language of the provided text using CLD.\n\n#### Parameters\n\n  * text\n\nstring\n\nUser input string to be translated.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: object) => void\n\n    * result\n\nobject\n\nLanguageDetectionResult object that holds detected langugae reliability and\narray of DetectedLanguage\n\n      * isReliable\n\nboolean\n\nCLD detected language reliability\n\n      * languages\n\nobject[]\n\narray of detectedLanguage\n\n        * language\n\nstring\n\n        * percentage\n\nnumber\n\nThe percentage of the detected language\n\n#### Returns\n\n  * Promise<object>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAcceptLanguages()\n\nPromise\n\n    \n    \n    chrome.i18n.getAcceptLanguages(  \n      callback?: function,  \n    )\n\nGets the accept-languages of the browser. This is different from the locale\nused by the browser; to get the locale, use `i18n.getUILanguage`.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (languages: string[]) => void\n\n    * languages\n\nstring[]\n\nArray of LanguageCode\n\n#### Returns\n\n  * Promise<LanguageCode[]>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getMessage()\n\n    \n    \n    chrome.i18n.getMessage(  \n      messageName: string,  \n      substitutions?: any,  \n      options?: object,  \n    )\n\nGets the localized string for the specified message. If the message is\nmissing, this method returns an empty string (''). If the format of the\n`getMessage()` call is wrong  for example, _messageName_ is not a string or\nthe _substitutions_ array has more than 9 elements  this method returns\n`undefined`.\n\n#### Parameters\n\n  * messageName\n\nstring\n\nThe name of the message, as specified in the `messages.json` file.\n\n  * substitutions\n\nany optional\n\nUp to 9 substitution strings, if the message requires any.\n\n  * options\n\nobject optional\n\nChrome 79+\n\n    * escapeLt\n\nboolean optional\n\nEscape `<` in translation to `&lt;`. This applies only to the message itself,\nnot to the placeholders. Developers might want to use this if the translation\nis used in an HTML context. Closure Templates used with Closure Compiler\ngenerate this automatically.\n\n#### Returns\n\n  * string\n\nMessage localized for current locale.\n\n### getUILanguage()\n\n    \n    \n    chrome.i18n.getUILanguage()\n\nGets the browser UI language of the browser. This is different from\n`i18n.getAcceptLanguages` which returns the preferred user languages.\n\n#### Returns\n\n  * string\n\nThe browser UI language code such as en-US or fr-FR.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/identity": "#  chrome.identity\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.identity` API to get OAuth2 access tokens.\n\n## Permissions\n\n`identity`  \n\n## Types\n\n### AccountInfo\n\n#### Properties\n\n  * id\n\nstring\n\nA unique identifier for the account. This ID will not change for the lifetime\nof the account.\n\n### AccountStatus\n\nChrome 84+\n\n#### Enum\n\n\"SYNC\"  \nSpecifies that Sync is enabled for the primary account.\n\n\"ANY\"  \nSpecifies the existence of a primary account, if any.\n\n### GetAuthTokenResult\n\nChrome 105+\n\n#### Properties\n\n  * grantedScopes\n\nstring[] optional\n\nA list of OAuth2 scopes granted to the extension.\n\n  * token\n\nstring optional\n\nThe specific token associated with the request.\n\n### InvalidTokenDetails\n\n#### Properties\n\n  * token\n\nstring\n\nThe specific token that should be removed from the cache.\n\n### ProfileDetails\n\nChrome 84+\n\n#### Properties\n\n  * accountStatus\n\nAccountStatus optional\n\nA status of the primary account signed into a profile whose `ProfileUserInfo`\nshould be returned. Defaults to `SYNC` account status.\n\n### ProfileUserInfo\n\n#### Properties\n\n  * email\n\nstring\n\nAn email address for the user account signed into the current profile. Empty\nif the user is not signed in or the `identity.email` manifest permission is\nnot specified.\n\n  * id\n\nstring\n\nA unique identifier for the account. This ID will not change for the lifetime\nof the account. Empty if the user is not signed in or (in M41+) the\n`identity.email` manifest permission is not specified.\n\n### TokenDetails\n\n#### Properties\n\n  * account\n\nAccountInfo optional\n\nThe account ID whose token should be returned. If not specified, the function\nwill use an account from the Chrome profile: the Sync account if there is one,\nor otherwise the first Google web account.\n\n  * enableGranularPermissions\n\nboolean optional\n\nChrome 87+\n\nThe `enableGranularPermissions` flag allows extensions to opt-in early to the\ngranular permissions consent screen, in which requested permissions are\ngranted or denied individually.\n\n  * interactive\n\nboolean optional\n\nFetching a token may require the user to sign-in to Chrome, or approve the\napplication's requested scopes. If the interactive flag is `true`,\n`getAuthToken` will prompt the user as necessary. When the flag is `false` or\nomitted, `getAuthToken` will return failure any time a prompt would be\nrequired.\n\n  * scopes\n\nstring[] optional\n\nA list of OAuth2 scopes to request.\n\nWhen the `scopes` field is present, it overrides the list of scopes specified\nin manifest.json.\n\n### WebAuthFlowDetails\n\n#### Properties\n\n  * abortOnLoadForNonInteractive\n\nboolean optional\n\nChrome 113+\n\nWhether to terminate `launchWebAuthFlow` for non-interactive requests after\nthe page loads. This parameter does not affect interactive flows.\n\nWhen set to `true` (default) the flow will terminate immediately after the\npage loads. When set to `false`, the flow will only terminate after the\n`timeoutMsForNonInteractive` passes. This is useful for identity providers\nthat use JavaScript to perform redirections after the page loads.\n\n  * interactive\n\nboolean optional\n\nWhether to launch auth flow in interactive mode.\n\nSince some auth flows may immediately redirect to a result URL,\n`launchWebAuthFlow` hides its web view until the first navigation either\nredirects to the final URL, or finishes loading a page meant to be displayed.\n\nIf the `interactive` flag is `true`, the window will be displayed when a page\nload completes. If the flag is `false` or omitted, `launchWebAuthFlow` will\nreturn with an error if the initial navigation does not complete the flow.\n\nFor flows that use JavaScript for redirection, `abortOnLoadForNonInteractive`\ncan be set to `false` in combination with setting `timeoutMsForNonInteractive`\nto give the page a chance to perform any redirects.\n\n  * timeoutMsForNonInteractive\n\nnumber optional\n\nChrome 113+\n\nThe maximum amount of time, in miliseconds, `launchWebAuthFlow` is allowed to\nrun in non-interactive mode in total. Only has an effect if `interactive` is\n`false`.\n\n  * url\n\nstring\n\nThe URL that initiates the auth flow.\n\n## Methods\n\n### clearAllCachedAuthTokens()\n\nPromise Chrome 87+\n\n    \n    \n    chrome.identity.clearAllCachedAuthTokens(  \n      callback?: function,  \n    )\n\nResets the state of the Identity API:\n\n  * Removes all OAuth2 access tokens from the token cache\n  * Removes user's account preferences\n  * De-authorizes the user from all auth flows\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 106+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAccounts()\n\nPromise  Dev channel\n\n    \n    \n    chrome.identity.getAccounts(  \n      callback?: function,  \n    )\n\nRetrieves a list of AccountInfo objects describing the accounts present on the\nprofile.\n\n`getAccounts` is only supported on dev channel.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (accounts: AccountInfo[]) => void\n\n    * accounts\n\nAccountInfo[]\n\n#### Returns\n\n  * Promise<AccountInfo[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAuthToken()\n\nPromise\n\n    \n    \n    chrome.identity.getAuthToken(  \n      details?: TokenDetails,  \n      callback?: function,  \n    )\n\nGets an OAuth2 access token using the client ID and scopes specified in the\n`oauth2` section of manifest.json.\n\nThe Identity API caches access tokens in memory, so it's ok to call\n`getAuthToken` non-interactively any time a token is required. The token cache\nautomatically handles expiration.\n\nFor a good user experience it is important interactive token requests are\ninitiated by UI in your app explaining what the authorization is for. Failing\nto do this will cause your users to get authorization requests, or Chrome sign\nin screens if they are not signed in, with with no context. In particular, do\nnot use `getAuthToken` interactively when your app is first launched.\n\nNote: When called with a callback, instead of returning an object this\nfunction will return the two properties as separate arguments passed to the\ncallback.\n\n#### Parameters\n\n  * details\n\nTokenDetails optional\n\nToken options.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: GetAuthTokenResult) => void\n\n    * result\n\nGetAuthTokenResult\n\nChrome 105+\n\n#### Returns\n\n  * Promise<GetAuthTokenResult>\n\nChrome 105+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getProfileUserInfo()\n\nPromise\n\n    \n    \n    chrome.identity.getProfileUserInfo(  \n      details?: ProfileDetails,  \n      callback?: function,  \n    )\n\nRetrieves email address and obfuscated gaia id of the user signed into a\nprofile.\n\nRequires the `identity.email` manifest permission. Otherwise, returns an empty\nresult.\n\nThis API is different from identity.getAccounts in two ways. The information\nreturned is available offline, and it only applies to the primary account for\nthe profile.\n\n#### Parameters\n\n  * details\n\nProfileDetails optional\n\nChrome 84+\n\nProfile options.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (userInfo: ProfileUserInfo) => void\n\n    * userInfo\n\nProfileUserInfo\n\n#### Returns\n\n  * Promise<ProfileUserInfo>\n\nChrome 106+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getRedirectURL()\n\n    \n    \n    chrome.identity.getRedirectURL(  \n      path?: string,  \n    )\n\nGenerates a redirect URL to be used in `launchWebAuthFlow`.\n\nThe generated URLs match the pattern `https://<app-id>.chromiumapp.org/*`.\n\n#### Parameters\n\n  * path\n\nstring optional\n\nThe path appended to the end of the generated URL.\n\n#### Returns\n\n  * string\n\n### launchWebAuthFlow()\n\nPromise\n\n    \n    \n    chrome.identity.launchWebAuthFlow(  \n      details: WebAuthFlowDetails,  \n      callback?: function,  \n    )\n\nStarts an auth flow at the specified URL.\n\nThis method enables auth flows with non-Google identity providers by launching\na web view and navigating it to the first URL in the provider's auth flow.\nWhen the provider redirects to a URL matching the pattern `https://<app-\nid>.chromiumapp.org/*`, the window will close, and the final redirect URL will\nbe passed to the `callback` function.\n\nFor a good user experience it is important interactive auth flows are\ninitiated by UI in your app explaining what the authorization is for. Failing\nto do this will cause your users to get authorization requests with no\ncontext. In particular, do not launch an interactive auth flow when your app\nis first launched.\n\n#### Parameters\n\n  * details\n\nWebAuthFlowDetails\n\nWebAuth flow options.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (responseUrl?: string) => void\n\n    * responseUrl\n\nstring optional\n\n#### Returns\n\n  * Promise<string | undefined>\n\nChrome 106+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeCachedAuthToken()\n\nPromise\n\n    \n    \n    chrome.identity.removeCachedAuthToken(  \n      details: InvalidTokenDetails,  \n      callback?: function,  \n    )\n\nRemoves an OAuth2 access token from the Identity API's token cache.\n\nIf an access token is discovered to be invalid, it should be passed to\nremoveCachedAuthToken to remove it from the cache. The app may then retrieve a\nfresh token with `getAuthToken`.\n\n#### Parameters\n\n  * details\n\nInvalidTokenDetails\n\nToken information.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 106+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onSignInChanged\n\n    \n    \n    chrome.identity.onSignInChanged.addListener(  \n      callback: function,  \n    )\n\nFired when signin state changes for an account on the user's profile.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (account: AccountInfo, signedIn: boolean) => void\n\n    * account\n\nAccountInfo\n\n    * signedIn\n\nboolean\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/idle": "#  chrome.idle\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.idle` API to detect when the machine's idle state changes.\n\n## Permissions\n\n`idle`  \n\nYou must declare the `\"idle\"` permission in your extension's manifest to use\nthe idle API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"idle\"\n      ],\n      ...\n    }\n    \n\n## Types\n\n### IdleState\n\nChrome 44+\n\n#### Enum\n\n\"active\"  \n\n\"idle\"  \n\n\"locked\"  \n\n## Methods\n\n### getAutoLockDelay()\n\nPromise Chrome 73+  ChromeOS only\n\n    \n    \n    chrome.idle.getAutoLockDelay(  \n      callback?: function,  \n    )\n\nGets the time, in seconds, it takes until the screen is locked automatically\nwhile idle. Returns a zero duration if the screen is never locked\nautomatically. Currently supported on Chrome OS only.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (delay: number) => void\n\n    * delay\n\nnumber\n\nTime, in seconds, until the screen is locked automatically while idle. This is\nzero if the screen never locks automatically.\n\n#### Returns\n\n  * Promise<number>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### queryState()\n\nPromise\n\n    \n    \n    chrome.idle.queryState(  \n      detectionIntervalInSeconds: number,  \n      callback?: function,  \n    )\n\nReturns \"locked\" if the system is locked, \"idle\" if the user has not generated\nany input for a specified number of seconds, or \"active\" otherwise.\n\n#### Parameters\n\n  * detectionIntervalInSeconds\n\nnumber\n\nThe system is considered idle if detectionIntervalInSeconds seconds have\nelapsed since the last user input detected.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (newState: IdleState) => void\n\n    * newState\n\nIdleState\n\n#### Returns\n\n  * Promise<IdleState>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setDetectionInterval()\n\n    \n    \n    chrome.idle.setDetectionInterval(  \n      intervalInSeconds: number,  \n    )\n\nSets the interval, in seconds, used to determine when the system is in an idle\nstate for onStateChanged events. The default interval is 60 seconds.\n\n#### Parameters\n\n  * intervalInSeconds\n\nnumber\n\nThreshold, in seconds, used to determine when the system is in an idle state.\n\n## Events\n\n### onStateChanged\n\n    \n    \n    chrome.idle.onStateChanged.addListener(  \n      callback: function,  \n    )\n\nFired when the system changes to an active, idle or locked state. The event\nfires with \"locked\" if the screen is locked or the screensaver activates,\n\"idle\" if the system is unlocked and the user has not generated any input for\na specified number of seconds, and \"active\" when the user generates input on\nan idle system.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (newState: IdleState) => void\n\n    * newState\n\nIdleState\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/input/ime": "#  chrome.input.ime\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.input.ime` API to implement a custom IME for Chrome OS. This\nallows your extension to handle keystrokes, set the composition, and manage\nthe candidate window.\n\n## Permissions\n\n`input`  \n\nYou must declare the \"input\" permission in the extension manifest to use the\ninput.ime API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"input\"\n      ],\n      ...\n    }\n    \n\n## Availability\n\nChromeOS only\n\n## Examples\n\nThe following code creates an IME that converts typed letters to upper case.\n\n    \n    \n    var context_id = -1;\n    \n    chrome.input.ime.onFocus.addListener(function(context) {\n      context_id = context.contextID;\n    });\n    \n    chrome.input.ime.onKeyEvent.addListener(\n      function(engineID, keyData) {\n        if (keyData.type == \"keydown\" && keyData.key.match(/^[a-z]$/)) {\n          chrome.input.ime.commitText({\"contextID\": context_id,\n                                        \"text\": keyData.key.toUpperCase()});\n          return true;\n        } else {\n          return false;\n        }\n      }\n    );\n    \n\n## Types\n\n### AssistiveWindowButton\n\nChrome 85+\n\nID of buttons in assistive window.\n\n#### Enum\n\n\"undo\"  \n\n\"addToDictionary\"  \n\n### AssistiveWindowProperties\n\nChrome 85+\n\nProperties of the assistive window.\n\n#### Properties\n\n  * announceString\n\nstring optional\n\nStrings for ChromeVox to announce.\n\n  * type\n\n\"undo\"  \n\n  * visible\n\nboolean\n\nSets true to show AssistiveWindow, sets false to hide.\n\n### AssistiveWindowType\n\nChrome 85+\n\nType of assistive window.\n\n#### Value\n\n\"undo\"  \n\n### AutoCapitalizeType\n\nChrome 69+\n\nThe auto-capitalize type of the text field.\n\n#### Enum\n\n\"characters\"  \n\n\"words\"  \n\n\"sentences\"  \n\n### InputContext\n\nDescribes an input Context\n\n#### Properties\n\n  * autoCapitalize\n\nAutoCapitalizeType\n\nChrome 69+\n\nThe auto-capitalize type of the text field.\n\n  * autoComplete\n\nboolean\n\nWhether the text field wants auto-complete.\n\n  * autoCorrect\n\nboolean\n\nWhether the text field wants auto-correct.\n\n  * contextID\n\nnumber\n\nThis is used to specify targets of text field operations. This ID becomes\ninvalid as soon as onBlur is called.\n\n  * shouldDoLearning\n\nboolean\n\nChrome 68+\n\nWhether text entered into the text field should be used to improve typing\nsuggestions for the user.\n\n  * spellCheck\n\nboolean\n\nWhether the text field wants spell-check.\n\n  * type\n\nInputContextType\n\nType of value this text field edits, (Text, Number, URL, etc)\n\n### InputContextType\n\nChrome 44+\n\nType of value this text field edits, (Text, Number, URL, etc)\n\n#### Enum\n\n\"text\"  \n\n\"search\"  \n\n\"tel\"  \n\n\"url\"  \n\n\"email\"  \n\n\"number\"  \n\n\"password\"  \n\n\"null\"  \n\n### KeyboardEvent\n\nSee http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent\n\n#### Properties\n\n  * altKey\n\nboolean optional\n\nWhether or not the ALT key is pressed.\n\n  * altgrKey\n\nboolean optional\n\nChrome 79+\n\nWhether or not the ALTGR key is pressed.\n\n  * capsLock\n\nboolean optional\n\nWhether or not the CAPS_LOCK is enabled.\n\n  * code\n\nstring\n\nValue of the physical key being pressed. The value is not affected by current\nkeyboard layout or modifier state.\n\n  * ctrlKey\n\nboolean optional\n\nWhether or not the CTRL key is pressed.\n\n  * extensionId\n\nstring optional\n\nThe extension ID of the sender of this keyevent.\n\n  * key\n\nstring\n\nValue of the key being pressed\n\n  * keyCode\n\nnumber optional\n\nThe deprecated HTML keyCode, which is system- and implementation-dependent\nnumerical code signifying the unmodified identifier associated with the key\npressed.\n\n  * requestId\n\nstring optional\n\n(Deprecated) The ID of the request. Use the `requestId` param from the\n`onKeyEvent` event instead.\n\n  * shiftKey\n\nboolean optional\n\nWhether or not the SHIFT key is pressed.\n\n  * type\n\nKeyboardEventType\n\nOne of keyup or keydown.\n\n### KeyboardEventType\n\nChrome 44+\n\n#### Enum\n\n\"keyup\"  \n\n\"keydown\"  \n\n### MenuItem\n\nA menu item used by an input method to interact with the user from the\nlanguage menu.\n\n#### Properties\n\n  * checked\n\nboolean optional\n\nIndicates this item should be drawn with a check.\n\n  * enabled\n\nboolean optional\n\nIndicates this item is enabled.\n\n  * id\n\nstring\n\nString that will be passed to callbacks referencing this MenuItem.\n\n  * label\n\nstring optional\n\nText displayed in the menu for this item.\n\n  * style\n\nMenuItemStyle optional\n\nThe type of menu item.\n\n  * visible\n\nboolean optional\n\nIndicates this item is visible.\n\n### MenuItemStyle\n\nChrome 44+\n\nThe type of menu item. Radio buttons between separators are considered\ngrouped.\n\n#### Enum\n\n\"check\"  \n\n\"radio\"  \n\n\"separator\"  \n\n### MenuParameters\n\nChrome 88+\n\n#### Properties\n\n  * engineID\n\nstring\n\nID of the engine to use.\n\n  * items\n\nMenuItem[]\n\nMenuItems to add or update. They will be added in the order they exist in the\narray.\n\n### MouseButton\n\nChrome 44+\n\nWhich mouse buttons was clicked.\n\n#### Enum\n\n\"left\"  \n\n\"middle\"  \n\n\"right\"  \n\n### ScreenType\n\nChrome 44+\n\nThe screen type under which the IME is activated.\n\n#### Enum\n\n\"normal\"  \n\n\"login\"  \n\n\"lock\"  \n\n\"secondary-login\"  \n\n### UnderlineStyle\n\nChrome 44+\n\nThe type of the underline to modify this segment.\n\n#### Enum\n\n\"underline\"  \n\n\"doubleUnderline\"  \n\n\"noUnderline\"  \n\n### WindowPosition\n\nChrome 44+\n\nWhere to display the candidate window. If set to 'cursor', the window follows\nthe cursor. If set to 'composition', the window is locked to the beginning of\nthe composition.\n\n#### Enum\n\n\"cursor\"  \n\n\"composition\"  \n\n## Methods\n\n### clearComposition()\n\nPromise\n\n    \n    \n    chrome.input.ime.clearComposition(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nClear the current composition. If this extension does not own the active IME,\nthis fails.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * contextID\n\nnumber\n\nID of the context where the composition will be cleared\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### commitText()\n\nPromise\n\n    \n    \n    chrome.input.ime.commitText(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nCommits the provided text to the current input.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * contextID\n\nnumber\n\nID of the context where the text will be committed\n\n    * text\n\nstring\n\nThe text to commit\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### deleteSurroundingText()\n\nPromise\n\n    \n    \n    chrome.input.ime.deleteSurroundingText(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nDeletes the text around the caret.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * contextID\n\nnumber\n\nID of the context where the surrounding text will be deleted.\n\n    * engineID\n\nstring\n\nID of the engine receiving the event.\n\n    * length\n\nnumber\n\nThe number of characters to be deleted\n\n    * offset\n\nnumber\n\nThe offset from the caret position where deletion will start. This value can\nbe negative.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### hideInputView()\n\n    \n    \n    chrome.input.ime.hideInputView()\n\nHides the input view window, which is popped up automatically by system. If\nthe input view window is already hidden, this function will do nothing.\n\n### keyEventHandled()\n\n    \n    \n    chrome.input.ime.keyEventHandled(  \n      requestId: string,  \n      response: boolean,  \n    )\n\nIndicates that the key event received by onKeyEvent is handled. This should\nonly be called if the onKeyEvent listener is asynchronous.\n\n#### Parameters\n\n  * requestId\n\nstring\n\nRequest id of the event that was handled. This should come from\nkeyEvent.requestId\n\n  * response\n\nboolean\n\nTrue if the keystroke was handled, false if not\n\n### sendKeyEvents()\n\nPromise\n\n    \n    \n    chrome.input.ime.sendKeyEvents(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nSends the key events. This function is expected to be used by virtual\nkeyboards. When key(s) on a virtual keyboard is pressed by a user, this\nfunction is used to propagate that event to the system.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * contextID\n\nnumber\n\nID of the context where the key events will be sent, or zero to send key\nevents to non-input field.\n\n    * keyData\n\nKeyboardEvent[]\n\nData on the key event.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setAssistiveWindowButtonHighlighted()\n\nPromise Chrome 86+\n\n    \n    \n    chrome.input.ime.setAssistiveWindowButtonHighlighted(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nHighlights/Unhighlights a button in an assistive window.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * announceString\n\nstring optional\n\nThe text for the screenreader to announce.\n\n    * buttonID\n\nAssistiveWindowButton\n\nThe ID of the button\n\n    * contextID\n\nnumber\n\nID of the context owning the assistive window.\n\n    * highlighted\n\nboolean\n\nWhether the button should be highlighted.\n\n    * windowType\n\n\"undo\"  \n\nThe window type the button belongs to.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setAssistiveWindowProperties()\n\nPromise Chrome 85+\n\n    \n    \n    chrome.input.ime.setAssistiveWindowProperties(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nShows/Hides an assistive window with the given properties.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * contextID\n\nnumber\n\nID of the context owning the assistive window.\n\n    * properties\n\nAssistiveWindowProperties\n\nProperties of the assistive window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setCandidates()\n\nPromise\n\n    \n    \n    chrome.input.ime.setCandidates(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nSets the current candidate list. This fails if this extension doesn't own the\nactive IME\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * candidates\n\nobject[]\n\nList of candidates to show in the candidate window\n\n      * annotation\n\nstring optional\n\nAdditional text describing the candidate\n\n      * candidate\n\nstring\n\nThe candidate\n\n      * id\n\nnumber\n\nThe candidate's id\n\n      * label\n\nstring optional\n\nShort string displayed to next to the candidate, often the shortcut key or\nindex\n\n      * parentId\n\nnumber optional\n\nThe id to add these candidates under\n\n      * usage\n\nobject optional\n\nThe usage or detail description of word.\n\n        * body\n\nstring\n\nThe body string of detail description.\n\n        * title\n\nstring\n\nThe title string of details description.\n\n    * contextID\n\nnumber\n\nID of the context that owns the candidate window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setCandidateWindowProperties()\n\nPromise\n\n    \n    \n    chrome.input.ime.setCandidateWindowProperties(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nSets the properties of the candidate window. This fails if the extension\ndoesn't own the active IME\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * engineID\n\nstring\n\nID of the engine to set properties on.\n\n    * properties\n\nobject\n\n      * auxiliaryText\n\nstring optional\n\nText that is shown at the bottom of the candidate window.\n\n      * auxiliaryTextVisible\n\nboolean optional\n\nTrue to display the auxiliary text, false to hide it.\n\n      * currentCandidateIndex\n\nnumber optional\n\nChrome 84+\n\nThe index of the current chosen candidate out of total candidates.\n\n      * cursorVisible\n\nboolean optional\n\nTrue to show the cursor, false to hide it.\n\n      * pageSize\n\nnumber optional\n\nThe number of candidates to display per page.\n\n      * totalCandidates\n\nnumber optional\n\nChrome 84+\n\nThe total number of candidates for the candidate window.\n\n      * vertical\n\nboolean optional\n\nTrue if the candidate window should be rendered vertical, false to make it\nhorizontal.\n\n      * visible\n\nboolean optional\n\nTrue to show the Candidate window, false to hide it.\n\n      * windowPosition\n\nWindowPosition optional\n\nWhere to display the candidate window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setComposition()\n\nPromise\n\n    \n    \n    chrome.input.ime.setComposition(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nSet the current composition. If this extension does not own the active IME,\nthis fails.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * contextID\n\nnumber\n\nID of the context where the composition text will be set\n\n    * cursor\n\nnumber\n\nPosition in the text of the cursor.\n\n    * segments\n\nobject[] optional\n\nList of segments and their associated types.\n\n      * end\n\nnumber\n\nIndex of the character to end this segment after.\n\n      * start\n\nnumber\n\nIndex of the character to start this segment at\n\n      * style\n\nUnderlineStyle\n\nThe type of the underline to modify this segment.\n\n    * selectionEnd\n\nnumber optional\n\nPosition in the text that the selection ends at.\n\n    * selectionStart\n\nnumber optional\n\nPosition in the text that the selection starts at.\n\n    * text\n\nstring\n\nText to set\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setCursorPosition()\n\nPromise\n\n    \n    \n    chrome.input.ime.setCursorPosition(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nSet the position of the cursor in the candidate window. This is a no-op if\nthis extension does not own the active IME.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * candidateID\n\nnumber\n\nID of the candidate to select.\n\n    * contextID\n\nnumber\n\nID of the context that owns the candidate window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setMenuItems()\n\nPromise\n\n    \n    \n    chrome.input.ime.setMenuItems(  \n      parameters: MenuParameters,  \n      callback?: function,  \n    )\n\nAdds the provided menu items to the language menu when this IME is active.\n\n#### Parameters\n\n  * parameters\n\nMenuParameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### updateMenuItems()\n\nPromise\n\n    \n    \n    chrome.input.ime.updateMenuItems(  \n      parameters: MenuParameters,  \n      callback?: function,  \n    )\n\nUpdates the state of the MenuItems specified\n\n#### Parameters\n\n  * parameters\n\nMenuParameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onActivate\n\n    \n    \n    chrome.input.ime.onActivate.addListener(  \n      callback: function,  \n    )\n\nThis event is sent when an IME is activated. It signals that the IME will be\nreceiving onKeyPress events.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (engineID: string, screen: ScreenType) => void\n\n    * engineID\n\nstring\n\n    * screen\n\nScreenType\n\n### onAssistiveWindowButtonClicked\n\nChrome 85+\n\n    \n    \n    chrome.input.ime.onAssistiveWindowButtonClicked.addListener(  \n      callback: function,  \n    )\n\nThis event is sent when a button in an assistive window is clicked.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * buttonID\n\nAssistiveWindowButton\n\nThe ID of the button clicked.\n\n      * windowType\n\nAssistiveWindowType\n\nThe type of the assistive window.\n\n### onBlur\n\n    \n    \n    chrome.input.ime.onBlur.addListener(  \n      callback: function,  \n    )\n\nThis event is sent when focus leaves a text box. It is sent to all extensions\nthat are listening to this event, and enabled by the user.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (contextID: number) => void\n\n    * contextID\n\nnumber\n\n### onCandidateClicked\n\n    \n    \n    chrome.input.ime.onCandidateClicked.addListener(  \n      callback: function,  \n    )\n\nThis event is sent if this extension owns the active IME.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (engineID: string, candidateID: number, button: MouseButton) => void\n\n    * engineID\n\nstring\n\n    * candidateID\n\nnumber\n\n    * button\n\nMouseButton\n\n### onDeactivated\n\n    \n    \n    chrome.input.ime.onDeactivated.addListener(  \n      callback: function,  \n    )\n\nThis event is sent when an IME is deactivated. It signals that the IME will no\nlonger be receiving onKeyPress events.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (engineID: string) => void\n\n    * engineID\n\nstring\n\n### onFocus\n\n    \n    \n    chrome.input.ime.onFocus.addListener(  \n      callback: function,  \n    )\n\nThis event is sent when focus enters a text box. It is sent to all extensions\nthat are listening to this event, and enabled by the user.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (context: InputContext) => void\n\n    * context\n\nInputContext\n\n### onInputContextUpdate\n\n    \n    \n    chrome.input.ime.onInputContextUpdate.addListener(  \n      callback: function,  \n    )\n\nThis event is sent when the properties of the current InputContext change,\nsuch as the the type. It is sent to all extensions that are listening to this\nevent, and enabled by the user.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (context: InputContext) => void\n\n    * context\n\nInputContext\n\n### onKeyEvent\n\n    \n    \n    chrome.input.ime.onKeyEvent.addListener(  \n      callback: function,  \n    )\n\nFired when a key event is sent from the operating system. The event will be\nsent to the extension if this extension owns the active IME. The listener\nfunction should return true if the event was handled false if it was not. If\nthe event will be evaluated asynchronously, this function must return\nundefined and the IME must later call keyEventHandled() with the result.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (engineID: string, keyData: KeyboardEvent, requestId: string) => boolean | undefined\n\n    * engineID\n\nstring\n\n    * keyData\n\nKeyboardEvent\n\n    * requestId\n\nstring\n\n    * returns\n\nboolean | undefined\n\n### onMenuItemActivated\n\n    \n    \n    chrome.input.ime.onMenuItemActivated.addListener(  \n      callback: function,  \n    )\n\nCalled when the user selects a menu item\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (engineID: string, name: string) => void\n\n    * engineID\n\nstring\n\n    * name\n\nstring\n\n### onReset\n\n    \n    \n    chrome.input.ime.onReset.addListener(  \n      callback: function,  \n    )\n\nThis event is sent when chrome terminates ongoing text input session.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (engineID: string) => void\n\n    * engineID\n\nstring\n\n### onSurroundingTextChanged\n\n    \n    \n    chrome.input.ime.onSurroundingTextChanged.addListener(  \n      callback: function,  \n    )\n\nCalled when the editable string around caret is changed or when the caret\nposition is moved. The text length is limited to 100 characters for each back\nand forth direction.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (engineID: string, surroundingInfo: object) => void\n\n    * engineID\n\nstring\n\n    * surroundingInfo\n\nobject\n\n      * anchor\n\nnumber\n\nThe beginning position of the selection. This value indicates caret position\nif there is no selection.\n\n      * focus\n\nnumber\n\nThe ending position of the selection. This value indicates caret position if\nthere is no selection.\n\n      * offset\n\nnumber\n\nChrome 46+\n\nThe offset position of `text`. Since `text` only includes a subset of text\naround the cursor, offset indicates the absolute position of the first\ncharacter of `text`.\n\n      * text\n\nstring\n\nThe text around the cursor. This is only a subset of all text in the input\nfield.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/instanceID": "#  chrome.instanceID\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse `chrome.instanceID` to access the Instance ID service.\n\n## Permissions\n\n`gcm`  \n\n## Availability\n\nChrome 44+\n\n## Methods\n\n### deleteID()\n\nPromise\n\n    \n    \n    chrome.instanceID.deleteID(  \n      callback?: function,  \n    )\n\nResets the app instance identifier and revokes all tokens associated with it.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### deleteToken()\n\nPromise\n\n    \n    \n    chrome.instanceID.deleteToken(  \n      deleteTokenParams: object,  \n      callback?: function,  \n    )\n\nRevokes a granted token.\n\n#### Parameters\n\n  * deleteTokenParams\n\nobject\n\nParameters for deleteToken.\n\n    * authorizedEntity\n\nstring\n\nChrome 46+\n\nThe authorized entity that is used to obtain the token.\n\n    * scope\n\nstring\n\nChrome 46+\n\nThe scope that is used to obtain the token.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getCreationTime()\n\nPromise\n\n    \n    \n    chrome.instanceID.getCreationTime(  \n      callback?: function,  \n    )\n\nRetrieves the time when the InstanceID has been generated. The creation time\nwill be returned by the `callback`.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (creationTime: number) => void\n\n    * creationTime\n\nnumber\n\nThe time when the Instance ID has been generated, represented in milliseconds\nsince the epoch.\n\n#### Returns\n\n  * Promise<number>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getID()\n\nPromise\n\n    \n    \n    chrome.instanceID.getID(  \n      callback?: function,  \n    )\n\nRetrieves an identifier for the app instance. The instance ID will be returned\nby the `callback`. The same ID will be returned as long as the application\nidentity has not been revoked or expired.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (instanceID: string) => void\n\n    * instanceID\n\nstring\n\nAn Instance ID assigned to the app instance.\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getToken()\n\nPromise\n\n    \n    \n    chrome.instanceID.getToken(  \n      getTokenParams: object,  \n      callback?: function,  \n    )\n\nReturn a token that allows the authorized entity to access the service defined\nby scope.\n\n#### Parameters\n\n  * getTokenParams\n\nobject\n\nParameters for getToken.\n\n    * authorizedEntity\n\nstring\n\nChrome 46+\n\nIdentifies the entity that is authorized to access resources associated with\nthis Instance ID. It can be a project ID from Google developer console.\n\n    * options\n\nobject optional\n\nChrome 46+  Deprecated since Chrome 89\n\noptions are deprecated and will be ignored.\n\nAllows including a small number of string key/value pairs that will be\nassociated with the token and may be used in processing the request.\n\n    * scope\n\nstring\n\nChrome 46+\n\nIdentifies authorized actions that the authorized entity can take. E.g. for\nsending GCM messages, `GCM` scope should be used.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (token: string) => void\n\n    * token\n\nstring\n\nA token assigned by the requested service.\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onTokenRefresh\n\n    \n    \n    chrome.instanceID.onTokenRefresh.addListener(  \n      callback: function,  \n    )\n\nFired when all the granted tokens need to be refreshed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/loginState": "#  chrome.loginState\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.loginState` API to read and monitor the login state.\n\n## Permissions\n\n`loginState`  \n\n## Availability\n\nChrome 78+  ChromeOS only\n\n## Types\n\n### ProfileType\n\n#### Enum\n\n\"SIGNIN_PROFILE\"  \nSpecifies that the extension is in the signin profile.\n\n\"USER_PROFILE\"  \nSpecifies that the extension is in the user profile.\n\n### SessionState\n\n#### Enum\n\n\"UNKNOWN\"  \nSpecifies that the session state is unknown.\n\n\"IN_OOBE_SCREEN\"  \nSpecifies that the user is in the out-of-box-experience screen.\n\n\"IN_LOGIN_SCREEN\"  \nSpecifies that the user is in the login screen.\n\n\"IN_SESSION\"  \nSpecifies that the user is in the session.\n\n\"IN_LOCK_SCREEN\"  \nSpecifies that the user is in the lock screen.\n\n\"IN_RMA_SCREEN\"  \nSpecifies that the device is in RMA mode, finalizing repairs.\n\n## Methods\n\n### getProfileType()\n\nPromise\n\n    \n    \n    chrome.loginState.getProfileType(  \n      callback?: function,  \n    )\n\nGets the type of the profile the extension is in.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ProfileType) => void\n\n    * result\n\nProfileType\n\n#### Returns\n\n  * Promise<ProfileType>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getSessionState()\n\nPromise\n\n    \n    \n    chrome.loginState.getSessionState(  \n      callback?: function,  \n    )\n\nGets the current session state.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: SessionState) => void\n\n    * result\n\nSessionState\n\n#### Returns\n\n  * Promise<SessionState>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onSessionStateChanged\n\n    \n    \n    chrome.loginState.onSessionStateChanged.addListener(  \n      callback: function,  \n    )\n\nDispatched when the session state changes. `sessionState` is the new session\nstate.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (sessionState: SessionState) => void\n\n    * sessionState\n\nSessionState\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/management": "#  chrome.management\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.management` API provides ways to manage installed apps and\nextensions.\n\n## Permissions\n\n`management`  \n\nYou must declare the \"management\" permission in the extension manifest to use\nthe management API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"management\"\n      ],\n      ...\n    }\n    \n\n`management.getPermissionWarningsByManifest()`, `management.uninstallSelf()`,\nand `management.getSelf()` do not require the management permission.\n\n## Types\n\n### ExtensionDisabledReason\n\nChrome 44+\n\nA reason the item is disabled.\n\n#### Enum\n\n\"unknown\"  \n\n\"permissions_increase\"  \n\n### ExtensionInfo\n\nInformation about an installed extension, app, or theme.\n\n#### Properties\n\n  * appLaunchUrl\n\nstring optional\n\nThe launch url (only present for apps).\n\n  * availableLaunchTypes\n\nLaunchType[] optional\n\nThe currently available launch types (only present for apps).\n\n  * description\n\nstring\n\nThe description of this extension, app, or theme.\n\n  * disabledReason\n\nExtensionDisabledReason optional\n\nA reason the item is disabled.\n\n  * enabled\n\nboolean\n\nWhether it is currently enabled or disabled.\n\n  * homepageUrl\n\nstring optional\n\nThe URL of the homepage of this extension, app, or theme.\n\n  * hostPermissions\n\nstring[]\n\nReturns a list of host based permissions.\n\n  * icons\n\nIconInfo[] optional\n\nA list of icon information. Note that this just reflects what was declared in\nthe manifest, and the actual image at that url may be larger or smaller than\nwhat was declared, so you might consider using explicit width and height\nattributes on img tags referencing these images. See the manifest\ndocumentation on icons for more details.\n\n  * id\n\nstring\n\nThe extension's unique identifier.\n\n  * installType\n\nExtensionInstallType\n\nHow the extension was installed.\n\n  * isApp\n\nboolean\n\nDeprecated\n\nPlease use `management.ExtensionInfo.type`.\n\nTrue if this is an app.\n\n  * launchType\n\nLaunchType optional\n\nThe app launch type (only present for apps).\n\n  * mayDisable\n\nboolean\n\nWhether this extension can be disabled or uninstalled by the user.\n\n  * mayEnable\n\nboolean optional\n\nChrome 62+\n\nWhether this extension can be enabled by the user. This is only returned for\nextensions which are not enabled.\n\n  * name\n\nstring\n\nThe name of this extension, app, or theme.\n\n  * offlineEnabled\n\nboolean\n\nWhether the extension, app, or theme declares that it supports offline.\n\n  * optionsUrl\n\nstring\n\nThe url for the item's options page, if it has one.\n\n  * permissions\n\nstring[]\n\nReturns a list of API based permissions.\n\n  * shortName\n\nstring\n\nA short version of the name of this extension, app, or theme.\n\n  * type\n\nExtensionType\n\nThe type of this extension, app, or theme.\n\n  * updateUrl\n\nstring optional\n\nThe update URL of this extension, app, or theme.\n\n  * version\n\nstring\n\nThe version of this extension, app, or theme.\n\n  * versionName\n\nstring optional\n\nChrome 50+\n\nThe version name of this extension, app, or theme if the manifest specified\none.\n\n### ExtensionInstallType\n\nChrome 44+\n\nHow the extension was installed. One of `admin`: The extension was installed\nbecause of an administrative policy, `development`: The extension was loaded\nunpacked in developer mode, `normal`: The extension was installed normally via\na .crx file, `sideload`: The extension was installed by other software on the\nmachine, `other`: The extension was installed by other means.\n\n#### Enum\n\n\"admin\"  \n\n\"development\"  \n\n\"normal\"  \n\n\"sideload\"  \n\n\"other\"  \n\n### ExtensionType\n\nChrome 44+\n\nThe type of this extension, app, or theme.\n\n#### Enum\n\n\"extension\"  \n\n\"hosted_app\"  \n\n\"packaged_app\"  \n\n\"legacy_packaged_app\"  \n\n\"theme\"  \n\n\"login_screen_extension\"  \n\n### IconInfo\n\nInformation about an icon belonging to an extension, app, or theme.\n\n#### Properties\n\n  * size\n\nnumber\n\nA number representing the width and height of the icon. Likely values include\n(but are not limited to) 128, 48, 24, and 16.\n\n  * url\n\nstring\n\nThe URL for this icon image. To display a grayscale version of the icon (to\nindicate that an extension is disabled, for example), append `?grayscale=true`\nto the URL.\n\n### LaunchType\n\nThese are all possible app launch types.\n\n#### Enum\n\n\"OPEN_AS_REGULAR_TAB\"  \n\n\"OPEN_AS_PINNED_TAB\"  \n\n\"OPEN_AS_WINDOW\"  \n\n\"OPEN_FULL_SCREEN\"  \n\n### UninstallOptions\n\nChrome 88+\n\nOptions for how to handle the extension's uninstallation.\n\n#### Properties\n\n  * showConfirmDialog\n\nboolean optional\n\nWhether or not a confirm-uninstall dialog should prompt the user. Defaults to\nfalse for self uninstalls. If an extension uninstalls another extension, this\nparameter is ignored and the dialog is always shown.\n\n## Methods\n\n### createAppShortcut()\n\nPromise\n\n    \n    \n    chrome.management.createAppShortcut(  \n      id: string,  \n      callback?: function,  \n    )\n\nDisplay options to create shortcuts for an app. On Mac, only packaged app\nshortcuts can be created.\n\n#### Parameters\n\n  * id\n\nstring\n\nThis should be the id from an app item of `management.ExtensionInfo`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### generateAppForLink()\n\nPromise\n\n    \n    \n    chrome.management.generateAppForLink(  \n      url: string,  \n      title: string,  \n      callback?: function,  \n    )\n\nGenerate an app for a URL. Returns the generated bookmark app.\n\n#### Parameters\n\n  * url\n\nstring\n\nThe URL of a web page. The scheme of the URL can only be \"http\" or \"https\".\n\n  * title\n\nstring\n\nThe title of the generated app.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ExtensionInfo) => void\n\n    * result\n\nExtensionInfo\n\n#### Returns\n\n  * Promise<ExtensionInfo>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### get()\n\nPromise\n\n    \n    \n    chrome.management.get(  \n      id: string,  \n      callback?: function,  \n    )\n\nReturns information about the installed extension, app, or theme that has the\ngiven ID.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe ID from an item of `management.ExtensionInfo`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ExtensionInfo) => void\n\n    * result\n\nExtensionInfo\n\n#### Returns\n\n  * Promise<ExtensionInfo>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.management.getAll(  \n      callback?: function,  \n    )\n\nReturns a list of information about installed extensions and apps.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ExtensionInfo[]) => void\n\n    * result\n\nExtensionInfo[]\n\n#### Returns\n\n  * Promise<ExtensionInfo[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPermissionWarningsById()\n\nPromise\n\n    \n    \n    chrome.management.getPermissionWarningsById(  \n      id: string,  \n      callback?: function,  \n    )\n\nReturns a list of permission warnings for the given extension id.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe ID of an already installed extension.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (permissionWarnings: string[]) => void\n\n    * permissionWarnings\n\nstring[]\n\n#### Returns\n\n  * Promise<string[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPermissionWarningsByManifest()\n\nPromise\n\n    \n    \n    chrome.management.getPermissionWarningsByManifest(  \n      manifestStr: string,  \n      callback?: function,  \n    )\n\nReturns a list of permission warnings for the given extension manifest string.\nNote: This function can be used without requesting the 'management' permission\nin the manifest.\n\n#### Parameters\n\n  * manifestStr\n\nstring\n\nExtension manifest JSON string.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (permissionWarnings: string[]) => void\n\n    * permissionWarnings\n\nstring[]\n\n#### Returns\n\n  * Promise<string[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getSelf()\n\nPromise\n\n    \n    \n    chrome.management.getSelf(  \n      callback?: function,  \n    )\n\nReturns information about the calling extension, app, or theme. Note: This\nfunction can be used without requesting the 'management' permission in the\nmanifest.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ExtensionInfo) => void\n\n    * result\n\nExtensionInfo\n\n#### Returns\n\n  * Promise<ExtensionInfo>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### installReplacementWebApp()\n\nPromise Chrome 77+\n\n    \n    \n    chrome.management.installReplacementWebApp(  \n      callback?: function,  \n    )\n\nLaunches the replacement_web_app specified in the manifest. Prompts the user\nto install if not already installed.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### launchApp()\n\nPromise\n\n    \n    \n    chrome.management.launchApp(  \n      id: string,  \n      callback?: function,  \n    )\n\nLaunches an application.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe extension id of the application.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setEnabled()\n\nPromise\n\n    \n    \n    chrome.management.setEnabled(  \n      id: string,  \n      enabled: boolean,  \n      callback?: function,  \n    )\n\nEnables or disables an app or extension. In most cases this function must be\ncalled in the context of a user gesture (e.g. an onclick handler for a\nbutton), and may present the user with a native confirmation UI as a way of\npreventing abuse.\n\n#### Parameters\n\n  * id\n\nstring\n\nThis should be the id from an item of `management.ExtensionInfo`.\n\n  * enabled\n\nboolean\n\nWhether this item should be enabled or disabled.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setLaunchType()\n\nPromise\n\n    \n    \n    chrome.management.setLaunchType(  \n      id: string,  \n      launchType: LaunchType,  \n      callback?: function,  \n    )\n\nSet the launch type of an app.\n\n#### Parameters\n\n  * id\n\nstring\n\nThis should be the id from an app item of `management.ExtensionInfo`.\n\n  * launchType\n\nLaunchType\n\nThe target launch type. Always check and make sure this launch type is in\n`ExtensionInfo.availableLaunchTypes`, because the available launch types vary\non different platforms and configurations.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### uninstall()\n\nPromise\n\n    \n    \n    chrome.management.uninstall(  \n      id: string,  \n      options?: UninstallOptions,  \n      callback?: function,  \n    )\n\nUninstalls a currently installed app or extension. Note: This function does\nnot work in managed environments when the user is not allowed to uninstall the\nspecified extension/app. If the uninstall fails (e.g. the user cancels the\ndialog) the promise will be rejected or the callback will be called with\n`runtime.lastError` set.\n\n#### Parameters\n\n  * id\n\nstring\n\nThis should be the id from an item of `management.ExtensionInfo`.\n\n  * options\n\nUninstallOptions optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### uninstallSelf()\n\nPromise\n\n    \n    \n    chrome.management.uninstallSelf(  \n      options?: UninstallOptions,  \n      callback?: function,  \n    )\n\nUninstalls the calling extension. Note: This function can be used without\nrequesting the 'management' permission in the manifest. This function does not\nwork in managed environments when the user is not allowed to uninstall the\nspecified extension/app.\n\n#### Parameters\n\n  * options\n\nUninstallOptions optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onDisabled\n\n    \n    \n    chrome.management.onDisabled.addListener(  \n      callback: function,  \n    )\n\nFired when an app or extension has been disabled.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (info: ExtensionInfo) => void\n\n    * info\n\nExtensionInfo\n\n### onEnabled\n\n    \n    \n    chrome.management.onEnabled.addListener(  \n      callback: function,  \n    )\n\nFired when an app or extension has been enabled.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (info: ExtensionInfo) => void\n\n    * info\n\nExtensionInfo\n\n### onInstalled\n\n    \n    \n    chrome.management.onInstalled.addListener(  \n      callback: function,  \n    )\n\nFired when an app or extension has been installed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (info: ExtensionInfo) => void\n\n    * info\n\nExtensionInfo\n\n### onUninstalled\n\n    \n    \n    chrome.management.onUninstalled.addListener(  \n      callback: function,  \n    )\n\nFired when an app or extension has been uninstalled.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string) => void\n\n    * id\n\nstring\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/notifications": "#  chrome.notifications\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.notifications` API to create rich notifications using\ntemplates and show these notifications to users in the system tray.\n\n## Permissions\n\n`notifications`  \n\n## Types\n\n### NotificationBitmap\n\n### NotificationButton\n\n#### Properties\n\n  * iconUrl\n\nstring optional\n\nDeprecated since Chrome 59\n\nButton icons not visible for Mac OS X users.\n\n  * title\n\nstring\n\n### NotificationItem\n\n#### Properties\n\n  * message\n\nstring\n\nAdditional details about this item.\n\n  * title\n\nstring\n\nTitle of one item of a list notification.\n\n### NotificationOptions\n\n#### Properties\n\n  * appIconMaskUrl\n\nstring optional\n\nDeprecated since Chrome 59\n\nThe app icon mask is not visible for Mac OS X users.\n\nA URL to the app icon mask. URLs have the same restrictions as iconUrl.\n\nThe app icon mask should be in alpha channel, as only the alpha channel of the\nimage will be considered.\n\n  * buttons\n\nNotificationButton[] optional\n\nText and icons for up to two notification action buttons.\n\n  * contextMessage\n\nstring optional\n\nAlternate notification content with a lower-weight font.\n\n  * eventTime\n\nnumber optional\n\nA timestamp associated with the notification, in milliseconds past the epoch\n(e.g. `Date.now() + n`).\n\n  * iconUrl\n\nstring optional\n\nA URL to the sender's avatar, app icon, or a thumbnail for image\nnotifications.\n\nURLs can be a data URL, a blob URL, or a URL relative to a resource within\nthis extension's .crx file\n\n**Note:**This value is required for the `notifications.create``()` method.\n\n  * imageUrl\n\nstring optional\n\nDeprecated since Chrome 59\n\nThe image is not visible for Mac OS X users.\n\nA URL to the image thumbnail for image-type notifications. URLs have the same\nrestrictions as iconUrl.\n\n  * isClickable\n\nboolean optional\n\nDeprecated since Chrome 67\n\nThis UI hint is ignored as of Chrome 67\n\n  * items\n\nNotificationItem[] optional\n\nItems for multi-item notifications. Users on Mac OS X only see the first item.\n\n  * message\n\nstring optional\n\nMain notification content.\n\n**Note:**This value is required for the `notifications.create``()` method.\n\n  * priority\n\nnumber optional\n\nPriority ranges from -2 to 2. -2 is lowest priority. 2 is highest. Zero is\ndefault. On platforms that don't support a notification center (Windows, Linux\n& Mac), -2 and -1 result in an error as notifications with those priorities\nwill not be shown at all.\n\n  * progress\n\nnumber optional\n\nCurrent progress ranges from 0 to 100.\n\n  * requireInteraction\n\nboolean optional\n\nChrome 50+\n\nIndicates that the notification should remain visible on screen until the user\nactivates or dismisses the notification. This defaults to false.\n\n  * silent\n\nboolean optional\n\nChrome 70+\n\nIndicates that no sounds or vibrations should be made when the notification is\nbeing shown. This defaults to false.\n\n  * title\n\nstring optional\n\nTitle of the notification (e.g. sender name for email).\n\n**Note:**This value is required for the `notifications.create``()` method.\n\n  * type\n\nTemplateType optional\n\nWhich type of notification to display. _Required for`notifications.create`_\nmethod.\n\n### PermissionLevel\n\n#### Enum\n\n\"granted\"  \nSpecifies that the user has elected to show notifications from the app or\nextension. This is the default at install time.\n\n\"denied\"  \nSpecifies that the user has elected not to show notifications from the app or\nextension.\n\n### TemplateType\n\n#### Enum\n\n\"basic\"  \nContains an icon, title, message, expandedMessage, and up to two buttons.\n\n\"image\"  \nContains an icon, title, message, expandedMessage, image, and up to two\nbuttons.\n\n\"list\"  \nContains an icon, title, message, items, and up to two buttons. Users on Mac\nOS X only see the first item.\n\n\"progress\"  \nContains an icon, title, message, progress, and up to two buttons.\n\n## Methods\n\n### clear()\n\nPromise\n\n    \n    \n    chrome.notifications.clear(  \n      notificationId: string,  \n      callback?: function,  \n    )\n\nClears the specified notification.\n\n#### Parameters\n\n  * notificationId\n\nstring\n\nThe id of the notification to be cleared. This is returned by\n`notifications.create` method.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (wasCleared: boolean) => void\n\n    * wasCleared\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### create()\n\nPromise\n\n    \n    \n    chrome.notifications.create(  \n      notificationId?: string,  \n      options: NotificationOptions,  \n      callback?: function,  \n    )\n\nCreates and displays a notification.\n\n#### Parameters\n\n  * notificationId\n\nstring optional\n\nIdentifier of the notification. If not set or empty, an ID will automatically\nbe generated. If it matches an existing notification, this method first clears\nthat notification before proceeding with the create operation. The identifier\nmay not be longer than 500 characters.\n\nThe `notificationId` parameter is required before Chrome 42.\n\n  * options\n\nNotificationOptions\n\nContents of the notification.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (notificationId: string) => void\n\n    * notificationId\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.notifications.getAll(  \n      callback?: function,  \n    )\n\nRetrieves all the notifications of this app or extension.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (notifications: object) => void\n\n    * notifications\n\nobject\n\n#### Returns\n\n  * Promise<object>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPermissionLevel()\n\nPromise\n\n    \n    \n    chrome.notifications.getPermissionLevel(  \n      callback?: function,  \n    )\n\nRetrieves whether the user has enabled notifications from this app or\nextension.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (level: PermissionLevel) => void\n\n    * level\n\nPermissionLevel\n\n#### Returns\n\n  * Promise<PermissionLevel>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### update()\n\nPromise\n\n    \n    \n    chrome.notifications.update(  \n      notificationId: string,  \n      options: NotificationOptions,  \n      callback?: function,  \n    )\n\nUpdates an existing notification.\n\n#### Parameters\n\n  * notificationId\n\nstring\n\nThe id of the notification to be updated. This is returned by\n`notifications.create` method.\n\n  * options\n\nNotificationOptions\n\nContents of the notification to update to.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (wasUpdated: boolean) => void\n\n    * wasUpdated\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onButtonClicked\n\n    \n    \n    chrome.notifications.onButtonClicked.addListener(  \n      callback: function,  \n    )\n\nThe user pressed a button in the notification.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (notificationId: string, buttonIndex: number) => void\n\n    * notificationId\n\nstring\n\n    * buttonIndex\n\nnumber\n\n### onClicked\n\n    \n    \n    chrome.notifications.onClicked.addListener(  \n      callback: function,  \n    )\n\nThe user clicked in a non-button area of the notification.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (notificationId: string) => void\n\n    * notificationId\n\nstring\n\n### onClosed\n\n    \n    \n    chrome.notifications.onClosed.addListener(  \n      callback: function,  \n    )\n\nThe notification closed, either by the system or by user action.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (notificationId: string, byUser: boolean) => void\n\n    * notificationId\n\nstring\n\n    * byUser\n\nboolean\n\n### onPermissionLevelChanged\n\n    \n    \n    chrome.notifications.onPermissionLevelChanged.addListener(  \n      callback: function,  \n    )\n\nThe user changes the permission level. As of Chrome 47, only ChromeOS has UI\nthat dispatches this event.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (level: PermissionLevel) => void\n\n    * level\n\nPermissionLevel\n\n### onShowSettings\n\nDeprecated since Chrome 65\n\n    \n    \n    chrome.notifications.onShowSettings.addListener(  \n      callback: function,  \n    )\n\nCustom notification settings button is no longer supported.\n\nThe user clicked on a link for the app's notification settings. As of Chrome\n47, only ChromeOS has UI that dispatches this event. As of Chrome 65, that UI\nhas been removed from ChromeOS, too.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/offscreen": "#  chrome.offscreen\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `offscreen` API to create and manage offscreen documents.\n\n## Permissions\n\n`offscreen`  \n\nTo use the Offscreen API, declare the `\"offscreen\"` permission in the\nextension manifest. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"offscreen\"\n      ],\n      ...\n    }\n    \n\n## Availability\n\nChrome 109+ MV3+\n\n## Concepts and usage\n\nService workers don't have DOM access, and many websites have content security\npolicies that limit the functionality of content scripts. The Offscreen API\nallows the extension to use DOM APIs in a hidden document without interrupting\nthe user experience by opening new windows or tabs. The `runtime` API is the\nonly extensions API supported by offscreen documents.\n\nPages loaded as offscreen documents are handled differently from other types\nof extension pages. The extension's permissions carry over to offscreen\ndocuments, but with limits on extension API access. For example, because the\n`chrome.runtime` API is the only extensions API supported by offscreen\ndocuments, messaging must be handled using members of that API.\n\nThe following are other ways offscreen documents behave differently from\nnormal pages:\n\n  * An offscreen document's URL must be a static HTML file bundled with the extension.\n  * Offscreen documents can't be focused.\n  * An offscreen document is an instance of `window`, but the value of its `opener` property is always `null`.\n  * Though an extension package can contain multiple offscreen documents, an installed extension can only have one open at a time. If the extension is running in split mode with an active incognito profile, the normal and incognito profiles can each have one offscreen document.\n\nUse `chrome.offscreen.createDocument()` and `chrome.offscreen.closeDocument()`\nto create and close an offscreen document. `createDocument()` requires the\ndocument's `url`, a reason, and a justification:\n\n    \n    \n    chrome.offscreen.createDocument({\n      url: 'off_screen.html',\n      reasons: ['CLIPBOARD'],\n      justification: 'reason for needing the document',\n    });\n    \n\n### Reasons\n\nFor a list of valid reasons, see the Reasons section. Reasons are set during\ndocument creation to determine the document's lifespan. The `AUDIO_PLAYBACK`\nreason sets the document to close after 30 seconds without audio playing. All\nother reasons don't set lifetime limits.\n\n## Examples\n\n### Maintain the lifecycle of an offscreen document\n\nThe following example shows how to ensure that an offscreen document exists.\nThe `setupOffscreenDocument()` function calls `runtime.getContexts()` to find\nan existing offscreen document, or creates the document if it doesn't already\nexist.\n\n    \n    \n    let creating; // A global promise to avoid concurrency issues\n    async function setupOffscreenDocument(path) {\n      // Check all windows controlled by the service worker to see if one\n      // of them is the offscreen document with the given path\n      const offscreenUrl = chrome.runtime.getURL(path);\n      const existingContexts = await chrome.runtime.getContexts({\n        contextTypes: ['OFFSCREEN_DOCUMENT'],\n        documentUrls: [offscreenUrl]\n      });\n    \n      if (existingContexts.length > 0) {\n        return;\n      }\n    \n      // create offscreen document\n      if (creating) {\n        await creating;\n      } else {\n        creating = chrome.offscreen.createDocument({\n          url: path,\n          reasons: ['CLIPBOARD'],\n          justification: 'reason for needing the document',\n        });\n        await creating;\n        creating = null;\n      }\n    }\n    \n\nBefore sending a message to an offscreen document, call\n`setupOffscreenDocument()` to make sure the document exists, as demonstrated\nin the following example.\n\n    \n    \n    chrome.action.onClicked.addListener(async () => {\n      await setupOffscreenDocument('off_screen.html');\n    \n      // Send message to offscreen document\n      chrome.runtime.sendMessage({\n        type: '...',\n        target: 'offscreen',\n        data: '...'\n      });\n    });\n    \n\nFor complete examples, see the offscreen-clipboard and offscreen-dom demos on\nGitHub.\n\n### Before Chrome 116: check if an offscreen document is open\n\n`runtime.getContexts()` was added in Chrome 116. In earlier versions of\nChrome, use `clients.matchAll()` to check for an existing offscreen document:\n\n    \n    \n    async function hasOffscreenDocument() {\n      if ('getContexts' in chrome.runtime) {\n        const contexts = await chrome.runtime.getContexts({\n          contextTypes: ['OFFSCREEN_DOCUMENT'],\n          documentUrls: [OFFSCREEN_DOCUMENT_PATH]\n        });\n        return Boolean(contexts.length);\n      } else {\n        const matchedClients = await clients.matchAll();\n        return matchedClients.some(client => {\n          return client.url.includes(chrome.runtime.id);\n        });\n      }\n    }\n    \n\n## Types\n\n### CreateParameters\n\n#### Properties\n\n  * justification\n\nstring\n\nA developer-provided string that explains, in more detail, the need for the\nbackground context. The user agent _may_ use this in display to the user.\n\n  * reasons\n\nReason[]\n\nThe reason(s) the extension is creating the offscreen document.\n\n  * url\n\nstring\n\nThe (relative) URL to load in the document.\n\n### Reason\n\n#### Enum\n\n\"TESTING\"  \nA reason used for testing purposes only.\n\n\"AUDIO_PLAYBACK\"  \nSpecifies that the offscreen document is responsible for playing audio.\n\n\"IFRAME_SCRIPTING\"  \nSpecifies that the offscreen document needs to embed and script an iframe in\norder to modify the iframe's content.\n\n\"DOM_SCRAPING\"  \nSpecifies that the offscreen document needs to embed an iframe and scrape its\nDOM to extract information.\n\n\"BLOBS\"  \nSpecifies that the offscreen document needs to interact with Blob objects\n(including `URL.createObjectURL()`).\n\n\"DOM_PARSER\"  \nSpecifies that the offscreen document needs to use the DOMParser API.\n\n\"USER_MEDIA\"  \nSpecifies that the offscreen document needs to interact with media streams\nfrom user media (e.g. `getUserMedia()`).\n\n\"DISPLAY_MEDIA\"  \nSpecifies that the offscreen document needs to interact with media streams\nfrom display media (e.g. `getDisplayMedia()`).\n\n\"WEB_RTC\"  \nSpecifies that the offscreen document needs to use WebRTC APIs.\n\n\"CLIPBOARD\"  \nSpecifies that the offscreen document needs to interact with the Clipboard\nAPI.\n\n\"LOCAL_STORAGE\"  \nSpecifies that the offscreen document needs access to localStorage.\n\n\"WORKERS\"  \nSpecifies that the offscreen document needs to spawn workers.\n\n\"BATTERY_STATUS\"  \nSpecifies that the offscreen document needs to use navigator.getBattery.\n\n\"MATCH_MEDIA\"  \nSpecifies that the offscreen document needs to use window.matchMedia.\n\n\"GEOLOCATION\"  \nSpecifies that the offscreen document needs to use navigator.geolocation.\n\n## Methods\n\n### closeDocument()\n\nPromise\n\n    \n    \n    chrome.offscreen.closeDocument(  \n      callback?: function,  \n    )\n\nCloses the currently-open offscreen document for the extension.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### createDocument()\n\nPromise\n\n    \n    \n    chrome.offscreen.createDocument(  \n      parameters: CreateParameters,  \n      callback?: function,  \n    )\n\nCreates a new offscreen document for the extension.\n\n#### Parameters\n\n  * parameters\n\nCreateParameters\n\nThe parameters describing the offscreen document to create.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/omnibox": "#  chrome.omnibox\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe omnibox API allows you to register a keyword with Google Chrome's address\nbar, which is also known as the omnibox.\n\n![A screenshot showing suggestions related to the keyword 'Chromium\nSearch'](/static/docs/extensions/mv2/reference/omnibox/images/omnibox.png)\n\nWhen the user enters your extension's keyword, the user starts interacting\nsolely with your extension. Each keystroke is sent to your extension, and you\ncan provide suggestions in response.\n\nThe suggestions can be richly formatted in a variety of ways. When the user\naccepts a suggestion, your extension is notified and can take action.\n\n## Manifest\n\nThe following keys must be declared in the manifest to use this API.\n\n`\"omnibox\"`  \n\nYou must include an `\"omnibox.keyword\"` field in the manifest to use the\nomnibox API. You should also specify a 16 by 16-pixel icon, which will be\ndisplayed in the address bar when suggesting that users enter keyword mode.\n\nFor example:\n\n    \n    \n    {\n      \"name\": \"Aaron's omnibox extension\",\n      \"version\": \"1.0\",\n      \"omnibox\": { \"keyword\" : \"aaron\" },\n      \"icons\": {\n        \"16\": \"16-full-color.png\"\n      },\n      \"background\": {\n        \"persistent\": false,\n        \"scripts\": [\"background.js\"]\n      }\n    }\n    \n\n**Note:** Chrome automatically creates a grayscale version of your 16x16-pixel\nicon. You should provide a full-color version so that it can also be used in\nother situations that require color. For example, the context menus API also\nuses a 16x16-pixel icon, but it is displayed in color.\n\n## Examples\n\nTo try this API, install the omnibox API example from the chrome-extension-\nsamples repository.\n\n## Types\n\n### DefaultSuggestResult\n\nA suggest result.\n\n#### Properties\n\n  * description\n\nstring\n\nThe text that is displayed in the URL dropdown. Can contain XML-style markup\nfor styling. The supported tags are 'url' (for a literal URL), 'match' (for\nhighlighting text that matched what the user's query), and 'dim' (for dim\nhelper text). The styles can be nested, eg. dimmed match.\n\n### DescriptionStyleType\n\nChrome 44+\n\nThe style type.\n\n#### Enum\n\n\"url\"  \n\n\"match\"  \n\n\"dim\"  \n\n### OnInputEnteredDisposition\n\nChrome 44+\n\nThe window disposition for the omnibox query. This is the recommended context\nto display results. For example, if the omnibox command is to navigate to a\ncertain URL, a disposition of 'newForegroundTab' means the navigation should\ntake place in a new selected tab.\n\n#### Enum\n\n\"currentTab\"  \n\n\"newForegroundTab\"  \n\n\"newBackgroundTab\"  \n\n### SuggestResult\n\nA suggest result.\n\n#### Properties\n\n  * content\n\nstring\n\nThe text that is put into the URL bar, and that is sent to the extension when\nthe user chooses this entry.\n\n  * deletable\n\nboolean optional\n\nChrome 63+\n\nWhether the suggest result can be deleted by the user.\n\n  * description\n\nstring\n\nThe text that is displayed in the URL dropdown. Can contain XML-style markup\nfor styling. The supported tags are 'url' (for a literal URL), 'match' (for\nhighlighting text that matched what the user's query), and 'dim' (for dim\nhelper text). The styles can be nested, eg. dimmed match. You must escape the\nfive predefined entities to display them as text:\nstackoverflow.com/a/1091953/89484\n\n## Methods\n\n### setDefaultSuggestion()\n\nPromise\n\n    \n    \n    chrome.omnibox.setDefaultSuggestion(  \n      suggestion: DefaultSuggestResult,  \n      callback?: function,  \n    )\n\nSets the description and styling for the default suggestion. The default\nsuggestion is the text that is displayed in the first suggestion row\nunderneath the URL bar.\n\n#### Parameters\n\n  * suggestion\n\nDefaultSuggestResult\n\nA partial SuggestResult object, without the 'content' parameter.\n\n  * callback\n\nfunction optional\n\nChrome 100+\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 100+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onDeleteSuggestion\n\nChrome 63+\n\n    \n    \n    chrome.omnibox.onDeleteSuggestion.addListener(  \n      callback: function,  \n    )\n\nUser has deleted a suggested result.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (text: string) => void\n\n    * text\n\nstring\n\n### onInputCancelled\n\n    \n    \n    chrome.omnibox.onInputCancelled.addListener(  \n      callback: function,  \n    )\n\nUser has ended the keyword input session without accepting the input.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onInputChanged\n\n    \n    \n    chrome.omnibox.onInputChanged.addListener(  \n      callback: function,  \n    )\n\nUser has changed what is typed into the omnibox.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (text: string, suggest: function) => void\n\n    * text\n\nstring\n\n    * suggest\n\nfunction\n\nThe `suggest` parameter looks like:\n\n          \n          (suggestResults: SuggestResult[]) => void\n\n      * suggestResults\n\nSuggestResult[]\n\nArray of suggest results\n\n### onInputEntered\n\n    \n    \n    chrome.omnibox.onInputEntered.addListener(  \n      callback: function,  \n    )\n\nUser has accepted what is typed into the omnibox.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (text: string, disposition: OnInputEnteredDisposition) => void\n\n    * text\n\nstring\n\n    * disposition\n\nOnInputEnteredDisposition\n\n### onInputStarted\n\n    \n    \n    chrome.omnibox.onInputStarted.addListener(  \n      callback: function,  \n    )\n\nUser has started a keyword input session by typing the extension's keyword.\nThis is guaranteed to be sent exactly once per input session, and before any\nonInputChanged events.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/pageCapture": "#  chrome.pageCapture\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.pageCapture` API to save a tab as MHTML.\n\nMHTML is a standard format supported by most browsers. It encapsulates in a\nsingle file a page and all its resources (CSS files, images..).\n\nNote that for security reasons a MHTML file can only be loaded from the file\nsystem and that it can only be loaded in the main frame.\n\n## Permissions\n\n`pageCapture`  \n\nYou must declare the \"pageCapture\" permission in the extension manifest to use\nthe pageCapture API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"pageCapture\"\n      ],\n      ...\n    }\n    \n\n## Methods\n\n### saveAsMHTML()\n\nPromise\n\n    \n    \n    chrome.pageCapture.saveAsMHTML(  \n      details: object,  \n      callback?: function,  \n    )\n\nSaves the content of the tab with given id as MHTML.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * tabId\n\nnumber\n\nThe id of the tab to save as MHTML.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (mhtmlData?: Blob) => void\n\n    * mhtmlData\n\nBlob optional\n\nThe MHTML data as a Blob.\n\n#### Returns\n\n  * Promise<Blob | undefined>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/permissions": "#  chrome.permissions\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.permissions` API to request declared optional permissions at\nrun time rather than install time, so users understand why the permissions are\nneeded and grant only those that are necessary.\n\n## Concepts and usage\n\nPermission warnings exist to describe the capabilities granted by an API, but\nsome of these warnings may not be obvious. The Permissions API allows\ndevelopers to explain permission warnings and introduce new features gradually\nwhich gives users a risk-free introduction to the extension. This way, users\ncan specify how much access they are willing to grant and which features they\nwant to enable.\n\nFor example, the optional permissions extension's core functionality is\noverriding the new tab page. One feature is displaying the user's goal of the\nday. This feature only requires the storage permission, which does not include\na warning. The extension has an additional feature, that users can enable by\nclicking the following button:\n\n![An extension button that enables additional\nfeatures.](/static/docs/extensions/reference/api/permissions/images/extension-\nbutton-enables-c53fe17733b8f.png) An extension button that enables additional\nfeatures.\n\nDisplaying the user's top sites requires the topSites permission, which has\nthe following warning.\n\n![Axtension warning for topSites\nAPI.](/static/docs/extensions/reference/api/permissions/images/extension-\nwarning-topsit-8927d6b7cb863.png) An extension warning for `topSites` API\n\n### Implement optional permissions\n\n#### Step 1: Decide which permissions are required and which are optional\n\nAn extension can declare both required and optional permissions. In general,\nyou should:\n\n  * Use required permissions when they are needed for your extension's basic functionality.\n  * Use optional permissions when they are needed for optional features in your extension.\n\nAdvantages of _required_ permissions:\n\n  * **Fewer prompts:** An extension can prompt the user once to accept all permissions.\n  * **Simpler development:** Required permissions are guaranteed to be present.\n\nAdvantages of _optional_ permissions:\n\n  * **Better security:** Extensions run with fewer permissions since users only enable permissions that are needed.\n  * **Better information for users:** An extension can explain why it needs a particular permission when the user enables the relevant feature.\n  * **Easier upgrades:** When you upgrade your extension, Chrome won't disable it for your users if the upgrade adds optional rather than required permissions.\n\n#### Step 2: Declare optional permissions in the manifest\n\nDeclare optional permissions in your extension manifest with the\n`optional_permissions` key, using the same format as the permissions field:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"optional_permissions\": [\"tabs\"],\n      \"optional_host_permissions\": [\"https://www.google.com/\"],\n      ...\n    }\n    \n\nIf you want to request hosts that you only discover at runtime, include\n`\"https://*/*\"` in your extension's `optional_host_permissions` field. This\nlets you specify any origin in `\"Permissions.origins\"` as long as it has a\nmatching scheme.\n\n**Permissions that can _not_ be specified as optional**\n\nMost Chrome extension permissions can be specified as optional, with the\nfollowing exceptions.\n\nPermission | Description  \n---|---  \n`\"debugger\"` | The chrome.debugger API serves as an alternate transport for Chrome's remote debugging protocol.  \n`\"declarativeNetRequest\"` | Grants the extension access to the  chrome.declarativeNetRequest API.  \n`\"devtools\"` | Allows extension to expand Chrome DevTools functionality.  \n`\"geolocation\"` | Allows the extension to use the HTML5 geolocation API.  \n`\"mdns\"` | Grants the extension access to the chrome.mdns API.  \n`\"proxy\"` | Grants the extension access to the chrome.proxy API to manage Chrome's proxy settings.  \n`\"tts\"` | The chrome.tts API plays synthesized text-to-speech (TTS).  \n`\"ttsEngine\"` | The chrome.ttsEngine API implements a text-to-speech (TTS) engine using an extension.  \n`\"wallpaper\"` | **ChromeOS only**. Use the chrome.wallpaper API change the ChromeOS wallpaper.  \n  \nView Declare Permissions for further information on available permissions and\ntheir warnings.\n\n#### Step 3: Request optional permissions\n\nRequest the permissions from within a user gesture using\n`permissions.request()`:\n\n    \n    \n    document.querySelector('#my-button').addEventListener('click', (event) => {\n      // Permissions must be requested from inside a user gesture, like a button's\n      // click handler.\n      chrome.permissions.request({\n        permissions: ['tabs'],\n        origins: ['https://www.google.com/']\n      }, (granted) => {\n        // The callback argument will be true if the user granted the permissions.\n        if (granted) {\n          doSomething();\n        } else {\n          doSomethingElse();\n        }\n      });\n    });\n    \n\nChrome prompts the user if adding the permissions results in different warning\nmessages than the user has already seen and accepted. For example, the\nprevious code might result in a prompt like this:\n\n![An example permission confirmation\nprompt.](/static/docs/extensions/reference/api/permissions/images/perms-\noptional.png) An example permission confirmation prompt.\n\n#### Step 4: Check the extension's current permissions\n\nTo check whether your extension has a specific permission or set of\npermissions, use `permission.contains()`:\n\n    \n    \n    chrome.permissions.contains({\n      permissions: ['tabs'],\n      origins: ['https://www.google.com/']\n    }, (result) => {\n      if (result) {\n        // The extension has the permissions.\n      } else {\n        // The extension doesn't have the permissions.\n      }\n    });\n    \n\n#### Step 5: Remove the permissions\n\nYou should remove permissions when you no longer need them. After a permission\nhas been removed, calling `permissions.request()` usually adds the permission\nback without prompting the user.\n\n    \n    \n    chrome.permissions.remove({\n      permissions: ['tabs'],\n      origins: ['https://www.google.com/']\n    }, (removed) => {\n      if (removed) {\n        // The permissions have been removed.\n      } else {\n        // The permissions have not been removed (e.g., you tried to remove\n        // required permissions).\n      }\n    });\n    \n\n## Types\n\n### Permissions\n\n#### Properties\n\n  * origins\n\nstring[] optional\n\nThe list of host permissions, including those specified in the\n`optional_permissions` or `permissions` keys in the manifest, and those\nassociated with Content Scripts.\n\n  * permissions\n\nstring[] optional\n\nList of named permissions (does not include hosts or origins).\n\n## Methods\n\n### addHostAccessRequest()\n\nPromise Chrome 133+ MV3+\n\n    \n    \n    chrome.permissions.addHostAccessRequest(  \n      request: object,  \n      callback?: function,  \n    )\n\nAdds a host access request. Request will only be signaled to the user if\nextension can be granted access to the host in the request. Request will be\nreset on cross-origin navigation. When accepted, grants persistent access to\nthe sites top origin\n\n#### Parameters\n\n  * request\n\nobject\n\n    * documentId\n\nstring optional\n\nThe id of a document where host access requests can be shown. Must be the top-\nlevel document within a tab. If provided, the request is shown on the tab of\nthe specified document and is removed when the document navigates to a new\norigin. Adding a new request will override any existent request for `tabId`.\nThis or `tabId` must be specified.\n\n    * pattern\n\nstring optional\n\nThe URL pattern where host access requests can be shown. If provided, host\naccess requests will only be shown on URLs that match this pattern.\n\n    * tabId\n\nnumber optional\n\nThe id of the tab where host access requests can be shown. If provided, the\nrequest is shown on the specified tab and is removed when the tab navigates to\na new origin. Adding a new request will override an existent request for\n`documentId`. This or `documentId` must be specified.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### contains()\n\nPromise\n\n    \n    \n    chrome.permissions.contains(  \n      permissions: Permissions,  \n      callback?: function,  \n    )\n\nChecks if the extension has the specified permissions.\n\n#### Parameters\n\n  * permissions\n\nPermissions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: boolean) => void\n\n    * result\n\nboolean\n\nTrue if the extension has the specified permissions. If an origin is specified\nas both an optional permission and a content script match pattern, this will\nreturn `false` unless both permissions are granted.\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.permissions.getAll(  \n      callback?: function,  \n    )\n\nGets the extension's current set of permissions.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (permissions: Permissions) => void\n\n    * permissions\n\nPermissions\n\nThe extension's active permissions. Note that the `origins` property will\ncontain granted origins from those specified in the `permissions` and\n`optional_permissions` keys in the manifest and those associated with Content\nScripts.\n\n#### Returns\n\n  * Promise<Permissions>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### remove()\n\nPromise\n\n    \n    \n    chrome.permissions.remove(  \n      permissions: Permissions,  \n      callback?: function,  \n    )\n\nRemoves access to the specified permissions. If there are any problems\nremoving the permissions, `runtime.lastError` will be set.\n\n#### Parameters\n\n  * permissions\n\nPermissions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (removed: boolean) => void\n\n    * removed\n\nboolean\n\nTrue if the permissions were removed.\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeHostAccessRequest()\n\nPromise Chrome 133+ MV3+\n\n    \n    \n    chrome.permissions.removeHostAccessRequest(  \n      request: object,  \n      callback?: function,  \n    )\n\nRemoves a host access request, if existent.\n\n#### Parameters\n\n  * request\n\nobject\n\n    * documentId\n\nstring optional\n\nThe id of a document where host access request will be removed. Must be the\ntop-level document within a tab. This or `tabId` must be specified.\n\n    * pattern\n\nstring optional\n\nThe URL pattern where host access request will be removed. If provided, this\nmust exactly match the pattern of an existing host access request.\n\n    * tabId\n\nnumber optional\n\nThe id of the tab where host access request will be removed. This or\n`documentId` must be specified.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### request()\n\nPromise\n\n    \n    \n    chrome.permissions.request(  \n      permissions: Permissions,  \n      callback?: function,  \n    )\n\nRequests access to the specified permissions, displaying a prompt to the user\nif necessary. These permissions must either be defined in the\n`optional_permissions` field of the manifest or be required permissions that\nwere withheld by the user. Paths on origin patterns will be ignored. You can\nrequest subsets of optional origin permissions; for example, if you specify\n`*://*\\/*` in the `optional_permissions` section of the manifest, you can\nrequest `http://example.com/`. If there are any problems requesting the\npermissions, `runtime.lastError` will be set.\n\n#### Parameters\n\n  * permissions\n\nPermissions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (granted: boolean) => void\n\n    * granted\n\nboolean\n\nTrue if the user granted the specified permissions.\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onAdded\n\n    \n    \n    chrome.permissions.onAdded.addListener(  \n      callback: function,  \n    )\n\nFired when the extension acquires new permissions.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (permissions: Permissions) => void\n\n    * permissions\n\nPermissions\n\n### onRemoved\n\n    \n    \n    chrome.permissions.onRemoved.addListener(  \n      callback: function,  \n    )\n\nFired when access to permissions has been removed from the extension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (permissions: Permissions) => void\n\n    * permissions\n\nPermissions\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/platformKeys": "#  chrome.platformKeys\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.platformKeys` API to access client certificates managed by the\nplatform. If the user or policy grants the permission, an extension can use\nsuch a certficate in its custom authentication protocol. E.g. this allows\nusage of platform managed certificates in third party VPNs (see\nchrome.vpnProvider).\n\n## Permissions\n\n`platformKeys`  \n\n## Availability\n\nChrome 45+  ChromeOS only\n\n## Types\n\n### ClientCertificateRequest\n\n#### Properties\n\n  * certificateAuthorities\n\nArrayBuffer[]\n\nList of distinguished names of certificate authorities allowed by the server.\nEach entry must be a DER-encoded X.509 DistinguishedName.\n\n  * certificateTypes\n\nClientCertificateType[]\n\nThis field is a list of the types of certificates requested, sorted in order\nof the server's preference. Only certificates of a type contained in this list\nwill be retrieved. If `certificateTypes` is the empty list, however,\ncertificates of any type will be returned.\n\n### ClientCertificateType\n\n#### Enum\n\n\"rsaSign\"  \n\n\"ecdsaSign\"  \n\n### Match\n\n#### Properties\n\n  * certificate\n\nArrayBuffer\n\nThe DER encoding of a X.509 certificate.\n\n  * keyAlgorithm\n\nobject\n\nThe KeyAlgorithm of the certified key. This contains algorithm parameters that\nare inherent to the key of the certificate (e.g. the key length). Other\nparameters like the hash function used by the sign function are not included.\n\n### SelectDetails\n\n#### Properties\n\n  * clientCerts\n\nArrayBuffer[] optional\n\nIf given, the `selectClientCertificates` operates on this list. Otherwise,\nobtains the list of all certificates from the platform's certificate stores\nthat are available to this extensions. Entries that the extension doesn't have\npermission for or which doesn't match the request, are removed.\n\n  * interactive\n\nboolean\n\nIf true, the filtered list is presented to the user to manually select a\ncertificate and thereby granting the extension access to the certificate(s)\nand key(s). Only the selected certificate(s) will be returned. If is false,\nthe list is reduced to all certificates that the extension has been granted\naccess to (automatically or manually).\n\n  * request\n\nClientCertificateRequest\n\nOnly certificates that match this request will be returned.\n\n### VerificationDetails\n\n#### Properties\n\n  * hostname\n\nstring\n\nThe hostname of the server to verify the certificate for, e.g. the server that\npresented the `serverCertificateChain`.\n\n  * serverCertificateChain\n\nArrayBuffer[]\n\nEach chain entry must be the DER encoding of a X.509 certificate, the first\nentry must be the server certificate and each entry must certify the entry\npreceding it.\n\n### VerificationResult\n\n#### Properties\n\n  * debug_errors\n\nstring[]\n\nIf the trust verification failed, this array contains the errors reported by\nthe underlying network layer. Otherwise, this array is empty.\n\n**Note:** This list is meant for debugging only and may not contain all\nrelevant errors. The errors returned may change in future revisions of this\nAPI, and are not guaranteed to be forwards or backwards compatible.\n\n  * trusted\n\nboolean\n\nThe result of the trust verification: true if trust for the given verification\ndetails could be established and false if trust is rejected for any reason.\n\n## Methods\n\n### getKeyPair()\n\n    \n    \n    chrome.platformKeys.getKeyPair(  \n      certificate: ArrayBuffer,  \n      parameters: object,  \n      callback: function,  \n    )\n\nPasses the key pair of `certificate` for usage with\n`platformKeys.subtleCrypto` to `callback`.\n\n#### Parameters\n\n  * certificate\n\nArrayBuffer\n\nThe certificate of a `Match` returned by `selectClientCertificates`.\n\n  * parameters\n\nobject\n\nDetermines signature/hash algorithm parameters additionally to the parameters\nfixed by the key itself. The same parameters are accepted as by WebCrypto's\nimportKey function, e.g. `RsaHashedImportParams` for a RSASSA-PKCS1-v1_5 key\nand `EcKeyImportParams` for EC key. Additionally for RSASSA-PKCS1-v1_5 keys,\nhashing algorithm name parameter can be specified with one of the following\nvalues: \"none\", \"SHA-1\", \"SHA-256\", \"SHA-384\", or \"SHA-512\", e.g. `{\"hash\": {\n\"name\": \"none\" } }`. The sign function will then apply PKCS#1 v1.5 padding but\nnot hash the given data.\n\nCurrently, this method only supports the \"RSASSA-PKCS1-v1_5\" and \"ECDSA\"\nalgorithms.\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (publicKey: object, privateKey?: object) => void\n\n    * publicKey\n\nobject\n\n    * privateKey\n\nobject optional\n\nMight be `null` if this extension does not have access to it.\n\n### getKeyPairBySpki()\n\nChrome 85+\n\n    \n    \n    chrome.platformKeys.getKeyPairBySpki(  \n      publicKeySpkiDer: ArrayBuffer,  \n      parameters: object,  \n      callback: function,  \n    )\n\nPasses the key pair identified by `publicKeySpkiDer` for usage with\n`platformKeys.subtleCrypto` to `callback`.\n\n#### Parameters\n\n  * publicKeySpkiDer\n\nArrayBuffer\n\nA DER-encoded X.509 SubjectPublicKeyInfo, obtained e.g. by calling WebCrypto's\nexportKey function with format=\"spki\".\n\n  * parameters\n\nobject\n\nProvides signature and hash algorithm parameters, in addition to those fixed\nby the key itself. The same parameters are accepted as by WebCrypto's\nimportKey function, e.g. `RsaHashedImportParams` for a RSASSA-PKCS1-v1_5 key.\nFor RSASSA-PKCS1-v1_5 keys, we need to also pass a \"hash\" parameter `{ \"hash\":\n{ \"name\": string } }`. The \"hash\" parameter represents the name of the hashing\nalgorithm to be used in the digest operation before a sign. It is possible to\npass \"none\" as the hash name, in which case the sign function will apply\nPKCS#1 v1.5 padding and but not hash the given data.\n\nCurrently, this method supports the \"ECDSA\" algorithm with named-curve P-256\nand \"RSASSA-PKCS1-v1_5\" algorithm with one of the hashing algorithms \"none\",\n\"SHA-1\", \"SHA-256\", \"SHA-384\", and \"SHA-512\".\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (publicKey: object, privateKey?: object) => void\n\n    * publicKey\n\nobject\n\n    * privateKey\n\nobject optional\n\nMight be `null` if this extension does not have access to it.\n\n### selectClientCertificates()\n\nPromise\n\n    \n    \n    chrome.platformKeys.selectClientCertificates(  \n      details: SelectDetails,  \n      callback?: function,  \n    )\n\nThis method filters from a list of client certificates the ones that are known\nto the platform, match `request` and for which the extension has permission to\naccess the certificate and its private key. If `interactive` is true, the user\nis presented a dialog where they can select from matching certificates and\ngrant the extension access to the certificate. The selected/filtered client\ncertificates will be passed to `callback`.\n\n#### Parameters\n\n  * details\n\nSelectDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (matches: Match[]) => void\n\n    * matches\n\nMatch[]\n\nThe list of certificates that match the request, that the extension has\npermission for and, if `interactive` is true, that were selected by the user.\n\n#### Returns\n\n  * Promise<Match[]>\n\nChrome 121+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### subtleCrypto()\n\n    \n    \n    chrome.platformKeys.subtleCrypto()\n\nAn implementation of WebCrypto's SubtleCrypto that allows crypto operations on\nkeys of client certificates that are available to this extension.\n\n#### Returns\n\n  * object | undefined\n\n### verifyTLSServerCertificate()\n\nPromise\n\n    \n    \n    chrome.platformKeys.verifyTLSServerCertificate(  \n      details: VerificationDetails,  \n      callback?: function,  \n    )\n\nChecks whether `details.serverCertificateChain` can be trusted for\n`details.hostname` according to the trust settings of the platform. Note: The\nactual behavior of the trust verification is not fully specified and might\nchange in the future. The API implementation verifies certificate expiration,\nvalidates the certification path and checks trust by a known CA. The\nimplementation is supposed to respect the EKU serverAuth and to support\nsubject alternative names.\n\n#### Parameters\n\n  * details\n\nVerificationDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: VerificationResult) => void\n\n    * result\n\nVerificationResult\n\n#### Returns\n\n  * Promise<VerificationResult>\n\nChrome 121+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/power": "#  chrome.power\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.power` API to override the system's power management features.\n\n## Permissions\n\n`power`  \n\n## Concepts and usage\n\nBy default, operating systems dim the screen when users are inactive and\neventually suspend the system. With the power API, an app or extension can\nkeep the system awake.\n\nUsing this API, you can specify the Level to which power management is\ndisabled. The `\"system\"` level keeps the system active, but allows the screen\nto be dimmed or turned off. For example, a communication app can continue to\nreceive messages while the screen is off. The `\"display\"` level keeps the\nscreen and system active. E-book and presentation apps, for example, can keep\nthe screen and system active while users read.\n\nWhen a user has more than one app or extension active, each with its own power\nlevel, the highest-precedence level takes effect; `\"display\"` always takes\nprecedence over `\"system\"`. For example, if app A asks for `\"system\"` power\nmanagement, and app B asks for `\"display\"`, `\"display\"` is used until app B is\nunloaded or releases its request. If app A is still active, `\"system\"` is then\nused.\n\n## Types\n\n### Level\n\n#### Enum\n\n\"system\"  \nPrevents the system from sleeping in response to user inactivity.\n\n\"display\"  \nPrevents the display from being turned off or dimmed, or the system from\nsleeping in response to user inactivity.\n\n## Methods\n\n### releaseKeepAwake()\n\n    \n    \n    chrome.power.releaseKeepAwake()\n\nReleases a request previously made via requestKeepAwake().\n\n### reportActivity()\n\nPromise Chrome 113+  ChromeOS only\n\n    \n    \n    chrome.power.reportActivity(  \n      callback?: function,  \n    )\n\nReports a user activity in order to awake the screen from a dimmed or turned\noff state or from a screensaver. Exits the screensaver if it is currently\nactive.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### requestKeepAwake()\n\n    \n    \n    chrome.power.requestKeepAwake(  \n      level: Level,  \n    )\n\nRequests that power management be temporarily disabled. `level` describes the\ndegree to which power management should be disabled. If a request previously\nmade by the same app is still active, it will be replaced by the new request.\n\n#### Parameters\n\n  * level\n\nLevel\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/printerProvider": "#  chrome.printerProvider\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.printerProvider` API exposes events used by print manager to query\nprinters controlled by extensions, to query their capabilities and to submit\nprint jobs to these printers.\n\n## Permissions\n\n`printerProvider`  \n\n## Availability\n\nChrome 44+\n\n## Types\n\n### PrinterInfo\n\n#### Properties\n\n  * description\n\nstring optional\n\nPrinter's human readable description.\n\n  * id\n\nstring\n\nUnique printer ID.\n\n  * name\n\nstring\n\nPrinter's human readable name.\n\n### PrintError\n\nError codes returned in response to `onPrintRequested` event.\n\n#### Enum\n\n\"OK\"  \nSpecifies that the operation was completed successfully.\n\n\"FAILED\"  \nSpecifies that a general failure occured.\n\n\"INVALID_TICKET\"  \nSpecifies that the print ticket is invalid. For example, the ticket is\ninconsistent with some capabilities, or the extension is not able to handle\nall settings from the ticket.\n\n\"INVALID_DATA\"  \nSpecifies that the document is invalid. For example, data may be corrupted or\nthe format is incompatible with the extension.\n\n### PrintJob\n\n#### Properties\n\n  * contentType\n\nstring\n\nThe document content type. Supported formats are `\"application/pdf\"` and\n`\"image/pwg-raster\"`.\n\n  * document\n\nBlob\n\nBlob containing the document data to print. Format must match `contentType`.\n\n  * printerId\n\nstring\n\nID of the printer which should handle the job.\n\n  * ticket\n\nobject\n\nPrint ticket in CJT format.\n\nThe CJT reference is marked as deprecated. It is deprecated for Google Cloud\nPrint only. is not deprecated for ChromeOS printing.\n\n  * title\n\nstring\n\nThe print job title.\n\n## Events\n\n### onGetCapabilityRequested\n\n    \n    \n    chrome.printerProvider.onGetCapabilityRequested.addListener(  \n      callback: function,  \n    )\n\nEvent fired when print manager requests printer capabilities.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (printerId: string, resultCallback: function) => void\n\n    * printerId\n\nstring\n\n    * resultCallback\n\nfunction\n\nThe `resultCallback` parameter looks like:\n\n          \n          (capabilities: object) => void\n\n      * capabilities\n\nobject\n\nDevice capabilities in CDD format.\n\n### onGetPrintersRequested\n\n    \n    \n    chrome.printerProvider.onGetPrintersRequested.addListener(  \n      callback: function,  \n    )\n\nEvent fired when print manager requests printers provided by extensions.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (resultCallback: function) => void\n\n    * resultCallback\n\nfunction\n\nThe `resultCallback` parameter looks like:\n\n          \n          (printerInfo: PrinterInfo[]) => void\n\n      * printerInfo\n\nPrinterInfo[]\n\n### onGetUsbPrinterInfoRequested\n\nChrome 45+\n\n    \n    \n    chrome.printerProvider.onGetUsbPrinterInfoRequested.addListener(  \n      callback: function,  \n    )\n\nEvent fired when print manager requests information about a USB device that\nmay be a printer.\n\n_Note:_ An application should not rely on this event being fired more than\nonce per device. If a connected device is supported it should be returned in\nthe `onGetPrintersRequested` event.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (device: usb.Device, resultCallback: function) => void\n\n    * device\n\nusb.Device\n\n    * resultCallback\n\nfunction\n\nThe `resultCallback` parameter looks like:\n\n          \n          (printerInfo?: PrinterInfo) => void\n\n      * printerInfo\n\nPrinterInfo optional\n\n### onPrintRequested\n\n    \n    \n    chrome.printerProvider.onPrintRequested.addListener(  \n      callback: function,  \n    )\n\nEvent fired when print manager requests printing.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (printJob: PrintJob, resultCallback: function) => void\n\n    * printJob\n\nPrintJob\n\n    * resultCallback\n\nfunction\n\nThe `resultCallback` parameter looks like:\n\n          \n          (result: PrintError) => void\n\n      * result\n\nPrintError\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/printing": "#  chrome.printing\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.printing` API to send print jobs to printers installed on\nChromebook.\n\n## Permissions\n\n`printing`  \n\n## Availability\n\nChrome 81+  ChromeOS only\n\nAll `chrome.printing` methods and events require you to declare the\n`\"printing\"` permission in the extension manifest. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"printing\"\n      ],\n      ...\n    }\n    \n\n## Examples\n\nThe examples below demonstrate using each of the methods in the printing\nnamespace. This code is copied from or based on the api-samples/printing in\nthe extensions-samples Github repo.\n\n### cancelJob()\n\nThis example uses the `onJobStatusChanged` handler to hide a 'cancel' button\nwhen the `jobStatus` is neither `PENDING` or `IN_PROGRESS`. Note that on some\nnetworks or when a Chromebook is connected directly to the printer, these\nstates may pass too quickly for the cancel button to be visible long enough to\nbe called. This is greatly simplified printing example.\n\n    \n    \n    chrome.printing.onJobStatusChanged.addListener((jobId, status) => {\n      const cancelButton = document.getElementById(\"cancelButton\");\n      cancelButton.addEventListener('click', () => {\n        chrome.printing.cancelJob(jobId).then((response) => {\n          if (response !== undefined) {\n            console.log(response.status);\n          }\n          if (chrome.runtime.lastError !== undefined) {\n            console.log(chrome.runtime.lastError.message);\n          }\n        });\n      });\n      if (status !== \"PENDING\" && status !== \"IN_PROGRESS\") {\n        cancelButton.style.visibility = 'hidden';\n      } else {\n        cancelButton.style.visibility = 'visible';\n      }\n    }\n    \n\n### getPrinters() and getPrinterInfo()\n\nA single example is used for these functions because getting printer\ninformation requires a printer ID, which is retrieved by calling\n`getPrinters()`. This example logs the name and description of the default\nprinter to the console. This is a simplified version of the printing example.\n\n    \n    \n    const printers = await chrome.printing.getPrinters();\n    const defaultPrinter = printers.find((printer) => {\n      const printerInfo = await chrome.printing.getPrinterInfo(printer.id);\n      return printerInfo.isDefault;\n    }\n    console.log(`Default printer: ${defaultPrinter.name}.\\n\\t${defaultPrinter.description}`);\n    \n\n### submitJob()\n\nThe `submitJob()` method requires three things.\n\n  * A `ticket` structure specifying which capabilities of the printer are to be used. If the user needs to select from available capabilities, you can retrieve them for a specific printer using `getPrinterInfo()`.\n  * A `SubmitJobRequest` structure, which specifies the printer to use, and the file or date to print. This structure contains a reference to the `ticket` structure.\n  * A blob of the file or data to print.\n\nCalling `submitJob()` triggers a dialog box asking the user to confirm\nprinting. Use the `PrintingAPIExtensionsAllowlist` to bypass confirmation.\n\nThis is a simplified version of the printing example. Notice that the `ticket`\nis attached to the `SubmitJobRequest` structure (line 8) and that the data to\nprint is converted to a blob (line 10). Getting the ID of the printer (line 1)\nis more complicated in the sample than is shown here.\n\n    \n    \n    const defaultPrinter = getDefaultPrinter();\n    const ticket = getPrinterTicket(defaultPrinter);\n    const arrayBuffer = getPrintData();\n    const submitJobRequest = {\n      job: {\n        printerId: defaultPrinter,\n        title: 'test job',\n        ticket: ticket,\n        contentType: 'application/pdf',\n        document: new Blob([new Uint8Array(arrayBuffer)], {\n          type: 'application/pdf'\n        });\n      }\n    };\n    \n    chrome.printing.submitJob(submitJobRequest, (response) => {\n      if (response !== undefined) {\n        console.log(response.status);\n      }\n      if (chrome.runtime.lastError !== undefined) {\n        console.log(chrome.runtime.lastError.message);\n      }\n    });\n    \n\n### Roll printing\n\nThis example shows how to build a printer ticket for continuous (or roll)\nprinting, which is often used with receipt printing. The `submitJobRequest`\nobject for roll printing is the same as that shown for the `submitJob()`\nexample.\n\nIf you need to change the default value for paper cutting, use the\n`vendor_ticket_item` key. (The default varies from printer to printer.) To\nchange the value, provide an array with one member: an object whose `id` is\n`'finishings'`. The value can either be `'trim'` for printers that cut the\nroll at the end of printing or `'none'` for printers that require the print\njob to be torn off.\n\n    \n    \n    const ticket = {\n      version: '1.0',\n      print: {\n        vendor_ticket_item: [{id: 'finishings', value: 'trim'}],\n        color: {type: 'STANDARD_MONOCHROME'},\n        duplex: {type: 'NO_DUPLEX'},\n        page_orientation: {type: 'PORTRAIT'},\n        copies: {copies: 1},\n        dpi: {horizontal_dpi: 300, vertical_dpi: 300},\n        media_size: {\n          width_microns: 72320,\n          height_microns: 100000\n        },\n        collate: {collate: false}\n      }\n    };\n    \n\nSome printers do not support the `\"finishings\"` option. To determine if your\nprinter does, call `getPrinterInfo()` and look for a `\"display_name\"` of\n`\"finishings/11\"`.\n\n    \n    \n    \"vendor_capability\": [\n      {\n        \"display_name\": \"finishings/11\",\n        \"id\": \"finishings/11\",\n        \"type\": \"TYPED_VALUE\",\n        \"typed_value_cap\": {\n          \"value_type\": \"BOOLEAN\"\n        }\n      },\n      ...\n    ]\n    \n\n**Note:** starting with Chrome 124, the `vendor_ticket_item` allows all items\nfrom the printer's `vendor_capabilities`. For example, any value return by\n`getPrinterInfo()` is valid. Before, only the `finishings` key was supported.\n\nThe values in a ticket's `media_size` key are specific to each printer. To\nselect an appropriate size call `getPrinterInfo()`. The returned\n`GetPrinterResponse` contains an array of supported media sizes at\n`\"media_size\".\"option\"`. Choose an option whose `\"is_continuous_feed\"` value\nis true. Use its height and width values for the ticket.\n\n    \n    \n    \"media_size\": {\n      \"option\": [\n      {\n        \"custom_display_name\": \"\",\n        \"is_continuous_feed\": true,\n        \"max_height_microns\": 2000000,\n        \"min_height_microns\": 25400,\n        \"width_microns\": 50800\n      },\n      ...\n      ]\n    }\n    \n\n## Types\n\n### GetPrinterInfoResponse\n\n#### Properties\n\n  * capabilities\n\nobject optional\n\nPrinter capabilities in CDD format. The property may be missing.\n\n  * status\n\nPrinterStatus\n\nThe status of the printer.\n\n### JobStatus\n\nStatus of the print job.\n\n#### Enum\n\n\"PENDING\"  \nPrint job is received on Chrome side but was not processed yet.\n\n\"IN_PROGRESS\"  \nPrint job is sent for printing.\n\n\"FAILED\"  \nPrint job was interrupted due to some error.\n\n\"CANCELED\"  \nPrint job was canceled by the user or via API.\n\n\"PRINTED\"  \nPrint job was printed without any errors.\n\n### Printer\n\n#### Properties\n\n  * description\n\nstring\n\nThe human-readable description of the printer.\n\n  * id\n\nstring\n\nThe printer's identifier; guaranteed to be unique among printers on the\ndevice.\n\n  * isDefault\n\nboolean\n\nThe flag which shows whether the printer fits DefaultPrinterSelection rules.\nNote that several printers could be flagged.\n\n  * name\n\nstring\n\nThe name of the printer.\n\n  * recentlyUsedRank\n\nnumber optional\n\nThe value showing how recent the printer was used for printing from Chrome.\nThe lower the value is the more recent the printer was used. The minimum value\nis 0. Missing value indicates that the printer wasn't used recently. This\nvalue is guaranteed to be unique amongst printers.\n\n  * source\n\nPrinterSource\n\nThe source of the printer (user or policy configured).\n\n  * uri\n\nstring\n\nThe printer URI. This can be used by extensions to choose the printer for the\nuser.\n\n### PrinterSource\n\nThe source of the printer.\n\n#### Enum\n\n\"USER\"  \nPrinter was added by user.\n\n\"POLICY\"  \nPrinter was added via policy.\n\n### PrinterStatus\n\nThe status of the printer.\n\n#### Enum\n\n\"DOOR_OPEN\"  \nThe door of the printer is open. Printer still accepts print jobs.\n\n\"TRAY_MISSING\"  \nThe tray of the printer is missing. Printer still accepts print jobs.\n\n\"OUT_OF_INK\"  \nThe printer is out of ink. Printer still accepts print jobs.\n\n\"OUT_OF_PAPER\"  \nThe printer is out of paper. Printer still accepts print jobs.\n\n\"OUTPUT_FULL\"  \nThe output area of the printer (e.g. tray) is full. Printer still accepts\nprint jobs.\n\n\"PAPER_JAM\"  \nThe printer has a paper jam. Printer still accepts print jobs.\n\n\"GENERIC_ISSUE\"  \nSome generic issue. Printer still accepts print jobs.\n\n\"STOPPED\"  \nThe printer is stopped and doesn't print but still accepts print jobs.\n\n\"UNREACHABLE\"  \nThe printer is unreachable and doesn't accept print jobs.\n\n\"EXPIRED_CERTIFICATE\"  \nThe SSL certificate is expired. Printer accepts jobs but they fail.\n\n\"AVAILABLE\"  \nThe printer is available.\n\n### SubmitJobRequest\n\n#### Properties\n\n  * job\n\nPrintJob\n\nThe print job to be submitted. Supported content types are \"application/pdf\"\nand \"image/png\". The Cloud Job Ticket shouldn't include `FitToPageTicketItem`,\n`PageRangeTicketItem` and `ReverseOrderTicketItem` fields since they are\nirrelevant for native printing. `VendorTicketItem` is optional. All other\nfields must be present.\n\n### SubmitJobResponse\n\n#### Properties\n\n  * jobId\n\nstring optional\n\nThe id of created print job. This is a unique identifier among all print jobs\non the device. If status is not OK, jobId will be null.\n\n  * status\n\nSubmitJobStatus\n\nThe status of the request.\n\n### SubmitJobStatus\n\nThe status of `submitJob` request.\n\n#### Enum\n\n\"OK\"  \nSent print job request is accepted.\n\n\"USER_REJECTED\"  \nSent print job request is rejected by the user.\n\n## Properties\n\n### MAX_GET_PRINTER_INFO_CALLS_PER_MINUTE\n\nThe maximum number of times that `getPrinterInfo` can be called per minute.\n\n#### Value\n\n20  \n\n### MAX_SUBMIT_JOB_CALLS_PER_MINUTE\n\nThe maximum number of times that `submitJob` can be called per minute.\n\n#### Value\n\n40  \n\n## Methods\n\n### cancelJob()\n\nPromise\n\n    \n    \n    chrome.printing.cancelJob(  \n      jobId: string,  \n      callback?: function,  \n    )\n\nCancels previously submitted job.\n\n#### Parameters\n\n  * jobId\n\nstring\n\nThe id of the print job to cancel. This should be the same id received in a\n`SubmitJobResponse`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 100+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getJobStatus()\n\nPromise Chrome 135+\n\n    \n    \n    chrome.printing.getJobStatus(  \n      jobId: string,  \n      callback?: function,  \n    )\n\nReturns the status of the print job. This call will fail with a runtime error\nif the print job with the given `jobId` doesn't exist. `jobId`: The id of the\nprint job to return the status of. This should be the same id received in a\n`SubmitJobResponse`.\n\n#### Parameters\n\n  * jobId\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (status: JobStatus) => void\n\n    * status\n\nJobStatus\n\n#### Returns\n\n  * Promise<JobStatus>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPrinterInfo()\n\nPromise\n\n    \n    \n    chrome.printing.getPrinterInfo(  \n      printerId: string,  \n      callback?: function,  \n    )\n\nReturns the status and capabilities of the printer in CDD format. This call\nwill fail with a runtime error if no printers with given id are installed.\n\n#### Parameters\n\n  * printerId\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: GetPrinterInfoResponse) => void\n\n    * response\n\nGetPrinterInfoResponse\n\n#### Returns\n\n  * Promise<GetPrinterInfoResponse>\n\nChrome 100+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPrinters()\n\nPromise\n\n    \n    \n    chrome.printing.getPrinters(  \n      callback?: function,  \n    )\n\nReturns the list of available printers on the device. This includes manually\nadded, enterprise and discovered printers.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (printers: Printer[]) => void\n\n    * printers\n\nPrinter[]\n\n#### Returns\n\n  * Promise<Printer[]>\n\nChrome 100+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### submitJob()\n\nPromise\n\n    \n    \n    chrome.printing.submitJob(  \n      request: SubmitJobRequest,  \n      callback?: function,  \n    )\n\nSubmits the job for printing. If the extension is not listed in the\n`PrintingAPIExtensionsAllowlist` policy, the user is prompted to accept the\nprint job. Before Chrome 120, this function did not return a promise.\n\n#### Parameters\n\n  * request\n\nSubmitJobRequest\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: SubmitJobResponse) => void\n\n    * response\n\nSubmitJobResponse\n\n#### Returns\n\n  * Promise<SubmitJobResponse>\n\nChrome 100+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onJobStatusChanged\n\n    \n    \n    chrome.printing.onJobStatusChanged.addListener(  \n      callback: function,  \n    )\n\nEvent fired when the status of the job is changed. This is only fired for the\njobs created by this extension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (jobId: string, status: JobStatus) => void\n\n    * jobId\n\nstring\n\n    * status\n\nJobStatus\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/printingMetrics": "#  chrome.printingMetrics\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.printingMetrics` API to fetch data about printing usage.\n\n## Permissions\n\n`printingMetrics`  \n\n## Availability\n\nChrome 79+  ChromeOS only  Requires policy\n\n## Types\n\n### ColorMode\n\n#### Enum\n\n\"BLACK_AND_WHITE\"  \nSpecifies that black and white mode was used.\n\n\"COLOR\"  \nSpecifies that color mode was used.\n\n### DuplexMode\n\n#### Enum\n\n\"ONE_SIDED\"  \nSpecifies that one-sided printing was used.\n\n\"TWO_SIDED_LONG_EDGE\"  \nSpecifies that two-sided printing was used, flipping on long edge.\n\n\"TWO_SIDED_SHORT_EDGE\"  \nSpecifies that two-sided printing was used, flipping on short edge.\n\n### MediaSize\n\n#### Properties\n\n  * height\n\nnumber\n\nHeight (in micrometers) of the media used for printing.\n\n  * vendorId\n\nstring\n\nVendor-provided ID, e.g. \"iso_a3_297x420mm\" or \"na_index-3x5_3x5in\". Possible\nvalues are values of \"media\" IPP attribute and can be found on IANA page .\n\n  * width\n\nnumber\n\nWidth (in micrometers) of the media used for printing.\n\n### Printer\n\n#### Properties\n\n  * name\n\nstring\n\nDisplayed name of the printer.\n\n  * source\n\nPrinterSource\n\nThe source of the printer.\n\n  * uri\n\nstring\n\nThe full path for the printer. Contains protocol, hostname, port, and queue.\n\n### PrinterSource\n\nThe source of the printer.\n\n#### Enum\n\n\"USER\"  \nSpecifies that the printer was added by user.\n\n\"POLICY\"  \nSpecifies that the printer was added via policy.\n\n### PrintJobInfo\n\n#### Properties\n\n  * completionTime\n\nnumber\n\nThe job completion time (in milliseconds past the Unix epoch).\n\n  * creationTime\n\nnumber\n\nThe job creation time (in milliseconds past the Unix epoch).\n\n  * id\n\nstring\n\nThe ID of the job.\n\n  * numberOfPages\n\nnumber\n\nThe number of pages in the document.\n\n  * printer\n\nPrinter\n\nThe info about the printer which printed the document.\n\n  * printer_status\n\nPrinterStatus\n\nChrome 85+\n\nThe status of the printer.\n\n  * settings\n\nPrintSettings\n\nThe settings of the print job.\n\n  * source\n\nPrintJobSource\n\nSource showing who initiated the print job.\n\n  * sourceId\n\nstring optional\n\nID of source. Null if source is PRINT_PREVIEW or ANDROID_APP.\n\n  * status\n\nPrintJobStatus\n\nThe final status of the job.\n\n  * title\n\nstring\n\nThe title of the document which was printed.\n\n### PrintJobSource\n\nThe source of the print job.\n\n#### Enum\n\n\"PRINT_PREVIEW\"  \nSpecifies that the job was created from the Print Preview page initiated by\nthe user.\n\n\"ANDROID_APP\"  \nSpecifies that the job was created from an Android App.\n\n\"EXTENSION\"  \nSpecifies that the job was created by extension via Chrome API.\n\n\"ISOLATED_WEB_APP\"  \nSpecifies that the job was created by an Isolated Web App via API.\n\n### PrintJobStatus\n\nSpecifies the final status of the print job.\n\n#### Enum\n\n\"FAILED\"  \nSpecifies that the print job was interrupted due to some error.\n\n\"CANCELED\"  \nSpecifies that the print job was canceled by the user or via API.\n\n\"PRINTED\"  \nSpecifies that the print job was printed without any errors.\n\n### PrintSettings\n\n#### Properties\n\n  * color\n\nColorMode\n\nThe requested color mode.\n\n  * copies\n\nnumber\n\nThe requested number of copies.\n\n  * duplex\n\nDuplexMode\n\nThe requested duplex mode.\n\n  * mediaSize\n\nMediaSize\n\nThe requested media size.\n\n## Methods\n\n### getPrintJobs()\n\nPromise\n\n    \n    \n    chrome.printingMetrics.getPrintJobs(  \n      callback?: function,  \n    )\n\nReturns the list of the finished print jobs.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (jobs: PrintJobInfo[]) => void\n\n    * jobs\n\nPrintJobInfo[]\n\n#### Returns\n\n  * Promise<PrintJobInfo[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onPrintJobFinished\n\n    \n    \n    chrome.printingMetrics.onPrintJobFinished.addListener(  \n      callback: function,  \n    )\n\nEvent fired when the print job is finished. This includes any of termination\nstatuses: FAILED, CANCELED and PRINTED.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (jobInfo: PrintJobInfo) => void\n\n    * jobInfo\n\nPrintJobInfo\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/privacy": "#  chrome.privacy\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Note:** The Chrome Privacy Whitepaper gives background detail regarding the\nfeatures which this API can control.\n\n## Description\n\nUse the `chrome.privacy` API to control usage of the features in Chrome that\ncan affect a user's privacy. This API relies on the ChromeSetting prototype of\nthe type API for getting and setting Chrome's configuration.\n\n## Permissions\n\n`privacy`  \n\nYou must declare the \"privacy\" permission in your extension's manifest to use\nthe API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"privacy\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nReading the current value of a Chrome setting is straightforward. You'll first\nneed to find the property you're interested in, then you'll call `get()` on\nthat object in order to retrieve its current value and your extension's level\nof control. For example, to determine if Chrome's credit card autofill feature\nis enabled, you'd write:\n\n    \n    \n    chrome.privacy.services.autofillCreditCardEnabled.get({}, function(details) {\n      if (details.value) {\n        console.log('Autofill is on!');\n      } else {\n        console.log('Autofill is off!');\n      }\n    });\n    \n\nChanging the value of a setting is a little bit more complex, because you\nfirst must verify that your extension can control the setting. The user won't\nsee any change to their settings if your extension toggles a setting that is\neither locked to a specific value by enterprise policies (`levelOfControl`\nwill be set to \"not_controllable\"), or if another extension is controlling the\nvalue (`levelOfControl` will be set to \"controlled_by_other_extensions\"). The\n`set()` call will succeed, but the setting will be immediately overridden. As\nthis might be confusing, it is advisable to warn the user when the settings\nthey've chosen aren't practically applied.\n\n**Note:** Full details about extensions' ability to control `ChromeSetting`s\ncan be found under `chrome.types.ChromeSetting`.\n\nThis means that you ought to use the `get()` method to determine your level of\naccess, and then only call `set()` if your extension can grab control over the\nsetting (in fact if your extension can't control the setting it's probably a\ngood idea to visually disable the feature to reduce user confusion):\n\n    \n    \n    chrome.privacy.services.autofillCreditCardEnabled.get({}, function(details) {\n      if (details.levelOfControl === 'controllable_by_this_extension') {\n        chrome.privacy.services.autofillCreditCardEnabled.set({ value: true }, function() {\n          if (chrome.runtime.lastError === undefined) {\n            console.log(\"Hooray, it worked!\");\n          } else {\n            console.log(\"Sadness!\", chrome.runtime.lastError);\n          }\n        });\n      }\n    });\n    \n\nIf you're interested in changes to a setting's value, add a listener to its\n`onChange` event. Among other uses, this will allow you to warn the user if a\nmore recently installed extension grabs control of a setting, or if enterprise\npolicy overrides your control. To listen for changes to credit card autofill\nstatus, for example, the following code would suffice:\n\n    \n    \n    chrome.privacy.services.autofillCreditCardEnabled.onChange.addListener(\n      function (details) {\n        // The new value is stored in `details.value`, the new level of control\n        // in `details.levelOfControl`, and `details.incognitoSpecific` will be\n        // `true` if the value is specific to Incognito mode.\n      }\n    );\n    \n\n## Examples\n\nTo try this API, install the privacy API example from the chrome-extension-\nsamples repository.\n\n## Types\n\n### IPHandlingPolicy\n\nChrome 48+\n\nThe IP handling policy of WebRTC.\n\n#### Enum\n\n\"default\"  \n\n\"default_public_and_private_interfaces\"  \n\n\"default_public_interface_only\"  \n\n\"disable_non_proxied_udp\"  \n\n## Properties\n\n### network\n\nSettings that influence Chrome's handling of network connections in general.\n\n#### Type\n\nobject\n\n#### Properties\n\n  * networkPredictionEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome attempts to speed up your web browsing experience by pre-\nresolving DNS entries and preemptively opening TCP and SSL connections to\nservers. This preference only affects actions taken by Chrome's internal\nprediction service. It does not affect webpage-initiated prefectches or\npreconnects. This preference's value is a boolean, defaulting to `true`.\n\n  * webRTCIPHandlingPolicy\n\ntypes.ChromeSetting<IPHandlingPolicy>\n\nChrome 48+\n\nAllow users to specify the media performance/privacy tradeoffs which impacts\nhow WebRTC traffic will be routed and how much local address information is\nexposed. This preference's value is of type IPHandlingPolicy, defaulting to\n`default`.\n\n### services\n\nSettings that enable or disable features that require third-party network\nservices provided by Google and your default search provider.\n\n#### Type\n\nobject\n\n#### Properties\n\n  * alternateErrorPagesEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome uses a web service to help resolve navigation errors. This\npreference's value is a boolean, defaulting to `true`.\n\n  * autofillAddressEnabled\n\ntypes.ChromeSetting<boolean>\n\nChrome 70+\n\nIf enabled, Chrome offers to automatically fill in addresses and other form\ndata. This preference's value is a boolean, defaulting to `true`.\n\n  * autofillCreditCardEnabled\n\ntypes.ChromeSetting<boolean>\n\nChrome 70+\n\nIf enabled, Chrome offers to automatically fill in credit card forms. This\npreference's value is a boolean, defaulting to `true`.\n\n  * autofillEnabled\n\ntypes.ChromeSetting<boolean>\n\nDeprecated since Chrome 70\n\nPlease use privacy.services.autofillAddressEnabled and\nprivacy.services.autofillCreditCardEnabled. This remains for backward\ncompatibility in this release and will be removed in the future.\n\nIf enabled, Chrome offers to automatically fill in forms. This preference's\nvalue is a boolean, defaulting to `true`.\n\n  * passwordSavingEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, the password manager will ask if you want to save passwords. This\npreference's value is a boolean, defaulting to `true`.\n\n  * safeBrowsingEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome does its best to protect you from phishing and malware.\nThis preference's value is a boolean, defaulting to `true`.\n\n  * safeBrowsingExtendedReportingEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome will send additional information to Google when\nSafeBrowsing blocks a page, such as the content of the blocked page. This\npreference's value is a boolean, defaulting to `false`.\n\n  * searchSuggestEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome sends the text you type into the Omnibox to your default\nsearch engine, which provides predictions of websites and searches that are\nlikely completions of what you've typed so far. This preference's value is a\nboolean, defaulting to `true`.\n\n  * spellingServiceEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome uses a web service to help correct spelling errors. This\npreference's value is a boolean, defaulting to `false`.\n\n  * translationServiceEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome offers to translate pages that aren't in a language you\nread. This preference's value is a boolean, defaulting to `true`.\n\n### websites\n\nSettings that determine what information Chrome makes available to websites.\n\n#### Type\n\nobject\n\n#### Properties\n\n  * adMeasurementEnabled\n\ntypes.ChromeSetting<boolean>\n\nChrome 111+\n\nIf disabled, the Attribution Reporting API and Private Aggregation API are\ndeactivated. The value of this preference is of type boolean, and the default\nvalue is `true`. Extensions may only disable these APIs by setting the value\nto `false`. If you try setting these APIs to `true`, it will throw an error.\n\n  * doNotTrackEnabled\n\ntypes.ChromeSetting<boolean>\n\nChrome 65+\n\nIf enabled, Chrome sends 'Do Not Track' (`DNT: 1`) header with your requests.\nThe value of this preference is of type boolean, and the default value is\n`false`.\n\n  * fledgeEnabled\n\ntypes.ChromeSetting<boolean>\n\nChrome 111+\n\nIf disabled, the Fledge API is deactivated. The value of this preference is of\ntype boolean, and the default value is `true`. Extensions may only disable\nthis API by setting the value to `false`. If you try setting this API to\n`true`, it will throw an error.\n\n  * hyperlinkAuditingEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome sends auditing pings when requested by a website (`<a\nping>`). The value of this preference is of type boolean, and the default\nvalue is `true`.\n\n  * protectedContentEnabled\n\ntypes.ChromeSetting<boolean>\n\n**Available on Windows and ChromeOS only** : If enabled, Chrome provides a\nunique ID to plugins in order to run protected content. The value of this\npreference is of type boolean, and the default value is `true`.\n\n  * referrersEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome sends `referer` headers with your requests. Yes, the name\nof this preference doesn't match the misspelled header. No, we're not going to\nchange it. The value of this preference is of type boolean, and the default\nvalue is `true`.\n\n  * relatedWebsiteSetsEnabled\n\ntypes.ChromeSetting<boolean>\n\nChrome 121+\n\nIf disabled, Related Website Sets is deactivated. The value of this preference\nis of type boolean, and the default value is `true`. Extensions may only\ndisable this API by setting the value to `false`. If you try setting this API\nto `true`, it will throw an error.\n\n  * thirdPartyCookiesAllowed\n\ntypes.ChromeSetting<boolean>\n\nIf disabled, Chrome blocks third-party sites from setting cookies. The value\nof this preference is of type boolean, and the default value is `true`.\n\n**Note:**Individual sites may still be able to access third-party cookies when\nthis API returns `false`, if they have a valid exemption or they use the\nStorage Access API instead.\n\n  * topicsEnabled\n\ntypes.ChromeSetting<boolean>\n\nChrome 111+\n\nIf disabled, the Topics API is deactivated. The value of this preference is of\ntype boolean, and the default value is `true`. Extensions may only disable\nthis API by setting the value to `false`. If you try setting this API to\n`true`, it will throw an error.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/processes": "#  chrome.processes\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.processes` API to interact with the browser's processes.\n\n## Permissions\n\n`processes`  \n\n## Availability\n\nDev channel\n\n## Types\n\n### Cache\n\n#### Properties\n\n  * liveSize\n\nnumber\n\nThe part of the cache that is utilized, in bytes.\n\n  * size\n\nnumber\n\nThe size of the cache, in bytes.\n\n### Process\n\n#### Properties\n\n  * cpu\n\nnumber optional\n\nThe most recent measurement of the process's CPU usage, expressed as the\npercentage of a single CPU core used in total, by all of the process's\nthreads. This gives a value from zero to CpuInfo.numOfProcessors*100, which\ncan exceed 100% in multi-threaded processes. Only available when receiving the\nobject as part of a callback from onUpdated or onUpdatedWithMemory.\n\n  * cssCache\n\nCache optional\n\nThe most recent information about the CSS cache for the process. Only\navailable when receiving the object as part of a callback from onUpdated or\nonUpdatedWithMemory.\n\n  * id\n\nnumber\n\nUnique ID of the process provided by the browser.\n\n  * imageCache\n\nCache optional\n\nThe most recent information about the image cache for the process. Only\navailable when receiving the object as part of a callback from onUpdated or\nonUpdatedWithMemory.\n\n  * jsMemoryAllocated\n\nnumber optional\n\nThe most recent measurement of the process JavaScript allocated memory, in\nbytes. Only available when receiving the object as part of a callback from\nonUpdated or onUpdatedWithMemory.\n\n  * jsMemoryUsed\n\nnumber optional\n\nThe most recent measurement of the process JavaScript memory used, in bytes.\nOnly available when receiving the object as part of a callback from onUpdated\nor onUpdatedWithMemory.\n\n  * naclDebugPort\n\nnumber\n\nThe debugging port for Native Client processes. Zero for other process types\nand for NaCl processes that do not have debugging enabled.\n\n  * network\n\nnumber optional\n\nThe most recent measurement of the process network usage, in bytes per second.\nOnly available when receiving the object as part of a callback from onUpdated\nor onUpdatedWithMemory.\n\n  * osProcessId\n\nnumber\n\nThe ID of the process, as provided by the OS.\n\n  * privateMemory\n\nnumber optional\n\nThe most recent measurement of the process private memory usage, in bytes.\nOnly available when receiving the object as part of a callback from\nonUpdatedWithMemory or getProcessInfo with the includeMemory flag.\n\n  * profile\n\nstring\n\nThe profile which the process is associated with.\n\n  * scriptCache\n\nCache optional\n\nThe most recent information about the script cache for the process. Only\navailable when receiving the object as part of a callback from onUpdated or\nonUpdatedWithMemory.\n\n  * sqliteMemory\n\nnumber optional\n\nThe most recent measurement of the process's SQLite memory usage, in bytes.\nOnly available when receiving the object as part of a callback from onUpdated\nor onUpdatedWithMemory.\n\n  * tasks\n\nTaskInfo[]\n\nArray of TaskInfos representing the tasks running on this process.\n\n  * type\n\nProcessType\n\nThe type of process.\n\n### ProcessType\n\nThe types of the browser processes.\n\n#### Enum\n\n\"browser\"  \n\n\"renderer\"  \n\n\"extension\"  \n\n\"notification\"  \n\n\"plugin\"  \n\n\"worker\"  \n\n\"nacl\"  \n\n\"service_worker\"  \n\n\"utility\"  \n\n\"gpu\"  \n\n\"other\"  \n\n### TaskInfo\n\n#### Properties\n\n  * tabId\n\nnumber optional\n\nOptional tab ID, if this task represents a tab running on a renderer process.\n\n  * title\n\nstring\n\nThe title of the task.\n\n## Methods\n\n### getProcessIdForTab()\n\nPromise\n\n    \n    \n    chrome.processes.getProcessIdForTab(  \n      tabId: number,  \n      callback?: function,  \n    )\n\nReturns the ID of the renderer process for the specified tab.\n\n#### Parameters\n\n  * tabId\n\nnumber\n\nThe ID of the tab for which the renderer process ID is to be returned.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (processId: number) => void\n\n    * processId\n\nnumber\n\nProcess ID of the tab's renderer process.\n\n#### Returns\n\n  * Promise<number>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getProcessInfo()\n\nPromise\n\n    \n    \n    chrome.processes.getProcessInfo(  \n      processIds: number | number[],  \n      includeMemory: boolean,  \n      callback?: function,  \n    )\n\nRetrieves the process information for each process ID specified.\n\n#### Parameters\n\n  * processIds\n\nnumber | number[]\n\nThe list of process IDs or single process ID for which to return the process\ninformation. An empty list indicates all processes are requested.\n\n  * includeMemory\n\nboolean\n\nTrue if detailed memory usage is required. Note, collecting memory usage\ninformation incurs extra CPU usage and should only be queried for when needed.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (processes: object) => void\n\n    * processes\n\nobject\n\nA dictionary of `Process` objects for each requested process that is a live\nchild process of the current browser process, indexed by process ID. Metrics\nrequiring aggregation over time will not be populated in each Process object.\n\n#### Returns\n\n  * Promise<object>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### terminate()\n\nPromise\n\n    \n    \n    chrome.processes.terminate(  \n      processId: number,  \n      callback?: function,  \n    )\n\nTerminates the specified renderer process. Equivalent to visiting about:crash,\nbut without changing the tab's URL.\n\n#### Parameters\n\n  * processId\n\nnumber\n\nThe ID of the process to be terminated.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (didTerminate: boolean) => void\n\n    * didTerminate\n\nboolean\n\nTrue if terminating the process was successful, and false otherwise.\n\n#### Returns\n\n  * Promise<boolean>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onCreated\n\n    \n    \n    chrome.processes.onCreated.addListener(  \n      callback: function,  \n    )\n\nFired each time a process is created, providing the corrseponding Process\nobject.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (process: Process) => void\n\n    * process\n\nProcess\n\n### onExited\n\n    \n    \n    chrome.processes.onExited.addListener(  \n      callback: function,  \n    )\n\nFired each time a process is terminated, providing the type of exit.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (processId: number, exitType: number, exitCode: number) => void\n\n    * processId\n\nnumber\n\n    * exitType\n\nnumber\n\n    * exitCode\n\nnumber\n\n### onUnresponsive\n\n    \n    \n    chrome.processes.onUnresponsive.addListener(  \n      callback: function,  \n    )\n\nFired each time a process becomes unresponsive, providing the corrseponding\nProcess object.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (process: Process) => void\n\n    * process\n\nProcess\n\n### onUpdated\n\n    \n    \n    chrome.processes.onUpdated.addListener(  \n      callback: function,  \n    )\n\nFired each time the Task Manager updates its process statistics, providing the\ndictionary of updated Process objects, indexed by process ID.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (processes: object) => void\n\n    * processes\n\nobject\n\n### onUpdatedWithMemory\n\n    \n    \n    chrome.processes.onUpdatedWithMemory.addListener(  \n      callback: function,  \n    )\n\nFired each time the Task Manager updates its process statistics, providing the\ndictionary of updated Process objects, indexed by process ID. Identical to\nonUpdate, with the addition of memory usage details included in each Process\nobject. Note, collecting memory usage information incurs extra CPU usage and\nshould only be listened for when needed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (processes: object) => void\n\n    * processes\n\nobject\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/proxy": "#  chrome.proxy\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.proxy` API to manage Chrome's proxy settings. This API relies\non the ChromeSetting prototype of the type API for getting and setting the\nproxy configuration.\n\n## Permissions\n\n`proxy`  \n\nYou must declare the \"proxy\" permission in the extension manifest to use the\nproxy settings API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"proxy\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nProxy settings are defined in a `proxy.ProxyConfig` object. Depending on\nChrome's proxy settings, the settings may contain `proxy.ProxyRules` or a\n`proxy.PacScript`.\n\n### Proxy modes\n\nA ProxyConfig object's `mode` attribute determines the overall behavior of\nChrome with regards to proxy usage. It can take the following values:\n\n`direct`\n\n    In `direct` mode all connections are created directly, without any proxy involved. This mode allows no further parameters in the `ProxyConfig` object.\n`auto_detect`\n\n    In `auto_detect` mode the proxy configuration is determined by a PAC script that can be downloaded at http://wpad/wpad.dat. This mode allows no further parameters in the `ProxyConfig` object.\n`pac_script`\n\n    In `pac_script` mode the proxy configuration is determined by a PAC script that is either retrieved from the URL specified in the `proxy.PacScript` object or taken literally from the `data` element specified in the `proxy.PacScript` object. Besides this, this mode allows no further parameters in the `ProxyConfig` object.\n`fixed_servers`\n\n    In `fixed_servers` mode the proxy configuration is codified in a `proxy.ProxyRules` object. Its structure is described in Proxy rules. Besides this, the `fixed_servers` mode allows no further parameters in the `ProxyConfig` object.\n`system`\n\n    In `system` mode the proxy configuration is taken from the operating system. This mode allows no further parameters in the `ProxyConfig` object. Note that the `system` mode is different from setting no proxy configuration. In the latter case, Chrome falls back to the system settings only if no command-line options influence the proxy configuration.\n\n### Proxy rules\n\nThe `proxy.ProxyRules` object can contain either a `singleProxy` attribute or\na subset of `proxyForHttp`, `proxyForHttps`, `proxyForFtp`, and\n`fallbackProxy`.\n\nIn the first case, HTTP, HTTPS and FTP traffic is proxied through the\nspecified proxy server. Other traffic is sent directly. In the latter case the\nbehavior is slightly more subtle: If a proxy server is configured for the\nHTTP, HTTPS or FTP protocol, the respective traffic is proxied through the\nspecified server. If no such proxy server is specified or traffic uses a\ndifferent protocol than HTTP, HTTPS or FTP, the `fallbackProxy` is used. If no\n`fallbackProxy` is specified, traffic is sent directly without a proxy server.\n\n### Proxy server objects\n\nA proxy server is configured in a `proxy.ProxyServer` object. The connection\nto the proxy server (defined by the `host` attribute) uses the protocol\ndefined in the `scheme` attribute. If no `scheme` is specified, the proxy\nconnection defaults to `http`.\n\nIf no `port` is defined in a `proxy.ProxyServer` object, the port is derived\nfrom the scheme. The default ports are:\n\nScheme| Port  \n---|---  \nhttp| 80  \nhttps| 443  \nsocks4| 1080  \nsocks5| 1080  \n  \n### Bypass list\n\nIndividual servers may be excluded from being proxied with the `bypassList`.\nThis list may contain the following entries:\n\n`[SCHEME://]HOST_PATTERN[:PORT]`\n\n    \n\nMatch all hostnames that match the pattern `HOST_PATTERN`. A leading `\".\"` is\ninterpreted as a `\"*.\"`.\n\nExamples: `\"foobar.com\", \"*foobar.com\", \"*.foobar.com\", \"*foobar.com:99\",\n\"https://x.*.y.com:99\"`.\n\nPattern| Matches| Does not match  \n---|---|---  \n`\".foobar.com\"`| `\"www.foobar.com\"`| `\"foobar.com\"`  \n`\"*.foobar.com\"`| `\"www.foobar.com\"`| `\"foobar.com\"`  \n`\"foobar.com\"`| `\"foobar.com\"`| `\"www.foobar.com\"`  \n`\"*foobar.com\"`| `\"foobar.com\"`, `\"www.foobar.com\"`, `\"foofoobar.com\"`|  \n`[SCHEME://]IP_LITERAL[:PORT]`\n\n    \n\nMatch URLs that are IP address literals. Conceptually this is the similar to\nthe first case, but with special cases to handle IP literal canonicalization.\nFor example, matching on \"[0:0:0::1]\" is the same as matching on \"[::1]\"\nbecause the IPv6 canonicalization is done internally.\n\nExamples: `127.0.1`, `[0:0::1]`, `[::1]:80`, `https://[::1]:443`\n\n`IP_LITERAL/PREFIX_LENGTH_IN_BITS`\n\n    \n\nMatch any URL containing an IP literal (`IP_LITERAL`) within the given range.\nThe IP range (`PREFIX_LENGTH_IN_BITS`) is specified using CIDR notation.\n\n    \n\nMatch any URL containing an IP literal within the given range. The IP range is\nspecified using CIDR notation. Examples: `\"192.168.1.1/16\", \"fefe:13::abc/33\"`\n\n`<local>`\n\n    \n\nThe literal string `<local>` matches simple hostnames. A simple hostname is\none that contains no dots and is not an IP literal. For instance `example` and\n`localhost` are simple hostnames, whereas `example.com`, `example.`, and\n`[::1]` are not.\n\nExample: `\"<local>\"`\n\n## Examples\n\nThe following code sets a SOCKS 5 proxy for HTTP connections to all servers\nbut foobar.com and uses direct connections for all other protocols. The\nsettings apply to regular and incognito windows, as incognito windows inherit\nsettings from regular windows. See also the Types API documentation.\n\n    \n    \n    var config = {\n      mode: \"fixed_servers\",\n      rules: {\n        proxyForHttp: {\n          scheme: \"socks5\",\n          host: \"1.2.3.4\"\n        },\n        bypassList: [\"foobar.com\"]\n      }\n    };\n    chrome.proxy.settings.set(\n      {value: config, scope: 'regular'},\n      function() {}\n    );\n    \n\nThe following code sets a custom PAC script.\n\n    \n    \n    var config = {\n      mode: \"pac_script\",\n      pacScript: {\n        data: \"function FindProxyForURL(url, host) {\\n\" +\n              \"  if (host == 'foobar.com')\\n\" +\n              \"    return 'PROXY blackhole:80';\\n\" +\n              \"  return 'DIRECT';\\n\" +\n              \"}\"\n      }\n    };\n    chrome.proxy.settings.set(\n      {value: config, scope: 'regular'},\n      function() {}\n    );\n    \n\nThe next snippet queries the current effective proxy settings. The effective\nproxy settings can be determined by another extension or by a policy. See the\nTypes API documentation for details.\n\n    \n    \n    chrome.proxy.settings.get(\n      {'incognito': false},\n      function(config) {\n        console.log(JSON.stringify(config));\n      }\n    );\n    \n\nNote that the `value` object passed to `set()` is not identical to the `value`\nobject passed to callback function of `get()`. The latter will contain a\n`rules.proxyForHttp.port` element.\n\n## Types\n\n### Mode\n\nChrome 54+\n\n#### Enum\n\n\"direct\"  \n\n\"auto_detect\"  \n\n\"pac_script\"  \n\n\"fixed_servers\"  \n\n\"system\"  \n\n### PacScript\n\nAn object holding proxy auto-config information. Exactly one of the fields\nshould be non-empty.\n\n#### Properties\n\n  * data\n\nstring optional\n\nA PAC script.\n\n  * mandatory\n\nboolean optional\n\nIf true, an invalid PAC script will prevent the network stack from falling\nback to direct connections. Defaults to false.\n\n  * url\n\nstring optional\n\nURL of the PAC file to be used.\n\n### ProxyConfig\n\nAn object encapsulating a complete proxy configuration.\n\n#### Properties\n\n  * mode\n\nMode\n\n'direct' = Never use a proxy 'auto_detect' = Auto detect proxy settings\n'pac_script' = Use specified PAC script 'fixed_servers' = Manually specify\nproxy servers 'system' = Use system proxy settings\n\n  * pacScript\n\nPacScript optional\n\nThe proxy auto-config (PAC) script for this configuration. Use this for\n'pac_script' mode.\n\n  * rules\n\nProxyRules optional\n\nThe proxy rules describing this configuration. Use this for 'fixed_servers'\nmode.\n\n### ProxyRules\n\nAn object encapsulating the set of proxy rules for all protocols. Use either\n'singleProxy' or (a subset of) 'proxyForHttp', 'proxyForHttps', 'proxyForFtp'\nand 'fallbackProxy'.\n\n#### Properties\n\n  * bypassList\n\nstring[] optional\n\nList of servers to connect to without a proxy server.\n\n  * fallbackProxy\n\nProxyServer optional\n\nThe proxy server to be used for everthing else or if any of the specific\nproxyFor... is not specified.\n\n  * proxyForFtp\n\nProxyServer optional\n\nThe proxy server to be used for FTP requests.\n\n  * proxyForHttp\n\nProxyServer optional\n\nThe proxy server to be used for HTTP requests.\n\n  * proxyForHttps\n\nProxyServer optional\n\nThe proxy server to be used for HTTPS requests.\n\n  * singleProxy\n\nProxyServer optional\n\nThe proxy server to be used for all per-URL requests (that is http, https, and\nftp).\n\n### ProxyServer\n\nAn object encapsulating a single proxy server's specification.\n\n#### Properties\n\n  * host\n\nstring\n\nThe hostname or IP address of the proxy server. Hostnames must be in ASCII (in\nPunycode format). IDNA is not supported, yet.\n\n  * port\n\nnumber optional\n\nThe port of the proxy server. Defaults to a port that depends on the scheme.\n\n  * scheme\n\nScheme optional\n\nThe scheme (protocol) of the proxy server itself. Defaults to 'http'.\n\n### Scheme\n\nChrome 54+\n\n#### Enum\n\n\"http\"  \n\n\"https\"  \n\n\"quic\"  \n\n\"socks4\"  \n\n\"socks5\"  \n\n## Properties\n\n### settings\n\nProxy settings to be used. The value of this setting is a ProxyConfig object.\n\n#### Type\n\ntypes.ChromeSetting<ProxyConfig>\n\n## Events\n\n### onProxyError\n\n    \n    \n    chrome.proxy.onProxyError.addListener(  \n      callback: function,  \n    )\n\nNotifies about proxy errors.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * details\n\nstring\n\nAdditional details about the error such as a JavaScript runtime error.\n\n      * error\n\nstring\n\nThe error description.\n\n      * fatal\n\nboolean\n\nIf true, the error was fatal and the network transaction was aborted.\nOtherwise, a direct connection is used instead.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/readingList": "#  chrome.readingList\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.readingList` API to read from and modify the items in the\nReading List.\n\n## Permissions\n\n`readingList`  \n\nTo use the Reading List API, add the `\"readingList\"` permission in the\nextension manifest file:\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"My reading list extension\",\n      ...\n      \"permissions\": [\n        \"readingList\"\n      ]\n    }\n    \n\n## Availability\n\nChrome 120+ MV3+\n\nChrome features a reading list located on the side panel. It lets users save\nweb pages to read later or when offline. Use the Reading List API to retrieve\nexisting items and add or remove items from the list.\n\n![Reading list showing a number of\narticles](/static/docs/extensions/reference/api/readingList/image/reading-\nlist-showing-num-a0718c5ab1fe5.png) Reading list showing a number of articles\n\n## Concepts and usage\n\n### Item ordering\n\nItems in the reading list are not in any guaranteed order.\n\n### Item uniqueness\n\nItems are keyed by URL. This includes the hash and query string.\n\n## Use cases\n\nThe following sections demonstrate some common use cases for the Reading List\nAPI. See Extension samples for complete extension examples.\n\n### Add an item\n\nTo add an item to the reading list, use `chrome.readingList.addEntry()`:\n\n    \n    \n    chrome.readingList.addEntry({\n      title: \"New to the web platform in September | web.dev\",\n      url: \"https://developer.chrome.com/\",\n      hasBeenRead: false\n    });\n    \n\n### Display items\n\nTo display items from the reading list, use the `chrome.readingList.query()`\nmethod to retrieve them. method.\n\n    \n    \n    const items = await chrome.readingList.query({});\n    \n    for (const item of items) {\n      // Do something do display the item\n    }\n    \n\n### Mark an item as read\n\nYou can use `chrome.readingList.updateEntry()` to update the title, URL, and\nread status. The following code marks an item as read:\n\n    \n    \n    chrome.readingList.updateEntry({\n      url: \"https://developer.chrome.com/\",\n      hasBeenRead: true\n    });\n    \n\n### Remove an item\n\nTo remove an item, use `chrome.readingList.removeEntry()`:\n\n    \n    \n    chrome.readingList.removeEntry({\n      url: \"https://developer.chrome.com/\"\n    });\n    \n\n## Extension samples\n\nFor more Reading List API extensions demos, see the Reading List API sample.\n\n## Types\n\n### AddEntryOptions\n\n#### Properties\n\n  * hasBeenRead\n\nboolean\n\nWill be `true` if the entry has been read.\n\n  * title\n\nstring\n\nThe title of the entry.\n\n  * url\n\nstring\n\nThe url of the entry.\n\n### QueryInfo\n\n#### Properties\n\n  * hasBeenRead\n\nboolean optional\n\nIndicates whether to search for read (`true`) or unread (`false`) items.\n\n  * title\n\nstring optional\n\nA title to search for.\n\n  * url\n\nstring optional\n\nA url to search for.\n\n### ReadingListEntry\n\n#### Properties\n\n  * creationTime\n\nnumber\n\nThe time the entry was created. Recorded in milliseconds since Jan 1, 1970.\n\n  * hasBeenRead\n\nboolean\n\nWill be `true` if the entry has been read.\n\n  * lastUpdateTime\n\nnumber\n\nThe last time the entry was updated. This value is in milliseconds since Jan\n1, 1970.\n\n  * title\n\nstring\n\nThe title of the entry.\n\n  * url\n\nstring\n\nThe url of the entry.\n\n### RemoveOptions\n\n#### Properties\n\n  * url\n\nstring\n\nThe url to remove.\n\n### UpdateEntryOptions\n\n#### Properties\n\n  * hasBeenRead\n\nboolean optional\n\nThe updated read status. The existing status remains if a value isn't\nprovided.\n\n  * title\n\nstring optional\n\nThe new title. The existing tile remains if a value isn't provided.\n\n  * url\n\nstring\n\nThe url that will be updated.\n\n## Methods\n\n### addEntry()\n\nPromise\n\n    \n    \n    chrome.readingList.addEntry(  \n      entry: AddEntryOptions,  \n      callback?: function,  \n    )\n\nAdds an entry to the reading list if it does not exist.\n\n#### Parameters\n\n  * entry\n\nAddEntryOptions\n\nThe entry to add to the reading list.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### query()\n\nPromise\n\n    \n    \n    chrome.readingList.query(  \n      info: QueryInfo,  \n      callback?: function,  \n    )\n\nRetrieves all entries that match the `QueryInfo` properties. Properties that\nare not provided will not be matched.\n\n#### Parameters\n\n  * info\n\nQueryInfo\n\nThe properties to search for.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (entries: ReadingListEntry[]) => void\n\n    * entries\n\nReadingListEntry[]\n\n#### Returns\n\n  * Promise<ReadingListEntry[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeEntry()\n\nPromise\n\n    \n    \n    chrome.readingList.removeEntry(  \n      info: RemoveOptions,  \n      callback?: function,  \n    )\n\nRemoves an entry from the reading list if it exists.\n\n#### Parameters\n\n  * info\n\nRemoveOptions\n\nThe entry to remove from the reading list.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### updateEntry()\n\nPromise\n\n    \n    \n    chrome.readingList.updateEntry(  \n      info: UpdateEntryOptions,  \n      callback?: function,  \n    )\n\nUpdates a reading list entry if it exists.\n\n#### Parameters\n\n  * info\n\nUpdateEntryOptions\n\nThe entry to update.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onEntryAdded\n\n    \n    \n    chrome.readingList.onEntryAdded.addListener(  \n      callback: function,  \n    )\n\nTriggered when a `ReadingListEntry` is added to the reading list.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (entry: ReadingListEntry) => void\n\n    * entry\n\nReadingListEntry\n\n### onEntryRemoved\n\n    \n    \n    chrome.readingList.onEntryRemoved.addListener(  \n      callback: function,  \n    )\n\nTriggered when a `ReadingListEntry` is removed from the reading list.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (entry: ReadingListEntry) => void\n\n    * entry\n\nReadingListEntry\n\n### onEntryUpdated\n\n    \n    \n    chrome.readingList.onEntryUpdated.addListener(  \n      callback: function,  \n    )\n\nTriggered when a `ReadingListEntry` is updated in the reading list.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (entry: ReadingListEntry) => void\n\n    * entry\n\nReadingListEntry\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/runtime": "#  chrome.runtime\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.runtime` API to retrieve the service worker, return details\nabout the manifest, and listen for and respond to events in the extension\nlifecycle. You can also use this API to convert the relative path of URLs to\nfully-qualified URLs.\n\nMost members of this API do **not** require any permissions. This permission\nis needed for `connectNative()`, `sendNativeMessage()` and `onNativeConnect`.\n\nThe following example shows how to declare the `\"nativeMessaging\"` permission\nin the manifest:\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"nativeMessaging\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nThe Runtime API provides methods to support a number of areas that your\nextensions can use:\n\nMessage passing\n\n    Your extension can communicate with different contexts within your extension and also with other extensions using these methods and events: `connect()`, `onConnect`, `onConnectExternal`, `sendMessage()`, `onMessage` and `onMessageExternal`. In addition, your extension can pass messages to native applications on the user's device using `connectNative()` and `sendNativeMessage()`.\n**Note:** See Message Passing for an overview of the subject.\n\nAccessing extension and platform metadata\n\n    These methods let you retrieve several specific pieces of metadata about the extension and the platform. Methods in this category include `getManifest()`, and `getPlatformInfo()`.\nManaging extension lifecycle and options\n\n    These properties let you perform some meta-operations on the extension, and display the options page. Methods and events in this category include `onInstalled`, `onStartup`, `openOptionsPage()`, `reload()`, `requestUpdateCheck()`, and `setUninstallURL()`.\nHelper utilities\n\n    These methods provide utility such as the conversion of internal resource representations to external formats. Methods in this category include `getURL()`.\nKiosk mode utilities\n\n    These methods are available only on ChromeOS, and exist mainly to support kiosk implementations. Methods in this category include `restart()` and `restartAfterDelay()``.\n\n### Unpacked extension behavior\n\nWhen an unpacked extension is reloaded, this is treated as an update. This\nmeans that the `chrome.runtime.onInstalled` event will fire with the\n`\"update\"` reason. This includes when the extension is reloaded with\n`chrome.runtime.reload()`.\n\n## Use cases\n\n### Add an image to a web page\n\nFor a web page to access an asset hosted on another domain, it must specify\nthe resource's full URL (e.g. `<img src=\"https://example.com/logo.png\">`). The\nsame is true to include an extension asset on a web page. The two differences\nare that the extension's assets must be exposed as web accessible resources\nand that typically content scripts are responsible for injecting extension\nassets.\n\nIn this example, the extension will add `logo.png` to the page that the\ncontent script is being injected into by using `runtime.getURL()` to create a\nfully-qualified URL. But first, the asset must be declared as a web accessible\nresource in the manifest.\n\nmanifest.json:\n\n    \n    \n    {\n      ...\n      \"web_accessible_resources\": [\n        {\n          \"resources\": [ \"logo.png\" ],\n          \"matches\": [ \"https://*/*\" ]\n        }\n      ],\n      ...\n    }\n    \n\ncontent.js:\n\n    \n    \n    { // Block used to avoid setting global variables\n      const img = document.createElement('img');\n      img.src = chrome.runtime.getURL('logo.png');\n      document.body.append(img);\n    }\n    \n\n### Send data from a content script to the service worker\n\nIts common for an extension's content scripts to need data managed by another\npart of the extension, like the service worker. Much like two browser windows\nopened to the same web page, these two contexts cannot directly access each\nother's values. Instead, the extension can use message passing to coordinate\nacross these different contexts.\n\nIn this example, the content script needs some data from the extension's\nservice worker to initialize its UI. To get this data, it passes the\ndeveloper-defined `get-user-data` message to the service worker, and it\nresponds with a copy of the user's information.\n\ncontent.js:\n\n    \n    \n    // 1. Send a message to the service worker requesting the user's data\n    chrome.runtime.sendMessage('get-user-data', (response) => {\n      // 3. Got an asynchronous response with the data from the service worker\n      console.log('received user data', response);\n      initializeUI(response);\n    });\n    \n\nservice-worker.js:\n\n    \n    \n    // Example of a simple user data object\n    const user = {\n      username: 'demo-user'\n    };\n    \n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n      // 2. A page requested user data, respond with a copy of `user`\n      if (message === 'get-user-data') {\n        sendResponse(user);\n      }\n    });\n    \n\n### Gather feedback on uninstall\n\nMany extensions use post-uninstall surveys to understand how the extension\ncould better serve its users and improve retention. The following example\nshows how to add this functionality.\n\nbackground.js:\n\n    \n    \n    chrome.runtime.onInstalled.addListener(details => {\n      if (details.reason === chrome.runtime.OnInstalledReason.INSTALL) {\n        chrome.runtime.setUninstallURL('https://example.com/extension-survey');\n      }\n    });\n    \n\n## Examples\n\nSee the Manifest V3 - Web Accessible Resources demo for more Runtime API\nexamples.\n\n## Types\n\n### ContextFilter\n\nChrome 114+\n\nA filter to match against certain extension contexts. Matching contexts must\nmatch all specified filters; any filter that is not specified matches all\navailable contexts. Thus, a filter of `{}` will match all available contexts.\n\n#### Properties\n\n  * contextIds\n\nstring[] optional\n\n  * contextTypes\n\nContextType[] optional\n\n  * documentIds\n\nstring[] optional\n\n  * documentOrigins\n\nstring[] optional\n\n  * documentUrls\n\nstring[] optional\n\n  * frameIds\n\nnumber[] optional\n\n  * incognito\n\nboolean optional\n\n  * tabIds\n\nnumber[] optional\n\n  * windowIds\n\nnumber[] optional\n\n### ContextType\n\nChrome 114+\n\n#### Enum\n\n\"TAB\"  \nSpecifies the context type as a tab\n\n\"POPUP\"  \nSpecifies the context type as an extension popup window\n\n\"BACKGROUND\"  \nSpecifies the context type as a service worker.\n\n\"OFFSCREEN_DOCUMENT\"  \nSpecifies the context type as an offscreen document.\n\n\"SIDE_PANEL\"  \nSpecifies the context type as a side panel.\n\n\"DEVELOPER_TOOLS\"  \nSpecifies the context type as developer tools.\n\n### ExtensionContext\n\nChrome 114+\n\nA context hosting extension content.\n\n#### Properties\n\n  * contextId\n\nstring\n\nA unique identifier for this context\n\n  * contextType\n\nContextType\n\nThe type of context this corresponds to.\n\n  * documentId\n\nstring optional\n\nA UUID for the document associated with this context, or undefined if this\ncontext is hosted not in a document.\n\n  * documentOrigin\n\nstring optional\n\nThe origin of the document associated with this context, or undefined if the\ncontext is not hosted in a document.\n\n  * documentUrl\n\nstring optional\n\nThe URL of the document associated with this context, or undefined if the\ncontext is not hosted in a document.\n\n  * frameId\n\nnumber\n\nThe ID of the frame for this context, or -1 if this context is not hosted in a\nframe.\n\n  * incognito\n\nboolean\n\nWhether the context is associated with an incognito profile.\n\n  * tabId\n\nnumber\n\nThe ID of the tab for this context, or -1 if this context is not hosted in a\ntab.\n\n  * windowId\n\nnumber\n\nThe ID of the window for this context, or -1 if this context is not hosted in\na window.\n\n### MessageSender\n\nAn object containing information about the script context that sent a message\nor request.\n\n#### Properties\n\n  * documentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the document that opened the connection.\n\n  * documentLifecycle\n\nstring optional\n\nChrome 106+\n\nThe lifecycle the document that opened the connection is in at the time the\nport was created. Note that the lifecycle state of the document may have\nchanged since port creation.\n\n  * frameId\n\nnumber optional\n\nThe frame that opened the connection. 0 for top-level frames, positive for\nchild frames. This will only be set when `tab` is set.\n\n  * id\n\nstring optional\n\nThe ID of the extension that opened the connection, if any.\n\n  * nativeApplication\n\nstring optional\n\nChrome 74+\n\nThe name of the native application that opened the connection, if any.\n\n  * origin\n\nstring optional\n\nChrome 80+\n\nThe origin of the page or frame that opened the connection. It can vary from\nthe url property (e.g., about:blank) or can be opaque (e.g., sandboxed\niframes). This is useful for identifying if the origin can be trusted if we\ncan't immediately tell from the URL.\n\n  * tab\n\nTab optional\n\nThe `tabs.Tab` which opened the connection, if any. This property will\n**only** be present when the connection was opened from a tab (including\ncontent scripts), and **only** if the receiver is an extension, not an app.\n\n  * tlsChannelId\n\nstring optional\n\nThe TLS channel ID of the page or frame that opened the connection, if\nrequested by the extension, and if available.\n\n  * url\n\nstring optional\n\nThe URL of the page or frame that opened the connection. If the sender is in\nan iframe, it will be iframe's URL not the URL of the page which hosts it.\n\n### OnInstalledReason\n\nChrome 44+\n\nThe reason that this event is being dispatched.\n\n#### Enum\n\n\"install\"  \nSpecifies the event reason as an installation.\n\n\"update\"  \nSpecifies the event reason as an extension update.\n\n\"chrome_update\"  \nSpecifies the event reason as a Chrome update.\n\n\"shared_module_update\"  \nSpecifies the event reason as an update to a shared module.\n\n### OnRestartRequiredReason\n\nChrome 44+\n\nThe reason that the event is being dispatched. 'app_update' is used when the\nrestart is needed because the application is updated to a newer version.\n'os_update' is used when the restart is needed because the browser/OS is\nupdated to a newer version. 'periodic' is used when the system runs for more\nthan the permitted uptime set in the enterprise policy.\n\n#### Enum\n\n\"app_update\"  \nSpecifies the event reason as an update to the app.\n\n\"os_update\"  \nSpecifies the event reason as an update to the operating system.\n\n\"periodic\"  \nSpecifies the event reason as a periodic restart of the app.\n\n### PlatformArch\n\nChrome 44+\n\nThe machine's processor architecture.\n\n#### Enum\n\n\"arm\"  \nSpecifies the processer architecture as arm.\n\n\"arm64\"  \nSpecifies the processer architecture as arm64.\n\n\"x86-32\"  \nSpecifies the processer architecture as x86-32.\n\n\"x86-64\"  \nSpecifies the processer architecture as x86-64.\n\n\"mips\"  \nSpecifies the processer architecture as mips.\n\n\"mips64\"  \nSpecifies the processer architecture as mips64.\n\n### PlatformInfo\n\nAn object containing information about the current platform.\n\n#### Properties\n\n  * arch\n\nPlatformArch\n\nThe machine's processor architecture.\n\n  * nacl_arch\n\nPlatformNaclArch\n\nThe native client architecture. This may be different from arch on some\nplatforms.\n\n  * os\n\nPlatformOs\n\nThe operating system Chrome is running on.\n\n### PlatformNaclArch\n\nChrome 44+\n\nThe native client architecture. This may be different from arch on some\nplatforms.\n\n#### Enum\n\n\"arm\"  \nSpecifies the native client architecture as arm.\n\n\"x86-32\"  \nSpecifies the native client architecture as x86-32.\n\n\"x86-64\"  \nSpecifies the native client architecture as x86-64.\n\n\"mips\"  \nSpecifies the native client architecture as mips.\n\n\"mips64\"  \nSpecifies the native client architecture as mips64.\n\n### PlatformOs\n\nChrome 44+\n\nThe operating system Chrome is running on.\n\n#### Enum\n\n\"mac\"  \nSpecifies the MacOS operating system.\n\n\"win\"  \nSpecifies the Windows operating system.\n\n\"android\"  \nSpecifies the Android operating system.\n\n\"cros\"  \nSpecifies the Chrome operating system.\n\n\"linux\"  \nSpecifies the Linux operating system.\n\n\"openbsd\"  \nSpecifies the OpenBSD operating system.\n\n\"fuchsia\"  \nSpecifies the Fuchsia operating system.\n\n### Port\n\nAn object which allows two way communication with other pages. See Long-lived\nconnections for more information.\n\n#### Properties\n\n  * name\n\nstring\n\nThe name of the port, as specified in the call to `runtime.connect`.\n\n  * onDisconnect\n\nEvent<functionvoidvoid>\n\nFired when the port is disconnected from the other end(s). `runtime.lastError`\nmay be set if the port was disconnected by an error. If the port is closed via\ndisconnect, then this event is _only_ fired on the other end. This event is\nfired at most once (see also Port lifetime).\n\nThe `onDisconnect.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (port: Port) => void\n\n      * port\n\nPort\n\n  * onMessage\n\nEvent<functionvoidvoid>\n\nThis event is fired when postMessage is called by the other end of the port.\n\nThe `onMessage.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (message: any, port: Port) => void\n\n      * message\n\nany\n\n      * port\n\nPort\n\n  * sender\n\nMessageSender optional\n\nThis property will **only** be present on ports passed to onConnect /\nonConnectExternal / onConnectNative listeners.\n\n  * disconnect\n\nvoid\n\nImmediately disconnect the port. Calling `disconnect()` on an already-\ndisconnected port has no effect. When a port is disconnected, no new events\nwill be dispatched to this port.\n\nThe `disconnect` function looks like:\n\n        \n        () => {...}\n\n  * postMessage\n\nvoid\n\nSend a message to the other end of the port. If the port is disconnected, an\nerror is thrown.\n\nThe `postMessage` function looks like:\n\n        \n        (message: any) => {...}\n\n    * message\n\nany\n\nChrome 52+\n\nThe message to send. This object should be JSON-ifiable.\n\n### RequestUpdateCheckStatus\n\nChrome 44+\n\nResult of the update check.\n\n#### Enum\n\n\"throttled\"  \nSpecifies that the status check has been throttled. This can occur after\nrepeated checks within a short amount of time.\n\n\"no_update\"  \nSpecifies that there are no available updates to install.\n\n\"update_available\"  \nSpecifies that there is an available update to install.\n\n## Properties\n\n### id\n\nThe ID of the extension/app.\n\n#### Type\n\nstring\n\n### lastError\n\nPopulated with an error message if calling an API function fails; otherwise\nundefined. This is only defined within the scope of that function's callback.\nIf an error is produced, but `runtime.lastError` is not accessed within the\ncallback, a message is logged to the console listing the API function that\nproduced the error. API functions that return promises do not set this\nproperty.\n\n#### Type\n\nobject\n\n#### Properties\n\n  * message\n\nstring optional\n\nDetails about the error which occurred.\n\n## Methods\n\n### connect()\n\n    \n    \n    chrome.runtime.connect(  \n      extensionId?: string,  \n      connectInfo?: object,  \n    )\n\nAttempts to connect listeners within an extension (such as the background\npage), or other extensions/apps. This is useful for content scripts connecting\nto their extension processes, inter-app/extension communication, and web\nmessaging. Note that this does not connect to any listeners in a content\nscript. Extensions may connect to content scripts embedded in tabs via\n`tabs.connect`.\n\n#### Parameters\n\n  * extensionId\n\nstring optional\n\nThe ID of the extension to connect to. If omitted, a connection will be\nattempted with your own extension. Required if sending messages from a web\npage for web messaging.\n\n  * connectInfo\n\nobject optional\n\n    * includeTlsChannelId\n\nboolean optional\n\nWhether the TLS channel ID will be passed into onConnectExternal for processes\nthat are listening for the connection event.\n\n    * name\n\nstring optional\n\nWill be passed into onConnect for processes that are listening for the\nconnection event.\n\n#### Returns\n\n  * Port\n\nPort through which messages can be sent and received. The port's onDisconnect\nevent is fired if the extension does not exist.\n\n### connectNative()\n\n    \n    \n    chrome.runtime.connectNative(  \n      application: string,  \n    )\n\nConnects to a native application in the host machine. This method requires the\n`\"nativeMessaging\"` permission. See Native Messaging for more information.\n\n#### Parameters\n\n  * application\n\nstring\n\nThe name of the registered application to connect to.\n\n#### Returns\n\n  * Port\n\nPort through which messages can be sent and received with the application\n\n### getBackgroundPage()\n\nPromise  Foreground only  Deprecated since Chrome 133\n\n    \n    \n    chrome.runtime.getBackgroundPage(  \n      callback?: function,  \n    )\n\nBackground pages do not exist in MV3 extensions.\n\nRetrieves the JavaScript 'window' object for the background page running\ninside the current extension/app. If the background page is an event page, the\nsystem will ensure it is loaded before calling the callback. If there is no\nbackground page, an error is set.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (backgroundPage?: Window) => void\n\n    * backgroundPage\n\nWindow optional\n\nThe JavaScript 'window' object for the background page.\n\n#### Returns\n\n  * Promise<Window | undefined>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getContexts()\n\nPromise Chrome 116+ MV3+\n\n    \n    \n    chrome.runtime.getContexts(  \n      filter: ContextFilter,  \n      callback?: function,  \n    )\n\nFetches information about active contexts associated with this extension\n\n#### Parameters\n\n  * filter\n\nContextFilter\n\nA filter to find matching contexts. A context matches if it matches all\nspecified fields in the filter. Any unspecified field in the filter matches\nall contexts.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (contexts: ExtensionContext[]) => void\n\n    * contexts\n\nExtensionContext[]\n\nThe matching contexts, if any.\n\n#### Returns\n\n  * Promise<ExtensionContext[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getManifest()\n\n    \n    \n    chrome.runtime.getManifest()\n\nReturns details about the app or extension from the manifest. The object\nreturned is a serialization of the full manifest file.\n\n#### Returns\n\n  * object\n\nThe manifest details.\n\n### getPackageDirectoryEntry()\n\nPromise  Foreground only\n\n    \n    \n    chrome.runtime.getPackageDirectoryEntry(  \n      callback?: function,  \n    )\n\nReturns a DirectoryEntry for the package directory.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (directoryEntry: DirectoryEntry) => void\n\n    * directoryEntry\n\nDirectoryEntry\n\n#### Returns\n\n  * Promise<DirectoryEntry>\n\nChrome 122+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPlatformInfo()\n\nPromise\n\n    \n    \n    chrome.runtime.getPlatformInfo(  \n      callback?: function,  \n    )\n\nReturns information about the current platform.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (platformInfo: PlatformInfo) => void\n\n    * platformInfo\n\nPlatformInfo\n\n#### Returns\n\n  * Promise<PlatformInfo>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getURL()\n\n    \n    \n    chrome.runtime.getURL(  \n      path: string,  \n    )\n\nConverts a relative path within an app/extension install directory to a fully-\nqualified URL.\n\n#### Parameters\n\n  * path\n\nstring\n\nA path to a resource within an app/extension expressed relative to its install\ndirectory.\n\n#### Returns\n\n  * string\n\nThe fully-qualified URL to the resource.\n\n### openOptionsPage()\n\nPromise\n\n    \n    \n    chrome.runtime.openOptionsPage(  \n      callback?: function,  \n    )\n\nOpen your Extension's options page, if possible.\n\nThe precise behavior may depend on your manifest's `options_ui` or\n`options_page` key, or what Chrome happens to support at the time. For\nexample, the page may be opened in a new tab, within chrome://extensions,\nwithin an App, or it may just focus an open options page. It will never cause\nthe caller page to reload.\n\nIf your Extension does not declare an options page, or Chrome failed to create\none for some other reason, the callback will set `lastError`.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### reload()\n\n    \n    \n    chrome.runtime.reload()\n\nReloads the app or extension. This method is not supported in kiosk mode. For\nkiosk mode, use chrome.runtime.restart() method.\n\n### requestUpdateCheck()\n\nPromise\n\n    \n    \n    chrome.runtime.requestUpdateCheck(  \n      callback?: function,  \n    )\n\nRequests an immediate update check be done for this app/extension.\n\n**Important** : Most extensions/apps should **not** use this method, since\nChrome already does automatic checks every few hours, and you can listen for\nthe `runtime.onUpdateAvailable` event without needing to call\nrequestUpdateCheck.\n\nThis method is only appropriate to call in very limited circumstances, such as\nif your extension talks to a backend service, and the backend service has\ndetermined that the client extension version is very far out of date and you'd\nlike to prompt a user to update. Most other uses of requestUpdateCheck, such\nas calling it unconditionally based on a repeating timer, probably only serve\nto waste client, network, and server resources.\n\nNote: When called with a callback, instead of returning an object this\nfunction will return the two properties as separate arguments passed to the\ncallback.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: object) => void\n\n    * result\n\nobject\n\nChrome 109+\n\nRequestUpdateCheckResult object that holds the status of the update check and\nany details of the result if there is an update available\n\n      * status\n\nRequestUpdateCheckStatus\n\nResult of the update check.\n\n      * version\n\nstring optional\n\nIf an update is available, this contains the version of the available update.\n\n#### Returns\n\n  * Promise<object>\n\nChrome 109+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### restart()\n\n    \n    \n    chrome.runtime.restart()\n\nRestart the ChromeOS device when the app runs in kiosk mode. Otherwise, it's\nno-op.\n\n### restartAfterDelay()\n\nPromise Chrome 53+\n\n    \n    \n    chrome.runtime.restartAfterDelay(  \n      seconds: number,  \n      callback?: function,  \n    )\n\nRestart the ChromeOS device when the app runs in kiosk mode after the given\nseconds. If called again before the time ends, the reboot will be delayed. If\ncalled with a value of -1, the reboot will be cancelled. It's a no-op in non-\nkiosk mode. It's only allowed to be called repeatedly by the first extension\nto invoke this API.\n\n#### Parameters\n\n  * seconds\n\nnumber\n\nTime to wait in seconds before rebooting the device, or -1 to cancel a\nscheduled reboot.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### sendMessage()\n\nPromise\n\n    \n    \n    chrome.runtime.sendMessage(  \n      extensionId?: string,  \n      message: any,  \n      options?: object,  \n      callback?: function,  \n    )\n\nSends a single message to event listeners within your extension or a different\nextension/app. Similar to `runtime.connect` but only sends a single message,\nwith an optional response. If sending to your extension, the\n`runtime.onMessage` event will be fired in every frame of your extension\n(except for the sender's frame), or `runtime.onMessageExternal`, if a\ndifferent extension. Note that extensions cannot send messages to content\nscripts using this method. To send messages to content scripts, use\n`tabs.sendMessage`.\n\n#### Parameters\n\n  * extensionId\n\nstring optional\n\nThe ID of the extension to send the message to. If omitted, the message will\nbe sent to your own extension/app. Required if sending messages from a web\npage for web messaging.\n\n  * message\n\nany\n\nThe message to send. This message should be a JSON-ifiable object.\n\n  * options\n\nobject optional\n\n    * includeTlsChannelId\n\nboolean optional\n\nWhether the TLS channel ID will be passed into onMessageExternal for processes\nthat are listening for the connection event.\n\n  * callback\n\nfunction optional\n\nChrome 99+\n\nThe `callback` parameter looks like:\n\n        \n        (response: any) => void\n\n    * response\n\nany\n\nThe JSON response object sent by the handler of the message. If an error\noccurs while connecting to the extension, the callback will be called with no\narguments and `runtime.lastError` will be set to the error message.\n\n#### Returns\n\n  * Promise<any>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### sendNativeMessage()\n\nPromise\n\n    \n    \n    chrome.runtime.sendNativeMessage(  \n      application: string,  \n      message: object,  \n      callback?: function,  \n    )\n\nSend a single message to a native application. This method requires the\n`\"nativeMessaging\"` permission.\n\n#### Parameters\n\n  * application\n\nstring\n\nThe name of the native messaging host.\n\n  * message\n\nobject\n\nThe message that will be passed to the native messaging host.\n\n  * callback\n\nfunction optional\n\nChrome 99+\n\nThe `callback` parameter looks like:\n\n        \n        (response: any) => void\n\n    * response\n\nany\n\nThe response message sent by the native messaging host. If an error occurs\nwhile connecting to the native messaging host, the callback will be called\nwith no arguments and `runtime.lastError` will be set to the error message.\n\n#### Returns\n\n  * Promise<any>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setUninstallURL()\n\nPromise\n\n    \n    \n    chrome.runtime.setUninstallURL(  \n      url: string,  \n      callback?: function,  \n    )\n\nSets the URL to be visited upon uninstallation. This may be used to clean up\nserver-side data, do analytics, and implement surveys. Maximum 1023\ncharacters.\n\n#### Parameters\n\n  * url\n\nstring\n\nURL to be opened after the extension is uninstalled. This URL must have an\nhttp: or https: scheme. Set an empty string to not open a new tab upon\nuninstallation.\n\n  * callback\n\nfunction optional\n\nChrome 45+\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onBrowserUpdateAvailable\n\nDeprecated\n\n    \n    \n    chrome.runtime.onBrowserUpdateAvailable.addListener(  \n      callback: function,  \n    )\n\nPlease use `runtime.onRestartRequired`.\n\nFired when a Chrome update is available, but isn't installed immediately\nbecause a browser restart is required.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onConnect\n\n    \n    \n    chrome.runtime.onConnect.addListener(  \n      callback: function,  \n    )\n\nFired when a connection is made from either an extension process or a content\nscript (by `runtime.connect`).\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (port: Port) => void\n\n    * port\n\nPort\n\n### onConnectExternal\n\n    \n    \n    chrome.runtime.onConnectExternal.addListener(  \n      callback: function,  \n    )\n\nFired when a connection is made from another extension (by `runtime.connect`),\nor from an externally connectable web site.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (port: Port) => void\n\n    * port\n\nPort\n\n### onConnectNative\n\nChrome 76+\n\n    \n    \n    chrome.runtime.onConnectNative.addListener(  \n      callback: function,  \n    )\n\nFired when a connection is made from a native application. This event requires\nthe `\"nativeMessaging\"` permission. It is only supported on Chrome OS.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (port: Port) => void\n\n    * port\n\nPort\n\n### onInstalled\n\n    \n    \n    chrome.runtime.onInstalled.addListener(  \n      callback: function,  \n    )\n\nFired when the extension is first installed, when the extension is updated to\na new version, and when Chrome is updated to a new version.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * id\n\nstring optional\n\nIndicates the ID of the imported shared module extension which updated. This\nis present only if 'reason' is 'shared_module_update'.\n\n      * previousVersion\n\nstring optional\n\nIndicates the previous version of the extension, which has just been updated.\nThis is present only if 'reason' is 'update'.\n\n      * reason\n\nOnInstalledReason\n\nThe reason that this event is being dispatched.\n\n### onMessage\n\n    \n    \n    chrome.runtime.onMessage.addListener(  \n      callback: function,  \n    )\n\nFired when a message is sent from either an extension process (by\n`runtime.sendMessage`) or a content script (by `tabs.sendMessage`).\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n\n    * message\n\nany\n\n    * sender\n\nMessageSender\n\n    * sendResponse\n\nfunction\n\nThe `sendResponse` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nboolean | undefined\n\n### onMessageExternal\n\n    \n    \n    chrome.runtime.onMessageExternal.addListener(  \n      callback: function,  \n    )\n\nFired when a message is sent from another extension (by\n`runtime.sendMessage`). Cannot be used in a content script.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n\n    * message\n\nany\n\n    * sender\n\nMessageSender\n\n    * sendResponse\n\nfunction\n\nThe `sendResponse` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nboolean | undefined\n\n### onRestartRequired\n\n    \n    \n    chrome.runtime.onRestartRequired.addListener(  \n      callback: function,  \n    )\n\nFired when an app or the device that it runs on needs to be restarted. The app\nshould close all its windows at its earliest convenient time to let the\nrestart to happen. If the app does nothing, a restart will be enforced after a\n24-hour grace period has passed. Currently, this event is only fired for\nChrome OS kiosk apps.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (reason: OnRestartRequiredReason) => void\n\n    * reason\n\nOnRestartRequiredReason\n\n### onStartup\n\n    \n    \n    chrome.runtime.onStartup.addListener(  \n      callback: function,  \n    )\n\nFired when a profile that has this extension installed first starts up. This\nevent is not fired when an incognito profile is started, even if this\nextension is operating in 'split' incognito mode.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onSuspend\n\n    \n    \n    chrome.runtime.onSuspend.addListener(  \n      callback: function,  \n    )\n\nSent to the event page just before it is unloaded. This gives the extension\nopportunity to do some clean up. Note that since the page is unloading, any\nasynchronous operations started while handling this event are not guaranteed\nto complete. If more activity for the event page occurs before it gets\nunloaded the onSuspendCanceled event will be sent and the page won't be\nunloaded.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onSuspendCanceled\n\n    \n    \n    chrome.runtime.onSuspendCanceled.addListener(  \n      callback: function,  \n    )\n\nSent after onSuspend to indicate that the app won't be unloaded after all.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onUpdateAvailable\n\n    \n    \n    chrome.runtime.onUpdateAvailable.addListener(  \n      callback: function,  \n    )\n\nFired when an update is available, but isn't installed immediately because the\napp is currently running. If you do nothing, the update will be installed the\nnext time the background page gets unloaded, if you want it to be installed\nsooner you can explicitly call chrome.runtime.reload(). If your extension is\nusing a persistent background page, the background page of course never gets\nunloaded, so unless you call chrome.runtime.reload() manually in response to\nthis event the update will not get installed until the next time Chrome itself\nrestarts. If no handlers are listening for this event, and your extension has\na persistent background page, it behaves as if chrome.runtime.reload() is\ncalled in response to this event.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * version\n\nstring\n\nThe version number of the available update.\n\n### onUserScriptConnect\n\nChrome 115+ MV3+\n\n    \n    \n    chrome.runtime.onUserScriptConnect.addListener(  \n      callback: function,  \n    )\n\nFired when a connection is made from a user script from this extension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (port: Port) => void\n\n    * port\n\nPort\n\n### onUserScriptMessage\n\nChrome 115+ MV3+\n\n    \n    \n    chrome.runtime.onUserScriptMessage.addListener(  \n      callback: function,  \n    )\n\nFired when a message is sent from a user script associated with the same\nextension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n\n    * message\n\nany\n\n    * sender\n\nMessageSender\n\n    * sendResponse\n\nfunction\n\nThe `sendResponse` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nboolean | undefined\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/scripting": "#  chrome.scripting\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.scripting` API to execute script in different contexts.\n\n## Permissions\n\n`scripting`  \n\n## Availability\n\nChrome 88+ MV3+\n\n## Manifest\n\nTo use the `chrome.scripting` API, declare the `\"scripting\"` permission in the\nmanifest plus the host permissions for the pages to inject scripts into. Use\nthe `\"host_permissions\"` key or the `\"activeTab\"` permission, which grants\ntemporary host permissions. The following example uses the activeTab\npermission.\n\n    \n    \n    {\n     \"name\": \"Scripting Extension\",\n     \"manifest_version\": 3,\n     \"permissions\": [\"scripting\", \"activeTab\"],\n     ...\n    }\n    \n\n## Concepts and usage\n\nYou can use the `chrome.scripting` API to inject JavaScript and CSS into\nwebsites. This is similar to what you can do with content scripts. But by\nusing the `chrome.scripting` namespace, extensions can make decisions at\nruntime.\n\n### Injection targets\n\nYou can use the `target` parameter to specify a target to inject JavaScript or\nCSS into.\n\nThe only required field is `tabId`. By default, an injection will run in the\nmain frame of the specified tab.\n\n    \n    \n    function getTabId() { ... }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId()},\n          files : [ \"script.js\" ],\n        })\n        .then(() => console.log(\"script injected\"));\n    \n\nTo run in all frames of the specified tab, you can set the `allFrames` boolean\nto `true`.\n\n    \n    \n    function getTabId() { ... }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId(), allFrames : true},\n          files : [ \"script.js\" ],\n        })\n        .then(() => console.log(\"script injected in all frames\"));\n    \n\nYou can also inject into specific frames of a tab by specifying individual\nframe IDs. For more information on frame IDs, see the `chrome.webNavigation`\nAPI.\n\n    \n    \n    function getTabId() { ... }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId(), frameIds : [ frameId1, frameId2 ]},\n          files : [ \"script.js\" ],\n        })\n        .then(() => console.log(\"script injected on target frames\"));\n    \n\n**Note:** You cannot specify both the `\"frameIds\"` and `\"allFrames\"`\nproperties.\n\n### Injected code\n\nExtensions can specify the code to be injected either via an external file or\na runtime variable.\n\n#### Files\n\nFiles are specified as strings that are paths relative to the extension's root\ndirectory. The following code will inject the file `script.js` into the main\nframe of the tab.\n\n    \n    \n    function getTabId() { ... }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId()},\n          files : [ \"script.js\" ],\n        })\n        .then(() => console.log(\"injected script file\"));\n    \n\n#### Runtime functions\n\nWhen injecting JavaScript with `scripting.executeScript()`, you can specify a\nfunction to be executed instead of a file. This function should be a function\nvariable available to the current extension context.\n\n    \n    \n    function getTabId() { ... }\n    function getTitle() { return document.title; }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId()},\n          func : getTitle,\n        })\n        .then(() => console.log(\"injected a function\"));\n    \n    \n    \n    function getTabId() { ... }\n    function getUserColor() { ... }\n    \n    function changeBackgroundColor() {\n      document.body.style.backgroundColor = getUserColor();\n    }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId()},\n          func : changeBackgroundColor,\n        })\n        .then(() => console.log(\"injected a function\"));\n    \n\nYou can work around this by using the `args` property:\n\n    \n    \n    function getTabId() { ... }\n    function getUserColor() { ... }\n    function changeBackgroundColor(backgroundColor) {\n      document.body.style.backgroundColor = backgroundColor;\n    }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId()},\n          func : changeBackgroundColor,\n          args : [ getUserColor() ],\n        })\n        .then(() => console.log(\"injected a function\"));\n    \n\n#### Runtime strings\n\nIf injecting CSS within a page, you can also specify a string to be used in\nthe `css` property. This option is only available for `scripting.insertCSS()`;\nyou can't execute a string using `scripting.executeScript()`.\n\n    \n    \n    function getTabId() { ... }\n    const css = \"body { background-color: red; }\";\n    \n    chrome.scripting\n        .insertCSS({\n          target : {tabId : getTabId()},\n          css : css,\n        })\n        .then(() => console.log(\"CSS injected\"));\n    \n\n### Handle the results\n\nThe results of executing JavaScript are passed to the extension. A single\nresult is included per-frame. The main frame is guaranteed to be the first\nindex in the resulting array; all other frames are in a non-deterministic\norder.\n\n    \n    \n    function getTabId() { ... }\n    function getTitle() { return document.title; }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId(), allFrames : true},\n          func : getTitle,\n        })\n        .then(injectionResults => {\n          for (const {frameId, result} of injectionResults) {\n            console.log(`Frame ${frameId} result:`, result);\n          }\n        });\n    \n\n`scripting.insertCSS()` does not return any results.\n\n#### Promises\n\nIf the resulting value of the script execution is a promise, Chrome will wait\nfor the promise to settle and return the resulting value.\n\n    \n    \n    function getTabId() { ... }\n    async function addIframe() {\n      const iframe = document.createElement(\"iframe\");\n      const loadComplete =\n          new Promise(resolve => iframe.addEventListener(\"load\", resolve));\n      iframe.src = \"https://example.com\";\n      document.body.appendChild(iframe);\n      await loadComplete;\n      return iframe.contentWindow.document.title;\n    }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId(), allFrames : true},\n          func : addIframe,\n        })\n        .then(injectionResults => {\n          for (const frameResult of injectionResults) {\n            const {frameId, result} = frameResult;\n            console.log(`Frame ${frameId} result:`, result);\n          }\n        });\n    \n\n## Examples\n\n### Unregister all dynamic content scripts\n\nThe following snippet contains a function that unregisters all dynamic content\nscripts the extension has previously registered.\n\n    \n    \n    async function unregisterAllDynamicContentScripts() {\n      try {\n        const scripts = await chrome.scripting.getRegisteredContentScripts();\n        const scriptIds = scripts.map(script => script.id);\n        return chrome.scripting.unregisterContentScripts({ ids: scriptIds });\n      } catch (error) {\n        const message = [\n          \"An unexpected error occurred while\",\n          \"unregistering dynamic content scripts.\",\n        ].join(\" \");\n        throw new Error(message, {cause : error});\n      }\n    }\n    \n\n**Key point:** Unregistering content scripts will not remove scripts or styles\nthat have already been injected.\n\nTo try the `chrome.scripting` API, install the scripting sample from the\nChrome extension samples repository.\n\n## Types\n\n### ContentScriptFilter\n\nChrome 96+\n\n#### Properties\n\n  * ids\n\nstring[] optional\n\nIf specified, `getRegisteredContentScripts` will only return scripts with an\nid specified in this list.\n\n### CSSInjection\n\n#### Properties\n\n  * css\n\nstring optional\n\nA string containing the CSS to inject. Exactly one of `files` and `css` must\nbe specified.\n\n  * files\n\nstring[] optional\n\nThe path of the CSS files to inject, relative to the extension's root\ndirectory. Exactly one of `files` and `css` must be specified.\n\n  * origin\n\nStyleOrigin optional\n\nThe style origin for the injection. Defaults to `'AUTHOR'`.\n\n  * target\n\nInjectionTarget\n\nDetails specifying the target into which to insert the CSS.\n\n### ExecutionWorld\n\nChrome 95+\n\nThe JavaScript world for a script to execute within.\n\n#### Enum\n\n\"ISOLATED\"  \nSpecifies the isolated world, which is the execution environment unique to\nthis extension.\n\n\"MAIN\"  \nSpecifies the main world of the DOM, which is the execution environment shared\nwith the host page's JavaScript.\n\n### InjectionResult\n\n#### Properties\n\n  * documentId\n\nstring\n\nChrome 106+\n\nThe document associated with the injection.\n\n  * frameId\n\nnumber\n\nChrome 90+\n\nThe frame associated with the injection.\n\n  * result\n\nany optional\n\nThe result of the script execution.\n\n### InjectionTarget\n\n#### Properties\n\n  * allFrames\n\nboolean optional\n\nWhether the script should inject into all frames within the tab. Defaults to\nfalse. This must not be true if `frameIds` is specified.\n\n  * documentIds\n\nstring[] optional\n\nChrome 106+\n\nThe IDs of specific documentIds to inject into. This must not be set if\n`frameIds` is set.\n\n  * frameIds\n\nnumber[] optional\n\nThe IDs of specific frames to inject into.\n\n  * tabId\n\nnumber\n\nThe ID of the tab into which to inject.\n\n### RegisteredContentScript\n\nChrome 96+\n\n#### Properties\n\n  * allFrames\n\nboolean optional\n\nIf specified true, it will inject into all frames, even if the frame is not\nthe top-most frame in the tab. Each frame is checked independently for URL\nrequirements; it will not inject into child frames if the URL requirements are\nnot met. Defaults to false, meaning that only the top frame is matched.\n\n  * css\n\nstring[] optional\n\nThe list of CSS files to be injected into matching pages. These are injected\nin the order they appear in this array, before any DOM is constructed or\ndisplayed for the page.\n\n  * excludeMatches\n\nstring[] optional\n\nExcludes pages that this content script would otherwise be injected into. See\nMatch Patterns for more details on the syntax of these strings.\n\n  * id\n\nstring\n\nThe id of the content script, specified in the API call. Must not start with a\n'_' as it's reserved as a prefix for generated script IDs.\n\n  * js\n\nstring[] optional\n\nThe list of JavaScript files to be injected into matching pages. These are\ninjected in the order they appear in this array.\n\n  * matchOriginAsFallback\n\nboolean optional\n\nChrome 119+\n\nIndicates whether the script can be injected into frames where the URL\ncontains an unsupported scheme; specifically: about:, data:, blob:, or\nfilesystem:. In these cases, the URL's origin is checked to determine if the\nscript should be injected. If the origin is `null` (as is the case for data:\nURLs) then the used origin is either the frame that created the current frame\nor the frame that initiated the navigation to this frame. Note that this may\nnot be the parent frame.\n\n  * matches\n\nstring[] optional\n\nSpecifies which pages this content script will be injected into. See Match\nPatterns for more details on the syntax of these strings. Must be specified\nfor `registerContentScripts`.\n\n  * persistAcrossSessions\n\nboolean optional\n\nSpecifies if this content script will persist into future sessions. The\ndefault is true.\n\n  * runAt\n\nRunAt optional\n\nSpecifies when JavaScript files are injected into the web page. The preferred\nand default value is `document_idle`.\n\n  * world\n\nExecutionWorld optional\n\nChrome 102+\n\nThe JavaScript \"world\" to run the script in. Defaults to `ISOLATED`.\n\n### ScriptInjection\n\n#### Properties\n\n  * args\n\nany[] optional\n\nChrome 92+\n\nThe arguments to pass to the provided function. This is only valid if the\n`func` parameter is specified. These arguments must be JSON-serializable.\n\n  * files\n\nstring[] optional\n\nThe path of the JS or CSS files to inject, relative to the extension's root\ndirectory. Exactly one of `files` or `func` must be specified.\n\n  * injectImmediately\n\nboolean optional\n\nChrome 102+\n\nWhether the injection should be triggered in the target as soon as possible.\nNote that this is not a guarantee that injection will occur prior to page\nload, as the page may have already loaded by the time the script reaches the\ntarget.\n\n  * target\n\nInjectionTarget\n\nDetails specifying the target into which to inject the script.\n\n  * world\n\nExecutionWorld optional\n\nChrome 95+\n\nThe JavaScript \"world\" to run the script in. Defaults to `ISOLATED`.\n\n  * func\n\nvoid optional\n\nChrome 92+\n\nA JavaScript function to inject. This function will be serialized, and then\ndeserialized for injection. This means that any bound parameters and execution\ncontext will be lost. Exactly one of `files` or `func` must be specified.\n\nThe `func` function looks like:\n\n        \n        () => {...}\n\n### StyleOrigin\n\nThe origin for a style change. See style origins for more info.\n\n#### Enum\n\n\"AUTHOR\"  \n\n\"USER\"  \n\n## Methods\n\n### executeScript()\n\nPromise\n\n    \n    \n    chrome.scripting.executeScript(  \n      injection: ScriptInjection,  \n      callback?: function,  \n    )\n\nInjects a script into a target context. By default, the script will be run at\n`document_idle`, or immediately if the page has already loaded. If the\n`injectImmediately` property is set, the script will inject without waiting,\neven if the page has not finished loading. If the script evaluates to a\npromise, the browser will wait for the promise to settle and return the\nresulting value.\n\n#### Parameters\n\n  * injection\n\nScriptInjection\n\nThe details of the script which to inject.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: InjectionResult[]) => void\n\n    * results\n\nInjectionResult[]\n\n#### Returns\n\n  * Promise<InjectionResult[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getRegisteredContentScripts()\n\nPromise Chrome 96+\n\n    \n    \n    chrome.scripting.getRegisteredContentScripts(  \n      filter?: ContentScriptFilter,  \n      callback?: function,  \n    )\n\nReturns all dynamically registered content scripts for this extension that\nmatch the given filter.\n\n#### Parameters\n\n  * filter\n\nContentScriptFilter optional\n\nAn object to filter the extension's dynamically registered scripts.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (scripts: RegisteredContentScript[]) => void\n\n    * scripts\n\nRegisteredContentScript[]\n\n#### Returns\n\n  * Promise<RegisteredContentScript[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### insertCSS()\n\nPromise\n\n    \n    \n    chrome.scripting.insertCSS(  \n      injection: CSSInjection,  \n      callback?: function,  \n    )\n\nInserts a CSS stylesheet into a target context. If multiple frames are\nspecified, unsuccessful injections are ignored.\n\n#### Parameters\n\n  * injection\n\nCSSInjection\n\nThe details of the styles to insert.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### registerContentScripts()\n\nPromise Chrome 96+\n\n    \n    \n    chrome.scripting.registerContentScripts(  \n      scripts: RegisteredContentScript[],  \n      callback?: function,  \n    )\n\nRegisters one or more content scripts for this extension.\n\n#### Parameters\n\n  * scripts\n\nRegisteredContentScript[]\n\nContains a list of scripts to be registered. If there are errors during script\nparsing/file validation, or if the IDs specified already exist, then no\nscripts are registered.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeCSS()\n\nPromise Chrome 90+\n\n    \n    \n    chrome.scripting.removeCSS(  \n      injection: CSSInjection,  \n      callback?: function,  \n    )\n\nRemoves a CSS stylesheet that was previously inserted by this extension from a\ntarget context.\n\n#### Parameters\n\n  * injection\n\nCSSInjection\n\nThe details of the styles to remove. Note that the `css`, `files`, and\n`origin` properties must exactly match the stylesheet inserted through\n`insertCSS`. Attempting to remove a non-existent stylesheet is a no-op.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### unregisterContentScripts()\n\nPromise Chrome 96+\n\n    \n    \n    chrome.scripting.unregisterContentScripts(  \n      filter?: ContentScriptFilter,  \n      callback?: function,  \n    )\n\nUnregisters content scripts for this extension.\n\n#### Parameters\n\n  * filter\n\nContentScriptFilter optional\n\nIf specified, only unregisters dynamic content scripts which match the filter.\nOtherwise, all of the extension's dynamic content scripts are unregistered.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### updateContentScripts()\n\nPromise Chrome 96+\n\n    \n    \n    chrome.scripting.updateContentScripts(  \n      scripts: RegisteredContentScript[],  \n      callback?: function,  \n    )\n\nUpdates one or more content scripts for this extension.\n\n#### Parameters\n\n  * scripts\n\nRegisteredContentScript[]\n\nContains a list of scripts to be updated. A property is only updated for the\nexisting script if it is specified in this object. If there are errors during\nscript parsing/file validation, or if the IDs specified do not correspond to a\nfully registered script, then no scripts are updated.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/search": "#  chrome.search\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.search` API to search via the default provider.\n\n## Permissions\n\n`search`  \n\n## Availability\n\nChrome 87+\n\n## Types\n\n### Disposition\n\n#### Enum\n\n\"CURRENT_TAB\"  \nSpecifies that the search results display in the calling tab or the tab from\nthe active browser.\n\n\"NEW_TAB\"  \nSpecifies that the search results display in a new tab.\n\n\"NEW_WINDOW\"  \nSpecifies that the search results display in a new window.\n\n### QueryInfo\n\n#### Properties\n\n  * disposition\n\nDisposition optional\n\nLocation where search results should be displayed. `CURRENT_TAB` is the\ndefault.\n\n  * tabId\n\nnumber optional\n\nLocation where search results should be displayed. `tabId` cannot be used with\n`disposition`.\n\n  * text\n\nstring\n\nString to query with the default search provider.\n\n## Methods\n\n### query()\n\nPromise\n\n    \n    \n    chrome.search.query(  \n      queryInfo: QueryInfo,  \n      callback?: function,  \n    )\n\nUsed to query the default search provider. In case of an error,\n`runtime.lastError` will be set.\n\n#### Parameters\n\n  * queryInfo\n\nQueryInfo\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/sessions": "#  chrome.sessions\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.sessions` API to query and restore tabs and windows from a\nbrowsing session.\n\n## Permissions\n\n`sessions`  \n\n## Types\n\n### Device\n\n#### Properties\n\n  * deviceName\n\nstring\n\nThe name of the foreign device.\n\n  * sessions\n\nSession[]\n\nA list of open window sessions for the foreign device, sorted from most\nrecently to least recently modified session.\n\n### Filter\n\n#### Properties\n\n  * maxResults\n\nnumber optional\n\nThe maximum number of entries to be fetched in the requested list. Omit this\nparameter to fetch the maximum number of entries\n(`sessions.MAX_SESSION_RESULTS`).\n\n### Session\n\n#### Properties\n\n  * lastModified\n\nnumber\n\nThe time when the window or tab was closed or modified, represented in seconds\nsince the epoch.\n\n  * tab\n\nTab optional\n\nThe `tabs.Tab`, if this entry describes a tab. Either this or\n`sessions.Session.window` will be set.\n\n  * window\n\nWindow optional\n\nThe `windows.Window`, if this entry describes a window. Either this or\n`sessions.Session.tab` will be set.\n\n## Properties\n\n### MAX_SESSION_RESULTS\n\nThe maximum number of `sessions.Session` that will be included in a requested\nlist.\n\n#### Value\n\n25  \n\n## Methods\n\n### getDevices()\n\nPromise\n\n    \n    \n    chrome.sessions.getDevices(  \n      filter?: Filter,  \n      callback?: function,  \n    )\n\nRetrieves all devices with synced sessions.\n\n#### Parameters\n\n  * filter\n\nFilter optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (devices: Device[]) => void\n\n    * devices\n\nDevice[]\n\nThe list of `sessions.Device` objects for each synced session, sorted in order\nfrom device with most recently modified session to device with least recently\nmodified session. `tabs.Tab` objects are sorted by recency in the\n`windows.Window` of the `sessions.Session` objects.\n\n#### Returns\n\n  * Promise<Device[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getRecentlyClosed()\n\nPromise\n\n    \n    \n    chrome.sessions.getRecentlyClosed(  \n      filter?: Filter,  \n      callback?: function,  \n    )\n\nGets the list of recently closed tabs and/or windows.\n\n#### Parameters\n\n  * filter\n\nFilter optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (sessions: Session[]) => void\n\n    * sessions\n\nSession[]\n\nThe list of closed entries in reverse order that they were closed (the most\nrecently closed tab or window will be at index `0`). The entries may contain\neither tabs or windows.\n\n#### Returns\n\n  * Promise<Session[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### restore()\n\nPromise\n\n    \n    \n    chrome.sessions.restore(  \n      sessionId?: string,  \n      callback?: function,  \n    )\n\nReopens a `windows.Window` or `tabs.Tab`, with an optional callback to run\nwhen the entry has been restored.\n\n#### Parameters\n\n  * sessionId\n\nstring optional\n\nThe `windows.Window.sessionId`, or `tabs.Tab.sessionId` to restore. If this\nparameter is not specified, the most recently closed session is restored.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (restoredSession: Session) => void\n\n    * restoredSession\n\nSession\n\nA `sessions.Session` containing the restored `windows.Window` or `tabs.Tab`\nobject.\n\n#### Returns\n\n  * Promise<Session>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onChanged\n\n    \n    \n    chrome.sessions.onChanged.addListener(  \n      callback: function,  \n    )\n\nFired when recently closed tabs and/or windows are changed. This event does\nnot monitor synced sessions changes.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/sidePanel": "#  chrome.sidePanel\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.sidePanel` API to host content in the browser's side panel\nalongside the main content of a webpage.\n\n## Permissions\n\n`sidePanel`  \n\nTo use the Side Panel API, add the `\"sidePanel\"` permission in the extension\nmanifest file:\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"My side panel extension\",\n      ...\n      \"permissions\": [\n        \"sidePanel\"\n      ]\n    }\n    \n\n## Availability\n\nChrome 114+ MV3+\n\n## Concepts and usage\n\nThe Side Panel API allows extensions to display their own UI in the side\npanel, enabling persistent experiences that complement the user's browsing\njourney.\n\n![Side panel drop-down\nmenu](/static/docs/extensions/reference/api/sidePanel/images/example-side-\npanel.png) Chrome browser side panel UI.\n\nSome features include:\n\n  * The side panel remains open when navigating between tabs (if set to do so).\n  * It can be available only on specific websites.\n  * As an extension page, side panels have access to all Chrome APIs.\n  * Within Chrome's settings, users can specify which side the panel should be displayed on.\n\n### Use cases\n\nThe following sections demonstrate some common use cases for the Side Panel\nAPI. See Extension samples for complete extension examples.\n\n#### Display the same side panel on every site\n\nThe side panel can be set initially from the `\"default_path\"` property in the\n`\"side_panel\"` key of the manifest to display the same side panel on every\nsite. This should point to a relative path within the extension directory.\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"My side panel extension\",\n      ...\n      \"side_panel\": {\n        \"default_path\": \"sidepanel.html\"\n      }\n      ...\n    }\n    \n\nsidepanel.html:\n\n    \n    \n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>My Sidepanel</title>\n      </head>\n      <body>\n        <h1>All sites sidepanel extension</h1>\n        <p>This side panel is enabled on all sites</p>\n      </body>\n    </html>\n    \n\n#### Enable a side panel on a specific site\n\nAn extension can use `sidepanel.setOptions()` to enable a side panel on a\nspecific tab. This example uses `chrome.tabs.onUpdated()` to listen for any\nupdates made to the tab. It checks if the URL is www.google.com and enables\nthe side panel. Otherwise, it disables it.\n\nservice-worker.js:\n\n    \n    \n    const GOOGLE_ORIGIN = 'https://www.google.com';\n    \n    chrome.tabs.onUpdated.addListener(async (tabId, info, tab) => {\n      if (!tab.url) return;\n      const url = new URL(tab.url);\n      // Enables the side panel on google.com\n      if (url.origin === GOOGLE_ORIGIN) {\n        await chrome.sidePanel.setOptions({\n          tabId,\n          path: 'sidepanel.html',\n          enabled: true\n        });\n      } else {\n        // Disables the side panel on all other sites\n        await chrome.sidePanel.setOptions({\n          tabId,\n          enabled: false\n        });\n      }\n    });\n    \n\nWhen a user temporarily switches to a tab where the side panel is not enabled,\nthe side panel will be hidden. It will automatically show again when the user\nswitches to a tab where it was previously open.\n\nWhen the user navigates to a site where the side panel is not enabled, the\nside panel will close, and the extension won't show in the side panel drop-\ndown menu.\n\nFor a complete example, see the Tab-specific side panel sample.\n\n#### Open the side panel by clicking the toolbar icon\n\nDevelopers can allow users to open the side panel when they click the action\ntoolbar icon with `sidePanel.setPanelBehavior()`. First, declare the\n`\"action\"` key in the manifest:\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"My side panel extension\",\n      ...\n      \"action\": {\n        \"default_title\": \"Click to open panel\"\n      },\n      ...\n    }\n    \n\nNow, add this code to the previous example:\n\nservice-worker.js:\n\n    \n    \n    const GOOGLE_ORIGIN = 'https://www.google.com';\n    \n    // Allows users to open the side panel by clicking on the action toolbar icon\n    chrome.sidePanel\n      .setPanelBehavior({ openPanelOnActionClick: true })\n      .catch((error) => console.error(error));\n    ...\n    \n\n#### Programmatically open the side panel on user interaction\n\nChrome 116 introduces `sidePanel.open()`. It allows extensions to open the\nside panel through an extension user gesture, such as clicking on the action\nicon. Or a user interaction on an extension page or content script, such as\nclicking a button. For a complete demo, see the Open Side Panel sample\nextension.\n\nThe following code shows how to open a global side panel on the current window\nwhen the user clicks on a context menu. When using `sidePanel.open()`, you\nmust choose the context in which it should open. Use `windowId` to open a\nglobal side panel. Alternatively, set the `tabId` to open the side panel only\non a specific tab.\n\nservice-worker.js:\n\n    \n    \n    chrome.runtime.onInstalled.addListener(() => {\n      chrome.contextMenus.create({\n        id: 'openSidePanel',\n        title: 'Open side panel',\n        contexts: ['all']\n      });\n    });\n    \n    chrome.contextMenus.onClicked.addListener((info, tab) => {\n      if (info.menuItemId === 'openSidePanel') {\n        // This will open the panel in all the pages on the current window.\n        chrome.sidePanel.open({ windowId: tab.windowId });\n      }\n    });\n    \n\n**Key point:** Remember to design your side panel as a useful companion tool\nfor users, improving their browsing experience without unnecessary\ndistractions. Check the Quality Guidelines in the Program Policies for more\ninfo.\n\n#### Switch to a different panel\n\nExtensions can use `sidepanel.getOptions()` to retrieve the current side\npanel. The following example sets a welcome side panel on\n`runtime.onInstalled()`. Then when the user navigates to a different tab, it\nreplaces it with the main side panel.\n\nservice-worker.js:\n\n    \n    \n    const welcomePage = 'sidepanels/welcome-sp.html';\n    const mainPage = 'sidepanels/main-sp.html';\n    \n    chrome.runtime.onInstalled.addListener(() => {\n      chrome.sidePanel.setOptions({ path: welcomePage });\n      chrome.sidePanel.setPanelBehavior({ openPanelOnActionClick: true });\n    });\n    \n    chrome.tabs.onActivated.addListener(async ({ tabId }) => {\n      const { path } = await chrome.sidePanel.getOptions({ tabId });\n      if (path === welcomePage) {\n        chrome.sidePanel.setOptions({ path: mainPage });\n      }\n    });\n    \n\nSee the Multiple side panels sample for the full code.\n\n### Side panel user experience\n\nUsers will see Chrome's built-in side panels first. Each side panel displays\nthe extension's icon in the side panel menu. If no icons are included, it will\nshow a placeholder icon with the first letter of the extension's name.\n\n#### Open the side panel\n\nTo allow users to open the side panel, use an action icon in combination with\n`sidePanel.setPanelBehavior()`. Alternatively, make a call to\n`sidePanel.open()` following a user interaction, such as:\n\n  * An action click\n  * A keyboard shortcut\n  * A context menu\n  * A user gesture on an extension page or content script.\n\n#### Pin the side panel\n\n![Pin icon in side panel\nUI.](/static/docs/extensions/reference/api/sidePanel/images/side-panel-\npin.png) Pin icon in side panel UI.\n\nThe side panel toolbar displays a pin icon when your side panel is open.\nClicking the icon pins your extension's action icon. Clicking the action icon\nonce pinned will perform the default action for your action icon and will only\nopen the side panel if this has been explicitly configured.\n\n## Examples\n\nFor more Side Panel API extensions demos, explore any of the following\nextensions:\n\n  * Dictionary side panel.\n  * Global side panel.\n  * Multiple side panels.\n  * Open Side panel.\n  * Site-specific side panel.\n\n## Types\n\n### GetPanelOptions\n\n#### Properties\n\n  * tabId\n\nnumber optional\n\nIf specified, the side panel options for the given tab will be returned.\nOtherwise, returns the default side panel options (used for any tab that\ndoesn't have specific settings).\n\n### OpenOptions\n\nChrome 116+\n\n#### Properties\n\n  * tabId\n\nnumber optional\n\nThe tab in which to open the side panel. If the corresponding tab has a tab-\nspecific side panel, the panel will only be open for that tab. If there is not\na tab-specific panel, the global panel will be open in the specified tab and\nany other tabs without a currently-open tab- specific panel. This will\noverride any currently-active side panel (global or tab-specific) in the\ncorresponding tab. At least one of this or `windowId` must be provided.\n\n  * windowId\n\nnumber optional\n\nThe window in which to open the side panel. This is only applicable if the\nextension has a global (non-tab-specific) side panel or `tabId` is also\nspecified. This will override any currently-active global side panel the user\nhas open in the given window. At least one of this or `tabId` must be\nprovided.\n\n### PanelBehavior\n\n#### Properties\n\n  * openPanelOnActionClick\n\nboolean optional\n\nWhether clicking the extension's icon will toggle showing the extension's\nentry in the side panel. Defaults to false.\n\n### PanelOptions\n\n#### Properties\n\n  * enabled\n\nboolean optional\n\nWhether the side panel should be enabled. This is optional. The default value\nis true.\n\n  * path\n\nstring optional\n\nThe path to the side panel HTML file to use. This must be a local resource\nwithin the extension package.\n\n  * tabId\n\nnumber optional\n\nIf specified, the side panel options will only apply to the tab with this id.\nIf omitted, these options set the default behavior (used for any tab that\ndoesn't have specific settings). Note: if the same path is set for this tabId\nand the default tabId, then the panel for this tabId will be a different\ninstance than the panel for the default tabId.\n\n### SidePanel\n\n#### Properties\n\n  * default_path\n\nstring\n\nDeveloper specified path for side panel display.\n\n## Methods\n\n### getOptions()\n\nPromise\n\n    \n    \n    chrome.sidePanel.getOptions(  \n      options: GetPanelOptions,  \n      callback?: function,  \n    )\n\nReturns the active panel configuration.\n\n#### Parameters\n\n  * options\n\nGetPanelOptions\n\nSpecifies the context to return the configuration for.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (options: PanelOptions) => void\n\n    * options\n\nPanelOptions\n\n#### Returns\n\n  * Promise<PanelOptions>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPanelBehavior()\n\nPromise\n\n    \n    \n    chrome.sidePanel.getPanelBehavior(  \n      callback?: function,  \n    )\n\nReturns the extension's current side panel behavior.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (behavior: PanelBehavior) => void\n\n    * behavior\n\nPanelBehavior\n\n#### Returns\n\n  * Promise<PanelBehavior>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### open()\n\nPromise Chrome 116+\n\n    \n    \n    chrome.sidePanel.open(  \n      options: OpenOptions,  \n      callback?: function,  \n    )\n\nOpens the side panel for the extension. This may only be called in response to\na user action.\n\n#### Parameters\n\n  * options\n\nOpenOptions\n\nSpecifies the context in which to open the side panel.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setOptions()\n\nPromise\n\n    \n    \n    chrome.sidePanel.setOptions(  \n      options: PanelOptions,  \n      callback?: function,  \n    )\n\nConfigures the side panel.\n\n#### Parameters\n\n  * options\n\nPanelOptions\n\nThe configuration options to apply to the panel.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setPanelBehavior()\n\nPromise\n\n    \n    \n    chrome.sidePanel.setPanelBehavior(  \n      behavior: PanelBehavior,  \n      callback?: function,  \n    )\n\nConfigures the extension's side panel behavior. This is an upsert operation.\n\n#### Parameters\n\n  * behavior\n\nPanelBehavior\n\nThe new behavior to be set.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/storage": "#  chrome.storage\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.storage` API to store, retrieve, and track changes to user\ndata.\n\n## Permissions\n\n`storage`  \n\nTo use the storage API, declare the `\"storage\"` permission in the extension\nmanifest. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"storage\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nThe Storage API provides an extension-specific way to persist user data and\nstate. It's similar to the web platform's storage APIs (IndexedDB, and\nStorage), but was designed to meet the storage needs of extensions. The\nfollowing are a few key features:\n\n  * All extension contexts, including the extension service worker and content scripts have access to the Storage API.\n  * The JSON serializable values are stored as object properties.\n  * The Storage API is asynchronous with bulk read and write operations.\n  * Even if the user clears the cache and browsing history, the data persists.\n  * Stored settings persist even when using split incognito.\n  * Includes an exclusive read-only managed storage area for enterprise policies.\n\n### Can extensions use web storage APIs?\n\nWhile extensions can use the `Storage` interface (accessible from\n`window.localStorage`) in some contexts (popup and other HTML pages), we don't\nrecommend it for the following reasons:\n\n  * Extension service workers can't use the Web Storage API.\n  * Content scripts share storage with the host page.\n  * Data saved using the Web Storage API is lost when the user clears their browsing history.\n\nTo move data from web storage APIs to extension storage APIs from a service\nworker:\n\n  1. Prepare an offscreen document html page and script file. The script file should contain a conversion routine and an `onMessage` handler.\n  2. In the extension service worker, check `chrome.storage` for your data.\n  3. If your data isn't found, call `createDocument()`.\n  4. After the returned Promise resolves, call `sendMessage()` to start the conversion routine.\n  5. Inside the offscreen document's `onMessage` handler, call the conversion routine.\n\nThere are also some nuances to how web storage APIs work in extensions. Learn\nmore in the Storage and Cookies article.\n\n### Storage areas\n\nThe Storage API is divided into the following storage areas:\n\n`storage.local`\n\n    Data is stored locally and cleared when the extension is removed. The storage limit is 10 MB (5 MB in Chrome 113 and earlier), but can be increased by requesting the `\"unlimitedStorage\"` permission. We recommend using `storage.local` to store larger amounts of data.\n`storage.managed`\n\n    Managed storage is read-only storage for policy installed extensions and managed by system administrators using a developer-defined schema and enterprise policies. Policies are analogous to options but are configured by a system administrator instead of the user, allowing the extension to be preconfigured for all users of an organization. For information on policies, see Documentation for Administrators. To learn more about the `managed` storage area, see Manifest for storage areas.\n`storage.session`\n\n    Holds data in memory while an extension is loaded. The storage is cleared if the extension is disabled, reloaded or updated and when the browser restarts. By default, it's not exposed to content scripts, but this behavior can be changed by setting `chrome.storage.session.setAccessLevel()`. The storage limit is 10 MB (1 MB in Chrome 111 and earlier). The`storage.session` interface is one of several we recommend for service workers.\n`storage.sync`\n\n    If syncing is enabled, the data is synced to any Chrome browser that the user is logged into. If disabled, it behaves like `storage.local`. Chrome stores the data locally when the browser is offline and resumes syncing when it's back online. The quota limitation is approximately 100 KB, 8 KB per item. We recommend using `storage.sync` to preserve user settings across synced browsers. If you're working with sensitive user data, instead use `storage.session`.\n\n### Storage and throttling limits\n\nThe Storage API has the following usage limitations:\n\n  * Storing data often comes with performance costs, and the API includes storage quotas. We recommend being careful about what data you store so that you don't lose the ability to store data.\n  * Storage can take time to complete. Make sure to structure your code to account for that time.\n\nFor details on storage area limitations and what happens when they're\nexceeded, see the quota information for `sync`, `local`, and `session`.\n\n## Use cases\n\nThe following sections demonstrate common use cases for the Storage API.\n\n### Synchronous response to storage updates\n\nTo track changes made to storage, add a listener to its `onChanged` event.\nWhen anything changes in storage, that event fires. The sample code listens\nfor these changes:\n\nbackground.js:\n\n    \n    \n    chrome.storage.onChanged.addListener((changes, namespace) => {\n      for (let [key, { oldValue, newValue }] of Object.entries(changes)) {\n        console.log(\n          `Storage key \"${key}\" in namespace \"${namespace}\" changed.`,\n          `Old value was \"${oldValue}\", new value is \"${newValue}\".`\n        );\n      }\n    });\n    \n\nWe can take this idea even further. In this example, we have an options page\nthat allows the user to toggle a \"debug mode\" (implementation not shown here).\nThe options page immediately saves the new settings to `storage.sync`, and the\nservice worker uses `storage.onChanged` to apply the setting as soon as\npossible.\n\noptions.html:\n\n    \n    \n    <!-- type=\"module\" allows you to use top level await -->\n    <script defer src=\"options.js\" type=\"module\"></script>\n    <form id=\"optionsForm\">\n      <label for=\"debug\">\n        <input type=\"checkbox\" name=\"debug\" id=\"debug\">\n        Enable debug mode\n      </label>\n    </form>\n    \n\noptions.js:\n\n    \n    \n    // In-page cache of the user's options\n    const options = {};\n    const optionsForm = document.getElementById(\"optionsForm\");\n    \n    // Immediately persist options changes\n    optionsForm.debug.addEventListener(\"change\", (event) => {\n      options.debug = event.target.checked;\n      chrome.storage.sync.set({ options });\n    });\n    \n    // Initialize the form with the user's option settings\n    const data = await chrome.storage.sync.get(\"options\");\n    Object.assign(options, data.options);\n    optionsForm.debug.checked = Boolean(options.debug);\n    \n\nbackground.js:\n\n    \n    \n    function setDebugMode() { /* ... */ }\n    \n    // Watch for changes to the user's options & apply them\n    chrome.storage.onChanged.addListener((changes, area) => {\n      if (area === 'sync' && changes.options?.newValue) {\n        const debugMode = Boolean(changes.options.newValue.debug);\n        console.log('enable debug mode?', debugMode);\n        setDebugMode(debugMode);\n      }\n    });\n    \n\n### Asynchronous preload from storage\n\nBecause service workers don't run all the time, Manifest V3 extensions\nsometimes need to asynchronously load data from storage before they execute\ntheir event handlers. To do this, the following snippet uses an async\n`action.onClicked` event handler that waits for the `storageCache` global to\nbe populated before executing its logic.\n\nbackground.js:\n\n    \n    \n    // Where we will expose all the data we retrieve from storage.sync.\n    const storageCache = { count: 0 };\n    // Asynchronously retrieve data from storage.sync, then cache it.\n    const initStorageCache = chrome.storage.sync.get().then((items) => {\n      // Copy the data retrieved from storage into storageCache.\n      Object.assign(storageCache, items);\n    });\n    \n    chrome.action.onClicked.addListener(async (tab) => {\n      try {\n        await initStorageCache;\n      } catch (e) {\n        // Handle error that occurred during storage initialization.\n      }\n    \n      // Normal action handler logic.\n      storageCache.count++;\n      storageCache.lastTabId = tab.id;\n      chrome.storage.sync.set(storageCache);\n    });\n    \n\n## DevTools\n\nYou can view and edit data stored using the API in DevTools. To learn more,\nsee the View and edit extension storage page in the DevTools documentation.\n\n## Examples\n\nThe following samples demonstrate the `local`, `sync`, and `session` storage\nareas:\n\n### Local\n\n    \n    \n    chrome.storage.local.set({ key: value }).then(() => {\n      console.log(\"Value is set\");\n    });\n    \n    chrome.storage.local.get([\"key\"]).then((result) => {\n      console.log(\"Value is \" + result.key);\n    });\n    \n\n### Sync\n\n    \n    \n    chrome.storage.sync.set({ key: value }).then(() => {\n      console.log(\"Value is set\");\n    });\n    \n    chrome.storage.sync.get([\"key\"]).then((result) => {\n      console.log(\"Value is \" + result.key);\n    });\n    \n\n### Session\n\n    \n    \n    chrome.storage.session.set({ key: value }).then(() => {\n      console.log(\"Value was set\");\n    });\n    \n    chrome.storage.session.get([\"key\"]).then((result) => {\n      console.log(\"Value is \" + result.key);\n    });\n    \n\nTo see other demos of the Storage API, explore any of the following samples:\n\n  * Global search extension.\n  * Water alarm extension.\n\n## Types\n\n### AccessLevel\n\nChrome 102+\n\nThe storage area's access level.\n\n#### Enum\n\n\"TRUSTED_CONTEXTS\"  \nSpecifies contexts originating from the extension itself.\n\n\"TRUSTED_AND_UNTRUSTED_CONTEXTS\"  \nSpecifies contexts originating from outside the extension.\n\n### StorageArea\n\n#### Properties\n\n  * onChanged\n\nEvent<functionvoidvoid>\n\nChrome 73+\n\nFired when one or more items change.\n\nThe `onChanged.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (changes: object) => void\n\n      * changes\n\nobject\n\n  * clear\n\nvoid\n\nPromise\n\nRemoves all items from storage.\n\nThe `clear` function looks like:\n\n        \n        (callback?: function) => {...}\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nChrome 95+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * get\n\nvoid\n\nPromise\n\nGets one or more items from storage.\n\nThe `get` function looks like:\n\n        \n        (keys?: string | string[] | object, callback?: function) => {...}\n\n    * keys\n\nstring | string[] | object optional\n\nA single key to get, list of keys to get, or a dictionary specifying default\nvalues (see description of the object). An empty list or object will return an\nempty result object. Pass in `null` to get the entire contents of storage.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (items: object) => void\n\n      * items\n\nobject\n\nObject with items in their key-value mappings.\n\n    * returns\n\nPromise<object>\n\nChrome 95+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * getBytesInUse\n\nvoid\n\nPromise\n\nGets the amount of space (in bytes) being used by one or more items.\n\nThe `getBytesInUse` function looks like:\n\n        \n        (keys?: string | string[], callback?: function) => {...}\n\n    * keys\n\nstring | string[] optional\n\nA single key or list of keys to get the total usage for. An empty list will\nreturn 0. Pass in `null` to get the total usage of all of storage.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (bytesInUse: number) => void\n\n      * bytesInUse\n\nnumber\n\nAmount of space being used in storage, in bytes.\n\n    * returns\n\nPromise<number>\n\nChrome 95+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * getKeys\n\nvoid\n\nPromise Chrome 130+\n\nGets all keys from storage.\n\nThe `getKeys` function looks like:\n\n        \n        (callback?: function) => {...}\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (keys: string[]) => void\n\n      * keys\n\nstring[]\n\nArray with keys read from storage.\n\n    * returns\n\nPromise<string[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * remove\n\nvoid\n\nPromise\n\nRemoves one or more items from storage.\n\nThe `remove` function looks like:\n\n        \n        (keys: string | string[], callback?: function) => {...}\n\n    * keys\n\nstring | string[]\n\nA single key or a list of keys for items to remove.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nChrome 95+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * set\n\nvoid\n\nPromise\n\nSets multiple items.\n\nThe `set` function looks like:\n\n        \n        (items: object, callback?: function) => {...}\n\n    * items\n\nobject\n\nAn object which gives each key/value pair to update storage with. Any other\nkey/value pairs in storage will not be affected.\n\nPrimitive values such as numbers will serialize as expected. Values with a\n`typeof` `\"object\"` and `\"function\"` will typically serialize to `{}`, with\nthe exception of `Array` (serializes as expected), `Date`, and `Regex`\n(serialize using their `String` representation).\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nChrome 95+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * setAccessLevel\n\nvoid\n\nPromise Chrome 102+\n\nSets the desired access level for the storage area. The default will be only\ntrusted contexts.\n\nThe `setAccessLevel` function looks like:\n\n        \n        (accessOptions: object, callback?: function) => {...}\n\n    * accessOptions\n\nobject\n\n      * accessLevel\n\nAccessLevel\n\nThe access level of the storage area.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### StorageChange\n\n#### Properties\n\n  * newValue\n\nany optional\n\nThe new value of the item, if there is a new value.\n\n  * oldValue\n\nany optional\n\nThe old value of the item, if there was an old value.\n\n## Properties\n\n### local\n\nItems in the `local` storage area are local to each machine.\n\n#### Type\n\nStorageArea & object\n\n#### Properties\n\n  * QUOTA_BYTES\n\n10485760  \n\nThe maximum amount (in bytes) of data that can be stored in local storage, as\nmeasured by the JSON stringification of every value plus every key's length.\nThis value will be ignored if the extension has the `unlimitedStorage`\npermission. Updates that would cause this limit to be exceeded fail\nimmediately and set `runtime.lastError` when using a callback, or a rejected\nPromise if using async/await.\n\n### managed\n\nItems in the `managed` storage area are set by an enterprise policy configured\nby the domain administrator, and are read-only for the extension; trying to\nmodify this namespace results in an error. For information on configuring a\npolicy, see Manifest for storage areas.\n\n#### Type\n\nStorageArea\n\n### session\n\nChrome 102+ MV3+\n\nItems in the `session` storage area are stored in-memory and will not be\npersisted to disk.\n\n#### Type\n\nStorageArea & object\n\n#### Properties\n\n  * QUOTA_BYTES\n\n10485760  \n\nThe maximum amount (in bytes) of data that can be stored in memory, as\nmeasured by estimating the dynamically allocated memory usage of every value\nand key. Updates that would cause this limit to be exceeded fail immediately\nand set `runtime.lastError` when using a callback, or when a Promise is\nrejected.\n\n### sync\n\nItems in the `sync` storage area are synced using Chrome Sync.\n\n#### Type\n\nStorageArea & object\n\n#### Properties\n\n  * MAX_ITEMS\n\n512  \n\nThe maximum number of items that can be stored in sync storage. Updates that\nwould cause this limit to be exceeded will fail immediately and set\n`runtime.lastError` when using a callback, or when a Promise is rejected.\n\n  * MAX_SUSTAINED_WRITE_OPERATIONS_PER_MINUTE\n\n1000000  \n\nDeprecated\n\nThe storage.sync API no longer has a sustained write operation quota.\n\n  * MAX_WRITE_OPERATIONS_PER_HOUR\n\n1800  \n\nThe maximum number of `set`, `remove`, or `clear` operations that can be\nperformed each hour. This is 1 every 2 seconds, a lower ceiling than the short\nterm higher writes-per-minute limit.\n\nUpdates that would cause this limit to be exceeded fail immediately and set\n`runtime.lastError` when using a callback, or when a Promise is rejected.\n\n  * MAX_WRITE_OPERATIONS_PER_MINUTE\n\n120  \n\nThe maximum number of `set`, `remove`, or `clear` operations that can be\nperformed each minute. This is 2 per second, providing higher throughput than\nwrites-per-hour over a shorter period of time.\n\nUpdates that would cause this limit to be exceeded fail immediately and set\n`runtime.lastError` when using a callback, or when a Promise is rejected.\n\n  * QUOTA_BYTES\n\n102400  \n\nThe maximum total amount (in bytes) of data that can be stored in sync\nstorage, as measured by the JSON stringification of every value plus every\nkey's length. Updates that would cause this limit to be exceeded fail\nimmediately and set `runtime.lastError` when using a callback, or when a\nPromise is rejected.\n\n  * QUOTA_BYTES_PER_ITEM\n\n8192  \n\nThe maximum size (in bytes) of each individual item in sync storage, as\nmeasured by the JSON stringification of its value plus its key length. Updates\ncontaining items larger than this limit will fail immediately and set\n`runtime.lastError` when using a callback, or when a Promise is rejected.\n\n## Events\n\n### onChanged\n\n    \n    \n    chrome.storage.onChanged.addListener(  \n      callback: function,  \n    )\n\nFired when one or more items change.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (changes: object, areaName: string) => void\n\n    * changes\n\nobject\n\n    * areaName\n\nstring\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/system/cpu": "#  chrome.system.cpu\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `system.cpu` API to query CPU metadata.\n\n## Permissions\n\n`system.cpu`  \n\n## Types\n\n### CpuInfo\n\n#### Properties\n\n  * archName\n\nstring\n\nThe architecture name of the processors.\n\n  * features\n\nstring[]\n\nA set of feature codes indicating some of the processor's capabilities. The\ncurrently supported codes are \"mmx\", \"sse\", \"sse2\", \"sse3\", \"ssse3\", \"sse4_1\",\n\"sse4_2\", and \"avx\".\n\n  * modelName\n\nstring\n\nThe model name of the processors.\n\n  * numOfProcessors\n\nnumber\n\nThe number of logical processors.\n\n  * processors\n\nProcessorInfo[]\n\nInformation about each logical processor.\n\n  * temperatures\n\nnumber[]\n\nChrome 60+\n\nList of CPU temperature readings from each thermal zone of the CPU.\nTemperatures are in degrees Celsius.\n\n**Currently supported on Chrome OS only.**\n\n### CpuTime\n\n#### Properties\n\n  * idle\n\nnumber\n\nThe cumulative time spent idle by this processor.\n\n  * kernel\n\nnumber\n\nThe cumulative time used by kernel programs on this processor.\n\n  * total\n\nnumber\n\nThe total cumulative time for this processor. This value is equal to user +\nkernel + idle.\n\n  * user\n\nnumber\n\nThe cumulative time used by userspace programs on this processor.\n\n### ProcessorInfo\n\n#### Properties\n\n  * usage\n\nCpuTime\n\nCumulative usage info for this logical processor.\n\n## Methods\n\n### getInfo()\n\nPromise\n\n    \n    \n    chrome.system.cpu.getInfo(  \n      callback?: function,  \n    )\n\nQueries basic CPU information of the system.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (info: CpuInfo) => void\n\n    * info\n\nCpuInfo\n\n#### Returns\n\n  * Promise<CpuInfo>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/system/display": "#  chrome.system.display\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `system.display` API to query display metadata.\n\n## Permissions\n\n`system.display`  \n\n## Types\n\n### ActiveState\n\nChrome 117+\n\nAn enum to tell if the display is detected and used by the system. The display\nis considered 'inactive', if it is not detected by the system (maybe\ndisconnected, or considered disconnected due to sleep mode, etc). This state\nis used to keep existing display when the all displays are disconnected, for\nexample.\n\n#### Enum\n\n\"active\"  \n\n\"inactive\"  \n\n### Bounds\n\n#### Properties\n\n  * height\n\nnumber\n\nThe height of the display in pixels.\n\n  * left\n\nnumber\n\nThe x-coordinate of the upper-left corner.\n\n  * top\n\nnumber\n\nThe y-coordinate of the upper-left corner.\n\n  * width\n\nnumber\n\nThe width of the display in pixels.\n\n### DisplayLayout\n\nChrome 53+\n\n#### Properties\n\n  * id\n\nstring\n\nThe unique identifier of the display.\n\n  * offset\n\nnumber\n\nThe offset of the display along the connected edge. 0 indicates that the\ntopmost or leftmost corners are aligned.\n\n  * parentId\n\nstring\n\nThe unique identifier of the parent display. Empty if this is the root.\n\n  * position\n\nLayoutPosition\n\nThe layout position of this display relative to the parent. This will be\nignored for the root.\n\n### DisplayMode\n\nChrome 52+\n\n#### Properties\n\n  * deviceScaleFactor\n\nnumber\n\nThe display mode device scale factor.\n\n  * height\n\nnumber\n\nThe display mode height in device independent (user visible) pixels.\n\n  * heightInNativePixels\n\nnumber\n\nThe display mode height in native pixels.\n\n  * isInterlaced\n\nboolean optional\n\nChrome 74+\n\nTrue if this mode is interlaced, false if not provided.\n\n  * isNative\n\nboolean\n\nTrue if the mode is the display's native mode.\n\n  * isSelected\n\nboolean\n\nTrue if the display mode is currently selected.\n\n  * refreshRate\n\nnumber\n\nChrome 67+\n\nThe display mode refresh rate in hertz.\n\n  * uiScale\n\nnumber optional\n\nDeprecated since Chrome 70\n\nUse `displayZoomFactor`\n\nThe display mode UI scale factor.\n\n  * width\n\nnumber\n\nThe display mode width in device independent (user visible) pixels.\n\n  * widthInNativePixels\n\nnumber\n\nThe display mode width in native pixels.\n\n### DisplayProperties\n\n#### Properties\n\n  * boundsOriginX\n\nnumber optional\n\nIf set, updates the display's logical bounds origin along the x-axis. Applied\ntogether with `boundsOriginY`. Defaults to the current value if not set and\n`boundsOriginY` is set. Note that when updating the display origin, some\nconstraints will be applied, so the final bounds origin may be different than\nthe one set. The final bounds can be retrieved using `getInfo`. The bounds\norigin cannot be changed on the primary display.\n\n  * boundsOriginY\n\nnumber optional\n\nIf set, updates the display's logical bounds origin along the y-axis. See\ndocumentation for `boundsOriginX` parameter.\n\n  * displayMode\n\nDisplayMode optional\n\nChrome 52+\n\nIf set, updates the display mode to the mode matching this value. If other\nparameters are invalid, this will not be applied. If the display mode is\ninvalid, it will not be applied and an error will be set, but other properties\nwill still be applied.\n\n  * displayZoomFactor\n\nnumber optional\n\nChrome 65+\n\nIf set, updates the zoom associated with the display. This zoom performs re-\nlayout and repaint thus resulting in a better quality zoom than just\nperforming a pixel by pixel stretch enlargement.\n\n  * isPrimary\n\nboolean optional\n\nIf set to true, makes the display primary. No-op if set to false. Note: If\nset, the display is considered primary for all other properties (i.e.\n`isUnified` may be set and bounds origin may not).\n\n  * isUnified\n\nboolean optional\n\nChrome 59+\n\nChromeOS only. If set to true, changes the display mode to unified desktop\n(see `enableUnifiedDesktop` for details). If set to false, unified desktop\nmode will be disabled. This is only valid for the primary display. If\nprovided, mirroringSourceId must not be provided and other properties will be\nignored. This is has no effect if not provided.\n\n  * mirroringSourceId\n\nstring optional\n\nDeprecated since Chrome 68\n\nUse `setMirrorMode`.\n\nChromeOS only. If set and not empty, enables mirroring for this display only.\nOtherwise disables mirroring for all displays. This value should indicate the\nid of the source display to mirror, which must not be the same as the id\npassed to setDisplayProperties. If set, no other property may be set.\n\n  * overscan\n\nInsets optional\n\nIf set, sets the display's overscan insets to the provided values. Note that\noverscan values may not be negative or larger than a half of the screen's\nsize. Overscan cannot be changed on the internal monitor.\n\n  * rotation\n\nnumber optional\n\nIf set, updates the display's rotation. Legal values are [0, 90, 180, 270].\nThe rotation is set clockwise, relative to the display's vertical position.\n\n### DisplayUnitInfo\n\n#### Properties\n\n  * activeState\n\nActiveState\n\nChrome 117+\n\nActive if the display is detected and used by the system.\n\n  * availableDisplayZoomFactors\n\nnumber[]\n\nChrome 67+\n\nA list of zoom factor values that can be set for the display.\n\n  * bounds\n\nBounds\n\nThe display's logical bounds.\n\n  * displayZoomFactor\n\nnumber\n\nChrome 65+\n\nThe ratio between the display's current and default zoom. For example, value 1\nis equivalent to 100% zoom, and value 1.5 is equivalent to 150% zoom.\n\n  * dpiX\n\nnumber\n\nThe number of pixels per inch along the x-axis.\n\n  * dpiY\n\nnumber\n\nThe number of pixels per inch along the y-axis.\n\n  * edid\n\nEdid optional\n\nChrome 67+\n\nNOTE: This is only available to ChromeOS Kiosk apps and Web UI.\n\n  * hasTouchSupport\n\nboolean\n\nChrome 57+\n\nTrue if this display has a touch input device associated with it.\n\n  * id\n\nstring\n\nThe unique identifier of the display.\n\n  * isEnabled\n\nboolean\n\nTrue if this display is enabled.\n\n  * isPrimary\n\nboolean\n\nTrue if this is the primary display.\n\n  * isUnified\n\nboolean\n\nChrome 59+\n\nTrue for all displays when in unified desktop mode. See documentation for\n`enableUnifiedDesktop`.\n\n  * mirroringDestinationIds\n\nstring[]\n\nChrome 64+\n\nChromeOS only. Identifiers of the displays to which the source display is\nbeing mirrored. Empty if no displays are being mirrored. This will be set to\nthe same value for all displays. This must not include `mirroringSourceId`.\n\n  * mirroringSourceId\n\nstring\n\nChromeOS only. Identifier of the display that is being mirrored if mirroring\nis enabled, otherwise empty. This will be set for all displays (including the\ndisplay being mirrored).\n\n  * modes\n\nDisplayMode[]\n\nChrome 52+\n\nThe list of available display modes. The current mode will have\nisSelected=true. Only available on ChromeOS. Will be set to an empty array on\nother platforms.\n\n  * name\n\nstring\n\nThe user-friendly name (e.g. \"HP LCD monitor\").\n\n  * overscan\n\nInsets\n\nThe display's insets within its screen's bounds. Currently exposed only on\nChromeOS. Will be set to empty insets on other platforms.\n\n  * rotation\n\nnumber\n\nThe display's clockwise rotation in degrees relative to the vertical position.\nCurrently exposed only on ChromeOS. Will be set to 0 on other platforms. A\nvalue of -1 will be interpreted as auto-rotate when the device is in a\nphysical tablet state.\n\n  * workArea\n\nBounds\n\nThe usable work area of the display within the display bounds. The work area\nexcludes areas of the display reserved for OS, for example taskbar and\nlauncher.\n\n### Edid\n\nChrome 67+\n\n#### Properties\n\n  * manufacturerId\n\nstring\n\n3 character manufacturer code. See Sec. 3.4.1 page 21. Required in v1.4.\n\n  * productId\n\nstring\n\n2 byte manufacturer-assigned code, Sec. 3.4.2 page 21. Required in v1.4.\n\n  * yearOfManufacture\n\nnumber\n\nYear of manufacturer, Sec. 3.4.4 page 22. Required in v1.4.\n\n### GetInfoFlags\n\nChrome 59+\n\n#### Properties\n\n  * singleUnified\n\nboolean optional\n\nIf set to true, only a single `DisplayUnitInfo` will be returned by `getInfo`\nwhen in unified desktop mode (see `enableUnifiedDesktop`). Defaults to false.\n\n### Insets\n\n#### Properties\n\n  * bottom\n\nnumber\n\nThe y-axis distance from the bottom bound.\n\n  * left\n\nnumber\n\nThe x-axis distance from the left bound.\n\n  * right\n\nnumber\n\nThe x-axis distance from the right bound.\n\n  * top\n\nnumber\n\nThe y-axis distance from the top bound.\n\n### LayoutPosition\n\nChrome 53+\n\nLayout position, i.e. edge of parent that the display is attached to.\n\n#### Enum\n\n\"top\"  \n\n\"right\"  \n\n\"bottom\"  \n\n\"left\"  \n\n### MirrorMode\n\nChrome 65+\n\nMirror mode, i.e. different ways of how a display is mirrored to other\ndisplays.\n\n#### Enum\n\n\"off\"  \nSpecifies the default mode (extended or unified desktop).\n\n\"normal\"  \nSpecifies that the default source display will be mirrored to all other\ndisplays.\n\n\"mixed\"  \nSpecifies that the specified source display will be mirrored to the provided\ndestination displays. All other connected displays will be extended.\n\n### MirrorModeInfo\n\nChrome 65+\n\n#### Properties\n\n  * mirroringDestinationIds\n\nstring[] optional\n\nThe ids of the mirroring destination displays. This is only valid for 'mixed'.\n\n  * mirroringSourceId\n\nstring optional\n\nThe id of the mirroring source display. This is only valid for 'mixed'.\n\n  * mode\n\nMirrorMode\n\nThe mirror mode that should be set.\n\n### Point\n\nChrome 57+\n\n#### Properties\n\n  * x\n\nnumber\n\nThe x-coordinate of the point.\n\n  * y\n\nnumber\n\nThe y-coordinate of the point.\n\n### TouchCalibrationPair\n\nChrome 57+\n\n#### Properties\n\n  * displayPoint\n\nPoint\n\nThe coordinates of the display point.\n\n  * touchPoint\n\nPoint\n\nThe coordinates of the touch point corresponding to the display point.\n\n### TouchCalibrationPairQuad\n\nChrome 57+\n\n#### Properties\n\n  * pair1\n\nTouchCalibrationPair\n\nFirst pair of touch and display point required for touch calibration.\n\n  * pair2\n\nTouchCalibrationPair\n\nSecond pair of touch and display point required for touch calibration.\n\n  * pair3\n\nTouchCalibrationPair\n\nThird pair of touch and display point required for touch calibration.\n\n  * pair4\n\nTouchCalibrationPair\n\nFourth pair of touch and display point required for touch calibration.\n\n## Methods\n\n### clearTouchCalibration()\n\nChrome 57+\n\n    \n    \n    chrome.system.display.clearTouchCalibration(  \n      id: string,  \n    )\n\nResets the touch calibration for the display and brings it back to its default\nstate by clearing any touch calibration data associated with the display.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n### completeCustomTouchCalibration()\n\nChrome 57+\n\n    \n    \n    chrome.system.display.completeCustomTouchCalibration(  \n      pairs: TouchCalibrationPairQuad,  \n      bounds: Bounds,  \n    )\n\nSets the touch calibration pairs for a display. These `pairs` would be used to\ncalibrate the touch screen for display with `id` called in\nstartCustomTouchCalibration(). Always call `startCustomTouchCalibration`\nbefore calling this method. If another touch calibration is already in\nprogress this will throw an error.\n\n#### Parameters\n\n  * pairs\n\nTouchCalibrationPairQuad\n\nThe pairs of point used to calibrate the display.\n\n  * bounds\n\nBounds\n\nBounds of the display when the touch calibration was performed. `bounds.left`\nand `bounds.top` values are ignored.\n\n### enableUnifiedDesktop()\n\nChrome 46+\n\n    \n    \n    chrome.system.display.enableUnifiedDesktop(  \n      enabled: boolean,  \n    )\n\nEnables/disables the unified desktop feature. If enabled while mirroring is\nactive, the desktop mode will not change until mirroring is turned off.\nOtherwise, the desktop mode will switch to unified immediately. NOTE: This is\nonly available to ChromeOS Kiosk apps and Web UI.\n\n#### Parameters\n\n  * enabled\n\nboolean\n\nTrue if unified desktop should be enabled.\n\n### getDisplayLayout()\n\nPromise Chrome 53+\n\n    \n    \n    chrome.system.display.getDisplayLayout(  \n      callback?: function,  \n    )\n\nRequests the layout info for all displays. NOTE: This is only available to\nChromeOS Kiosk apps and Web UI.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (layouts: DisplayLayout[]) => void\n\n    * layouts\n\nDisplayLayout[]\n\n#### Returns\n\n  * Promise<DisplayLayout[]>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getInfo()\n\nPromise\n\n    \n    \n    chrome.system.display.getInfo(  \n      flags?: GetInfoFlags,  \n      callback?: function,  \n    )\n\nRequests the information for all attached display devices.\n\n#### Parameters\n\n  * flags\n\nGetInfoFlags optional\n\nChrome 59+\n\nOptions affecting how the information is returned.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (displayInfo: DisplayUnitInfo[]) => void\n\n    * displayInfo\n\nDisplayUnitInfo[]\n\n#### Returns\n\n  * Promise<DisplayUnitInfo[]>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### overscanCalibrationAdjust()\n\nChrome 53+\n\n    \n    \n    chrome.system.display.overscanCalibrationAdjust(  \n      id: string,  \n      delta: Insets,  \n    )\n\nAdjusts the current overscan insets for a display. Typically this should\neither move the display along an axis (e.g. left+right have the same value) or\nscale it along an axis (e.g. top+bottom have opposite values). Each Adjust\ncall is cumulative with previous calls since Start.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n  * delta\n\nInsets\n\nThe amount to change the overscan insets.\n\n### overscanCalibrationComplete()\n\nChrome 53+\n\n    \n    \n    chrome.system.display.overscanCalibrationComplete(  \n      id: string,  \n    )\n\nComplete overscan adjustments for a display by saving the current values and\nhiding the overlay.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n### overscanCalibrationReset()\n\nChrome 53+\n\n    \n    \n    chrome.system.display.overscanCalibrationReset(  \n      id: string,  \n    )\n\nResets the overscan insets for a display to the last saved value (i.e before\nStart was called).\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n### overscanCalibrationStart()\n\nChrome 53+\n\n    \n    \n    chrome.system.display.overscanCalibrationStart(  \n      id: string,  \n    )\n\nStarts overscan calibration for a display. This will show an overlay on the\nscreen indicating the current overscan insets. If overscan calibration for\ndisplay `id` is in progress this will reset calibration.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n### setDisplayLayout()\n\nPromise Chrome 53+\n\n    \n    \n    chrome.system.display.setDisplayLayout(  \n      layouts: DisplayLayout[],  \n      callback?: function,  \n    )\n\nSet the layout for all displays. Any display not included will use the default\nlayout. If a layout would overlap or be otherwise invalid it will be adjusted\nto a valid layout. After layout is resolved, an onDisplayChanged event will be\ntriggered. NOTE: This is only available to ChromeOS Kiosk apps and Web UI.\n\n#### Parameters\n\n  * layouts\n\nDisplayLayout[]\n\nThe layout information, required for all displays except the primary display.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setDisplayProperties()\n\nPromise\n\n    \n    \n    chrome.system.display.setDisplayProperties(  \n      id: string,  \n      info: DisplayProperties,  \n      callback?: function,  \n    )\n\nUpdates the properties for the display specified by `id`, according to the\ninformation provided in `info`. On failure, `runtime.lastError` will be set.\nNOTE: This is only available to ChromeOS Kiosk apps and Web UI.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n  * info\n\nDisplayProperties\n\nThe information about display properties that should be changed. A property\nwill be changed only if a new value for it is specified in `info`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setMirrorMode()\n\nPromise Chrome 65+\n\n    \n    \n    chrome.system.display.setMirrorMode(  \n      info: MirrorModeInfo,  \n      callback?: function,  \n    )\n\nSets the display mode to the specified mirror mode. Each call resets the state\nfrom previous calls. Calling setDisplayProperties() will fail for the\nmirroring destination displays. NOTE: This is only available to ChromeOS Kiosk\napps and Web UI.\n\n#### Parameters\n\n  * info\n\nMirrorModeInfo\n\nThe information of the mirror mode that should be applied to the display mode.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### showNativeTouchCalibration()\n\nPromise Chrome 57+\n\n    \n    \n    chrome.system.display.showNativeTouchCalibration(  \n      id: string,  \n      callback?: function,  \n    )\n\nDisplays the native touch calibration UX for the display with `id` as display\nid. This will show an overlay on the screen with required instructions on how\nto proceed. The callback will be invoked in case of successful calibration\nonly. If the calibration fails, this will throw an error.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### startCustomTouchCalibration()\n\nChrome 57+\n\n    \n    \n    chrome.system.display.startCustomTouchCalibration(  \n      id: string,  \n    )\n\nStarts custom touch calibration for a display. This should be called when\nusing a custom UX for collecting calibration data. If another touch\ncalibration is already in progress this will throw an error.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n## Events\n\n### onDisplayChanged\n\n    \n    \n    chrome.system.display.onDisplayChanged.addListener(  \n      callback: function,  \n    )\n\nFired when anything changes to the display configuration.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/system/memory": "#  chrome.system.memory\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.system.memory` API.\n\n## Permissions\n\n`system.memory`  \n\n## Types\n\n### MemoryInfo\n\n#### Properties\n\n  * availableCapacity\n\nnumber\n\nThe amount of available capacity, in bytes.\n\n  * capacity\n\nnumber\n\nThe total amount of physical memory capacity, in bytes.\n\n## Methods\n\n### getInfo()\n\nPromise\n\n    \n    \n    chrome.system.memory.getInfo(  \n      callback?: function,  \n    )\n\nGet physical memory information.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (info: MemoryInfo) => void\n\n    * info\n\nMemoryInfo\n\n#### Returns\n\n  * Promise<MemoryInfo>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/system/storage": "#  chrome.system.storage\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.system.storage` API to query storage device information and be\nnotified when a removable storage device is attached and detached.\n\n## Permissions\n\n`system.storage`  \n\n## Types\n\n### EjectDeviceResultCode\n\n#### Enum\n\n\"success\"  \nThe ejection command is successful -- the application can prompt the user to\nremove the device.\n\n\"in_use\"  \nThe device is in use by another application. The ejection did not succeed; the\nuser should not remove the device until the other application is done with the\ndevice.\n\n\"no_such_device\"  \nThere is no such device known.\n\n\"failure\"  \nThe ejection command failed.\n\n### StorageAvailableCapacityInfo\n\n#### Properties\n\n  * availableCapacity\n\nnumber\n\nThe available capacity of the storage device, in bytes.\n\n  * id\n\nstring\n\nA copied `id` of getAvailableCapacity function parameter `id`.\n\n### StorageUnitInfo\n\n#### Properties\n\n  * capacity\n\nnumber\n\nThe total amount of the storage space, in bytes.\n\n  * id\n\nstring\n\nThe transient ID that uniquely identifies the storage device. This ID will be\npersistent within the same run of a single application. It will not be a\npersistent identifier between different runs of an application, or between\ndifferent applications.\n\n  * name\n\nstring\n\nThe name of the storage unit.\n\n  * type\n\nStorageUnitType\n\nThe media type of the storage unit.\n\n### StorageUnitType\n\n#### Enum\n\n\"fixed\"  \nThe storage has fixed media, e.g. hard disk or SSD.\n\n\"removable\"  \nThe storage is removable, e.g. USB flash drive.\n\n\"unknown\"  \nThe storage type is unknown.\n\n## Methods\n\n### ejectDevice()\n\nPromise\n\n    \n    \n    chrome.system.storage.ejectDevice(  \n      id: string,  \n      callback?: function,  \n    )\n\nEjects a removable storage device.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: EjectDeviceResultCode) => void\n\n    * result\n\nEjectDeviceResultCode\n\n#### Returns\n\n  * Promise<EjectDeviceResultCode>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAvailableCapacity()\n\nPromise  Dev channel\n\n    \n    \n    chrome.system.storage.getAvailableCapacity(  \n      id: string,  \n      callback?: function,  \n    )\n\nGet the available capacity of a specified `id` storage device. The `id` is the\ntransient device ID from StorageUnitInfo.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (info: StorageAvailableCapacityInfo) => void\n\n    * info\n\nStorageAvailableCapacityInfo\n\n#### Returns\n\n  * Promise<StorageAvailableCapacityInfo>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getInfo()\n\nPromise\n\n    \n    \n    chrome.system.storage.getInfo(  \n      callback?: function,  \n    )\n\nGet the storage information from the system. The argument passed to the\ncallback is an array of StorageUnitInfo objects.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (info: StorageUnitInfo[]) => void\n\n    * info\n\nStorageUnitInfo[]\n\n#### Returns\n\n  * Promise<StorageUnitInfo[]>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onAttached\n\n    \n    \n    chrome.system.storage.onAttached.addListener(  \n      callback: function,  \n    )\n\nFired when a new removable storage is attached to the system.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (info: StorageUnitInfo) => void\n\n    * info\n\nStorageUnitInfo\n\n### onDetached\n\n    \n    \n    chrome.system.storage.onDetached.addListener(  \n      callback: function,  \n    )\n\nFired when a removable storage is detached from the system.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string) => void\n\n    * id\n\nstring\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/systemLog": "#  chrome.systemLog\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.systemLog` API to record Chrome system logs from extensions.\n\n## Permissions\n\n`systemLog`  \n\n## Availability\n\nChrome 125+  ChromeOS only  Requires policy\n\n## Types\n\n### MessageOptions\n\n#### Properties\n\n  * message\n\nstring\n\n## Methods\n\n### add()\n\nPromise\n\n    \n    \n    chrome.systemLog.add(  \n      options: MessageOptions,  \n      callback?: function,  \n    )\n\nAdds a new log record.\n\n#### Parameters\n\n  * options\n\nMessageOptions\n\nThe logging options.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/tabCapture": "#  chrome.tabCapture\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.tabCapture` API to interact with tab media streams.\n\n## Permissions\n\n`tabCapture`  \n\n## Concepts and usage\n\nThe chrome.tabCapture API lets you access a `MediaStream` containing video and\naudio of the current tab. It can only be called after the user invokes an\nextension, such as by clicking the extension's action button. This is similar\nto the behavior of the `\"activeTab\"` permission.\n\n### Preserve system audio\n\nWhen a `MediaStream` is obtained for a tab, audio in that tab will no longer\nbe played to the user. This is similar to the behavior of the\n`getDisplayMedia()` function when the `suppressLocalAudioPlayback` flag is set\nto true.\n\nTo continue playing audio to the user, use the following:\n\n    \n    \n    const output = new AudioContext();\n    const source = output.createMediaStreamSource(stream);\n    source.connect(output.destination);\n    \n\nThis creates a new `AudioContext` and connects the audio of the tab's\n`MediaStream` to the default destination.\n\n### Stream IDs\n\nCalling `chrome.tabCapture.getMediaStreamId()` will return a stream ID. To\nlater access a `MediaStream` from the ID, use the following:\n\n    \n    \n    navigator.mediaDevices.getUserMedia({\n      audio: {\n        mandatory: {\n          chromeMediaSource: \"tab\",\n          chromeMediaSourceId: id,\n        },\n      },\n      video: {\n        mandatory: {\n          chromeMediaSource: \"tab\",\n          chromeMediaSourceId: id,\n        },\n      },\n    });\n    \n\n### Usage restrictions\n\nAfter calling `getMediaStreamId()`, there are restrictions on where the\nreturned stream ID can be used:\n\n  * If `consumerTabId` is specified, the ID can be used by a `getUserMedia()` call in any frame in the given tab which has the same security origin.\n  * When this is not specified, beginning in Chrome 116, the ID can be used in any frame with the same security origin in the same render process as the caller. This means that a stream ID obtained in a service worker can be used in an offscreen document.\n\nPrior to Chrome 116, when a `consumerTabId` was not specified, the stream ID\nwas restricted to both the security origin, render process and render frame of\nthe caller.\n\n### Learn more\n\nTo learn more about how to use the `chrome.tabCapture` API, see Audio\nrecording and screen capture. This demonstrates how to use `tabCapture` and\nrelated APIs to solve a number of common use cases.\n\n## Types\n\n### CaptureInfo\n\n#### Properties\n\n  * fullscreen\n\nboolean\n\nWhether an element in the tab being captured is in fullscreen mode.\n\n  * status\n\nTabCaptureState\n\nThe new capture status of the tab.\n\n  * tabId\n\nnumber\n\nThe id of the tab whose status changed.\n\n### CaptureOptions\n\n#### Properties\n\n  * audio\n\nboolean optional\n\n  * audioConstraints\n\nMediaStreamConstraint optional\n\n  * video\n\nboolean optional\n\n  * videoConstraints\n\nMediaStreamConstraint optional\n\n### GetMediaStreamOptions\n\nChrome 71+\n\n#### Properties\n\n  * consumerTabId\n\nnumber optional\n\nOptional tab id of the tab which will later invoke `getUserMedia()` to consume\nthe stream. If not specified then the resulting stream can be used only by the\ncalling extension. The stream can only be used by frames in the given tab\nwhose security origin matches the consumber tab's origin. The tab's origin\nmust be a secure origin, e.g. HTTPS.\n\n  * targetTabId\n\nnumber optional\n\nOptional tab id of the tab which will be captured. If not specified then the\ncurrent active tab will be selected. Only tabs for which the extension has\nbeen granted the `activeTab` permission can be used as the target tab.\n\n### MediaStreamConstraint\n\n#### Properties\n\n  * mandatory\n\nobject\n\n  * optional\n\nobject optional\n\n### TabCaptureState\n\n#### Enum\n\n\"pending\"  \n\n\"active\"  \n\n\"stopped\"  \n\n\"error\"  \n\n## Methods\n\n### capture()\n\nForeground only\n\n    \n    \n    chrome.tabCapture.capture(  \n      options: CaptureOptions,  \n      callback: function,  \n    )\n\nCaptures the visible area of the currently active tab. Capture can only be\nstarted on the currently active tab after the extension has been _invoked_ ,\nsimilar to the way that activeTab works. Capture is maintained across page\nnavigations within the tab, and stops when the tab is closed, or the media\nstream is closed by the extension.\n\n#### Parameters\n\n  * options\n\nCaptureOptions\n\nConfigures the returned media stream.\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (stream: LocalMediaStream) => void\n\n    * stream\n\nLocalMediaStream\n\n### getCapturedTabs()\n\nPromise\n\n    \n    \n    chrome.tabCapture.getCapturedTabs(  \n      callback?: function,  \n    )\n\nReturns a list of tabs that have requested capture or are being captured, i.e.\nstatus != stopped and status != error. This allows extensions to inform the\nuser that there is an existing tab capture that would prevent a new tab\ncapture from succeeding (or to prevent redundant requests for the same tab).\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: CaptureInfo[]) => void\n\n    * result\n\nCaptureInfo[]\n\n#### Returns\n\n  * Promise<CaptureInfo[]>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getMediaStreamId()\n\nPromise Chrome 71+\n\n    \n    \n    chrome.tabCapture.getMediaStreamId(  \n      options?: GetMediaStreamOptions,  \n      callback?: function,  \n    )\n\nCreates a stream ID to capture the target tab. Similar to\nchrome.tabCapture.capture() method, but returns a media stream ID, instead of\na media stream, to the consumer tab.\n\n#### Parameters\n\n  * options\n\nGetMediaStreamOptions optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (streamId: string) => void\n\n    * streamId\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onStatusChanged\n\n    \n    \n    chrome.tabCapture.onStatusChanged.addListener(  \n      callback: function,  \n    )\n\nEvent fired when the capture status of a tab changes. This allows extension\nauthors to keep track of the capture status of tabs to keep UI elements like\npage actions in sync.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (info: CaptureInfo) => void\n\n    * info\n\nCaptureInfo\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/tabGroups": "#  chrome.tabGroups\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.tabGroups` API to interact with the browser's tab grouping\nsystem. You can use this API to modify and rearrange tab groups in the\nbrowser. To group and ungroup tabs, or to query what tabs are in groups, use\nthe `chrome.tabs` API.\n\n## Permissions\n\n`tabGroups`  \n\n## Availability\n\nChrome 89+ MV3+\n\n## Types\n\n### Color\n\nThe group's color.\n\n#### Enum\n\n\"grey\"  \n\n\"blue\"  \n\n\"red\"  \n\n\"yellow\"  \n\n\"green\"  \n\n\"pink\"  \n\n\"purple\"  \n\n\"cyan\"  \n\n\"orange\"  \n\n### TabGroup\n\n#### Properties\n\n  * collapsed\n\nboolean\n\nWhether the group is collapsed. A collapsed group is one whose tabs are\nhidden.\n\n  * color\n\nColor\n\nThe group's color.\n\n  * id\n\nnumber\n\nThe ID of the group. Group IDs are unique within a browser session.\n\n  * title\n\nstring optional\n\nThe title of the group.\n\n  * windowId\n\nnumber\n\nThe ID of the window that contains the group.\n\n## Properties\n\n### TAB_GROUP_ID_NONE\n\nAn ID that represents the absence of a group.\n\n#### Value\n\n-1   \n\n## Methods\n\n### get()\n\nPromise\n\n    \n    \n    chrome.tabGroups.get(  \n      groupId: number,  \n      callback?: function,  \n    )\n\nRetrieves details about the specified group.\n\n#### Parameters\n\n  * groupId\n\nnumber\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (group: TabGroup) => void\n\n    * group\n\nTabGroup\n\n#### Returns\n\n  * Promise<TabGroup>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### move()\n\nPromise\n\n    \n    \n    chrome.tabGroups.move(  \n      groupId: number,  \n      moveProperties: object,  \n      callback?: function,  \n    )\n\nMoves the group and all its tabs within its window, or to a new window.\n\n#### Parameters\n\n  * groupId\n\nnumber\n\nThe ID of the group to move.\n\n  * moveProperties\n\nobject\n\n    * index\n\nnumber\n\nThe position to move the group to. Use `-1` to place the group at the end of\nthe window.\n\n    * windowId\n\nnumber optional\n\nThe window to move the group to. Defaults to the window the group is currently\nin. Note that groups can only be moved to and from windows with\n`windows.WindowType` type `\"normal\"`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (group?: TabGroup) => void\n\n    * group\n\nTabGroup optional\n\nDetails about the moved group.\n\n#### Returns\n\n  * Promise<TabGroup | undefined>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### query()\n\nPromise\n\n    \n    \n    chrome.tabGroups.query(  \n      queryInfo: object,  \n      callback?: function,  \n    )\n\nGets all groups that have the specified properties, or all groups if no\nproperties are specified.\n\n#### Parameters\n\n  * queryInfo\n\nobject\n\n    * collapsed\n\nboolean optional\n\nWhether the groups are collapsed.\n\n    * color\n\nColor optional\n\nThe color of the groups.\n\n    * title\n\nstring optional\n\nMatch group titles against a pattern.\n\n    * windowId\n\nnumber optional\n\nThe ID of the parent window, or `windows.WINDOW_ID_CURRENT` for the current\nwindow.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: TabGroup[]) => void\n\n    * result\n\nTabGroup[]\n\n#### Returns\n\n  * Promise<TabGroup[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### update()\n\nPromise\n\n    \n    \n    chrome.tabGroups.update(  \n      groupId: number,  \n      updateProperties: object,  \n      callback?: function,  \n    )\n\nModifies the properties of a group. Properties that are not specified in\n`updateProperties` are not modified.\n\n#### Parameters\n\n  * groupId\n\nnumber\n\nThe ID of the group to modify.\n\n  * updateProperties\n\nobject\n\n    * collapsed\n\nboolean optional\n\nWhether the group should be collapsed.\n\n    * color\n\nColor optional\n\nThe color of the group.\n\n    * title\n\nstring optional\n\nThe title of the group.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (group?: TabGroup) => void\n\n    * group\n\nTabGroup optional\n\nDetails about the updated group.\n\n#### Returns\n\n  * Promise<TabGroup | undefined>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onCreated\n\n    \n    \n    chrome.tabGroups.onCreated.addListener(  \n      callback: function,  \n    )\n\nFired when a group is created.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (group: TabGroup) => void\n\n    * group\n\nTabGroup\n\n### onMoved\n\n    \n    \n    chrome.tabGroups.onMoved.addListener(  \n      callback: function,  \n    )\n\nFired when a group is moved within a window. Move events are still fired for\nthe individual tabs within the group, as well as for the group itself. This\nevent is not fired when a group is moved between windows; instead, it will be\nremoved from one window and created in another.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (group: TabGroup) => void\n\n    * group\n\nTabGroup\n\n### onRemoved\n\n    \n    \n    chrome.tabGroups.onRemoved.addListener(  \n      callback: function,  \n    )\n\nFired when a group is closed, either directly by the user or automatically\nbecause it contained zero tabs.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (group: TabGroup) => void\n\n    * group\n\nTabGroup\n\n### onUpdated\n\n    \n    \n    chrome.tabGroups.onUpdated.addListener(  \n      callback: function,  \n    )\n\nFired when a group is updated.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (group: TabGroup) => void\n\n    * group\n\nTabGroup\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/tabs": "#  chrome.tabs\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Note:** The Tabs API can be used by the service worker and extension pages,\nbut not content scripts.\n\n## Description\n\nUse the `chrome.tabs` API to interact with the browser's tab system. You can\nuse this API to create, modify, and rearrange tabs in the browser.\n\nThe Tabs API not only offers features for manipulating and managing tabs, but\ncan also detect the language of the tab, take a screenshot, and communicate\nwith a tab's content scripts.\n\n## Permissions\n\nMost features don't require any permissions to use. For example: creating a\nnew tab, reloading a tab, navigating to another URL, etc.\n\nThere are three permissions developers should be aware of when working with\nthe Tabs API.\n\nThe \"tabs\" permission\n\n    \n\nThis permission does not give access to the `chrome.tabs` namespace. Instead,\nit grants an extension the ability to call `tabs.query()` against four\nsensitive properties on `tabs.Tab` instances: `url`, `pendingUrl`, `title`,\nand `favIconUrl`.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"tabs\"\n      ],\n      ...\n    }\n    \n\nHost permissions\n\n    \n\nHost permissions allow an extension to read and query a matching tab's four\nsensitive `tabs.Tab` properties. They can also interact directly with the\nmatching tabs using methods such as `tabs.captureVisibleTab()`,\n`scripting.executeScript()`, `scripting.insertCSS()`, and\n`scripting.removeCSS()`.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"host_permissions\": [\n        \"http://*/*\",\n        \"https://*/*\"\n      ],\n      ...\n    }\n    \n\nThe \"activeTab\" permission\n\n    \n\n`activeTab` grants an extension temporary host permission for the current tab\nin response to a user invocation. Unlike host permissions, `activeTab` does\nnot trigger any warnings.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"activeTab\"\n      ],\n      ...\n    }\n    \n\n## Use cases\n\nThe following sections demonstrate some common use cases.\n\n### Open an extension page in a new tab\n\nA common pattern for extensions is to open an onboarding page in a new tab\nwhen the extension is installed. The following example shows how to do this.\n\nbackground.js:\n\n    \n    \n    chrome.runtime.onInstalled.addListener(({reason}) => {\n      if (reason === 'install') {\n        chrome.tabs.create({\n          url: \"onboarding.html\"\n        });\n      }\n    });\n    \n\n**Note:** This example doesn't require any permissions.\n\n### Get the current tab\n\nThis example demonstrates how an extension's service worker can retrieve the\nactive tab from the currently-focused window (or most recently-focused window,\nif no Chrome windows are focused). This can usually be thought of as the\nuser's current tab.\n\n    \n    \n      async function getCurrentTab() {\n        let queryOptions = { active: true, lastFocusedWindow: true };\n        // `tab` will either be a `tabs.Tab` instance or `undefined`.\n        let [tab] = await chrome.tabs.query(queryOptions);\n        return tab;\n      }\n    \n    \n    \n      function getCurrentTab(callback) {\n        let queryOptions = { active: true, lastFocusedWindow: true };\n        chrome.tabs.query(queryOptions, ([tab]) => {\n          if (chrome.runtime.lastError)\n          console.error(chrome.runtime.lastError);\n          // `tab` will either be a `tabs.Tab` instance or `undefined`.\n          callback(tab);\n        });\n      }\n    \n\n### Mute the specified tab\n\nThis example shows how an extension can toggle the muted state for a given\ntab.\n\n    \n    \n      async function toggleMuteState(tabId) {\n        const tab = await chrome.tabs.get(tabId);\n        const muted = !tab.mutedInfo.muted;\n        await chrome.tabs.update(tabId, {muted});\n        console.log(`Tab ${tab.id} is ${muted ? \"muted\" : \"unmuted\"}`);\n      }\n    \n    \n    \n      function toggleMuteState(tabId) {\n        chrome.tabs.get(tabId, async (tab) => {\n          let muted = !tab.mutedInfo.muted;\n          await chrome.tabs.update(tabId, { muted });\n          console.log(`Tab ${tab.id} is ${ muted ? \"muted\" : \"unmuted\" }`);\n        });\n      }\n    \n\n### Move the current tab to the first position when clicked\n\nThis example shows how to move a tab while a drag may or may not be in\nprogress. While this example uses `chrome.tabs.move`, you can use the same\nwaiting pattern for other calls that modify tabs while a drag is in progress.\n\n    \n    \n      chrome.tabs.onActivated.addListener(moveToFirstPosition);\n    \n      async function moveToFirstPosition(activeInfo) {\n        try {\n          await chrome.tabs.move(activeInfo.tabId, {index: 0});\n          console.log(\"Success.\");\n        } catch (error) {\n          if (error == \"Error: Tabs cannot be edited right now (user may be dragging a tab).\") {\n            setTimeout(() => moveToFirstPosition(activeInfo), 50);\n          } else {\n            console.error(error);\n          }\n        }\n      }\n    \n\n**Important:** Using catch(error) in a Promise is a way to ensure that an\nerror that otherwise populates `chrome.runtime.lastError` is not unchecked.\n\n    \n    \n      chrome.tabs.onActivated.addListener(moveToFirstPositionMV2);\n    \n      function moveToFirstPositionMV2(activeInfo) {\n        chrome.tabs.move(activeInfo.tabId, { index: 0 }, () => {\n          if (chrome.runtime.lastError) {\n            const error = chrome.runtime.lastError;\n            if (error == \"Error: Tabs cannot be edited right now (user may be dragging a tab).\") {\n              setTimeout(() => moveToFirstPositionMV2(activeInfo), 50);\n            } else {\n              console.error(error);\n            }\n          } else {\n            console.log(\"Success.\");\n          }\n        });\n      }\n    \n\n### Pass a message to a selected tab's content script\n\nThis example demonstrates how an extension's service worker can communicate\nwith content scripts in specific browser tabs using `tabs.sendMessage()`.\n\n    \n    \n    function sendMessageToActiveTab(message) {\n      const [tab] = await chrome.tabs.query({ active: true, lastFocusedWindow: true });\n      const response = await chrome.tabs.sendMessage(tab.id, message);\n      // TODO: Do something with the response.\n    }\n    \n\n## Extension examples\n\nFor more Tabs API extensions demos, explore any of the following:\n\n  * Manifest V2 - Tabs API extensions.\n  * Manifest V3 - Tabs Manager.\n\n## Types\n\n### MutedInfo\n\nChrome 46+\n\nThe tab's muted state and the reason for the last state change.\n\n#### Properties\n\n  * extensionId\n\nstring optional\n\nThe ID of the extension that changed the muted state. Not set if an extension\nwas not the reason the muted state last changed.\n\n  * muted\n\nboolean\n\nWhether the tab is muted (prevented from playing sound). The tab may be muted\neven if it has not played or is not currently playing sound. Equivalent to\nwhether the 'muted' audio indicator is showing.\n\n  * reason\n\nMutedInfoReason optional\n\nThe reason the tab was muted or unmuted. Not set if the tab's mute state has\nnever been changed.\n\n### MutedInfoReason\n\nChrome 46+\n\nAn event that caused a muted state change.\n\n#### Enum\n\n\"user\"  \nA user input action set the muted state.\n\n\"capture\"  \nTab capture was started, forcing a muted state change.\n\n\"extension\"  \nAn extension, identified by the extensionId field, set the muted state.\n\n### Tab\n\n#### Properties\n\n  * active\n\nboolean\n\nWhether the tab is active in its window. Does not necessarily mean the window\nis focused.\n\n  * audible\n\nboolean optional\n\nChrome 45+\n\nWhether the tab has produced sound over the past couple of seconds (but it\nmight not be heard if also muted). Equivalent to whether the 'speaker audio'\nindicator is showing.\n\n  * autoDiscardable\n\nboolean\n\nChrome 54+\n\nWhether the tab can be discarded automatically by the browser when resources\nare low.\n\n  * discarded\n\nboolean\n\nChrome 54+\n\nWhether the tab is discarded. A discarded tab is one whose content has been\nunloaded from memory, but is still visible in the tab strip. Its content is\nreloaded the next time it is activated.\n\n  * favIconUrl\n\nstring optional\n\nThe URL of the tab's favicon. This property is only present if the extension\nhas the `\"tabs\"` permission or has host permissions for the page. It may also\nbe an empty string if the tab is loading.\n\n  * frozen\n\nboolean\n\nChrome 132+\n\nWhether the tab is frozen. A frozen tab cannot execute tasks, including event\nhandlers or timers. It is visible in the tab strip and its content is loaded\nin memory. It is unfrozen on activation.\n\n  * groupId\n\nnumber\n\nChrome 88+\n\nThe ID of the group that the tab belongs to.\n\n  * height\n\nnumber optional\n\nThe height of the tab in pixels.\n\n  * highlighted\n\nboolean\n\nWhether the tab is highlighted.\n\n  * id\n\nnumber optional\n\nThe ID of the tab. Tab IDs are unique within a browser session. Under some\ncircumstances a tab may not be assigned an ID; for example, when querying\nforeign tabs using the `sessions` API, in which case a session ID may be\npresent. Tab ID can also be set to `chrome.tabs.TAB_ID_NONE` for apps and\ndevtools windows.\n\n  * incognito\n\nboolean\n\nWhether the tab is in an incognito window.\n\n  * index\n\nnumber\n\nThe zero-based index of the tab within its window.\n\n  * lastAccessed\n\nnumber\n\nChrome 121+\n\nThe last time the tab became active in its window as the number of\nmilliseconds since epoch.\n\n  * mutedInfo\n\nMutedInfo optional\n\nChrome 46+\n\nThe tab's muted state and the reason for the last state change.\n\n  * openerTabId\n\nnumber optional\n\nThe ID of the tab that opened this tab, if any. This property is only present\nif the opener tab still exists.\n\n  * pendingUrl\n\nstring optional\n\nChrome 79+\n\nThe URL the tab is navigating to, before it has committed. This property is\nonly present if the extension has the `\"tabs\"` permission or has host\npermissions for the page and there is a pending navigation.\n\n  * pinned\n\nboolean\n\nWhether the tab is pinned.\n\n  * selected\n\nboolean\n\nDeprecated\n\nPlease use `tabs.Tab.highlighted`.\n\nWhether the tab is selected.\n\n  * sessionId\n\nstring optional\n\nThe session ID used to uniquely identify a tab obtained from the `sessions`\nAPI.\n\n  * status\n\nTabStatus optional\n\nThe tab's loading status.\n\n  * title\n\nstring optional\n\nThe title of the tab. This property is only present if the extension has the\n`\"tabs\"` permission or has host permissions for the page.\n\n  * url\n\nstring optional\n\nThe last committed URL of the main frame of the tab. This property is only\npresent if the extension has the `\"tabs\"` permission or has host permissions\nfor the page. May be an empty string if the tab has not yet committed. See\nalso `Tab.pendingUrl`.\n\n  * width\n\nnumber optional\n\nThe width of the tab in pixels.\n\n  * windowId\n\nnumber\n\nThe ID of the window that contains the tab.\n\n### TabStatus\n\nChrome 44+\n\nThe tab's loading status.\n\n#### Enum\n\n\"unloaded\"  \n\n\"loading\"  \n\n\"complete\"  \n\n### WindowType\n\nChrome 44+\n\nThe type of window.\n\n#### Enum\n\n\"normal\"  \n\n\"popup\"  \n\n\"panel\"  \n\n\"app\"  \n\n\"devtools\"  \n\n### ZoomSettings\n\nDefines how zoom changes in a tab are handled and at what scope.\n\n#### Properties\n\n  * defaultZoomFactor\n\nnumber optional\n\nChrome 43+\n\nUsed to return the default zoom level for the current tab in calls to\ntabs.getZoomSettings.\n\n  * mode\n\nZoomSettingsMode optional\n\nDefines how zoom changes are handled, i.e., which entity is responsible for\nthe actual scaling of the page; defaults to `automatic`.\n\n  * scope\n\nZoomSettingsScope optional\n\nDefines whether zoom changes persist for the page's origin, or only take\neffect in this tab; defaults to `per-origin` when in `automatic` mode, and\n`per-tab` otherwise.\n\n### ZoomSettingsMode\n\nChrome 44+\n\nDefines how zoom changes are handled, i.e., which entity is responsible for\nthe actual scaling of the page; defaults to `automatic`.\n\n#### Enum\n\n\"automatic\"  \nZoom changes are handled automatically by the browser.\n\n\"manual\"  \nOverrides the automatic handling of zoom changes. The `onZoomChange` event\nwill still be dispatched, and it is the extension's responsibility to listen\nfor this event and manually scale the page. This mode does not support `per-\norigin` zooming, and thus ignores the `scope` zoom setting and assumes `per-\ntab`.\n\n\"disabled\"  \nDisables all zooming in the tab. The tab reverts to the default zoom level,\nand all attempted zoom changes are ignored.\n\n### ZoomSettingsScope\n\nChrome 44+\n\nDefines whether zoom changes persist for the page's origin, or only take\neffect in this tab; defaults to `per-origin` when in `automatic` mode, and\n`per-tab` otherwise.\n\n#### Enum\n\n\"per-origin\"  \nZoom changes persist in the zoomed page's origin, i.e., all other tabs\nnavigated to that same origin are zoomed as well. Moreover, `per-origin` zoom\nchanges are saved with the origin, meaning that when navigating to other pages\nin the same origin, they are all zoomed to the same zoom factor. The `per-\norigin` scope is only available in the `automatic` mode.\n\n\"per-tab\"  \nZoom changes only take effect in this tab, and zoom changes in other tabs do\nnot affect the zooming of this tab. Also, `per-tab` zoom changes are reset on\nnavigation; navigating a tab always loads pages with their `per-origin` zoom\nfactors.\n\n## Properties\n\n### MAX_CAPTURE_VISIBLE_TAB_CALLS_PER_SECOND\n\nChrome 92+\n\nThe maximum number of times that `captureVisibleTab` can be called per second.\n`captureVisibleTab` is expensive and should not be called too often.\n\n#### Value\n\n2  \n\n### TAB_ID_NONE\n\nChrome 46+\n\nAn ID that represents the absence of a browser tab.\n\n#### Value\n\n-1   \n\n### TAB_INDEX_NONE\n\nChrome 123+\n\nAn index that represents the absence of a tab index in a tab_strip.\n\n#### Value\n\n-1   \n\n## Methods\n\n### captureVisibleTab()\n\nPromise\n\n    \n    \n    chrome.tabs.captureVisibleTab(  \n      windowId?: number,  \n      options?: ImageDetails,  \n      callback?: function,  \n    )\n\nCaptures the visible area of the currently active tab in the specified window.\nIn order to call this method, the extension must have either the <all_urls>\npermission or the activeTab permission. In addition to sites that extensions\ncan normally access, this method allows extensions to capture sensitive sites\nthat are otherwise restricted, including chrome:-scheme pages, other\nextensions' pages, and data: URLs. These sensitive sites can only be captured\nwith the activeTab permission. File URLs may be captured only if the extension\nhas been granted file access.\n\n#### Parameters\n\n  * windowId\n\nnumber optional\n\nThe target window. Defaults to the current window.\n\n  * options\n\nImageDetails optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (dataUrl: string) => void\n\n    * dataUrl\n\nstring\n\nA data URL that encodes an image of the visible area of the captured tab. May\nbe assigned to the 'src' property of an HTML `img` element for display.\n\n#### Returns\n\n  * Promise<string>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### connect()\n\n    \n    \n    chrome.tabs.connect(  \n      tabId: number,  \n      connectInfo?: object,  \n    )\n\nConnects to the content script(s) in the specified tab. The\n`runtime.onConnect` event is fired in each content script running in the\nspecified tab for the current extension. For more details, see Content Script\nMessaging.\n\n#### Parameters\n\n  * tabId\n\nnumber\n\n  * connectInfo\n\nobject optional\n\n    * documentId\n\nstring optional\n\nChrome 106+\n\nOpen a port to a specific document identified by `documentId` instead of all\nframes in the tab.\n\n    * frameId\n\nnumber optional\n\nOpen a port to a specific frame identified by `frameId` instead of all frames\nin the tab.\n\n    * name\n\nstring optional\n\nIs passed into onConnect for content scripts that are listening for the\nconnection event.\n\n#### Returns\n\n  * runtime.Port\n\nA port that can be used to communicate with the content scripts running in the\nspecified tab. The port's `runtime.Port` event is fired if the tab closes or\ndoes not exist.\n\n### create()\n\nPromise\n\n    \n    \n    chrome.tabs.create(  \n      createProperties: object,  \n      callback?: function,  \n    )\n\nCreates a new tab.\n\n#### Parameters\n\n  * createProperties\n\nobject\n\n    * active\n\nboolean optional\n\nWhether the tab should become the active tab in the window. Does not affect\nwhether the window is focused (see `windows.update`). Defaults to `true`.\n\n    * index\n\nnumber optional\n\nThe position the tab should take in the window. The provided value is clamped\nto between zero and the number of tabs in the window.\n\n    * openerTabId\n\nnumber optional\n\nThe ID of the tab that opened this tab. If specified, the opener tab must be\nin the same window as the newly created tab.\n\n    * pinned\n\nboolean optional\n\nWhether the tab should be pinned. Defaults to `false`\n\n    * selected\n\nboolean optional\n\nDeprecated\n\nPlease use _active_.\n\nWhether the tab should become the selected tab in the window. Defaults to\n`true`\n\n    * url\n\nstring optional\n\nThe URL to initially navigate the tab to. Fully-qualified URLs must include a\nscheme (i.e., 'http://www.google.com', not 'www.google.com'). Relative URLs\nare relative to the current page within the extension. Defaults to the New Tab\nPage.\n\n    * windowId\n\nnumber optional\n\nThe window in which to create the new tab. Defaults to the current window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tab: Tab) => void\n\n    * tab\n\nTab\n\nThe created tab.\n\n#### Returns\n\n  * Promise<Tab>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### detectLanguage()\n\nPromise\n\n    \n    \n    chrome.tabs.detectLanguage(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nDetects the primary language of the content in a tab.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nDefaults to the active tab of the current window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (language: string) => void\n\n    * language\n\nstring\n\nAn ISO language code such as `en` or `fr`. For a complete list of languages\nsupported by this method, see kLanguageInfoTable. The second to fourth columns\nare checked and the first non-NULL value is returned, except for Simplified\nChinese for which `zh-CN` is returned. For an unknown/undefined language,\n`und` is returned.\n\n#### Returns\n\n  * Promise<string>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### discard()\n\nPromise Chrome 54+\n\n    \n    \n    chrome.tabs.discard(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nDiscards a tab from memory. Discarded tabs are still visible on the tab strip\nand are reloaded when activated.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to be discarded. If specified, the tab is discarded unless\nit is active or already discarded. If omitted, the browser discards the least\nimportant tab. This can fail if no discardable tabs exist.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tab?: Tab) => void\n\n    * tab\n\nTab optional\n\nThe discarded tab, if it was successfully discarded; undefined otherwise.\n\n#### Returns\n\n  * Promise<Tab | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### duplicate()\n\nPromise\n\n    \n    \n    chrome.tabs.duplicate(  \n      tabId: number,  \n      callback?: function,  \n    )\n\nDuplicates a tab.\n\n#### Parameters\n\n  * tabId\n\nnumber\n\nThe ID of the tab to duplicate.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tab?: Tab) => void\n\n    * tab\n\nTab optional\n\nDetails about the duplicated tab. The `url`, `pendingUrl`, `title` and\n`favIconUrl` properties are only included on the `tabs.Tab` object if the\nextension has the `\"tabs\"` permission or has host permissions for the page.\n\n#### Returns\n\n  * Promise<Tab | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### get()\n\nPromise\n\n    \n    \n    chrome.tabs.get(  \n      tabId: number,  \n      callback?: function,  \n    )\n\nRetrieves details about the specified tab.\n\n#### Parameters\n\n  * tabId\n\nnumber\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tab: Tab) => void\n\n    * tab\n\nTab\n\n#### Returns\n\n  * Promise<Tab>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getCurrent()\n\nPromise\n\n    \n    \n    chrome.tabs.getCurrent(  \n      callback?: function,  \n    )\n\nGets the tab that this script call is being made from. Returns `undefined` if\ncalled from a non-tab context (for example, a background page or popup view).\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tab?: Tab) => void\n\n    * tab\n\nTab optional\n\n#### Returns\n\n  * Promise<Tab | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getZoom()\n\nPromise\n\n    \n    \n    chrome.tabs.getZoom(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nGets the current zoom factor of a specified tab.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to get the current zoom factor from; defaults to the active\ntab of the current window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (zoomFactor: number) => void\n\n    * zoomFactor\n\nnumber\n\nThe tab's current zoom factor.\n\n#### Returns\n\n  * Promise<number>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getZoomSettings()\n\nPromise\n\n    \n    \n    chrome.tabs.getZoomSettings(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nGets the current zoom settings of a specified tab.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to get the current zoom settings from; defaults to the\nactive tab of the current window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (zoomSettings: ZoomSettings) => void\n\n    * zoomSettings\n\nZoomSettings\n\nThe tab's current zoom settings.\n\n#### Returns\n\n  * Promise<ZoomSettings>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### goBack()\n\nPromise Chrome 72+\n\n    \n    \n    chrome.tabs.goBack(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nGo back to the previous page, if one is available.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to navigate back; defaults to the selected tab of the\ncurrent window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### goForward()\n\nPromise Chrome 72+\n\n    \n    \n    chrome.tabs.goForward(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nGo foward to the next page, if one is available.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to navigate forward; defaults to the selected tab of the\ncurrent window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### group()\n\nPromise Chrome 88+\n\n    \n    \n    chrome.tabs.group(  \n      options: object,  \n      callback?: function,  \n    )\n\nAdds one or more tabs to a specified group, or if no group is specified, adds\nthe given tabs to a newly created group.\n\n#### Parameters\n\n  * options\n\nobject\n\n    * createProperties\n\nobject optional\n\nConfigurations for creating a group. Cannot be used if groupId is already\nspecified.\n\n      * windowId\n\nnumber optional\n\nThe window of the new group. Defaults to the current window.\n\n    * groupId\n\nnumber optional\n\nThe ID of the group to add the tabs to. If not specified, a new group will be\ncreated.\n\n    * tabIds\n\nnumber | [number, ...number[]]\n\nThe tab ID or list of tab IDs to add to the specified group.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (groupId: number) => void\n\n    * groupId\n\nnumber\n\nThe ID of the group that the tabs were added to.\n\n#### Returns\n\n  * Promise<number>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### highlight()\n\nPromise\n\n    \n    \n    chrome.tabs.highlight(  \n      highlightInfo: object,  \n      callback?: function,  \n    )\n\nHighlights the given tabs and focuses on the first of group. Will appear to do\nnothing if the specified tab is currently active.\n\n#### Parameters\n\n  * highlightInfo\n\nobject\n\n    * tabs\n\nnumber | number[]\n\nOne or more tab indices to highlight.\n\n    * windowId\n\nnumber optional\n\nThe window that contains the tabs.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (window: Window) => void\n\n    * window\n\nWindow\n\nContains details about the window whose tabs were highlighted.\n\n#### Returns\n\n  * Promise<windows.Window>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### move()\n\nPromise\n\n    \n    \n    chrome.tabs.move(  \n      tabIds: number | number[],  \n      moveProperties: object,  \n      callback?: function,  \n    )\n\nMoves one or more tabs to a new position within its window, or to a new\nwindow. Note that tabs can only be moved to and from normal (window.type ===\n\"normal\") windows.\n\n#### Parameters\n\n  * tabIds\n\nnumber | number[]\n\nThe tab ID or list of tab IDs to move.\n\n  * moveProperties\n\nobject\n\n    * index\n\nnumber\n\nThe position to move the window to. Use `-1` to place the tab at the end of\nthe window.\n\n    * windowId\n\nnumber optional\n\nDefaults to the window the tab is currently in.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tabs: Tab | Tab[]) => void\n\n    * tabs\n\nTab | Tab[]\n\nDetails about the moved tabs.\n\n#### Returns\n\n  * Promise<Tab | Tab[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### query()\n\nPromise\n\n    \n    \n    chrome.tabs.query(  \n      queryInfo: object,  \n      callback?: function,  \n    )\n\nGets all tabs that have the specified properties, or all tabs if no properties\nare specified.\n\n#### Parameters\n\n  * queryInfo\n\nobject\n\n    * active\n\nboolean optional\n\nWhether the tabs are active in their windows.\n\n    * audible\n\nboolean optional\n\nChrome 45+\n\nWhether the tabs are audible.\n\n    * autoDiscardable\n\nboolean optional\n\nChrome 54+\n\nWhether the tabs can be discarded automatically by the browser when resources\nare low.\n\n    * currentWindow\n\nboolean optional\n\nWhether the tabs are in the current window.\n\n    * discarded\n\nboolean optional\n\nChrome 54+\n\nWhether the tabs are discarded. A discarded tab is one whose content has been\nunloaded from memory, but is still visible in the tab strip. Its content is\nreloaded the next time it is activated.\n\n    * frozen\n\nboolean optional\n\nChrome 132+\n\nWhether the tabs are frozen. A frozen tab cannot execute tasks, including\nevent handlers or timers. It is visible in the tab strip and its content is\nloaded in memory. It is unfrozen on activation.\n\n    * groupId\n\nnumber optional\n\nChrome 88+\n\nThe ID of the group that the tabs are in, or `tabGroups.TAB_GROUP_ID_NONE` for\nungrouped tabs.\n\n    * highlighted\n\nboolean optional\n\nWhether the tabs are highlighted.\n\n    * index\n\nnumber optional\n\nThe position of the tabs within their windows.\n\n    * lastFocusedWindow\n\nboolean optional\n\nWhether the tabs are in the last focused window.\n\n    * muted\n\nboolean optional\n\nChrome 45+\n\nWhether the tabs are muted.\n\n    * pinned\n\nboolean optional\n\nWhether the tabs are pinned.\n\n    * status\n\nTabStatus optional\n\nThe tab loading status.\n\n    * title\n\nstring optional\n\nMatch page titles against a pattern. This property is ignored if the extension\ndoes not have the `\"tabs\"` permission or host permissions for the page.\n\n    * url\n\nstring | string[] optional\n\nMatch tabs against one or more URL patterns. Fragment identifiers are not\nmatched. This property is ignored if the extension does not have the `\"tabs\"`\npermission or host permissions for the page.\n\n    * windowId\n\nnumber optional\n\nThe ID of the parent window, or `windows.WINDOW_ID_CURRENT` for the current\nwindow.\n\n    * windowType\n\nWindowType optional\n\nThe type of window the tabs are in.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: Tab[]) => void\n\n    * result\n\nTab[]\n\n#### Returns\n\n  * Promise<Tab[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### reload()\n\nPromise\n\n    \n    \n    chrome.tabs.reload(  \n      tabId?: number,  \n      reloadProperties?: object,  \n      callback?: function,  \n    )\n\nReload a tab.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to reload; defaults to the selected tab of the current\nwindow.\n\n  * reloadProperties\n\nobject optional\n\n    * bypassCache\n\nboolean optional\n\nWhether to bypass local caching. Defaults to `false`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### remove()\n\nPromise\n\n    \n    \n    chrome.tabs.remove(  \n      tabIds: number | number[],  \n      callback?: function,  \n    )\n\nCloses one or more tabs.\n\n#### Parameters\n\n  * tabIds\n\nnumber | number[]\n\nThe tab ID or list of tab IDs to close.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### sendMessage()\n\nPromise\n\n    \n    \n    chrome.tabs.sendMessage(  \n      tabId: number,  \n      message: any,  \n      options?: object,  \n      callback?: function,  \n    )\n\nSends a single message to the content script(s) in the specified tab, with an\noptional callback to run when a response is sent back. The `runtime.onMessage`\nevent is fired in each content script running in the specified tab for the\ncurrent extension.\n\n#### Parameters\n\n  * tabId\n\nnumber\n\n  * message\n\nany\n\nThe message to send. This message should be a JSON-ifiable object.\n\n  * options\n\nobject optional\n\n    * documentId\n\nstring optional\n\nChrome 106+\n\nSend a message to a specific document identified by `documentId` instead of\nall frames in the tab.\n\n    * frameId\n\nnumber optional\n\nSend a message to a specific frame identified by `frameId` instead of all\nframes in the tab.\n\n  * callback\n\nfunction optional\n\nChrome 99+\n\nThe `callback` parameter looks like:\n\n        \n        (response: any) => void\n\n    * response\n\nany\n\nThe JSON response object sent by the handler of the message. If an error\noccurs while connecting to the specified tab, the callback is called with no\narguments and `runtime.lastError` is set to the error message.\n\n#### Returns\n\n  * Promise<any>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setZoom()\n\nPromise\n\n    \n    \n    chrome.tabs.setZoom(  \n      tabId?: number,  \n      zoomFactor: number,  \n      callback?: function,  \n    )\n\nZooms a specified tab.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to zoom; defaults to the active tab of the current window.\n\n  * zoomFactor\n\nnumber\n\nThe new zoom factor. A value of `0` sets the tab to its current default zoom\nfactor. Values greater than `0` specify a (possibly non-default) zoom factor\nfor the tab.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setZoomSettings()\n\nPromise\n\n    \n    \n    chrome.tabs.setZoomSettings(  \n      tabId?: number,  \n      zoomSettings: ZoomSettings,  \n      callback?: function,  \n    )\n\nSets the zoom settings for a specified tab, which define how zoom changes are\nhandled. These settings are reset to defaults upon navigating the tab.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to change the zoom settings for; defaults to the active tab\nof the current window.\n\n  * zoomSettings\n\nZoomSettings\n\nDefines how zoom changes are handled and at what scope.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### ungroup()\n\nPromise Chrome 88+\n\n    \n    \n    chrome.tabs.ungroup(  \n      tabIds: number | [number, ...number[]],  \n      callback?: function,  \n    )\n\nRemoves one or more tabs from their respective groups. If any groups become\nempty, they are deleted.\n\n#### Parameters\n\n  * tabIds\n\nnumber | [number, ...number[]]\n\nThe tab ID or list of tab IDs to remove from their respective groups.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### update()\n\nPromise\n\n    \n    \n    chrome.tabs.update(  \n      tabId?: number,  \n      updateProperties: object,  \n      callback?: function,  \n    )\n\nModifies the properties of a tab. Properties that are not specified in\n`updateProperties` are not modified.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nDefaults to the selected tab of the current window.\n\n  * updateProperties\n\nobject\n\n    * active\n\nboolean optional\n\nWhether the tab should be active. Does not affect whether the window is\nfocused (see `windows.update`).\n\n    * autoDiscardable\n\nboolean optional\n\nChrome 54+\n\nWhether the tab should be discarded automatically by the browser when\nresources are low.\n\n    * highlighted\n\nboolean optional\n\nAdds or removes the tab from the current selection.\n\n    * muted\n\nboolean optional\n\nChrome 45+\n\nWhether the tab should be muted.\n\n    * openerTabId\n\nnumber optional\n\nThe ID of the tab that opened this tab. If specified, the opener tab must be\nin the same window as this tab.\n\n    * pinned\n\nboolean optional\n\nWhether the tab should be pinned.\n\n    * selected\n\nboolean optional\n\nDeprecated\n\nPlease use _highlighted_.\n\nWhether the tab should be selected.\n\n    * url\n\nstring optional\n\nA URL to navigate the tab to. JavaScript URLs are not supported; use\n`scripting.executeScript` instead.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tab?: Tab) => void\n\n    * tab\n\nTab optional\n\nDetails about the updated tab. The `url`, `pendingUrl`, `title` and\n`favIconUrl` properties are only included on the `tabs.Tab` object if the\nextension has the `\"tabs\"` permission or has host permissions for the page.\n\n#### Returns\n\n  * Promise<Tab | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onActivated\n\n    \n    \n    chrome.tabs.onActivated.addListener(  \n      callback: function,  \n    )\n\nFires when the active tab in a window changes. Note that the tab's URL may not\nbe set at the time this event fired, but you can listen to onUpdated events so\nas to be notified when a URL is set.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (activeInfo: object) => void\n\n    * activeInfo\n\nobject\n\n      * tabId\n\nnumber\n\nThe ID of the tab that has become active.\n\n      * windowId\n\nnumber\n\nThe ID of the window the active tab changed inside of.\n\n### onAttached\n\n    \n    \n    chrome.tabs.onAttached.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is attached to a window; for example, because it was moved\nbetween windows.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (tabId: number, attachInfo: object) => void\n\n    * tabId\n\nnumber\n\n    * attachInfo\n\nobject\n\n      * newPosition\n\nnumber\n\n      * newWindowId\n\nnumber\n\n### onCreated\n\n    \n    \n    chrome.tabs.onCreated.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is created. Note that the tab's URL and tab group membership\nmay not be set at the time this event is fired, but you can listen to\nonUpdated events so as to be notified when a URL is set or the tab is added to\na tab group.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (tab: Tab) => void\n\n    * tab\n\nTab\n\n### onDetached\n\n    \n    \n    chrome.tabs.onDetached.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is detached from a window; for example, because it was moved\nbetween windows.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (tabId: number, detachInfo: object) => void\n\n    * tabId\n\nnumber\n\n    * detachInfo\n\nobject\n\n      * oldPosition\n\nnumber\n\n      * oldWindowId\n\nnumber\n\n### onHighlighted\n\n    \n    \n    chrome.tabs.onHighlighted.addListener(  \n      callback: function,  \n    )\n\nFired when the highlighted or selected tabs in a window changes.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (highlightInfo: object) => void\n\n    * highlightInfo\n\nobject\n\n      * tabIds\n\nnumber[]\n\nAll highlighted tabs in the window.\n\n      * windowId\n\nnumber\n\nThe window whose tabs changed.\n\n### onMoved\n\n    \n    \n    chrome.tabs.onMoved.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is moved within a window. Only one move event is fired,\nrepresenting the tab the user directly moved. Move events are not fired for\nthe other tabs that must move in response to the manually-moved tab. This\nevent is not fired when a tab is moved between windows; for details, see\n`tabs.onDetached`.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (tabId: number, moveInfo: object) => void\n\n    * tabId\n\nnumber\n\n    * moveInfo\n\nobject\n\n      * fromIndex\n\nnumber\n\n      * toIndex\n\nnumber\n\n      * windowId\n\nnumber\n\n### onRemoved\n\n    \n    \n    chrome.tabs.onRemoved.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is closed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (tabId: number, removeInfo: object) => void\n\n    * tabId\n\nnumber\n\n    * removeInfo\n\nobject\n\n      * isWindowClosing\n\nboolean\n\nTrue when the tab was closed because its parent window was closed.\n\n      * windowId\n\nnumber\n\nThe window whose tab is closed.\n\n### onReplaced\n\n    \n    \n    chrome.tabs.onReplaced.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is replaced with another tab due to prerendering or instant.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (addedTabId: number, removedTabId: number) => void\n\n    * addedTabId\n\nnumber\n\n    * removedTabId\n\nnumber\n\n### onUpdated\n\n    \n    \n    chrome.tabs.onUpdated.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is updated.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (tabId: number, changeInfo: object, tab: Tab) => void\n\n    * tabId\n\nnumber\n\n    * changeInfo\n\nobject\n\n      * audible\n\nboolean optional\n\nChrome 45+\n\nThe tab's new audible state.\n\n      * autoDiscardable\n\nboolean optional\n\nChrome 54+\n\nThe tab's new auto-discardable state.\n\n      * discarded\n\nboolean optional\n\nChrome 54+\n\nThe tab's new discarded state.\n\n      * favIconUrl\n\nstring optional\n\nThe tab's new favicon URL.\n\n      * frozen\n\nboolean optional\n\nChrome 132+\n\nThe tab's new frozen state.\n\n      * groupId\n\nnumber optional\n\nChrome 88+\n\nThe tab's new group.\n\n      * mutedInfo\n\nMutedInfo optional\n\nChrome 46+\n\nThe tab's new muted state and the reason for the change.\n\n      * pinned\n\nboolean optional\n\nThe tab's new pinned state.\n\n      * status\n\nTabStatus optional\n\nThe tab's loading status.\n\n      * title\n\nstring optional\n\nChrome 48+\n\nThe tab's new title.\n\n      * url\n\nstring optional\n\nThe tab's URL if it has changed.\n\n    * tab\n\nTab\n\n### onZoomChange\n\n    \n    \n    chrome.tabs.onZoomChange.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is zoomed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (ZoomChangeInfo: object) => void\n\n    * ZoomChangeInfo\n\nobject\n\n      * newZoomFactor\n\nnumber\n\n      * oldZoomFactor\n\nnumber\n\n      * tabId\n\nnumber\n\n      * zoomSettings\n\nZoomSettings\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/topSites": "#  chrome.topSites\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.topSites` API to access the top sites (i.e. most visited\nsites) that are displayed on the new tab page. These do not include shortcuts\ncustomized by the user.\n\n## Permissions\n\n`topSites`  \n\nYou must declare the \"topSites\" permission in your extension's manifest to use\nthis API.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"topSites\",\n      ],\n      ...\n    }\n    \n\n## Examples\n\nTo try this API, install the topSites API example from the chrome-extension-\nsamples repository.\n\n## Types\n\n### MostVisitedURL\n\nAn object encapsulating a most visited URL, such as the default shortcuts on\nthe new tab page.\n\n#### Properties\n\n  * title\n\nstring\n\nThe title of the page\n\n  * url\n\nstring\n\nThe most visited URL.\n\n## Methods\n\n### get()\n\nPromise\n\n    \n    \n    chrome.topSites.get(  \n      callback?: function,  \n    )\n\nGets a list of top sites.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (data: MostVisitedURL[]) => void\n\n    * data\n\nMostVisitedURL[]\n\n#### Returns\n\n  * Promise<MostVisitedURL[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/tts": "#  chrome.tts\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.tts` API to play synthesized text-to-speech (TTS). See also\nthe related `ttsEngine` API, which allows an extension to implement a speech\nengine.\n\nChrome provides this capability on Windows (using SAPI 5), Mac OS X, and\nChromeOS, using speech synthesis capabilities provided by the operating\nsystem. On all platforms, the user can install extensions that register\nthemselves as alternative speech engines.\n\n## Permissions\n\n`tts`  \n\n## Concepts and usage\n\n### Generate speech\n\nCall `speak()` from your extension to speak. For example:\n\n    \n    \n    chrome.tts.speak('Hello, world.');\n    \n\nTo stop speaking immediately, just call `stop()`:\n\n    \n    \n    chrome.tts.stop();\n    \n\nYou can provide options that control various properties of the speech, such as\nits rate, pitch, and more. For example:\n\n    \n    \n    chrome.tts.speak('Hello, world.', {'rate': 2.0});\n    \n\nIt's also a good idea to specify the language so that a synthesizer supporting\nthat language (and regional dialect, if applicable) is chosen.\n\n    \n    \n    chrome.tts.speak('Hello, world.', {'lang': 'en-US', 'rate': 2.0});\n    \n\nBy default, each call to `speak()` interrupts any ongoing speech and speaks\nimmediately. To determine if a call would be interrupting anything, you can\ncall `isSpeaking()`. In addition, you can use the `enqueue` option to cause\nthis utterance to be added to a queue of utterances that will be spoken when\nthe current utterance has finished.\n\n    \n    \n    chrome.tts.speak('Speak this first.');\n    chrome.tts.speak(\n        'Speak this next, when the first sentence is done.', {'enqueue': true});\n    \n\nA complete description of all options can be found under `tts.speak()`. Not\nall speech engines will support all options.\n\nTo catch errors and make sure you're calling `speak()` correctly, pass a\ncallback function that takes no arguments. Inside the callback, check\n`runtime.lastError` to see if there were any errors.\n\n    \n    \n    chrome.tts.speak(\n      utterance,\n      options,\n      function() {\n        if (chrome.runtime.lastError) {\n          console.log('Error: ' + chrome.runtime.lastError.message);\n        }\n      }\n    );\n    \n\nThe callback returns right away, before the engine has started generating\nspeech. The purpose of the callback is to alert you to syntax errors in your\nuse of the TTS API, not to catch all possible errors that might occur in the\nprocess of synthesizing and outputting speech. To catch these errors too, you\nneed to use an event listener, described in the next section.\n\n### Listen to events\n\nTo get more real-time information about the status of synthesized speech, pass\nan event listener in the options to `speak()`, like this:\n\n    \n    \n    chrome.tts.speak(\n      utterance,\n      {\n        onEvent: function(event) {\n          console.log('Event ' + event.type + ' at position ' + event.charIndex);\n          if (event.type == 'error') {\n            console.log('Error: ' + event.errorMessage);\n          }\n        }\n      },\n      callback\n    );\n    \n\nEach event includes an event type, the character index of the current speech\nrelative to the utterance, and for error events, an optional error message.\nThe event types are:\n\n  * `'start'`: The engine has started speaking the utterance.\n  * `'word'`: A word boundary was reached. Use `event.charIndex` to determine the current speech position.\n  * `'sentence'`: A sentence boundary was reached. Use `event.charIndex` to determine the current speech position.\n  * `'marker'`: An SSML marker was reached. Use `event.charIndex` to determine the current speech position.\n  * `'end'`: The engine has finished speaking the utterance.\n  * `'interrupted'`: This utterance was interrupted by another call to `speak()` or `stop()` and did not finish.\n  * `'cancelled'`: This utterance was queued, but then cancelled by another call to `speak()` or `stop()` and never began to speak at all.\n  * `'error'`: An engine-specific error occurred and this utterance cannot be spoken. Check `event.errorMessage` for details.\n\nFour of the event types`'end'`, `'interrupted'`, `'cancelled'`, and\n`'error'`are _final_. After one of those events is received, this utterance\nwill no longer speak and no new events from this utterance will be received.\n\nSome voices may not support all event types, and some voices may not send any\nevents at all. If you don't want to use a voice unless it sends certain\nevents, pass the events you require in the `requiredEventTypes` member of the\noptions object, or use `getVoices()` to choose a voice that meets your\nrequirements. Both are described in what follows.\n\n### SSML markup\n\nUtterances used in this API may include markup using the Speech Synthesis\nMarkup Language (SSML). If you use SSML, the first argument to `speak()`\nshould be a complete SSML document with an XML header and a top-level\n`<speak>` tag, not a document fragment.\n\nFor example:\n\n    \n    \n    chrome.tts.speak(\n      '<?xml version=\"1.0\"?>' +\n      '<speak>' +\n      '  The <emphasis>second</emphasis> ' +\n      '  word of this sentence was emphasized.' +\n      '</speak>'\n    );\n    \n\nNot all speech engines will support all SSML tags, and some may not support\nSSML at all, but all engines are required to ignore any SSML they don't\nsupport and to still speak the underlying text.\n\n### Choose a voice\n\nBy default, Chrome chooses the most appropriate voice for each utterance you\nwant to speak, based on the language. On most Windows, Mac OS X, and ChromeOS\nsystems, speech synthesis provided by the operating system should be able to\nspeak any text in at least one language. Some users may have a variety of\nvoices available, though, from their operating system and from speech engines\nimplemented by other Chrome extensions. In those cases, you can implement\ncustom code to choose the appropriate voice, or to present the user with a\nlist of choices.\n\nTo get a list of all voices, call `getVoices()` and pass it a function that\nreceives an array of `TtsVoice` objects as its argument:\n\n    \n    \n    chrome.tts.getVoices(\n      function(voices) {\n        for (var i = 0; i < voices.length; i++) {\n          console.log('Voice ' + i + ':');\n          console.log('  name: ' + voices[i].voiceName);\n          console.log('  lang: ' + voices[i].lang);\n          console.log('  extension id: ' + voices[i].extensionId);\n          console.log('  event types: ' + voices[i].eventTypes);\n        }\n      }\n    );\n    \n\n## Types\n\n### EventType\n\nChrome 54+\n\n#### Enum\n\n\"start\"  \n\n\"end\"  \n\n\"word\"  \n\n\"sentence\"  \n\n\"marker\"  \n\n\"interrupted\"  \n\n\"cancelled\"  \n\n\"error\"  \n\n\"pause\"  \n\n\"resume\"  \n\n### TtsEvent\n\nAn event from the TTS engine to communicate the status of an utterance.\n\n#### Properties\n\n  * charIndex\n\nnumber optional\n\nThe index of the current character in the utterance. For word events, the\nevent fires at the end of one word and before the beginning of the next. The\n`charIndex` represents a point in the text at the beginning of the next word\nto be spoken.\n\n  * errorMessage\n\nstring optional\n\nThe error description, if the event type is `error`.\n\n  * length\n\nnumber optional\n\nChrome 74+\n\nThe length of the next part of the utterance. For example, in a `word` event,\nthis is the length of the word which will be spoken next. It will be set to -1\nif not set by the speech engine.\n\n  * type\n\nEventType\n\nThe type can be `start` as soon as speech has started, `word` when a word\nboundary is reached, `sentence` when a sentence boundary is reached, `marker`\nwhen an SSML mark element is reached, `end` when the end of the utterance is\nreached, `interrupted` when the utterance is stopped or interrupted before\nreaching the end, `cancelled` when it's removed from the queue before ever\nbeing synthesized, or `error` when any other error occurs. When pausing\nspeech, a `pause` event is fired if a particular utterance is paused in the\nmiddle, and `resume` if an utterance resumes speech. Note that pause and\nresume events may not fire if speech is paused in-between utterances.\n\n### TtsOptions\n\nChrome 77+\n\nThe speech options for the TTS engine.\n\n#### Properties\n\n  * desiredEventTypes\n\nstring[] optional\n\nThe TTS event types that you are interested in listening to. If missing, all\nevent types may be sent.\n\n  * enqueue\n\nboolean optional\n\nIf true, enqueues this utterance if TTS is already in progress. If false (the\ndefault), interrupts any current speech and flushes the speech queue before\nspeaking this new utterance.\n\n  * extensionId\n\nstring optional\n\nThe extension ID of the speech engine to use, if known.\n\n  * gender\n\nVoiceGender optional\n\nDeprecated since Chrome 77\n\nGender is deprecated and will be ignored.\n\nGender of voice for synthesized speech.\n\n  * lang\n\nstring optional\n\nThe language to be used for synthesis, in the form _language_ -_region_.\nExamples: 'en', 'en-US', 'en-GB', 'zh-CN'.\n\n  * pitch\n\nnumber optional\n\nSpeaking pitch between 0 and 2 inclusive, with 0 being lowest and 2 being\nhighest. 1.0 corresponds to a voice's default pitch.\n\n  * rate\n\nnumber optional\n\nSpeaking rate relative to the default rate for this voice. 1.0 is the default\nrate, normally around 180 to 220 words per minute. 2.0 is twice as fast, and\n0.5 is half as fast. Values below 0.1 or above 10.0 are strictly disallowed,\nbut many voices will constrain the minimum and maximum rates furtherfor\nexample a particular voice may not actually speak faster than 3 times normal\neven if you specify a value larger than 3.0.\n\n  * requiredEventTypes\n\nstring[] optional\n\nThe TTS event types the voice must support.\n\n  * voiceName\n\nstring optional\n\nThe name of the voice to use for synthesis. If empty, uses any available\nvoice.\n\n  * volume\n\nnumber optional\n\nSpeaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being\nhighest, with a default of 1.0.\n\n  * onEvent\n\nvoid optional\n\nThis function is called with events that occur in the process of speaking the\nutterance.\n\nThe `onEvent` function looks like:\n\n        \n        (event: TtsEvent) => {...}\n\n    * event\n\nTtsEvent\n\nThe update event from the text-to-speech engine indicating the status of this\nutterance.\n\n### TtsVoice\n\nA description of a voice available for speech synthesis.\n\n#### Properties\n\n  * eventTypes\n\nEventType[] optional\n\nAll of the callback event types that this voice is capable of sending.\n\n  * extensionId\n\nstring optional\n\nThe ID of the extension providing this voice.\n\n  * gender\n\nVoiceGender optional\n\nDeprecated since Chrome 70\n\nGender is deprecated and will be ignored.\n\nThis voice's gender.\n\n  * lang\n\nstring optional\n\nThe language that this voice supports, in the form _language_ -_region_.\nExamples: 'en', 'en-US', 'en-GB', 'zh-CN'.\n\n  * remote\n\nboolean optional\n\nIf true, the synthesis engine is a remote network resource. It may be higher\nlatency and may incur bandwidth costs.\n\n  * voiceName\n\nstring optional\n\nThe name of the voice.\n\n### VoiceGender\n\nChrome 54+  Deprecated since Chrome 70\n\nGender is deprecated and is ignored.\n\n#### Enum\n\n\"male\"  \n\n\"female\"  \n\n## Methods\n\n### getVoices()\n\nPromise\n\n    \n    \n    chrome.tts.getVoices(  \n      callback?: function,  \n    )\n\nGets an array of all available voices.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (voices: TtsVoice[]) => void\n\n    * voices\n\nTtsVoice[]\n\nArray of `tts.TtsVoice` objects representing the available voices for speech\nsynthesis.\n\n#### Returns\n\n  * Promise<TtsVoice[]>\n\nChrome 101+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### isSpeaking()\n\nPromise\n\n    \n    \n    chrome.tts.isSpeaking(  \n      callback?: function,  \n    )\n\nChecks whether the engine is currently speaking. On Mac OS X, the result is\ntrue whenever the system speech engine is speaking, even if the speech wasn't\ninitiated by Chrome.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (speaking: boolean) => void\n\n    * speaking\n\nboolean\n\nTrue if speaking, false otherwise.\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 101+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### pause()\n\n    \n    \n    chrome.tts.pause()\n\nPauses speech synthesis, potentially in the middle of an utterance. A call to\nresume or stop will un-pause speech.\n\n### resume()\n\n    \n    \n    chrome.tts.resume()\n\nIf speech was paused, resumes speaking where it left off.\n\n### speak()\n\nPromise\n\n    \n    \n    chrome.tts.speak(  \n      utterance: string,  \n      options?: TtsOptions,  \n      callback?: function,  \n    )\n\nSpeaks text using a text-to-speech engine.\n\n#### Parameters\n\n  * utterance\n\nstring\n\nThe text to speak, either plain text or a complete, well-formed SSML document.\nSpeech engines that do not support SSML will strip away the tags and speak the\ntext. The maximum length of the text is 32,768 characters.\n\n  * options\n\nTtsOptions optional\n\nThe speech options.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 101+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### stop()\n\n    \n    \n    chrome.tts.stop()\n\nStops any current speech and flushes the queue of any pending utterances. In\naddition, if speech was paused, it will now be un-paused for the next call to\nspeak.\n\n## Events\n\n### onVoicesChanged\n\nChrome 124+\n\n    \n    \n    chrome.tts.onVoicesChanged.addListener(  \n      callback: function,  \n    )\n\nCalled when the list of `tts.TtsVoice` that would be returned by getVoices has\nchanged.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/ttsEngine": "#  chrome.ttsEngine\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.ttsEngine` API to implement a text-to-speech(TTS) engine using\nan extension. If your extension registers using this API, it will receive\nevents containing an utterance to be spoken and other parameters when any\nextension or Chrome App uses the `tts` API to generate speech. Your extension\ncan then use any available web technology to synthesize and output the speech,\nand send events back to the calling function to report the status.\n\n## Permissions\n\n`ttsEngine`  \n\n## Concepts and usage\n\nAn extension can register itself as a speech engine. By doing so, it can\nintercept some or all calls to functions such as `tts.speak()` and\n`tts.stop()` and provide an alternate implementation. Extensions are free to\nuse any available web technology to provide speech, including streaming audio\nfrom a server, HTML5 audio. An extension could even do something different\nwith the utterances, like display closed captions in a popup or send them as\nlog messages to a remote server.\n\nTo implement a TTS engine, an extension must declare the \"ttsEngine\"\npermission and then declare all voices it provides in the extension manifest,\nlike this:\n\n    \n    \n    {\n      \"name\": \"My TTS Engine\",\n      \"version\": \"1.0\",\n      \"permissions\": [\"ttsEngine\"],\n      \"tts_engine\": {\n        \"voices\": [\n          {\n            \"voice_name\": \"Alice\",\n            \"lang\": \"en-US\",\n            \"event_types\": [\"start\", \"marker\", \"end\"]\n          },\n          {\n            \"voice_name\": \"Pat\",\n            \"lang\": \"en-US\",\n            \"event_types\": [\"end\"]\n          }\n        ]\n      },\n      \"background\": {\n        \"page\": \"background.html\",\n        \"persistent\": false\n      }\n    }\n    \n\nAn extension can specify any number of voices.\n\nThe `voice_name` parameter is required. The name should be descriptive enough\nthat it identifies the name of the voice and the engine used. In the unlikely\nevent that two extensions register voices with the same name, a client can\nspecify the ID of the extension that should do the synthesis.\n\nThe `lang` parameter is optional, but highly recommended. Almost always, a\nvoice can synthesize speech in just a single language. When an engine supports\nmore than one language, it can easily register a separate voice for each\nlanguage. Under rare circumstances where a single voice can handle more than\none language, it's easiest to just list two separate voices and handle them\nusing the same logic internally. However, if you want to create a voice that\nwill handle utterances in any language, leave out the `lang` parameter from\nyour extension's manifest.\n\nFinally, the `event_types` parameter is required if the engine can send events\nto update the client on the progress of speech synthesis. At a minimum,\nsupporting the `'end'` event type to indicate when speech is finished is\nhighly recommended, otherwise Chrome cannot schedule queued utterances.\n\nOnce loaded, an extension can replace the list of declared voices by calling\n`chrome.ttsEngine.updateVoices`. (Note that the parameters used in the\nprogramatic call to `updateVoices` are in camel case: e.g., `voiceName`,\nunlike the manifest file which uses `voice_name`.)\n\n**Note:** If your TTS engine does not support the `'end'` event type, Chrome\ncannot queue utterances because it has no way of knowing when your utterance\nhas finished. To help mitigate this, Chrome passes an additional boolean\n`enqueue` option to your engine's onSpeak handler, giving you the option of\nimplementing your own queueing. This is discouraged because then clients are\nunable to queue utterances that should get spoken by different speech engines.\n\nThe possible event types that you can send correspond to the event types that\nthe `speak()` method receives:\n\n  * `'start'`: The engine has started speaking the utterance.\n  * `'word'`: A word boundary was reached. Use `event.charIndex` to determine the current speech position.\n  * `'sentence'`: A sentence boundary was reached. Use `event.charIndex` to determine the current speech position.\n  * `'marker'`: An SSML marker was reached. Use `event.charIndex` to determine the current speech position.\n  * `'end'`: The engine has finished speaking the utterance.\n  * `'error'`: An engine-specific error occurred and this utterance cannot be spoken. Pass more information in `event.errorMessage`.\n\nThe `'interrupted'` and `'cancelled'` events are not sent by the speech\nengine; they are generated automatically by Chrome.\n\nText-to-speech clients can get the voice information from your extension's\nmanifest by calling `tts.getVoices`, assuming you've registered speech event\nlisteners as described below.\n\n### Handle speech events\n\nTo generate speech at the request of clients, your extension must register\nlisteners for both `onSpeak` and `onStop`, like this:\n\n    \n    \n    const speakListener = (utterance, options, sendTtsEvent) => {\n      sendTtsEvent({type: 'start', charIndex: 0})\n    \n      // (start speaking)\n    \n      sendTtsEvent({type: 'end', charIndex: utterance.length})\n    };\n    \n    const stopListener = () => {\n      // (stop all speech)\n    };\n    \n    chrome.ttsEngine.onSpeak.addListener(speakListener);\n    chrome.ttsEngine.onStop.addListener(stopListener);\n    \n\n**Caution:** If your extension does not register listeners for both `onSpeak`\nand `onStop`, it will not intercept any speech calls, regardless of what is in\nthe manifest.\n\nThe decision of whether or not to send a given speech request to an extension\nis based solely on whether the extension supports the given voice parameters\nin its manifest and has registered listeners for `onSpeak` and `onStop`. In\nother words, there's no way for an extension to receive a speech request and\ndynamically decide whether to handle it.\n\n## Types\n\n### AudioBuffer\n\nChrome 92+\n\nParameters containing an audio buffer and associated data.\n\n#### Properties\n\n  * audioBuffer\n\nArrayBuffer\n\nThe audio buffer from the text-to-speech engine. It should have length exactly\naudioStreamOptions.bufferSize and encoded as mono, at\naudioStreamOptions.sampleRate, and as linear pcm, 32-bit signed float i.e. the\nFloat32Array type in javascript.\n\n  * charIndex\n\nnumber optional\n\nThe character index associated with this audio buffer.\n\n  * isLastBuffer\n\nboolean optional\n\nTrue if this audio buffer is the last for the text being spoken.\n\n### AudioStreamOptions\n\nChrome 92+\n\nContains the audio stream format expected to be produced by an engine.\n\n#### Properties\n\n  * bufferSize\n\nnumber\n\nThe number of samples within an audio buffer.\n\n  * sampleRate\n\nnumber\n\nThe sample rate expected in an audio buffer.\n\n### LanguageInstallStatus\n\nChrome 132+\n\nThe install status of a voice.\n\n#### Enum\n\n\"notInstalled\"  \n\n\"installing\"  \n\n\"installed\"  \n\n\"failed\"  \n\n### LanguageStatus\n\nChrome 132+\n\nInstall status of a language.\n\n#### Properties\n\n  * error\n\nstring optional\n\nDetail about installation failures. Optionally populated if the language\nfailed to install.\n\n  * installStatus\n\nLanguageInstallStatus\n\nInstallation status.\n\n  * lang\n\nstring\n\nLanguage string in the form of language code-region code, where the region may\nbe omitted. Examples are en, en-AU, zh-CH.\n\n### LanguageUninstallOptions\n\nChrome 132+\n\nOptions for uninstalling a given language.\n\n#### Properties\n\n  * uninstallImmediately\n\nboolean\n\nTrue if the TTS client wants the language to be immediately uninstalled. The\nengine may choose whether or when to uninstall the language, based on this\nparameter and the requestor information. If false, it may use other criteria,\nsuch as recent usage, to determine when to uninstall.\n\n### SpeakOptions\n\nChrome 92+\n\nOptions specified to the tts.speak() method.\n\n#### Properties\n\n  * gender\n\nVoiceGender optional\n\nDeprecated since Chrome 92\n\nGender is deprecated and will be ignored.\n\nGender of voice for synthesized speech.\n\n  * lang\n\nstring optional\n\nThe language to be used for synthesis, in the form _language_ -_region_.\nExamples: 'en', 'en-US', 'en-GB', 'zh-CN'.\n\n  * pitch\n\nnumber optional\n\nSpeaking pitch between 0 and 2 inclusive, with 0 being lowest and 2 being\nhighest. 1.0 corresponds to this voice's default pitch.\n\n  * rate\n\nnumber optional\n\nSpeaking rate relative to the default rate for this voice. 1.0 is the default\nrate, normally around 180 to 220 words per minute. 2.0 is twice as fast, and\n0.5 is half as fast. This value is guaranteed to be between 0.1 and 10.0,\ninclusive. When a voice does not support this full range of rates, don't\nreturn an error. Instead, clip the rate to the range the voice supports.\n\n  * voiceName\n\nstring optional\n\nThe name of the voice to use for synthesis.\n\n  * volume\n\nnumber optional\n\nSpeaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being\nhighest, with a default of 1.0.\n\n### TtsClient\n\nChrome 131+\n\nIdentifier for the client requesting status.\n\n#### Properties\n\n  * id\n\nstring\n\nClient making a language management request. For an extension, this is the\nunique extension ID. For Chrome features, this is the human-readable name of\nthe feature.\n\n  * source\n\nTtsClientSource\n\nType of requestor.\n\n### TtsClientSource\n\nChrome 131+\n\nType of requestor.\n\n#### Enum\n\n\"chromefeature\"  \n\n\"extension\"  \n\n### VoiceGender\n\nChrome 54+  Deprecated since Chrome 70\n\nGender is deprecated and will be ignored.\n\n#### Enum\n\n\"male\"  \n\n\"female\"  \n\n## Methods\n\n### updateLanguage()\n\nChrome 132+\n\n    \n    \n    chrome.ttsEngine.updateLanguage(  \n      status: LanguageStatus,  \n    )\n\nCalled by an engine when a language install is attempted, and when a language\nis uninstalled. Also called in response to a status request from a client.\nWhen a voice is installed or uninstalled, the engine should also call\nttsEngine.updateVoices to register the voice.\n\n#### Parameters\n\n  * status\n\nLanguageStatus\n\nThe install status of the language.\n\n### updateVoices()\n\nChrome 66+\n\n    \n    \n    chrome.ttsEngine.updateVoices(  \n      voices: TtsVoice[],  \n    )\n\nCalled by an engine to update its list of voices. This list overrides any\nvoices declared in this extension's manifest.\n\n#### Parameters\n\n  * voices\n\nTtsVoice[]\n\nArray of `tts.TtsVoice` objects representing the available voices for speech\nsynthesis.\n\n## Events\n\n### onInstallLanguageRequest\n\nChrome 131+\n\n    \n    \n    chrome.ttsEngine.onInstallLanguageRequest.addListener(  \n      callback: function,  \n    )\n\nFired when a TTS client requests to install a new language. The engine should\nattempt to download and install the language, and call\nttsEngine.updateLanguage with the result. On success, the engine should also\ncall ttsEngine.updateVoices to register the newly available voices.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestor: TtsClient, lang: string) => void\n\n    * requestor\n\nTtsClient\n\n    * lang\n\nstring\n\n### onLanguageStatusRequest\n\nChrome 132+\n\n    \n    \n    chrome.ttsEngine.onLanguageStatusRequest.addListener(  \n      callback: function,  \n    )\n\nFired when a TTS client requests the install status of a language.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestor: TtsClient, lang: string) => void\n\n    * requestor\n\nTtsClient\n\n    * lang\n\nstring\n\n### onPause\n\n    \n    \n    chrome.ttsEngine.onPause.addListener(  \n      callback: function,  \n    )\n\nOptional: if an engine supports the pause event, it should pause the current\nutterance being spoken, if any, until it receives a resume event or stop\nevent. Note that a stop event should also clear the paused state.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onResume\n\n    \n    \n    chrome.ttsEngine.onResume.addListener(  \n      callback: function,  \n    )\n\nOptional: if an engine supports the pause event, it should also support the\nresume event, to continue speaking the current utterance, if any. Note that a\nstop event should also clear the paused state.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onSpeak\n\n    \n    \n    chrome.ttsEngine.onSpeak.addListener(  \n      callback: function,  \n    )\n\nCalled when the user makes a call to tts.speak() and one of the voices from\nthis extension's manifest is the first to match the options object.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (utterance: string, options: SpeakOptions, sendTtsEvent: function) => void\n\n    * utterance\n\nstring\n\n    * options\n\nSpeakOptions\n\n    * sendTtsEvent\n\nfunction\n\nThe `sendTtsEvent` parameter looks like:\n\n          \n          (event: tts.TtsEvent) => void\n\n      * event\n\ntts.TtsEvent\n\nThe event from the text-to-speech engine indicating the status of this\nutterance.\n\n### onSpeakWithAudioStream\n\nChrome 92+\n\n    \n    \n    chrome.ttsEngine.onSpeakWithAudioStream.addListener(  \n      callback: function,  \n    )\n\nCalled when the user makes a call to tts.speak() and one of the voices from\nthis extension's manifest is the first to match the options object. Differs\nfrom ttsEngine.onSpeak in that Chrome provides audio playback services and\nhandles dispatching tts events.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (utterance: string, options: SpeakOptions, audioStreamOptions: AudioStreamOptions, sendTtsAudio: function, sendError: function) => void\n\n    * utterance\n\nstring\n\n    * options\n\nSpeakOptions\n\n    * audioStreamOptions\n\nAudioStreamOptions\n\n    * sendTtsAudio\n\nfunction\n\nThe `sendTtsAudio` parameter looks like:\n\n          \n          (audioBufferParams: AudioBuffer) => void\n\n      * audioBufferParams\n\nAudioBuffer\n\nParameters containing an audio buffer and associated data.\n\n    * sendError\n\nfunction\n\nChrome 94+\n\nThe `sendError` parameter looks like:\n\n          \n          (errorMessage?: string) => void\n\n      * errorMessage\n\nstring optional\n\nA string describing the error.\n\n### onStop\n\n    \n    \n    chrome.ttsEngine.onStop.addListener(  \n      callback: function,  \n    )\n\nFired when a call is made to tts.stop and this extension may be in the middle\nof speaking. If an extension receives a call to onStop and speech is already\nstopped, it should do nothing (not raise an error). If speech is in the paused\nstate, this should cancel the paused state.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onUninstallLanguageRequest\n\nChrome 132+\n\n    \n    \n    chrome.ttsEngine.onUninstallLanguageRequest.addListener(  \n      callback: function,  \n    )\n\nFired when a TTS client indicates a language is no longer needed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestor: TtsClient, lang: string, uninstallOptions: LanguageUninstallOptions) => void\n\n    * requestor\n\nTtsClient\n\n    * lang\n\nstring\n\n    * uninstallOptions\n\nLanguageUninstallOptions\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/types": "#  chrome.types\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.types` API contains type declarations for Chrome.\n\n## Chrome settings\n\nThe `ChromeSetting` type provides a common set of functions (`get()`, `set()`,\nand `clear()`) as well as an event publisher (`onChange`) for settings of the\nChrome browser. The proxy settings examples demonstrate how these functions\nare intended to be used.\n\n### Scope and lifecycle\n\nChrome distinguishes between three different scopes of browser settings:\n\n`regular`\n\n    Settings set in the `regular` scope apply to regular browser windows and are inherited by incognito windows if they are not overwritten. These settings are stored to disk and remain in place until they are cleared by the governing extension, or the governing extension is disabled or uninstalled.\n`incognito_persistent`\n\n    Settings set in the `incognito_persistent` scope apply only to incognito windows. For these, they override `regular` settings. These settings are stored to disk and remain in place until they are cleared by the governing extension, or the governing extension is disabled or uninstalled.\n`incognito_session_only`\n\n    Settings set in the `incognito_session_only` scope apply only to incognito windows. For these, they override `regular` and `incognito_persistent` settings. These settings are not stored to disk and are cleared when the last incognito window is closed. They can only be set when at least one incognito window is open.\n\n### Precedence\n\nChrome manages settings on different layers. The following list describes the\nlayers that may influence the effective settings, in increasing order of\nprecedence.\n\n  1. System settings provided by the operating system\n  2. Command-line parameters\n  3. Settings provided by extensions\n  4. Policies\n\nAs the list implies, policies might overrule any changes that you specify with\nyour extension. You can use the `get()` function to determine whether your\nextension is capable of providing a setting or whether this setting would be\noverridden.\n\nAs discussed previously, Chrome allows using different settings for regular\nwindows and incognito windows. The following example illustrates the behavior.\nAssume that no policy overrides the settings and that an extension can set\nsettings for regular windows **(R)** and settings for incognito windows\n**(I)**.\n\n  * If only **(R)** is set, these settings are effective for both regular and incognito windows.\n  * If only **(I)** is set, these settings are effective for only incognito windows. Regular windows use the settings determined by the lower layers (command-line options and system settings).\n  * If both **(R)** and **(I)** are set, the respective settings are used for regular and incognito windows.\n\nIf two or more extensions want to set the same setting to different values,\nthe extension installed most recently takes precedence over the other\nextensions. If the most recently installed extension sets only **(I)** , the\nsettings of regular windows can be defined by previously installed extensions.\n\nThe _effective_ value of a setting is the one that results from considering\nthe precedence rules. It is used by Chrome.\n\n## Types\n\n### ChromeSetting\n\nAn interface that allows access to a Chrome browser setting. See\n`accessibilityFeatures` for an example.\n\n#### Properties\n\n  * onChange\n\nEvent<functionvoidvoid>\n\nFired after the setting changes.\n\nThe `onChange.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (details: object) => void\n\n      * details\n\nobject\n\n        * incognitoSpecific\n\nboolean optional\n\nWhether the value that has changed is specific to the incognito session. This\nproperty will _only_ be present if the user has enabled the extension in\nincognito mode.\n\n        * levelOfControl\n\nLevelOfControl\n\nThe level of control of the setting.\n\n        * value\n\nT\n\nThe value of the setting after the change.\n\n  * clear\n\nvoid\n\nPromise\n\nClears the setting, restoring any default value.\n\nThe `clear` function looks like:\n\n        \n        (details: object, callback?: function) => {...}\n\n    * details\n\nobject\n\nWhich setting to clear.\n\n      * scope\n\nChromeSettingScope optional\n\nWhere to clear the setting (default: regular).\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * get\n\nvoid\n\nPromise\n\nGets the value of a setting.\n\nThe `get` function looks like:\n\n        \n        (details: object, callback?: function) => {...}\n\n    * details\n\nobject\n\nWhich setting to consider.\n\n      * incognito\n\nboolean optional\n\nWhether to return the value that applies to the incognito session (default\nfalse).\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (details: object) => void\n\n      * details\n\nobject\n\nDetails of the currently effective value.\n\n        * incognitoSpecific\n\nboolean optional\n\nWhether the effective value is specific to the incognito session. This\nproperty will _only_ be present if the `incognito` property in the `details`\nparameter of `get()` was true.\n\n        * levelOfControl\n\nLevelOfControl\n\nThe level of control of the setting.\n\n        * value\n\nT\n\nThe value of the setting.\n\n    * returns\n\nPromise<object>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * set\n\nvoid\n\nPromise\n\nSets the value of a setting.\n\nThe `set` function looks like:\n\n        \n        (details: object, callback?: function) => {...}\n\n    * details\n\nobject\n\nWhich setting to change.\n\n      * scope\n\nChromeSettingScope optional\n\nWhere to set the setting (default: regular).\n\n      * value\n\nT\n\nThe value of the setting. Note that every setting has a specific value type,\nwhich is described together with the setting. An extension should _not_ set a\nvalue of a different type.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### ChromeSettingScope\n\nChrome 44+\n\nThe scope of the ChromeSetting. One of\n\n  * `regular`: setting for the regular profile (which is inherited by the incognito profile if not overridden elsewhere),\n  * `regular\\_only`: setting for the regular profile only (not inherited by the incognito profile),\n  * `incognito\\_persistent`: setting for the incognito profile that survives browser restarts (overrides regular preferences),\n  * `incognito\\_session\\_only`: setting for the incognito profile that can only be set during an incognito session and is deleted when the incognito session ends (overrides regular and incognito_persistent preferences).\n\n#### Enum\n\n\"regular\"  \n\n\"regular_only\"  \n\n\"incognito_persistent\"  \n\n\"incognito_session_only\"  \n\n### LevelOfControl\n\nChrome 44+\n\nOne of\n\n  * `not\\_controllable`: cannot be controlled by any extension\n  * `controlled\\_by\\_other\\_extensions`: controlled by extensions with higher precedence\n  * `controllable\\_by\\_this\\_extension`: can be controlled by this extension\n  * `controlled\\_by\\_this\\_extension`: controlled by this extension\n\n#### Enum\n\n\"not_controllable\"  \n\n\"controlled_by_other_extensions\"  \n\n\"controllable_by_this_extension\"  \n\n\"controlled_by_this_extension\"  \n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/userScripts": "#  chrome.userScripts\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `userScripts` API to execute user scripts in the User Scripts context.\n\n## Permissions\n\n`userScripts`  \n\nTo use the User Scripts API, `chrome.userScripts`, add the `\"userScripts\"`\npermission to your manifest.json and `\"host_permissions\"` for sites you want\nto run scripts on.\n\n    \n    \n    {\n      \"name\": \"User script test extension\",\n      \"manifest_version\": 3,\n      \"minimum_chrome_version\": \"120\",\n      \"permissions\": [\n        \"userScripts\"\n      ],\n      \"host_permissions\": [\n        \"*://example.com/*\"\n      ]\n    }\n    \n\n## Availability\n\nChrome 120+ MV3+\n\n## Concepts and usage\n\nA user script is a snippet of code injected into a web page to modify its\nappearance or behavior. Unlike other extension features, such as Content\nScripts and the `chrome.scripting` API, the User Scripts API lets you run\narbitrary code. This API is required for extensions that run scripts provided\nby the user that cannot be shipped as part of your extension package.\n\n### Developer mode for extension users\n\nAs an extension developer, you already have Developer mode enabled in your\ninstallation of Chrome. For user script extensions, your users will also need\nto enable developer mode. Here are instructions that you can copy and paste\ninto your own documentation.\n\n  1. Go to the Extensions page by entering `chrome://extensions` in a new tab. (By design `chrome://` URLs are not linkable.)\n  2. Enable Developer Mode by clicking the toggle switch next to **Developer mode**.  ![Extensions page](/static/docs/extensions/reference/api/userScripts/image/extensions-page-324e88e82e214.png)\n\nExtensions page (chrome://extensions)\n\nYou can determine if developer mode is enabled by checking whether\n`chrome.userScripts` throws an error. For example:\n\n    \n    \n    function isUserScriptsAvailable() {\n      try {\n        // Property access which throws if developer mode is not enabled.\n        chrome.userScripts;\n        return true;\n      } catch {\n        // Not available.\n        return false;\n      }\n    }\n    \n\n### Work in isolated worlds\n\nBoth user and content scripts can run in an isolated world or in the main\nworld. An isolated world is an execution environment that isn't accessible to\na host page or other extensions. This lets a user script change its JavaScript\nenvironment without affecting the host page or other extensions' user and\ncontent scripts. Conversely, user scripts (and content scripts) are not\nvisible to the host page or the user and content scripts of other extensions.\nScripts running in the main world are accessible to host pages and other\nextensions and are visible to host pages and to other extensions. To select\nthe world, pass `\"USER_SCRIPT\"` or `\"MAIN\"` when calling\n`userScripts.register()`.\n\nTo configure a content security policy for the `USER_SCRIPT` world, call\n`userScripts.configureWorld()`:\n\n    \n    \n    chrome.userScripts.configureWorld({\n      csp: \"script-src 'self'\"\n    });\n    \n\n### Messaging\n\nLike content scripts and offscreen documents, user scripts communicate with\nother parts of an extension using messaging (meaning they can call\n`runtime.sendMessage()` and `runtime.connect()` as any other part of an\nextension would). However, they're received using dedicated event handlers\n(meaning, they don't use `onMessage` or `onConnect`). These handlers are\ncalled `runtime.onUserScriptMessage` and `runtime.onUserScriptConnect`.\nDedicated handlers make it easier to identify messages from user scripts,\nwhich are a less-trusted context.\n\nBefore sending a message, you must call `configureWorld()` with the\n`messaging` argument set to `true`. Note that both the `csp` and `messaging`\narguments can be passed at the same time.\n\n    \n    \n    chrome.userScripts.configureWorld({\n      messaging: true\n    });\n    \n\n### Extension updates\n\nUser scripts are cleared when an extension updates. You can add them back by\nrunning code in the `runtime.onInstalled` event handler in the extension\nservice worker. Respond only to the `\"update\"` reason passed to the event\ncallback.\n\n## Example\n\nThis example is from the userScript sample in our samples repository.\n\n### Register a script\n\nThe following example shows a basic call to `register()`. The first argument\nis an array of objects defining the scripts to be registered. There are more\noptions than are shown here.\n\n    \n    \n    chrome.userScripts.register([{\n      id: 'test',\n      matches: ['*://*/*'],\n      js: [{code: 'alert(\"Hi!\")'}]\n    }]);\n    \n\n## Types\n\n### ExecutionWorld\n\nThe JavaScript world for a user script to execute within.\n\n#### Enum\n\n\"MAIN\"  \nSpecifies the execution environment of the DOM, which is the execution\nenvironment shared with the host page's JavaScript.\n\n\"USER_SCRIPT\"  \nSpecifies the execution environment that is specific to user scripts and is\nexempt from the page's CSP.\n\n### InjectionResult\n\nChrome 135+\n\n#### Properties\n\n  * documentId\n\nstring\n\nThe document associated with the injection.\n\n  * error\n\nstring optional\n\nThe error, if any. `error` and `result` are mutually exclusive.\n\n  * frameId\n\nnumber\n\nThe frame associated with the injection.\n\n  * result\n\nany optional\n\nThe result of the script execution.\n\n### InjectionTarget\n\nChrome 135+\n\n#### Properties\n\n  * allFrames\n\nboolean optional\n\nWhether the script should inject into all frames within the tab. Defaults to\nfalse. This must not be true if `frameIds` is specified.\n\n  * documentIds\n\nstring[] optional\n\nThe IDs of specific documentIds to inject into. This must not be set if\n`frameIds` is set.\n\n  * frameIds\n\nnumber[] optional\n\nThe IDs of specific frames to inject into.\n\n  * tabId\n\nnumber\n\nThe ID of the tab into which to inject.\n\n### RegisteredUserScript\n\n#### Properties\n\n  * allFrames\n\nboolean optional\n\nIf true, it will inject into all frames, even if the frame is not the top-most\nframe in the tab. Each frame is checked independently for URL requirements; it\nwill not inject into child frames if the URL requirements are not met.\nDefaults to false, meaning that only the top frame is matched.\n\n  * excludeGlobs\n\nstring[] optional\n\nSpecifies wildcard patterns for pages this user script will NOT be injected\ninto.\n\n  * excludeMatches\n\nstring[] optional\n\nExcludes pages that this user script would otherwise be injected into. See\nMatch Patterns for more details on the syntax of these strings.\n\n  * id\n\nstring\n\nThe ID of the user script specified in the API call. This property must not\nstart with a '_' as it's reserved as a prefix for generated script IDs.\n\n  * includeGlobs\n\nstring[] optional\n\nSpecifies wildcard patterns for pages this user script will be injected into.\n\n  * js\n\nScriptSource[] optional\n\nThe list of ScriptSource objects defining sources of scripts to be injected\ninto matching pages. This property must be specified for ${ref:register}, and\nwhen specified it must be a non-empty array.\n\n  * matches\n\nstring[] optional\n\nSpecifies which pages this user script will be injected into. See Match\nPatterns for more details on the syntax of these strings. This property must\nbe specified for ${ref:register}.\n\n  * runAt\n\nRunAt optional\n\nSpecifies when JavaScript files are injected into the web page. The preferred\nand default value is `document_idle`.\n\n  * world\n\nExecutionWorld optional\n\nThe JavaScript execution environment to run the script in. The default is\n``USER_SCRIPT``.\n\n  * worldId\n\nstring optional\n\nChrome 133+\n\nSpecifies the user script world ID to execute in. If omitted, the script will\nexecute in the default user script world. Only valid if `world` is omitted or\nis `USER_SCRIPT`. Values with leading underscores (`_`) are reserved.\n\n### ScriptSource\n\n#### Properties\n\n  * code\n\nstring optional\n\nA string containing the JavaScript code to inject. Exactly one of `file` or\n`code` must be specified.\n\n  * file\n\nstring optional\n\nThe path of the JavaScript file to inject relative to the extension's root\ndirectory. Exactly one of `file` or `code` must be specified.\n\n### UserScriptFilter\n\n#### Properties\n\n  * ids\n\nstring[] optional\n\n`getScripts` only returns scripts with the IDs specified in this list.\n\n### UserScriptInjection\n\nChrome 135+\n\n#### Properties\n\n  * injectImmediately\n\nboolean optional\n\nWhether the injection should be triggered in the target as soon as possible.\nNote that this is not a guarantee that injection will occur prior to page\nload, as the page may have already loaded by the time the script reaches the\ntarget.\n\n  * js\n\nScriptSource[]\n\nThe list of ScriptSource objects defining sources of scripts to be injected\ninto the target.\n\n  * target\n\nInjectionTarget\n\nDetails specifying the target into which to inject the script.\n\n  * world\n\nExecutionWorld optional\n\nThe JavaScript \"world\" to run the script in. The default is `USER_SCRIPT`.\n\n  * worldId\n\nstring optional\n\nSpecifies the user script world ID to execute in. If omitted, the script will\nexecute in the default user script world. Only valid if `world` is omitted or\nis `USER_SCRIPT`. Values with leading underscores (`_`) are reserved.\n\n### WorldProperties\n\n#### Properties\n\n  * csp\n\nstring optional\n\nSpecifies the world csp. The default is the ``ISOLATED`` world csp.\n\n  * messaging\n\nboolean optional\n\nSpecifies whether messaging APIs are exposed. The default is `false`.\n\n  * worldId\n\nstring optional\n\nChrome 133+\n\nSpecifies the ID of the specific user script world to update. If not provided,\nupdates the properties of the default user script world. Values with leading\nunderscores (`_`) are reserved.\n\n## Methods\n\n### configureWorld()\n\nPromise\n\n    \n    \n    chrome.userScripts.configureWorld(  \n      properties: WorldProperties,  \n      callback?: function,  \n    )\n\nConfigures the ``USER_SCRIPT`` execution environment.\n\n#### Parameters\n\n  * properties\n\nWorldProperties\n\nContains the user script world configuration.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### execute()\n\nPromise Chrome 135+\n\n    \n    \n    chrome.userScripts.execute(  \n      injection: UserScriptInjection,  \n      callback?: function,  \n    )\n\nInjects a script into a target context. By default, the script will be run at\n`document_idle`, or immediately if the page has already loaded. If the\n`injectImmediately` property is set, the script will inject without waiting,\neven if the page has not finished loading. If the script evaluates to a\npromise, the browser will wait for the promise to settle and return the\nresulting value.\n\n#### Parameters\n\n  * injection\n\nUserScriptInjection\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: InjectionResult[]) => void\n\n    * result\n\nInjectionResult[]\n\n#### Returns\n\n  * Promise<InjectionResult[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getScripts()\n\nPromise\n\n    \n    \n    chrome.userScripts.getScripts(  \n      filter?: UserScriptFilter,  \n      callback?: function,  \n    )\n\nReturns all dynamically-registered user scripts for this extension.\n\n#### Parameters\n\n  * filter\n\nUserScriptFilter optional\n\nIf specified, this method returns only the user scripts that match it.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (scripts: RegisteredUserScript[]) => void\n\n    * scripts\n\nRegisteredUserScript[]\n\n#### Returns\n\n  * Promise<RegisteredUserScript[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getWorldConfigurations()\n\nPromise Chrome 133+\n\n    \n    \n    chrome.userScripts.getWorldConfigurations(  \n      callback?: function,  \n    )\n\nRetrieves all registered world configurations.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (worlds: WorldProperties[]) => void\n\n    * worlds\n\nWorldProperties[]\n\n#### Returns\n\n  * Promise<WorldProperties[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### register()\n\nPromise\n\n    \n    \n    chrome.userScripts.register(  \n      scripts: RegisteredUserScript[],  \n      callback?: function,  \n    )\n\nRegisters one or more user scripts for this extension.\n\n#### Parameters\n\n  * scripts\n\nRegisteredUserScript[]\n\nContains a list of user scripts to be registered.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### resetWorldConfiguration()\n\nPromise Chrome 133+\n\n    \n    \n    chrome.userScripts.resetWorldConfiguration(  \n      worldId?: string,  \n      callback?: function,  \n    )\n\nResets the configuration for a user script world. Any scripts that inject into\nthe world with the specified ID will use the default world configuration.\n\n#### Parameters\n\n  * worldId\n\nstring optional\n\nThe ID of the user script world to reset. If omitted, resets the default\nworld's configuration.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### unregister()\n\nPromise\n\n    \n    \n    chrome.userScripts.unregister(  \n      filter?: UserScriptFilter,  \n      callback?: function,  \n    )\n\nUnregisters all dynamically-registered user scripts for this extension.\n\n#### Parameters\n\n  * filter\n\nUserScriptFilter optional\n\nIf specified, this method unregisters only the user scripts that match it.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### update()\n\nPromise\n\n    \n    \n    chrome.userScripts.update(  \n      scripts: RegisteredUserScript[],  \n      callback?: function,  \n    )\n\nUpdates one or more user scripts for this extension.\n\n#### Parameters\n\n  * scripts\n\nRegisteredUserScript[]\n\nContains a list of user scripts to be updated. A property is only updated for\nthe existing script if it is specified in this object. If there are errors\nduring script parsing/file validation, or if the IDs specified do not\ncorrespond to a fully registered script, then no scripts are updated.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/vpnProvider": "#  chrome.vpnProvider\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.vpnProvider` API to implement a VPN client.\n\n## Permissions\n\n`vpnProvider`  \n\n## Availability\n\nChrome 43+  ChromeOS only\n\n## Concepts and usage\n\nTypical usage of `chrome.vpnProvider` is as follows:\n\n  * Create VPN configurations by calling `createConfig()`. A VPN configuration is a persistent entry shown to the user in a ChromeOS UI. The user can select a VPN configuration from a list and connect to it or disconnect from it.\n\n  * Add listeners to the `onPlatformMessage`, `onPacketReceived`, and `onConfigRemoved` events.\n\n  * When the user connects to the VPN configuration, `onPlatformMessage` will be received with the message `\"connected\"`. The period between the `\"connected\"` and `\"disconnected\"` messages is called a \"VPN session\". In this time period, the extension that receives the message is said to own the VPN session.\n\n  * Initiate connection to the VPN server and start the VPN client.\n\n  * Set the Parameters of the connection by calling `setParameters()`.\n\n  * Notify the connection state as `\"connected\"` by calling `notifyConnectionStateChanged()`.\n\n  * When the steps previous are completed without errors, a virtual tunnel is created to the network stack of ChromeOS. IP packets can be sent through the tunnel by calling `sendPacket()` and any packets originating on the ChromeOS device will be received using the `onPacketReceived` event handler.\n\n  * When the user disconnects from the VPN configuration, `onPlatformMessage` will be fired with the message `\"disconnected\"`.\n\n  * If the VPN configuration is no longer necessary, it can be destroyed by calling `destroyConfig()`.\n\n## Types\n\n### Parameters\n\n#### Properties\n\n  * address\n\nstring\n\nIP address for the VPN interface in CIDR notation. IPv4 is currently the only\nsupported mode.\n\n  * broadcastAddress\n\nstring optional\n\nBroadcast address for the VPN interface. (default: deduced from IP address and\nmask)\n\n  * dnsServers\n\nstring[]\n\nA list of IPs for the DNS servers.\n\n  * domainSearch\n\nstring[] optional\n\nA list of search domains. (default: no search domain)\n\n  * exclusionList\n\nstring[]\n\nExclude network traffic to the list of IP blocks in CIDR notation from the\ntunnel. This can be used to bypass traffic to and from the VPN server. When\nmany rules match a destination, the rule with the longest matching prefix\nwins. Entries that correspond to the same CIDR block are treated as\nduplicates. Such duplicates in the collated (exclusionList + inclusionList)\nlist are eliminated and the exact duplicate entry that will be eliminated is\nundefined.\n\n  * inclusionList\n\nstring[]\n\nInclude network traffic to the list of IP blocks in CIDR notation to the\ntunnel. This parameter can be used to set up a split tunnel. By default no\ntraffic is directed to the tunnel. Adding the entry \"0.0.0.0/0\" to this list\ngets all the user traffic redirected to the tunnel. When many rules match a\ndestination, the rule with the longest matching prefix wins. Entries that\ncorrespond to the same CIDR block are treated as duplicates. Such duplicates\nin the collated (exclusionList + inclusionList) list are eliminated and the\nexact duplicate entry that will be eliminated is undefined.\n\n  * mtu\n\nstring optional\n\nMTU setting for the VPN interface. (default: 1500 bytes)\n\n  * reconnect\n\nstring optional\n\nChrome 51+\n\nWhether or not the VPN extension implements auto-reconnection.\n\nIf true, the `linkDown`, `linkUp`, `linkChanged`, `suspend`, and `resume`\nplatform messages will be used to signal the respective events. If false, the\nsystem will forcibly disconnect the VPN if the network topology changes, and\nthe user will need to reconnect manually. (default: false)\n\nThis property is new in Chrome 51; it will generate an exception in earlier\nversions. try/catch can be used to conditionally enable the feature based on\nbrowser support.\n\n### PlatformMessage\n\nThe enum is used by the platform to notify the client of the VPN session\nstatus.\n\n#### Enum\n\n\"connected\"  \nIndicates that the VPN configuration connected.\n\n\"disconnected\"  \nIndicates that the VPN configuration disconnected.\n\n\"error\"  \nIndicates that an error occurred in VPN connection, for example a timeout. A\ndescription of the error is given as the error argument to onPlatformMessage.\n\n\"linkDown\"  \nIndicates that the default physical network connection is down.\n\n\"linkUp\"  \nIndicates that the default physical network connection is back up.\n\n\"linkChanged\"  \nIndicates that the default physical network connection changed, e.g.\nwifi->mobile.\n\n\"suspend\"  \nIndicates that the OS is preparing to suspend, so the VPN should drop its\nconnection. The extension is not guaranteed to receive this event prior to\nsuspending.\n\n\"resume\"  \nIndicates that the OS has resumed and the user has logged back in, so the VPN\nshould try to reconnect.\n\n### UIEvent\n\nThe enum is used by the platform to indicate the event that triggered\n`onUIEvent`.\n\n#### Enum\n\n\"showAddDialog\"  \nRequests that the VPN client show the add configuration dialog box to the\nuser.\n\n\"showConfigureDialog\"  \nRequests that the VPN client show the configuration settings dialog box to the\nuser.\n\n### VpnConnectionState\n\nThe enum is used by the VPN client to inform the platform of its current\nstate. This helps provide meaningful messages to the user.\n\n#### Enum\n\n\"connected\"  \nSpecifies that VPN connection was successful.\n\n\"failure\"  \nSpecifies that VPN connection has failed.\n\n## Methods\n\n### createConfig()\n\nPromise\n\n    \n    \n    chrome.vpnProvider.createConfig(  \n      name: string,  \n      callback?: function,  \n    )\n\nCreates a new VPN configuration that persists across multiple login sessions\nof the user.\n\n#### Parameters\n\n  * name\n\nstring\n\nThe name of the VPN configuration.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (id: string) => void\n\n    * id\n\nstring\n\nA unique ID for the created configuration, or `undefined` on failure.\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### destroyConfig()\n\nPromise\n\n    \n    \n    chrome.vpnProvider.destroyConfig(  \n      id: string,  \n      callback?: function,  \n    )\n\nDestroys a VPN configuration created by the extension.\n\n#### Parameters\n\n  * id\n\nstring\n\nID of the VPN configuration to destroy.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### notifyConnectionStateChanged()\n\nPromise\n\n    \n    \n    chrome.vpnProvider.notifyConnectionStateChanged(  \n      state: VpnConnectionState,  \n      callback?: function,  \n    )\n\nNotifies the VPN session state to the platform. This will succeed only when\nthe VPN session is owned by the extension.\n\n#### Parameters\n\n  * state\n\nVpnConnectionState\n\nThe VPN session state of the VPN client.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### sendPacket()\n\nPromise\n\n    \n    \n    chrome.vpnProvider.sendPacket(  \n      data: ArrayBuffer,  \n      callback?: function,  \n    )\n\nSends an IP packet through the tunnel created for the VPN session. This will\nsucceed only when the VPN session is owned by the extension.\n\n#### Parameters\n\n  * data\n\nArrayBuffer\n\nThe IP packet to be sent to the platform.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setParameters()\n\nPromise\n\n    \n    \n    chrome.vpnProvider.setParameters(  \n      parameters: Parameters,  \n      callback?: function,  \n    )\n\nSets the parameters for the VPN session. This should be called immediately\nafter `\"connected\"` is received from the platform. This will succeed only when\nthe VPN session is owned by the extension.\n\n#### Parameters\n\n  * parameters\n\nParameters\n\nThe parameters for the VPN session.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onConfigCreated\n\n    \n    \n    chrome.vpnProvider.onConfigCreated.addListener(  \n      callback: function,  \n    )\n\nTriggered when a configuration is created by the platform for the extension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, name: string, data: object) => void\n\n    * id\n\nstring\n\n    * name\n\nstring\n\n    * data\n\nobject\n\n### onConfigRemoved\n\n    \n    \n    chrome.vpnProvider.onConfigRemoved.addListener(  \n      callback: function,  \n    )\n\nTriggered when a configuration created by the extension is removed by the\nplatform.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string) => void\n\n    * id\n\nstring\n\n### onPacketReceived\n\n    \n    \n    chrome.vpnProvider.onPacketReceived.addListener(  \n      callback: function,  \n    )\n\nTriggered when an IP packet is received via the tunnel for the VPN session\nowned by the extension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (data: ArrayBuffer) => void\n\n    * data\n\nArrayBuffer\n\n### onPlatformMessage\n\n    \n    \n    chrome.vpnProvider.onPlatformMessage.addListener(  \n      callback: function,  \n    )\n\nTriggered when a message is received from the platform for a VPN configuration\nowned by the extension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, message: PlatformMessage, error: string) => void\n\n    * id\n\nstring\n\n    * message\n\nPlatformMessage\n\n    * error\n\nstring\n\n### onUIEvent\n\n    \n    \n    chrome.vpnProvider.onUIEvent.addListener(  \n      callback: function,  \n    )\n\nTriggered when there is a UI event for the extension. UI events are signals\nfrom the platform that indicate to the app that a UI dialog needs to be shown\nto the user.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (event: UIEvent, id?: string) => void\n\n    * event\n\nUIEvent\n\n    * id\n\nstring optional\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/wallpaper": "#  chrome.wallpaper\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.wallpaper` API to change the ChromeOS wallpaper.\n\n## Permissions\n\n`wallpaper`  \n\nYou must declare the \"wallpaper\" permission in the app's manifest to use the\nwallpaper API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"wallpaper\"\n      ],\n      ...\n    }\n    \n\n## Availability\n\nChrome 43+  ChromeOS only\n\n## Examples\n\nFor example, to set the wallpaper as the image at\n`https://example.com/a_file.png`, you can call `chrome.wallpaper.setWallpaper`\nthis way:\n\n    \n    \n    chrome.wallpaper.setWallpaper(\n      {\n        'url': 'https://example.com/a_file.jpg',\n        'layout': 'CENTER_CROPPED',\n        'filename': 'test_wallpaper'\n      },\n      function() {}\n    );\n    \n\n## Types\n\n### WallpaperLayout\n\nChrome 44+\n\nThe supported wallpaper layouts.\n\n#### Enum\n\n\"STRETCH\"  \n\n\"CENTER\"  \n\n\"CENTER_CROPPED\"  \n\n## Methods\n\n### setWallpaper()\n\nPromise\n\n    \n    \n    chrome.wallpaper.setWallpaper(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets wallpaper to the image at _url_ or _wallpaperData_ with the specified\n_layout_\n\n#### Parameters\n\n  * details\n\nobject\n\n    * data\n\nArrayBuffer optional\n\nThe jpeg or png encoded wallpaper image as an ArrayBuffer.\n\n    * filename\n\nstring\n\nThe file name of the saved wallpaper.\n\n    * layout\n\nWallpaperLayout\n\nThe supported wallpaper layouts.\n\n    * thumbnail\n\nboolean optional\n\nTrue if a 128x60 thumbnail should be generated. Layout and ratio are not\nsupported yet.\n\n    * url\n\nstring optional\n\nThe URL of the wallpaper to be set (can be relative).\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (thumbnail?: ArrayBuffer) => void\n\n    * thumbnail\n\nArrayBuffer optional\n\nThe jpeg encoded wallpaper thumbnail. It is generated by resizing the\nwallpaper to 128x60.\n\n#### Returns\n\n  * Promise<ArrayBuffer | undefined>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/webAuthenticationProxy": "#  chrome.webAuthenticationProxy\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.webAuthenticationProxy` API lets remote desktop software running\non a remote host intercept Web Authentication API (WebAuthn) requests in order\nto handle them on a local client.\n\n## Permissions\n\n`webAuthenticationProxy`  \n\n## Availability\n\nChrome 115+ MV3+\n\n## Types\n\n### CreateRequest\n\n#### Properties\n\n  * requestDetailsJson\n\nstring\n\nThe `PublicKeyCredentialCreationOptions` passed to\n`navigator.credentials.create()`, serialized as a JSON string. The\nserialization format is compatible with\n`PublicKeyCredential.parseCreationOptionsFromJSON()`.\n\n  * requestId\n\nnumber\n\nAn opaque identifier for the request.\n\n### CreateResponseDetails\n\n#### Properties\n\n  * error\n\nDOMExceptionDetails optional\n\nThe `DOMException` yielded by the remote request, if any.\n\n  * requestId\n\nnumber\n\nThe `requestId` of the `CreateRequest`.\n\n  * responseJson\n\nstring optional\n\nThe `PublicKeyCredential`, yielded by the remote request, if any, serialized\nas a JSON string by calling href=\"https://w3c.github.io/webauthn/#dom-\npublickeycredential-tojson\"> `PublicKeyCredential.toJSON()`.\n\n### DOMExceptionDetails\n\n#### Properties\n\n  * message\n\nstring\n\n  * name\n\nstring\n\n### GetRequest\n\n#### Properties\n\n  * requestDetailsJson\n\nstring\n\nThe `PublicKeyCredentialRequestOptions` passed to\n`navigator.credentials.get()`, serialized as a JSON string. The serialization\nformat is compatible with `PublicKeyCredential.parseRequestOptionsFromJSON()`.\n\n  * requestId\n\nnumber\n\nAn opaque identifier for the request.\n\n### GetResponseDetails\n\n#### Properties\n\n  * error\n\nDOMExceptionDetails optional\n\nThe `DOMException` yielded by the remote request, if any.\n\n  * requestId\n\nnumber\n\nThe `requestId` of the `CreateRequest`.\n\n  * responseJson\n\nstring optional\n\nThe `PublicKeyCredential`, yielded by the remote request, if any, serialized\nas a JSON string by calling href=\"https://w3c.github.io/webauthn/#dom-\npublickeycredential-tojson\"> `PublicKeyCredential.toJSON()`.\n\n### IsUvpaaRequest\n\n#### Properties\n\n  * requestId\n\nnumber\n\nAn opaque identifier for the request.\n\n### IsUvpaaResponseDetails\n\n#### Properties\n\n  * isUvpaa\n\nboolean\n\n  * requestId\n\nnumber\n\n## Methods\n\n### attach()\n\nPromise\n\n    \n    \n    chrome.webAuthenticationProxy.attach(  \n      callback?: function,  \n    )\n\nMakes this extension the active Web Authentication API request proxy.\n\nRemote desktop extensions typically call this method after detecting\nattachment of a remote session to this host. Once this method returns without\nerror, regular processing of WebAuthn requests is suspended, and events from\nthis extension API are raised.\n\nThis method fails with an error if a different extension is already attached.\n\nThe attached extension must call `detach()` once the remote desktop session\nhas ended in order to resume regular WebAuthn request processing. Extensions\nautomatically become detached if they are unloaded.\n\nRefer to the `onRemoteSessionStateChange` event for signaling a change of\nremote session attachment from a native application to to the (possibly\nsuspended) extension.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (error?: string) => void\n\n    * error\n\nstring optional\n\n#### Returns\n\n  * Promise<string | undefined>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### completeCreateRequest()\n\nPromise\n\n    \n    \n    chrome.webAuthenticationProxy.completeCreateRequest(  \n      details: CreateResponseDetails,  \n      callback?: function,  \n    )\n\nReports the result of a `navigator.credentials.create()` call. The extension\nmust call this for every `onCreateRequest` event it has received, unless the\nrequest was canceled (in which case, an `onRequestCanceled` event is fired).\n\n#### Parameters\n\n  * details\n\nCreateResponseDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### completeGetRequest()\n\nPromise\n\n    \n    \n    chrome.webAuthenticationProxy.completeGetRequest(  \n      details: GetResponseDetails,  \n      callback?: function,  \n    )\n\nReports the result of a `navigator.credentials.get()` call. The extension must\ncall this for every `onGetRequest` event it has received, unless the request\nwas canceled (in which case, an `onRequestCanceled` event is fired).\n\n#### Parameters\n\n  * details\n\nGetResponseDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### completeIsUvpaaRequest()\n\nPromise\n\n    \n    \n    chrome.webAuthenticationProxy.completeIsUvpaaRequest(  \n      details: IsUvpaaResponseDetails,  \n      callback?: function,  \n    )\n\nReports the result of a\n`PublicKeyCredential.isUserVerifyingPlatformAuthenticator()` call. The\nextension must call this for every `onIsUvpaaRequest` event it has received.\n\n#### Parameters\n\n  * details\n\nIsUvpaaResponseDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### detach()\n\nPromise\n\n    \n    \n    chrome.webAuthenticationProxy.detach(  \n      callback?: function,  \n    )\n\nRemoves this extension from being the active Web Authentication API request\nproxy.\n\nThis method is typically called when the extension detects that a remote\ndesktop session was terminated. Once this method returns, the extension ceases\nto be the active Web Authentication API request proxy.\n\nRefer to the `onRemoteSessionStateChange` event for signaling a change of\nremote session attachment from a native application to to the (possibly\nsuspended) extension.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (error?: string) => void\n\n    * error\n\nstring optional\n\n#### Returns\n\n  * Promise<string | undefined>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onCreateRequest\n\n    \n    \n    chrome.webAuthenticationProxy.onCreateRequest.addListener(  \n      callback: function,  \n    )\n\nFires when a WebAuthn `navigator.credentials.create()` call occurs. The\nextension must supply a response by calling `completeCreateRequest()` with the\n`requestId` from `requestInfo`.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestInfo: CreateRequest) => void\n\n    * requestInfo\n\nCreateRequest\n\n### onGetRequest\n\n    \n    \n    chrome.webAuthenticationProxy.onGetRequest.addListener(  \n      callback: function,  \n    )\n\nFires when a WebAuthn navigator.credentials.get() call occurs. The extension\nmust supply a response by calling `completeGetRequest()` with the `requestId`\nfrom `requestInfo`\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestInfo: GetRequest) => void\n\n    * requestInfo\n\nGetRequest\n\n### onIsUvpaaRequest\n\n    \n    \n    chrome.webAuthenticationProxy.onIsUvpaaRequest.addListener(  \n      callback: function,  \n    )\n\nFires when a\n`PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()` call\noccurs. The extension must supply a response by calling\n`completeIsUvpaaRequest()` with the `requestId` from `requestInfo`\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestInfo: IsUvpaaRequest) => void\n\n    * requestInfo\n\nIsUvpaaRequest\n\n### onRemoteSessionStateChange\n\n    \n    \n    chrome.webAuthenticationProxy.onRemoteSessionStateChange.addListener(  \n      callback: function,  \n    )\n\nA native application associated with this extension can cause this event to be\nfired by writing to a file with a name equal to the extension's ID in a\ndirectory named `WebAuthenticationProxyRemoteSessionStateChange` inside the\ndefault user data directory\n\nThe contents of the file should be empty. I.e., it is not necessary to change\nthe contents of the file in order to trigger this event.\n\nThe native host application may use this event mechanism to signal a possible\nremote session state change (i.e. from detached to attached, or vice versa)\nwhile the extension service worker is possibly suspended. In the handler for\nthis event, the extension can call the `attach()` or `detach()` API methods\naccordingly.\n\nThe event listener must be registered synchronously at load time.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onRequestCanceled\n\n    \n    \n    chrome.webAuthenticationProxy.onRequestCanceled.addListener(  \n      callback: function,  \n    )\n\nFires when a `onCreateRequest` or `onGetRequest` event is canceled (because\nthe WebAuthn request was aborted by the caller, or because it timed out). When\nreceiving this event, the extension should cancel processing of the\ncorresponding request on the client side. Extensions cannot complete a request\nonce it has been canceled.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestId: number) => void\n\n    * requestId\n\nnumber\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/webNavigation": "#  chrome.webNavigation\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.webNavigation` API to receive notifications about the status\nof navigation requests in-flight.\n\n## Permissions\n\n`webNavigation`  \n\nAll `chrome.webNavigation` methods and events require you to declare the\n`\"webNavigation\"` permission in the extension manifest. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"webNavigation\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\n### Event order\n\nFor a navigation that is successfully completed, events are fired in the\nfollowing order:\n\n    \n    \n    onBeforeNavigate -> onCommitted -> [onDOMContentLoaded] -> onCompleted\n    \n\nAny error that occurs during the process results in an `onErrorOccurred`\nevent. For a specific navigation, there are no further events fired after\n`onErrorOccurred`.\n\nIf a navigating frame contains subframes, its `onCommitted` is fired before\nany of its children's `onBeforeNavigate`; while `onCompleted` is fired after\nall of its children's `onCompleted`.\n\nIf the reference fragment of a frame is changed, a\n`onReferenceFragmentUpdated` event is fired. This event can fire any time\nafter `onDOMContentLoaded`, even after `onCompleted`.\n\nIf the history API is used to modify the state of a frame (e.g. using\n`history.pushState()`, a `onHistoryStateUpdated` event is fired. This event\ncan fire any time after `onDOMContentLoaded`.\n\nIf a navigation restored a page from the Back Forward Cache, the\n`onDOMContentLoaded` event won't fire. The event is not fired because the\ncontent has already completed load when the page was first visited.\n\nIf a navigation was triggered using Chrome Instant or Instant Pages, a\ncompletely loaded page is swapped into the current tab. In that case, an\n`onTabReplaced` event is fired.\n\n### Relation to webRequest events\n\nThere is no defined ordering between events of the webRequest API and the\nevents of the webNavigation API. It is possible that webRequest events are\nstill received for frames that already started a new navigation, or that a\nnavigation only proceeds after the network resources are already fully loaded.\n\nIn general, the webNavigation events are closely related to the navigation\nstate that is displayed in the UI, while the webRequest events correspond to\nthe state of the network stack which is generally opaque to the user.\n\n### Tab IDs\n\nNot all navigating tabs correspond to actual tabs in Chrome's UI, for example,\na tab that is being pre-rendered. Such tabs are not accessible using the tabs\nAPI nor can you request information about them by calling\n`webNavigation.getFrame()` or `webNavigation.getAllFrames()`. Once such a tab\nis swapped in, an `onTabReplaced` event is fired and they become accessible\nthrough these APIs.\n\n### Timestamps\n\nIt's important to note that some technical oddities in the OS's handling of\ndistinct Chrome processes can cause the clock to be skewed between the browser\nitself and extension processes. That means that the `timeStamp` property of\nthe `WebNavigation` event `timeStamp` property is only guaranteed to be\n_internally_ consistent. Comparing one event to another event will give you\nthe correct offset between them, but comparing them to the current time inside\nthe extension (using `(new Date()).getTime()`, for instance) might give\nunexpected results.\n\n### Frame IDs\n\nFrames within a tab can be identified by a frame ID. The frame ID of the main\nframe is always 0, the ID of child frames is a positive number. Once a\ndocument is constructed in a frame, its frame ID remains constant during the\nlifetime of the document. As of Chrome 49, this ID is also constant for the\nlifetime of the frame (across multiple navigations).\n\nDue to the multi-process nature of Chrome, a tab might use different processes\nto render the source and destination of a web page. Therefore, if a navigation\ntakes place in a new process, you might receive events both from the new and\nthe old page until the new navigation is committed (i.e. the `onCommitted`\nevent is sent for the new main frame). In other words, it is possible to have\nmore than one pending sequence of webNavigation events with the same\n`frameId`. The sequences can be distinguished by the `processId` key.\n\nAlso note that during a provisional load the process might be switched several\ntimes. This happens when the load is redirected to a different site. In this\ncase, you will receive repeated `onBeforeNavigate` and `onErrorOccurred`\nevents, until you receive the final `onCommitted` event.\n\nAnother concept that is problematic with extensions is the lifecycle of the\nframe. A frame hosts a document (which is associated with a committed URL).\nThe document can change (say by navigating) but the _frameId_ won't, and so it\nis difficult to associate that something happened in a specific document with\njust _frameIds_. We are introducing a concept of a documentId which is a\nunique identifier per document. If a frame is navigated and opens a new\ndocument the identifier will change. This field is useful for determining when\npages change their lifecycle state (between prerender/active/cached) because\nit remains the same.\n\n### Transition types and qualifiers\n\nThe `webNavigation` `onCommitted` event has a `transitionType` and a\n`transitionQualifiers` property. The _transition type_ is the same as used in\nthe history API describing how the browser navigated to this particular URL.\nIn addition, several _transition qualifiers_ can be returned that further\ndefine the navigation.\n\nThe following transition qualifiers exist:\n\nTransition qualifier| Description  \n---|---  \n\"client_redirect\"| One or more redirects caused by JavaScript or meta refresh\ntags on the page happened during the navigation.  \n\"server_redirect\"| One or more redirects caused by HTTP headers sent from the\nserver happened during the navigation.  \n\"forward_back\"| The user used the Forward or Back button to initiate the\nnavigation.  \n\"from_address_bar\"| The user initiated the navigation from the address bar\n(aka Omnibox).  \n  \n## Examples\n\nTo try this API, install the webNavigation API example from the chrome-\nextension-samples repository.\n\n## Types\n\n### TransitionQualifier\n\nChrome 44+\n\n#### Enum\n\n\"client_redirect\"  \n\n\"server_redirect\"  \n\n\"forward_back\"  \n\n\"from_address_bar\"  \n\n### TransitionType\n\nChrome 44+\n\nCause of the navigation. The same transition types as defined in the history\nAPI are used. These are the same transition types as defined in the history\nAPI except with `\"start_page\"` in place of `\"auto_toplevel\"` (for backwards\ncompatibility).\n\n#### Enum\n\n\"link\"  \n\n\"typed\"  \n\n\"auto_bookmark\"  \n\n\"auto_subframe\"  \n\n\"manual_subframe\"  \n\n\"generated\"  \n\n\"start_page\"  \n\n\"form_submit\"  \n\n\"reload\"  \n\n\"keyword\"  \n\n\"keyword_generated\"  \n\n## Methods\n\n### getAllFrames()\n\nPromise\n\n    \n    \n    chrome.webNavigation.getAllFrames(  \n      details: object,  \n      callback?: function,  \n    )\n\nRetrieves information about all frames of a given tab.\n\n#### Parameters\n\n  * details\n\nobject\n\nInformation about the tab to retrieve all frames from.\n\n    * tabId\n\nnumber\n\nThe ID of the tab.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details?: object[]) => void\n\n    * details\n\nobject[] optional\n\nA list of frames in the given tab, null if the specified tab ID is invalid.\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nDocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * errorOccurred\n\nboolean\n\nTrue if the last navigation in this frame was interrupted by an error, i.e.\nthe onErrorOccurred event fired.\n\n      * frameId\n\nnumber\n\nThe ID of the frame. 0 indicates that this is the main frame; a positive value\nindicates the ID of a subframe.\n\n      * frameType\n\nFrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nThe ID of the process that runs the renderer for this frame.\n\n      * url\n\nstring\n\nThe URL currently associated with this frame.\n\n#### Returns\n\n  * Promise<object[] | undefined>\n\nChrome 93+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getFrame()\n\nPromise\n\n    \n    \n    chrome.webNavigation.getFrame(  \n      details: object,  \n      callback?: function,  \n    )\n\nRetrieves information about the given frame. A frame refers to an <iframe> or\na <frame> of a web page and is identified by a tab ID and a frame ID.\n\n#### Parameters\n\n  * details\n\nobject\n\nInformation about the frame to retrieve information about.\n\n    * documentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the document. If the frameId and/or tabId are provided they will\nbe validated to match the document found by provided document ID.\n\n    * frameId\n\nnumber optional\n\nThe ID of the frame in the given tab.\n\n    * processId\n\nnumber optional\n\nDeprecated since Chrome 49\n\nFrames are now uniquely identified by their tab ID and frame ID; the process\nID is no longer needed and therefore ignored.\n\nThe ID of the process that runs the renderer for this tab.\n\n    * tabId\n\nnumber optional\n\nThe ID of the tab in which the frame is.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details?: object) => void\n\n    * details\n\nobject optional\n\nInformation about the requested frame, null if the specified frame ID and/or\ntab ID are invalid.\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nDocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * errorOccurred\n\nboolean\n\nTrue if the last navigation in this frame was interrupted by an error, i.e.\nthe onErrorOccurred event fired.\n\n      * frameType\n\nFrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * url\n\nstring\n\nThe URL currently associated with this frame, if the frame identified by the\nframeId existed at one point in the given tab. The fact that an URL is\nassociated with a given frameId does not imply that the corresponding frame\nstill exists.\n\n#### Returns\n\n  * Promise<object | undefined>\n\nChrome 93+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onBeforeNavigate\n\n    \n    \n    chrome.webNavigation.onBeforeNavigate.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when a navigation is about to occur.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\n0 indicates the navigation happens in the tab content window; a positive value\nindicates navigation in a subframe. Frame IDs are unique for a given tab and\nprocess.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nDeprecated since Chrome 50\n\nThe processId is no longer set for this event, since the process which will\nrender the resulting document is not known until onCommit.\n\nThe value of -1.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the navigation is about to occur.\n\n      * timeStamp\n\nnumber\n\nThe time when the browser was about to start the navigation, in milliseconds\nsince the epoch.\n\n      * url\n\nstring\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onCommitted\n\n    \n    \n    chrome.webNavigation.onCommitted.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when a navigation is committed. The document (and the resources it\nrefers to, such as images and subframes) might still be downloading, but at\nleast part of the document has been received from the server and the browser\nhas decided to switch to the new document.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\n0 indicates the navigation happens in the tab content window; a positive value\nindicates navigation in a subframe. Frame IDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nChrome 74+\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nThe ID of the process that runs the renderer for this frame.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the navigation occurs.\n\n      * timeStamp\n\nnumber\n\nThe time when the navigation was committed, in milliseconds since the epoch.\n\n      * transitionQualifiers\n\nTransitionQualifier[]\n\nA list of transition qualifiers.\n\n      * transitionType\n\nTransitionType\n\nCause of the navigation.\n\n      * url\n\nstring\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onCompleted\n\n    \n    \n    chrome.webNavigation.onCompleted.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when a document, including the resources it refers to, is completely\nloaded and initialized.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\n0 indicates the navigation happens in the tab content window; a positive value\nindicates navigation in a subframe. Frame IDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nChrome 74+\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nThe ID of the process that runs the renderer for this frame.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the navigation occurs.\n\n      * timeStamp\n\nnumber\n\nThe time when the document finished loading, in milliseconds since the epoch.\n\n      * url\n\nstring\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onCreatedNavigationTarget\n\n    \n    \n    chrome.webNavigation.onCreatedNavigationTarget.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when a new window, or a new tab in an existing window, is created to\nhost a navigation.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * sourceFrameId\n\nnumber\n\nThe ID of the frame with sourceTabId in which the navigation is triggered. 0\nindicates the main frame.\n\n      * sourceProcessId\n\nnumber\n\nThe ID of the process that runs the renderer for the source frame.\n\n      * sourceTabId\n\nnumber\n\nThe ID of the tab in which the navigation is triggered.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the url is opened\n\n      * timeStamp\n\nnumber\n\nThe time when the browser was about to create a new view, in milliseconds\nsince the epoch.\n\n      * url\n\nstring\n\nThe URL to be opened in the new window.\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onDOMContentLoaded\n\n    \n    \n    chrome.webNavigation.onDOMContentLoaded.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when the page's DOM is fully constructed, but the referenced resources\nmay not finish loading.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\n0 indicates the navigation happens in the tab content window; a positive value\nindicates navigation in a subframe. Frame IDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nChrome 74+\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nThe ID of the process that runs the renderer for this frame.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the navigation occurs.\n\n      * timeStamp\n\nnumber\n\nThe time when the page's DOM was fully constructed, in milliseconds since the\nepoch.\n\n      * url\n\nstring\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onErrorOccurred\n\n    \n    \n    chrome.webNavigation.onErrorOccurred.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when an error occurs and the navigation is aborted. This can happen if\neither a network error occurred, or the user aborted the navigation.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * error\n\nstring\n\nThe error description.\n\n      * frameId\n\nnumber\n\n0 indicates the navigation happens in the tab content window; a positive value\nindicates navigation in a subframe. Frame IDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nChrome 74+\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nDeprecated since Chrome 50\n\nThe processId is no longer set for this event.\n\nThe value of -1.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the navigation occurs.\n\n      * timeStamp\n\nnumber\n\nThe time when the error occurred, in milliseconds since the epoch.\n\n      * url\n\nstring\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onHistoryStateUpdated\n\n    \n    \n    chrome.webNavigation.onHistoryStateUpdated.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when the frame's history was updated to a new URL. All future events for\nthat frame will use the updated URL.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\n0 indicates the navigation happens in the tab content window; a positive value\nindicates navigation in a subframe. Frame IDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nChrome 74+\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nThe ID of the process that runs the renderer for this frame.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the navigation occurs.\n\n      * timeStamp\n\nnumber\n\nThe time when the navigation was committed, in milliseconds since the epoch.\n\n      * transitionQualifiers\n\nTransitionQualifier[]\n\nA list of transition qualifiers.\n\n      * transitionType\n\nTransitionType\n\nCause of the navigation.\n\n      * url\n\nstring\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onReferenceFragmentUpdated\n\n    \n    \n    chrome.webNavigation.onReferenceFragmentUpdated.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when the reference fragment of a frame was updated. All future events\nfor that frame will use the updated URL.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\n0 indicates the navigation happens in the tab content window; a positive value\nindicates navigation in a subframe. Frame IDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nChrome 74+\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nThe ID of the process that runs the renderer for this frame.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the navigation occurs.\n\n      * timeStamp\n\nnumber\n\nThe time when the navigation was committed, in milliseconds since the epoch.\n\n      * transitionQualifiers\n\nTransitionQualifier[]\n\nA list of transition qualifiers.\n\n      * transitionType\n\nTransitionType\n\nCause of the navigation.\n\n      * url\n\nstring\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onTabReplaced\n\n    \n    \n    chrome.webNavigation.onTabReplaced.addListener(  \n      callback: function,  \n    )\n\nFired when the contents of the tab is replaced by a different (usually\npreviously pre-rendered) tab.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * replacedTabId\n\nnumber\n\nThe ID of the tab that was replaced.\n\n      * tabId\n\nnumber\n\nThe ID of the tab that replaced the old tab.\n\n      * timeStamp\n\nnumber\n\nThe time when the replacement happened, in milliseconds since the epoch.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/webRequest": "#  chrome.webRequest\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Note:** As of Manifest V3, the `\"webRequestBlocking\"` permission is no\nlonger available for most extensions. Consider `\"declarativeNetRequest\"`,\nwhich enables use the declarativeNetRequest API. Aside from\n`\"webRequestBlocking\"`, the webRequest API is unchanged and available for\nnormal use. Policy installed extensions can continue to use\n`\"webRequestBlocking\"`.\n\n## Description\n\nUse the `chrome.webRequest` API to observe and analyze traffic and to\nintercept, block, or modify requests in-flight.\n\n## Permissions\n\n`webRequest`  \n\nYou must declare the `\"webRequest\"` permission in the extension manifest to\nuse the web request API, along with the necessary host permissions. To\nintercept a sub-resource request, the extension must have access to both the\nrequested URL and its initiator. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"webRequest\"\n      ],\n      \"host_permissions\": [\n        \"*://*.google.com/*\"\n      ],\n      ...\n    }\n    \n\n`webRequestBlocking`\n\nRequired to register blocking event handlers. As of Manifest V3, this is only\navailable to policy installed extensions.\n\n`webRequestAuthProvider`\n\nRequired to use the `onAuthRequired` method. See Handling authentication.\n\n## Concepts and usage\n\n### Life cycle of requests\n\nThe web request API defines a set of events that follow the life cycle of a\nweb request. You can use these events to observe and analyze traffic. Certain\nsynchronous events will allow you to intercept, block, or modify a request.\n\nThe event life cycle for successful requests is illustrated here, followed by\nevent definitions:\n\n![Life cycle of a web request from the perspective of the webrequest\nAPI](/static/docs/extensions/reference/api/webRequest/images/webrequestapi.png)\n\n`onBeforeRequest` (optionally synchronous)\n\n    Fires when a request is about to occur. This event is sent before any TCP connection is made and can be used to cancel or redirect requests.\n`onBeforeSendHeaders` (optionally synchronous)\n\n    Fires when a request is about to occur and the initial headers have been prepared. The event is intended to allow extensions to add, modify, and delete request headers (*). The `onBeforeSendHeaders` event is passed to all subscribers, so different subscribers may attempt to modify the request; see the Implementation details section for how this is handled. This event can be used to cancel the request.\n`onSendHeaders`\n\n    Fires after all extensions have had a chance to modify the request headers, and presents the final (*) version. The event is triggered before the headers are sent to the network. This event is informational and handled asynchronously. It does not allow modifying or cancelling the request.\n`onHeadersReceived` (optionally synchronous)\n\n    Fires each time that an HTTP(S) response header is received. Due to redirects and authentication requests this can happen multiple times per request. This event is intended to allow extensions to add, modify, and delete response headers, such as incoming Content-Type headers. The caching directives are processed before this event is triggered, so modifying headers such as Cache-Control has no influence on the browser's cache. It also allows you to cancel or redirect the request.\n`onAuthRequired` (optionally synchronous)\n\n    Fires when a request requires authentication of the user. This event can be handled synchronously to provide authentication credentials. Note that extensions may provide invalid credentials. Take care not to enter an infinite loop by repeatedly providing invalid credentials. This can also be used to cancel the request.\n`onBeforeRedirect`\n\n    Fires when a redirect is about to be executed. A redirection can be triggered by an HTTP response code or by an extension. This event is informational and handled asynchronously. It does not allow you to modify or cancel the request.\n`onResponseStarted`\n\n    Fires when the first byte of the response body is received. For HTTP requests, this means that the status line and response headers are available. This event is informational and handled asynchronously. It does not allow modifying or canceling the request.\n`onCompleted`\n\n    Fires when a request has been processed successfully.\n`onErrorOccurred`\n\n    Fires when a request could not be processed successfully.\n\nThe web request API guarantees that for each request, either `onCompleted` or\n`onErrorOccurred` is fired as the final event with one exception: If a request\nis redirected to a `data://` URL, `onBeforeRedirect` is the last reported\nevent.\n\n* Note that the web request API presents an abstraction of the network stack to the extension. Internally, one URL request can be split into several HTTP requests (for example, to fetch individual byte ranges from a large file) or can be handled by the network stack without communicating with the network. For this reason, the API does not provide the final HTTP headers that are sent to the network. For example, all headers that are related to caching are invisible to the extension.\n\nThe following headers are currently **not provided** to the\n`onBeforeSendHeaders` event. This list is not guaranteed to be complete or\nstable.\n\n  * Authorization\n  * Cache-Control\n  * Connection\n  * Content-Length\n  * Host\n  * If-Modified-Since\n  * If-None-Match\n  * If-Range\n  * Partial-Data\n  * Pragma\n  * Proxy-Authorization\n  * Proxy-Connection\n  * Transfer-Encoding\n\nStarting from Chrome 79, request header modifications affect Cross-Origin\nResource Sharing (CORS) checks. If modified headers for cross-origin requests\ndo not meet the criteria, it will result in sending a CORS preflight to ask\nthe server if such headers can be accepted. If you really need to modify\nheaders in a way to violate the CORS protocol, you need to specify\n`'extraHeaders'` in `opt_extraInfoSpec`. On the other hand, response header\nmodifications do not work to deceive CORS checks. If you need to deceive the\nCORS protocol, you also need to specify `'extraHeaders'` for the response\nmodifications.\n\nStarting from Chrome 79, the webRequest API **does not** intercept CORS\npreflight requests and responses by default. A CORS preflight for a request\nURL is visible to an extension if there is a listener with `'extraHeaders'`\nspecified in `opt_extraInfoSpec` for the request URL. `onBeforeRequest` can\nalso take `'extraHeaders'` from Chrome 79.\n\nStarting from Chrome 79, the following request header is **not provided** and\ncannot be modified or removed without specifying `'extraHeaders'` in\n`opt_extraInfoSpec`:\n\n  * Origin\n\n**Note:** Modifying the `Origin` request header might not work as intended and\nmay result in unexpected errors in the response's CORS checks. This is because\nwhile extensions can only modify the Origin request header, they can't change\nthe `request origin` or initiator, which is a concept defined in the Fetch\nspec to represent who initiates the request. In such a scenario, the server\nmay allow the CORS access for the modified request and put the header's\n`Origin` into the `Access-Control-Allow-Origin` header in the response. But it\nwon't match the immutable `request origin` and will result in a CORS failure.\n\nStarting from Chrome 72, if you need to modify responses before Cross Origin\nRead Blocking (CORB) can block the response, you need to specify\n`'extraHeaders'` in `opt_extraInfoSpec`.\n\nStarting from Chrome 72, the following request headers are **not provided**\nand cannot be modified or removed without specifying `'extraHeaders'` in\n`opt_extraInfoSpec`:\n\n  * Accept-Language\n  * Accept-Encoding\n  * Referer\n  * Cookie\n\nStarting from Chrome 72, the `Set-Cookie` response header is **not provided**\nand cannot be modified or removed without specifying `'extraHeaders'` in\n`opt_extraInfoSpec`.\n\nStarting from Chrome 89, the `X-Frame-Options` response header cannot be\neffectively modified or removed without specifying `'extraHeaders'` in\n`opt_extraInfoSpec`.\n\n**Note:** Specifying `'extraHeaders'` in `opt_extraInfoSpec` may have a\nnegative impact on performance, hence it should only be used when really\nnecessary.\n\nThe webRequest API only exposes requests that the extension has permission to\nsee, given its host permissions. Moreover, only the following schemes are\naccessible: `http://`, `https://`, `ftp://`, `file://`, `ws://` (since Chrome\n58), `wss://` (since Chrome 58), `urn:` (since Chrome 91), or `chrome-\nextension://`. In addition, even certain requests with URLs using one of the\nabove schemes are hidden. These include `chrome-\nextension://other_extension_id` where `other_extension_id` is not the ID of\nthe extension to handle the request, `https://www.google.com/chrome`, and\nother sensitive requests core to browser functionality. Also synchronous\nXMLHttpRequests from your extension are hidden from blocking event handlers in\norder to prevent deadlocks. Note that for some of the supported schemes the\nset of available events might be limited due to the nature of the\ncorresponding protocol. For example, for the file: scheme, only\n`onBeforeRequest`, `onResponseStarted`, `onCompleted`, and `onErrorOccurred`\nmay be dispatched.\n\nStarting from Chrome 58, the webRequest API supports intercepting the\nWebSocket handshake request. Since the handshake is done by means of an HTTP\nupgrade request, its flow fits into HTTP-oriented webRequest model. Note that\nthe API does **not intercept** :\n\n  * Individual messages sent over an established WebSocket connection.\n  * WebSocket closing connection.\n\nRedirects are **not supported** for WebSocket requests.\n\nStarting from Chrome 72, an extension will be able to intercept a request only\nif it has host permissions to both the requested URL and the request\ninitiator.\n\nStarting from Chrome 96, the webRequest API supports intercepting the\nWebTransport over HTTP/3 handshake request. Since the handshake is done by\nmeans of an HTTP CONNECT request, its flow fits into HTTP-oriented webRequest\nmodel. Note that:\n\n  * Once the session is established, extensions cannot observe or intervene in the session via the webRequest API.\n  * Modifying HTTP request headers in `onBeforeSendHeaders` is ignored.\n  * Redirects and authentications are **not supported** in WebTransport over HTTP/3.\n\n### Request IDs\n\nEach request is identified by a request ID. This ID is unique within a browser\nsession and the context of an extension. It remains constant during the life\ncycle of a request and can be used to match events for the same request. Note\nthat several HTTP requests are mapped to one web request in case of HTTP\nredirection or HTTP authentication.\n\n### Registering event listeners\n\nTo register an event listener for a web request, you use a variation on the\nusual `addListener()` function. In addition to specifying a callback function,\nyou have to specify a filter argument, and you may specify an optional extra\ninfo argument.\n\nThe three arguments to the web request API's `addListener()` have the\nfollowing definitions:\n\n    \n    \n    var callback = function(details) {...};\n    var filter = {...};\n    var opt_extraInfoSpec = [...];\n    \n\nHere's an example of listening for the `onBeforeRequest` event:\n\n    \n    \n    chrome.webRequest.onBeforeRequest.addListener(\n        callback, filter, opt_extraInfoSpec);\n    \n\nEach `addListener()` call takes a mandatory callback function as the first\nparameter. This callback function is passed a dictionary containing\ninformation about the current URL request. The information in this dictionary\ndepends on the specific event type as well as the content of\n`opt_extraInfoSpec`.\n\nIf the optional `opt_extraInfoSpec` array contains the string `'blocking'`\n(only allowed for specific events), the callback function is handled\nsynchronously. That means that the request is blocked until the callback\nfunction returns. In this case, the callback can return a\n`webRequest.BlockingResponse` that determines the further life cycle of the\nrequest. Depending on the context, this response allows canceling or\nredirecting a request (`onBeforeRequest`), canceling a request or modifying\nheaders (`onBeforeSendHeaders`, `onHeadersReceived`), and canceling a request\nor providing authentication credentials (`onAuthRequired`).\n\nIf the optional `opt_extraInfoSpec` array contains the string\n`'asyncBlocking'` instead (only allowed for `onAuthRequired`), the extension\ncan generate the `webRequest.BlockingResponse` asynchronously.\n\nThe `webRequest.RequestFilter` `filter` allows limiting the requests for which\nevents are triggered in various dimensions:\n\nURLs\n\n    URL patterns such as `*://www.google.com/foo*bar`.\nTypes\n\n    Request types such as `main_frame` (a document that is loaded for a top-level frame), `sub_frame` (a document that is loaded for an embedded frame), and `image` (an image on a web site). See `webRequest.RequestFilter`.\nTab ID\n\n    The identifier for one tab.\nWindow ID\n\n    The identifier for a window.\n\nDepending on the event type, you can specify strings in `opt_extraInfoSpec` to\nask for additional information about the request. This is used to provide\ndetailed information on request's data only if explicitly requested.\n\n### Handling authentication\n\nTo handle requests for HTTP authentication, add the `\"webRequestAuthProvider\"`\npermission to your manifest file:\n\n    \n    \n    {\n      \"permissions\": [\n        \"webRequest\",\n        \"webRequestAuthProvider\"\n      ]\n    }\n    \n\nNote that this permission is not required for a policy installed extension\nwith the `\"webRequestBlocking\"` permission.\n\nTo provide credentials synchronously:\n\n    \n    \n    chrome.webRequest.onAuthRequired.addListener((details) => {\n        return {\n          authCredentials: {\n            username: 'guest',\n            password: 'guest'\n          }\n        };\n      },\n      { urls: ['https://httpbin.org/basic-auth/guest/guest'] },\n      ['blocking']\n    );\n    \n\nTo provide credentials asynchronously:\n\n    \n    \n    chrome.webRequest.onAuthRequired.addListener((details, callback) => {\n        callback({\n          authCredentials: {\n            username: 'guest',\n            password: 'guest'\n          }\n        });\n      },\n      { urls: ['https://httpbin.org/basic-auth/guest/guest'] },\n      ['asyncBlocking']\n    );\n    \n\n### Implementation details\n\nSeveral implementation details can be important to understand when developing\nan extension that uses the web request API:\n\n#### web_accessible_resources\n\nWhen an extension uses webRequest APIs to redirect a public resource request\nto a resource that is not web accessible, it is blocked and will result in an\nerror. The above holds true even if the resource that is not web accessible is\nowned by the redirecting extension. To declare resources for use with\ndeclarativeWebRequest APIs, the `\"web_accessible_resources\"` array must be\ndeclared and populated in the manifest as documented here.\n\n#### Conflict resolution\n\nIn the current implementation of the web request API, a request is considered\ncanceled if at least one extension instructs to cancel the request. If an\nextension cancels a request, all extensions are notified by an\n`onErrorOccurred` event. Only one extension can redirect a request or modify a\nheader at a time. If more than one extension attempts to modify the request,\nthe most recently installed extension wins, and all others are ignored. An\nextension is not notified if its instruction to modify or redirect has been\nignored.\n\n#### Caching\n\nChrome employs two cachesan on-disk cache and a very fast in-memory cache.\nThe lifetime of an in-memory cache is attached to the lifetime of a render\nprocess, which roughly corresponds to a tab. Requests that are answered from\nthe in-memory cache are invisible to the web request API. If a request handler\nchanges its behavior (for example, the behavior according to which requests\nare blocked), a simple page refresh might not respect this changed behavior.\nTo ensure the behavior change goes through, call `handlerBehaviorChanged()` to\nflush the in-memory cache. But don't do it often; flushing the cache is a very\nexpensive operation. You don't need to call `handlerBehaviorChanged()` after\nregistering or unregistering an event listener.\n\n#### Timestamps\n\nThe `timestamp` property of web request events is only guaranteed to be\n_internally_ consistent. Comparing one event to another event will give you\nthe correct offset between them, but comparing them to the current time inside\nthe extension (via `(new Date()).getTime()`, for instance) might give\nunexpected results.\n\n#### Error handling\n\nIf you try to register an event with invalid arguments, then a JavaScript\nerror will be thrown, and the event handler will not be registered. If an\nerror is thrown while an event is handled or if an event handler returns an\ninvalid blocking response, an error message is logged to your extension's\nconsole, and the handler is ignored for that request.\n\n## Examples\n\nThe following example illustrates how to block all requests to `www.evil.com`:\n\n    \n    \n    chrome.webRequest.onBeforeRequest.addListener(\n      function(details) {\n        return {cancel: details.url.indexOf(\"://www.evil.com/\") != -1};\n      },\n      {urls: [\"<all_urls>\"]},\n      [\"blocking\"]\n    );\n    \n\nAs this function uses a blocking event handler, it requires the `\"webRequest\"`\nas well as the `\"webRequestBlocking\"` permission in the manifest file.\n\nThe following example achieves the same goal in a more efficient way because\nrequests that are not targeted to `www.evil.com` do not need to be passed to\nthe extension:\n\n    \n    \n    chrome.webRequest.onBeforeRequest.addListener(\n      function(details) { return {cancel: true}; },\n      {urls: [\"*://www.evil.com/*\"]},\n      [\"blocking\"]\n    );\n    \n\nThe following example illustrates how to delete the User-Agent header from all\nrequests:\n\n    \n    \n    chrome.webRequest.onBeforeSendHeaders.addListener(\n      function(details) {\n        for (var i = 0; i < details.requestHeaders.length; ++i) {\n          if (details.requestHeaders[i].name === 'User-Agent') {\n            details.requestHeaders.splice(i, 1);\n            break;\n          }\n        }\n        return {requestHeaders: details.requestHeaders};\n      },\n      {urls: [\"<all_urls>\"]},\n      [\"blocking\", \"requestHeaders\"]\n    );\n    \n\nTo try the `chrome.webRequest` API, install the webRequest sample from the\nchrome-extension-samples repository.\n\n## Types\n\n### BlockingResponse\n\nReturns value for event handlers that have the 'blocking' extraInfoSpec\napplied. Allows the event handler to modify network requests.\n\n#### Properties\n\n  * authCredentials\n\nobject optional\n\nOnly used as a response to the onAuthRequired event. If set, the request is\nmade using the supplied credentials.\n\n    * password\n\nstring\n\n    * username\n\nstring\n\n  * cancel\n\nboolean optional\n\nIf true, the request is cancelled. This prevents the request from being sent.\nThis can be used as a response to the onBeforeRequest, onBeforeSendHeaders,\nonHeadersReceived and onAuthRequired events.\n\n  * redirectUrl\n\nstring optional\n\nOnly used as a response to the onBeforeRequest and onHeadersReceived events.\nIf set, the original request is prevented from being sent/completed and is\ninstead redirected to the given URL. Redirections to non-HTTP schemes such as\n`data:` are allowed. Redirects initiated by a redirect action use the original\nrequest method for the redirect, with one exception: If the redirect is\ninitiated at the onHeadersReceived stage, then the redirect will be issued\nusing the GET method. Redirects from URLs with `ws://` and `wss://` schemes\nare **ignored**.\n\n  * requestHeaders\n\nHttpHeaders optional\n\nOnly used as a response to the onBeforeSendHeaders event. If set, the request\nis made with these request headers instead.\n\n  * responseHeaders\n\nHttpHeaders optional\n\nOnly used as a response to the onHeadersReceived event. If set, the server is\nassumed to have responded with these response headers instead. Only return\n`responseHeaders` if you really want to modify the headers in order to limit\nthe number of conflicts (only one extension may modify `responseHeaders` for\neach request).\n\n### FormDataItem\n\nChrome 66+\n\nContains data passed within form data. For urlencoded form it is stored as\nstring if data is utf-8 string and as ArrayBuffer otherwise. For form-data it\nis ArrayBuffer. If form-data represents uploading file, it is string with\nfilename, if the filename is provided.\n\n#### Enum\n\nArrayBuffer\n\nstring\n\n### HttpHeaders\n\nAn array of HTTP headers. Each header is represented as a dictionary\ncontaining the keys `name` and either `value` or `binaryValue`.\n\n#### Type\n\nobject[]\n\n#### Properties\n\n  * binaryValue\n\nnumber[] optional\n\nValue of the HTTP header if it cannot be represented by UTF-8, stored as\nindividual byte values (0..255).\n\n  * name\n\nstring\n\nName of the HTTP header.\n\n  * value\n\nstring optional\n\nValue of the HTTP header if it can be represented by UTF-8.\n\n### IgnoredActionType\n\nChrome 70+\n\n#### Enum\n\n\"redirect\"  \n\n\"request_headers\"  \n\n\"response_headers\"  \n\n\"auth_credentials\"  \n\n### OnAuthRequiredOptions\n\nChrome 44+\n\n#### Enum\n\n\"responseHeaders\"  \nSpecifies that the response headers should be included in the event.\n\n\"blocking\"  \nSpecifies the request is blocked until the callback function returns.\n\n\"asyncBlocking\"  \nSpecifies that the callback function is handled asynchronously.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### OnBeforeRedirectOptions\n\nChrome 44+\n\n#### Enum\n\n\"responseHeaders\"  \nSpecifies that the response headers should be included in the event.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### OnBeforeRequestOptions\n\nChrome 44+\n\n#### Enum\n\n\"blocking\"  \nSpecifies the request is blocked until the callback function returns.\n\n\"requestBody\"  \nSpecifies that the request body should be included in the event.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### OnBeforeSendHeadersOptions\n\nChrome 44+\n\n#### Enum\n\n\"requestHeaders\"  \nSpecifies that the request header should be included in the event.\n\n\"blocking\"  \nSpecifies the request is blocked until the callback function returns.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### OnCompletedOptions\n\nChrome 44+\n\n#### Enum\n\n\"responseHeaders\"  \nSpecifies that the response headers should be included in the event.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### OnErrorOccurredOptions\n\nChrome 79+\n\n#### Value\n\n\"extraHeaders\"  \n\n### OnHeadersReceivedOptions\n\nChrome 44+\n\n#### Enum\n\n\"blocking\"  \nSpecifies the request is blocked until the callback function returns.\n\n\"responseHeaders\"  \nSpecifies that the response headers should be included in the event.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### OnResponseStartedOptions\n\nChrome 44+\n\n#### Enum\n\n\"responseHeaders\"  \nSpecifies that the response headers should be included in the event.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### OnSendHeadersOptions\n\nChrome 44+\n\n#### Enum\n\n\"requestHeaders\"  \nSpecifies that the request header should be included in the event.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### RequestFilter\n\nAn object describing filters to apply to webRequest events.\n\n#### Properties\n\n  * tabId\n\nnumber optional\n\n  * types\n\nResourceType[] optional\n\nA list of request types. Requests that cannot match any of the types will be\nfiltered out.\n\n  * urls\n\nstring[]\n\nA list of URLs or URL patterns. Requests that cannot match any of the URLs\nwill be filtered out.\n\n  * windowId\n\nnumber optional\n\n### ResourceType\n\nChrome 44+\n\n#### Enum\n\n\"main_frame\"  \nSpecifies the resource as the main frame.\n\n\"sub_frame\"  \nSpecifies the resource as a sub frame.\n\n\"stylesheet\"  \nSpecifies the resource as a stylesheet.\n\n\"script\"  \nSpecifies the resource as a script.\n\n\"image\"  \nSpecifies the resource as an image.\n\n\"font\"  \nSpecifies the resource as a font.\n\n\"object\"  \nSpecifies the resource as an object.\n\n\"xmlhttprequest\"  \nSpecifies the resource as an XMLHttpRequest.\n\n\"ping\"  \nSpecifies the resource as a ping.\n\n\"csp_report\"  \nSpecifies the resource as a Content Security Policy (CSP) report.\n\n\"media\"  \nSpecifies the resource as a media object.\n\n\"websocket\"  \nSpecifies the resource as a WebSocket.\n\n\"webbundle\"  \nSpecifies the resource as a WebBundle.\n\n\"other\"  \nSpecifies the resource as a type not included in the listed types.\n\n### UploadData\n\nContains data uploaded in a URL request.\n\n#### Properties\n\n  * bytes\n\nany optional\n\nAn ArrayBuffer with a copy of the data.\n\n  * file\n\nstring optional\n\nA string with the file's path and name.\n\n## Properties\n\n### MAX_HANDLER_BEHAVIOR_CHANGED_CALLS_PER_10_MINUTES\n\nThe maximum number of times that `handlerBehaviorChanged` can be called per 10\nminute sustained interval. `handlerBehaviorChanged` is an expensive function\ncall that shouldn't be called often.\n\n#### Value\n\n20  \n\n## Methods\n\n### handlerBehaviorChanged()\n\nPromise\n\n    \n    \n    chrome.webRequest.handlerBehaviorChanged(  \n      callback?: function,  \n    )\n\nNeeds to be called when the behavior of the webRequest handlers has changed to\nprevent incorrect handling due to caching. This function call is expensive.\nDon't call it often.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onActionIgnored\n\nChrome 70+\n\n    \n    \n    chrome.webRequest.onActionIgnored.addListener(  \n      callback: function,  \n    )\n\nFired when an extension's proposed modification to a network request is\nignored. This happens in case of conflicts with other extensions.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * action\n\nIgnoredActionType\n\nThe proposed action which was ignored.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n### onAuthRequired\n\n    \n    \n    chrome.webRequest.onAuthRequired.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnAuthRequiredOptions[],  \n    )\n\nFired when an authentication failure is received. The listener has three\noptions: it can provide authentication credentials, it can cancel the request\nand display the error page, or it can take no action on the challenge. If bad\nuser credentials are provided, this may be called multiple times for the same\nrequest. Note, only one of `'blocking'` or `'asyncBlocking'` modes must be\nspecified in the `extraInfoSpec` parameter.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object, asyncCallback?: function) => BlockingResponse | undefined\n\n    * details\n\nobject\n\n      * challenger\n\nobject\n\nThe server requesting authentication.\n\n        * host\n\nstring\n\n        * port\n\nnumber\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * isProxy\n\nboolean\n\nTrue for Proxy-Authenticate, false for WWW-Authenticate.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * realm\n\nstring optional\n\nThe authentication realm provided by the server, if there is one.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * responseHeaders\n\nHttpHeaders optional\n\nThe HTTP response headers that were received along with this response.\n\n      * scheme\n\nstring\n\nThe authentication scheme, e.g. Basic or Digest.\n\n      * statusCode\n\nnumber\n\nChrome 43+\n\nStandard HTTP status code returned by the server.\n\n      * statusLine\n\nstring\n\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9\nresponses (i.e., responses that lack a status line) or an empty string if\nthere are no headers.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n    * asyncCallback\n\nfunction optional\n\nChrome 58+\n\nThe `asyncCallback` parameter looks like:\n\n          \n          (response: BlockingResponse) => void\n\n      * response\n\nBlockingResponse\n\n    * returns\n\nBlockingResponse | undefined\n\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event\nlistener should return an object of this type.\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnAuthRequiredOptions[] optional\n\n### onBeforeRedirect\n\n    \n    \n    chrome.webRequest.onBeforeRedirect.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnBeforeRedirectOptions[],  \n    )\n\nFired when a server-initiated redirect is about to occur.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * fromCache\n\nboolean\n\nIndicates if this response was fetched from disk cache.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * ip\n\nstring optional\n\nThe server IP address that the request was actually sent to. Note that it may\nbe a literal IPv6 address.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * redirectUrl\n\nstring\n\nThe new URL.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * responseHeaders\n\nHttpHeaders optional\n\nThe HTTP response headers that were received along with this redirect.\n\n      * statusCode\n\nnumber\n\nStandard HTTP status code returned by the server.\n\n      * statusLine\n\nstring\n\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9\nresponses (i.e., responses that lack a status line) or an empty string if\nthere are no headers.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnBeforeRedirectOptions[] optional\n\n### onBeforeRequest\n\n    \n    \n    chrome.webRequest.onBeforeRequest.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnBeforeRequestOptions[],  \n    )\n\nFired when a request is about to occur.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => BlockingResponse | undefined\n\n    * details\n\nobject\n\n      * documentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle optional\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType optional\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * requestBody\n\nobject optional\n\nContains the HTTP request body data. Only provided if extraInfoSpec contains\n'requestBody'.\n\n        * error\n\nstring optional\n\nErrors when obtaining request body data.\n\n        * formData\n\nobject optional\n\nIf the request method is POST and the body is a sequence of key-value pairs\nencoded in UTF8, encoded as either multipart/form-data, or application/x-www-\nform-urlencoded, this dictionary is present and for each key contains the list\nof all values for that key. If the data is of another media type, or if it is\nmalformed, the dictionary is not present. An example value of this dictionary\nis {'key': ['value1', 'value2']}.\n\n        * raw\n\nUploadData[] optional\n\nIf the request method is PUT or POST, and the body is not already parsed in\nformData, then the unparsed request body elements are contained in this array.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n    * returns\n\nBlockingResponse | undefined\n\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event\nlistener should return an object of this type.\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnBeforeRequestOptions[] optional\n\n### onBeforeSendHeaders\n\n    \n    \n    chrome.webRequest.onBeforeSendHeaders.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnBeforeSendHeadersOptions[],  \n    )\n\nFired before sending an HTTP request, once the request headers are available.\nThis may occur after a TCP connection is made to the server, but before any\nHTTP data is sent.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => BlockingResponse | undefined\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * requestHeaders\n\nHttpHeaders optional\n\nThe HTTP request headers that are going to be sent out with this request.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n    * returns\n\nBlockingResponse | undefined\n\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event\nlistener should return an object of this type.\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnBeforeSendHeadersOptions[] optional\n\n### onCompleted\n\n    \n    \n    chrome.webRequest.onCompleted.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnCompletedOptions[],  \n    )\n\nFired when a request is completed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * fromCache\n\nboolean\n\nIndicates if this response was fetched from disk cache.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * ip\n\nstring optional\n\nThe server IP address that the request was actually sent to. Note that it may\nbe a literal IPv6 address.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * responseHeaders\n\nHttpHeaders optional\n\nThe HTTP response headers that were received along with this response.\n\n      * statusCode\n\nnumber\n\nStandard HTTP status code returned by the server.\n\n      * statusLine\n\nstring\n\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9\nresponses (i.e., responses that lack a status line) or an empty string if\nthere are no headers.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnCompletedOptions[] optional\n\n### onErrorOccurred\n\n    \n    \n    chrome.webRequest.onErrorOccurred.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnErrorOccurredOptions[],  \n    )\n\nFired when an error occurs.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request. This value is not present if the\nrequest is a navigation of a frame.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * error\n\nstring\n\nThe error description. This string is _not_ guaranteed to remain backwards\ncompatible between releases. You must not parse and act based upon its\ncontent.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * fromCache\n\nboolean\n\nIndicates if this response was fetched from disk cache.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * ip\n\nstring optional\n\nThe server IP address that the request was actually sent to. Note that it may\nbe a literal IPv6 address.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnErrorOccurredOptions[] optional\n\n### onHeadersReceived\n\n    \n    \n    chrome.webRequest.onHeadersReceived.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnHeadersReceivedOptions[],  \n    )\n\nFired when HTTP response headers of a request have been received.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => BlockingResponse | undefined\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * responseHeaders\n\nHttpHeaders optional\n\nThe HTTP response headers that have been received with this response.\n\n      * statusCode\n\nnumber\n\nChrome 43+\n\nStandard HTTP status code returned by the server.\n\n      * statusLine\n\nstring\n\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9\nresponses (i.e., responses that lack a status line).\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n    * returns\n\nBlockingResponse | undefined\n\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event\nlistener should return an object of this type.\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnHeadersReceivedOptions[] optional\n\n### onResponseStarted\n\n    \n    \n    chrome.webRequest.onResponseStarted.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnResponseStartedOptions[],  \n    )\n\nFired when the first byte of the response body is received. For HTTP requests,\nthis means that the status line and response headers are available.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * fromCache\n\nboolean\n\nIndicates if this response was fetched from disk cache.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * ip\n\nstring optional\n\nThe server IP address that the request was actually sent to. Note that it may\nbe a literal IPv6 address.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * responseHeaders\n\nHttpHeaders optional\n\nThe HTTP response headers that were received along with this response.\n\n      * statusCode\n\nnumber\n\nStandard HTTP status code returned by the server.\n\n      * statusLine\n\nstring\n\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9\nresponses (i.e., responses that lack a status line) or an empty string if\nthere are no headers.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnResponseStartedOptions[] optional\n\n### onSendHeaders\n\n    \n    \n    chrome.webRequest.onSendHeaders.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnSendHeadersOptions[],  \n    )\n\nFired just before a request is going to be sent to the server (modifications\nof previous onBeforeSendHeaders callbacks are visible by the time\nonSendHeaders is fired).\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * requestHeaders\n\nHttpHeaders optional\n\nThe HTTP request headers that have been sent out with this request.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnSendHeadersOptions[] optional\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/windows": "#  chrome.windows\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.windows` API to interact with browser windows. You can use\nthis API to create, modify, and rearrange windows in the browser.\n\n## Permissions\n\nWhen requested, a `windows.Window` contains an array of `tabs.Tab` objects.\nYou must declare the `\"tabs\"` permission in your manifest if you need access\nto the `url`, `pendingUrl`, `title`, or `favIconUrl` properties of `tabs.Tab`.\nFor example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\"tabs\"],\n      ...\n    }\n    \n\n## Concepts and usage\n\n### The current window\n\nMany functions in the extension system take an optional `windowId` argument,\nwhich defaults to the current window.\n\nThe _current window_ is the window that contains the code that is currently\nexecuting. It's important to realize that this can be different from the\ntopmost or focused window.\n\nFor example, say an extension creates a few tabs or windows from a single HTML\nfile, and that the HTML file contains a call to `tabs.query()`. The current\nwindow is the window that contains the page that made the call, no matter what\nthe topmost window is.\n\nIn the case of service workers, the value of the current window falls back to\nthe last active window. Under some circumstances, there may be no current\nwindow for background pages.\n\n## Examples\n\nTo try this API, install the windows API example from the chrome-extension-\nsamples repository.\n\n![Two windows, each with one\ntab](/static/docs/extensions/reference/api/windows/images/windows.png) Two\nwindows, each with one tab.\n\n## Types\n\n### CreateType\n\nChrome 44+\n\nSpecifies what type of browser window to create. 'panel' is deprecated and is\navailable only to existing allowlisted extensions on Chrome OS.\n\n#### Enum\n\n\"normal\"  \nSpecifies the window as a standard window.\n\n\"popup\"  \nSpecifies the window as a popup window.\n\n\"panel\"  \nSpecifies the window as a panel.\n\n### QueryOptions\n\nChrome 88+\n\n#### Properties\n\n  * populate\n\nboolean optional\n\nIf true, the `windows.Window` object has a `tabs` property that contains a\nlist of the `tabs.Tab` objects. The `Tab` objects only contain the `url`,\n`pendingUrl`, `title`, and `favIconUrl` properties if the extension's manifest\nfile includes the `\"tabs\"` permission.\n\n  * windowTypes\n\nWindowType[] optional\n\nIf set, the `windows.Window` returned is filtered based on its type. If unset,\nthe default filter is set to `['normal', 'popup']`.\n\n### Window\n\n#### Properties\n\n  * alwaysOnTop\n\nboolean\n\nWhether the window is set to be always on top.\n\n  * focused\n\nboolean\n\nWhether the window is currently the focused window.\n\n  * height\n\nnumber optional\n\nThe height of the window, including the frame, in pixels. In some\ncircumstances a window may not be assigned a `height` property; for example,\nwhen querying closed windows from the `sessions` API.\n\n  * id\n\nnumber optional\n\nThe ID of the window. Window IDs are unique within a browser session. In some\ncircumstances a window may not be assigned an `ID` property; for example, when\nquerying windows using the `sessions` API, in which case a session ID may be\npresent.\n\n  * incognito\n\nboolean\n\nWhether the window is incognito.\n\n  * left\n\nnumber optional\n\nThe offset of the window from the left edge of the screen in pixels. In some\ncircumstances a window may not be assigned a `left` property; for example,\nwhen querying closed windows from the `sessions` API.\n\n  * sessionId\n\nstring optional\n\nThe session ID used to uniquely identify a window, obtained from the\n`sessions` API.\n\n  * state\n\nWindowState optional\n\nThe state of this browser window.\n\n  * tabs\n\nTab[] optional\n\nArray of `tabs.Tab` objects representing the current tabs in the window.\n\n  * top\n\nnumber optional\n\nThe offset of the window from the top edge of the screen in pixels. In some\ncircumstances a window may not be assigned a `top` property; for example, when\nquerying closed windows from the `sessions` API.\n\n  * type\n\nWindowType optional\n\nThe type of browser window this is.\n\n  * width\n\nnumber optional\n\nThe width of the window, including the frame, in pixels. In some circumstances\na window may not be assigned a `width` property; for example, when querying\nclosed windows from the `sessions` API.\n\n### WindowState\n\nChrome 44+\n\nThe state of this browser window. In some circumstances a window may not be\nassigned a `state` property; for example, when querying closed windows from\nthe `sessions` API.\n\n#### Enum\n\n\"normal\"  \nNormal window state (not minimized, maximized, or fullscreen).\n\n\"minimized\"  \nMinimized window state.\n\n\"maximized\"  \nMaximized window state.\n\n\"fullscreen\"  \nFullscreen window state.\n\n\"locked-fullscreen\"  \nLocked fullscreen window state. This fullscreen state cannot be exited by user\naction and is available only to allowlisted extensions on Chrome OS.\n\n### WindowType\n\nChrome 44+\n\nThe type of browser window this is. In some circumstances a window may not be\nassigned a `type` property; for example, when querying closed windows from the\n`sessions` API.\n\n#### Enum\n\n\"normal\"  \nA normal browser window.\n\n\"popup\"  \nA browser popup.\n\n\"panel\"  \n_Deprecated in this API._ A Chrome App panel-style window. Extensions can only\nsee their own panel windows.\n\n\"app\"  \n_Deprecated in this API._ A Chrome App window. Extensions can only see their\napp own windows.\n\n\"devtools\"  \nA Developer Tools window.\n\n## Properties\n\n### WINDOW_ID_CURRENT\n\nThe windowId value that represents the current window.\n\n#### Value\n\n-2   \n\n### WINDOW_ID_NONE\n\nThe windowId value that represents the absence of a Chrome browser window.\n\n#### Value\n\n-1   \n\n## Methods\n\n### create()\n\nPromise\n\n    \n    \n    chrome.windows.create(  \n      createData?: object,  \n      callback?: function,  \n    )\n\nCreates (opens) a new browser window with any optional sizing, position, or\ndefault URL provided.\n\n#### Parameters\n\n  * createData\n\nobject optional\n\n    * focused\n\nboolean optional\n\nIf `true`, opens an active window. If `false`, opens an inactive window.\n\n    * height\n\nnumber optional\n\nThe height in pixels of the new window, including the frame. If not specified,\ndefaults to a natural height.\n\n    * incognito\n\nboolean optional\n\nWhether the new window should be an incognito window.\n\n    * left\n\nnumber optional\n\nThe number of pixels to position the new window from the left edge of the\nscreen. If not specified, the new window is offset naturally from the last\nfocused window. This value is ignored for panels.\n\n    * setSelfAsOpener\n\nboolean optional\n\nChrome 64+\n\nIf `true`, the newly-created window's 'window.opener' is set to the caller and\nis in the same unit of related browsing contexts as the caller.\n\n    * state\n\nWindowState optional\n\nChrome 44+\n\nThe initial state of the window. The `minimized`, `maximized`, and\n`fullscreen` states cannot be combined with `left`, `top`, `width`, or\n`height`.\n\n    * tabId\n\nnumber optional\n\nThe ID of the tab to add to the new window.\n\n    * top\n\nnumber optional\n\nThe number of pixels to position the new window from the top edge of the\nscreen. If not specified, the new window is offset naturally from the last\nfocused window. This value is ignored for panels.\n\n    * type\n\nCreateType optional\n\nSpecifies what type of browser window to create.\n\n    * url\n\nstring | string[] optional\n\nA URL or array of URLs to open as tabs in the window. Fully-qualified URLs\nmust include a scheme, e.g., 'http://www.google.com', not 'www.google.com'.\nNon-fully-qualified URLs are considered relative within the extension.\nDefaults to the New Tab Page.\n\n    * width\n\nnumber optional\n\nThe width in pixels of the new window, including the frame. If not specified,\ndefaults to a natural width.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (window?: Window) => void\n\n    * window\n\nWindow optional\n\nContains details about the created window.\n\n#### Returns\n\n  * Promise<Window | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### get()\n\nPromise\n\n    \n    \n    chrome.windows.get(  \n      windowId: number,  \n      queryOptions?: QueryOptions,  \n      callback?: function,  \n    )\n\nGets details about a window.\n\n#### Parameters\n\n  * windowId\n\nnumber\n\n  * queryOptions\n\nQueryOptions optional\n\nChrome 88+\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (window: Window) => void\n\n    * window\n\nWindow\n\n#### Returns\n\n  * Promise<Window>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.windows.getAll(  \n      queryOptions?: QueryOptions,  \n      callback?: function,  \n    )\n\nGets all windows.\n\n#### Parameters\n\n  * queryOptions\n\nQueryOptions optional\n\nChrome 88+\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (windows: Window[]) => void\n\n    * windows\n\nWindow[]\n\n#### Returns\n\n  * Promise<Window[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getCurrent()\n\nPromise\n\n    \n    \n    chrome.windows.getCurrent(  \n      queryOptions?: QueryOptions,  \n      callback?: function,  \n    )\n\nGets the current window.\n\n#### Parameters\n\n  * queryOptions\n\nQueryOptions optional\n\nChrome 88+\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (window: Window) => void\n\n    * window\n\nWindow\n\n#### Returns\n\n  * Promise<Window>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getLastFocused()\n\nPromise\n\n    \n    \n    chrome.windows.getLastFocused(  \n      queryOptions?: QueryOptions,  \n      callback?: function,  \n    )\n\nGets the window that was most recently focused  typically the window 'on\ntop'.\n\n#### Parameters\n\n  * queryOptions\n\nQueryOptions optional\n\nChrome 88+\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (window: Window) => void\n\n    * window\n\nWindow\n\n#### Returns\n\n  * Promise<Window>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### remove()\n\nPromise\n\n    \n    \n    chrome.windows.remove(  \n      windowId: number,  \n      callback?: function,  \n    )\n\nRemoves (closes) a window and all the tabs inside it.\n\n#### Parameters\n\n  * windowId\n\nnumber\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### update()\n\nPromise\n\n    \n    \n    chrome.windows.update(  \n      windowId: number,  \n      updateInfo: object,  \n      callback?: function,  \n    )\n\nUpdates the properties of a window. Specify only the properties that to be\nchanged; unspecified properties are unchanged.\n\n#### Parameters\n\n  * windowId\n\nnumber\n\n  * updateInfo\n\nobject\n\n    * drawAttention\n\nboolean optional\n\nIf `true`, causes the window to be displayed in a manner that draws the user's\nattention to the window, without changing the focused window. The effect lasts\nuntil the user changes focus to the window. This option has no effect if the\nwindow already has focus. Set to `false` to cancel a previous `drawAttention`\nrequest.\n\n    * focused\n\nboolean optional\n\nIf `true`, brings the window to the front; cannot be combined with the state\n'minimized'. If `false`, brings the next window in the z-order to the front;\ncannot be combined with the state 'fullscreen' or 'maximized'.\n\n    * height\n\nnumber optional\n\nThe height to resize the window to in pixels. This value is ignored for\npanels.\n\n    * left\n\nnumber optional\n\nThe offset from the left edge of the screen to move the window to in pixels.\nThis value is ignored for panels.\n\n    * state\n\nWindowState optional\n\nThe new state of the window. The 'minimized', 'maximized', and 'fullscreen'\nstates cannot be combined with 'left', 'top', 'width', or 'height'.\n\n    * top\n\nnumber optional\n\nThe offset from the top edge of the screen to move the window to in pixels.\nThis value is ignored for panels.\n\n    * width\n\nnumber optional\n\nThe width to resize the window to in pixels. This value is ignored for panels.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (window: Window) => void\n\n    * window\n\nWindow\n\n#### Returns\n\n  * Promise<Window>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onBoundsChanged\n\nChrome 86+\n\n    \n    \n    chrome.windows.onBoundsChanged.addListener(  \n      callback: function,  \n    )\n\nFired when a window has been resized; this event is only dispatched when the\nnew bounds are committed, and not for in-progress changes.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (window: Window) => void\n\n    * window\n\nWindow\n\n### onCreated\n\n    \n    \n    chrome.windows.onCreated.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when a window is created.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nChrome 46+\n\nThe `callback` parameter looks like:\n\n        \n        (window: Window) => void\n\n    * window\n\nWindow\n\nDetails of the created window.\n\n  * filters\n\nobject optional\n\n    * windowTypes\n\nWindowType[]\n\nConditions that the window's type being created must satisfy. By default it\nsatisfies `['normal', 'popup']`.\n\n### onFocusChanged\n\n    \n    \n    chrome.windows.onFocusChanged.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when the currently focused window changes. Returns\n`chrome.windows.WINDOW_ID_NONE` if all Chrome windows have lost focus.\n**Note:** On some Linux window managers, `WINDOW_ID_NONE` is always sent\nimmediately preceding a switch from one Chrome window to another.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nChrome 46+\n\nThe `callback` parameter looks like:\n\n        \n        (windowId: number) => void\n\n    * windowId\n\nnumber\n\nID of the newly-focused window.\n\n  * filters\n\nobject optional\n\n    * windowTypes\n\nWindowType[]\n\nConditions that the window's type being removed must satisfy. By default it\nsatisfies `['normal', 'popup']`.\n\n### onRemoved\n\n    \n    \n    chrome.windows.onRemoved.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when a window is removed (closed).\n\n#### Parameters\n\n  * callback\n\nfunction\n\nChrome 46+\n\nThe `callback` parameter looks like:\n\n        \n        (windowId: number) => void\n\n    * windowId\n\nnumber\n\nID of the removed window.\n\n  * filters\n\nobject optional\n\n    * windowTypes\n\nWindowType[]\n\nConditions that the window's type being removed must satisfy. By default it\nsatisfies `['normal', 'popup']`.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/accessibilityFeatures": "#  chrome.accessibilityFeatures\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.accessibilityFeatures` API to manage Chrome's accessibility\nfeatures. This API relies on the ChromeSetting prototype of the type API for\ngetting and setting individual accessibility features. In order to get feature\nstates the extension must request `accessibilityFeatures.read` permission. For\nmodifying feature state, the extension needs `accessibilityFeatures.modify`\npermission. Note that `accessibilityFeatures.modify` does not imply\n`accessibilityFeatures.read` permission.\n\n## Permissions\n\n`accessibilityFeatures.modify`  \n`accessibilityFeatures.read`  \n\n## Properties\n\n### animationPolicy\n\n`get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<\"allowed\"  \n | \"once\"   \n | \"none\"   \n>\n\n### autoclick\n\n**ChromeOS only.**\n\nAuto mouse click after mouse stops moving. The value indicates whether the\nfeature is enabled or not. `get()` requires `accessibilityFeatures.read`\npermission. `set()` and `clear()` require `accessibilityFeatures.modify`\npermission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### caretHighlight\n\nChrome 51+\n\n**ChromeOS only.**\n\nCaret highlighting. The value indicates whether the feature is enabled or not.\n`get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### cursorColor\n\nChrome 85+\n\n**ChromeOS only.**\n\nCursor color. The value indicates whether the feature is enabled or not,\ndoesn't indicate the color of it. `get()` requires\n`accessibilityFeatures.read` permission. `set()` and `clear()` require\n`accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### cursorHighlight\n\nChrome 51+\n\n**ChromeOS only.**\n\nCursor highlighting. The value indicates whether the feature is enabled or\nnot. `get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### dictation\n\nChrome 90+\n\n**ChromeOS only.**\n\nDictation. The value indicates whether the feature is enabled or not. `get()`\nrequires `accessibilityFeatures.read` permission. `set()` and `clear()`\nrequire `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### dockedMagnifier\n\nChrome 87+\n\n**ChromeOS only.**\n\nDocked magnifier. The value indicates whether docked magnifier feature is\nenabled or not. `get()` requires `accessibilityFeatures.read` permission.\n`set()` and `clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### focusHighlight\n\nChrome 51+\n\n**ChromeOS only.**\n\nFocus highlighting. The value indicates whether the feature is enabled or not.\n`get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### highContrast\n\n**ChromeOS only.**\n\nHigh contrast rendering mode. The value indicates whether the feature is\nenabled or not. `get()` requires `accessibilityFeatures.read` permission.\n`set()` and `clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### largeCursor\n\n**ChromeOS only.**\n\nEnlarged cursor. The value indicates whether the feature is enabled or not.\n`get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### screenMagnifier\n\n**ChromeOS only.**\n\nFull screen magnification. The value indicates whether the feature is enabled\nor not. `get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### selectToSpeak\n\nChrome 51+\n\n**ChromeOS only.**\n\nSelect-to-speak. The value indicates whether the feature is enabled or not.\n`get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### spokenFeedback\n\n**ChromeOS only.**\n\nSpoken feedback (text-to-speech). The value indicates whether the feature is\nenabled or not. `get()` requires `accessibilityFeatures.read` permission.\n`set()` and `clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### stickyKeys\n\n**ChromeOS only.**\n\nSticky modifier keys (like shift or alt). The value indicates whether the\nfeature is enabled or not. `get()` requires `accessibilityFeatures.read`\npermission. `set()` and `clear()` require `accessibilityFeatures.modify`\npermission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### switchAccess\n\nChrome 51+\n\n**ChromeOS only.**\n\nSwitch Access. The value indicates whether the feature is enabled or not.\n`get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n### virtualKeyboard\n\n**ChromeOS only.**\n\nVirtual on-screen keyboard. The value indicates whether the feature is enabled\nor not. `get()` requires `accessibilityFeatures.read` permission. `set()` and\n`clear()` require `accessibilityFeatures.modify` permission.\n\n#### Type\n\ntypes.ChromeSetting<boolean>\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/action": "#  chrome.action\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.action` API to control the extension's icon in the Google\nChrome toolbar.\n\nThe action icons are displayed in the browser toolbar next to the omnibox.\nAfter installation, these appear in the extensions menu (the puzzle piece\nicon). Users can pin your extension icon to the toolbar.\n\n## Availability\n\nChrome 88+ MV3+\n\n## Manifest\n\nThe following keys must be declared in the manifest to use this API.\n\n`\"action\"`  \n\nTo use the `chrome.action` API, specify a `\"manifest_version\"` of `3` and\ninclude the `\"action\"` key in your manifest file.\n\n**Note:** Every extension has an icon in the Chrome toolbar, even if the\n`\"action\"` key isn't added to the manifest.\n\n    \n    \n    {\n      \"name\": \"Action Extension\",\n      ...\n      \"action\": {\n        \"default_icon\": {              // optional\n          \"16\": \"images/icon16.png\",   // optional\n          \"24\": \"images/icon24.png\",   // optional\n          \"32\": \"images/icon32.png\"    // optional\n        },\n        \"default_title\": \"Click Me\",   // optional, shown in tooltip\n        \"default_popup\": \"popup.html\"  // optional\n      },\n      ...\n    }\n    \n\nThe `\"action\"` key (along with its children) is optional. When it isn't\nincluded, your extension is still shown in the toolbar to provide access to\nthe extension's menu. For this reason, we recommend that you always include at\nleast the `\"action\"` and `\"default_icon\"` keys.\n\n## Concepts and usage\n\n### Parts of the UI\n\n#### Icon\n\nThe icon is the main image on the toolbar for your extension, and is set by\nthe `\"default_icon\"` key in your manifest's `\"action\"` key. Icons must be 16\ndevice-independent pixels (DIPs) wide and tall.\n\nThe `\"default_icon\"` key is a dictionary of sizes to image paths. Chrome uses\nthese icons to choose which image scale to use. If an exact match is not\nfound, Chrome selects the closest available and scales it to fit the image,\nwhich might affect image quality.\n\nBecause devices with less-common scale factors like 1.5x or 1.2x are becoming\nmore common, we encourage you to provide multiple sizes for your icons. This\nalso futureproofs your extension against potential icon display size changes.\nHowever, if only providing a single size, the `\"default_icon\"` key can also be\nset to a string with the path to a single icon instead of a dictionary.\n\nYou can also call `action.setIcon()` to set your extension's icon\nprogrammatically by specifying a different image path or providing a\ndynamically-generated icon using the HTML canvas element, or, if setting from\nan extension service worker, the offscreen canvas API.\n\n    \n    \n    const canvas = new OffscreenCanvas(16, 16);\n    const context = canvas.getContext('2d');\n    context.clearRect(0, 0, 16, 16);\n    context.fillStyle = '#00FF00';  // Green\n    context.fillRect(0, 0, 16, 16);\n    const imageData = context.getImageData(0, 0, 16, 16);\n    chrome.action.setIcon({imageData: imageData}, () => { /* ... */ });\n    \n\n**Note:** The `action.setIcon()` API is intended to set a static image. Don't\nuse animated images for your icons.\n\nFor packed extensions (installed from a .crx file), images can be in most\nformats that the Blink rendering engine can display, including PNG, JPEG, BMP,\nICO, and others. SVG isn't supported. Unpacked extensions must use PNG images.\n\n#### Tooltip (title)\n\nThe tooltip, or title, appears when the user holds their mouse pointer over\nthe extension's icon in the toolbar. It's also included in the accessible text\nspoken by screen readers when the button gets focus.\n\nThe default tooltip is set using the `\"default_title\"` field of the `\"action\"`\nkey in `manifest.json`. You can also set it programmatically by calling\n`action.setTitle()`.\n\n#### Badge\n\nActions can optionally display a \"badge\" -- a bit of text layered over the\nicon. This lets you update the action to display a small amount of information\nabout the state of the extension, such as a counter. The badge has a text\ncomponent and a background color. Because space is limited, we recommend that\nbadge text use four or fewer characters.\n\nTo create a badge, set it programmatically by calling\n`action.setBadgeBackgroundColor()` and `action.setBadgeText()`. There isn't a\ndefault badge setting in the manifest. Badge color values can be either an\narray of four integers between 0 and 255 that make up the RGBA color of the\nbadge or a string with a CSS color value.\n\n    \n    \n    chrome.action.setBadgeBackgroundColor(\n      {color: [0, 255, 0, 0]},  // Green\n      () => { /* ... */ },\n    );\n    \n    chrome.action.setBadgeBackgroundColor(\n      {color: '#00FF00'},  // Also green\n      () => { /* ... */ },\n    );\n    \n    chrome.action.setBadgeBackgroundColor(\n      {color: 'green'},  // Also, also green\n      () => { /* ... */ },\n    );\n    \n\n#### Popup\n\nAn action's popup is shown when the user clicks on the extension's action\nbutton in the toolbar. The popup can contain any HTML contents you like, and\nwill be automatically sized to fit its contents. The popup's size must be\nbetween 25x25 and 800x600 pixels.\n\nThe popup is initially set by the `\"default_popup\"` property in the `\"action\"`\nkey in the `manifest.json` file. If present, this property should point to a\nrelative path within the extension directory. It can also be updated\ndynamically to point to a different relative path using the\n`action.setPopup()` method.\n\n**Note:** The `action.onClicked` event won't be sent if the extension action\nhas specified a popup to show on click of the current tab.\n\n## Use cases\n\n### Per-tab state\n\nExtension actions can have different states for each tab. To set a value for\nan individual tab, use the `tabId` property in the `action` API's setting\nmethods. For example, to set the badge text for a specific tab, do something\nlike the following:\n\n    \n    \n    function getTabId() { /* ... */}\n    function getTabBadge() { /* ... */}\n    \n    chrome.action.setBadgeText(\n      {\n        text: getTabBadge(tabId),\n        tabId: getTabId(),\n      },\n      () => { ... }\n    );\n    \n\nIf the `tabId` property is left out, the setting is treated as a global\nsetting. Tab-specific settings take priority over global settings.\n\n### Enabled state\n\nBy default, toolbar actions are enabled (clickable) on every tab. You can\nchange this default by setting the `default_state` property in the `action`\nkey of the manifest. If `default_state` is set to `\"disabled\"`, the action is\ndisabled by default and must be enabled programmatically to be clickable. If\n`default_state` is set to `\"enabled\"` (the default), the action is enabled and\nclickable by default.\n\nYou can control the state programmatically using the `action.enable()` and\n`action.disable()` methods. This only affects whether the popup (if any) or\n`action.onClicked` event is sent to your extension; it doesn't affect the\naction's presence in the toolbar.\n\n## Examples\n\nThe following examples show some common ways that actions are used in\nextensions. To try this API, install the Action API example from the chrome-\nextension-samples repository.\n\n### Show a popup\n\nIt's common for an extension to display a popup when the user clicks the\nextension's action. To implement this in your own extension, declare the popup\nin your `manifest.json` and specify the content that Chrome should display in\nthe popup.\n\n    \n    \n    // manifest.json\n    {\n      \"name\": \"Action popup demo\",\n      \"version\": \"1.0\",\n      \"manifest_version\": 3,\n      \"action\": {\n        \"default_title\": \"Click to view a popup\",\n        \"default_popup\": \"popup.html\"\n      }\n    }\n    \n    \n    \n    <!-- popup.html -->\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <style>\n        html {\n          min-height: 5em;\n          min-width: 10em;\n          background: salmon;\n        }\n      </style>\n    </head>\n    <body>\n      <p>Hello, world!</p>\n    </body>\n    </html>\n    \n\n### Inject a content script on click\n\nA common pattern for extensions is to expose their primary feature using the\nextension's action. The following example demonstrates this pattern. When the\nuser clicks the action, the extension injects a content script into the\ncurrent page. The content script then displays an alert to verify that\neverything worked as expected.\n\n    \n    \n    // manifest.json\n    {\n      \"name\": \"Action script injection demo\",\n      \"version\": \"1.0\",\n      \"manifest_version\": 3,\n      \"action\": {\n        \"default_title\": \"Click to show an alert\"\n      },\n      \"permissions\": [\"activeTab\", \"scripting\"],\n      \"background\": {\n        \"service_worker\": \"background.js\"\n      }\n    }\n    \n    \n    \n    // background.js\n    chrome.action.onClicked.addListener((tab) => {\n      chrome.scripting.executeScript({\n        target: {tabId: tab.id},\n        files: ['content.js']\n      });\n    });\n    \n    \n    \n    // content.js\n    alert('Hello, world!');\n    \n\n### Emulate actions with declarativeContent\n\nThis example shows how an extension's background logic can (a) disable an\naction by default and (b) use declarativeContent to enable the action on\nspecific sites.\n\n    \n    \n    // service-worker.js\n    \n    // Wrap in an onInstalled callback to avoid unnecessary work\n    // every time the service worker is run\n    chrome.runtime.onInstalled.addListener(() => {\n      // Page actions are disabled by default and enabled on select tabs\n      chrome.action.disable();\n    \n      // Clear all rules to ensure only our expected rules are set\n      chrome.declarativeContent.onPageChanged.removeRules(undefined, () => {\n        // Declare a rule to enable the action on example.com pages\n        let exampleRule = {\n          conditions: [\n            new chrome.declarativeContent.PageStateMatcher({\n              pageUrl: {hostSuffix: '.example.com'},\n            })\n          ],\n          actions: [new chrome.declarativeContent.ShowAction()],\n        };\n    \n        // Finally, apply our new array of rules\n        let rules = [exampleRule];\n        chrome.declarativeContent.onPageChanged.addRules(rules);\n      });\n    });\n    \n\n## Types\n\n### OpenPopupOptions\n\nChrome 99+\n\n#### Properties\n\n  * windowId\n\nnumber optional\n\nThe ID of the window to open the action popup in. Defaults to the currently-\nactive window if unspecified.\n\n### TabDetails\n\n#### Properties\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to query state for. If no tab is specified, the non-tab-\nspecific state is returned.\n\n### UserSettings\n\nChrome 91+\n\nThe collection of user-specified settings relating to an extension's action.\n\n#### Properties\n\n  * isOnToolbar\n\nboolean\n\nWhether the extension's action icon is visible on browser windows' top-level\ntoolbar (i.e., whether the extension has been 'pinned' by the user).\n\n### UserSettingsChange\n\nChrome 130+\n\n#### Properties\n\n  * isOnToolbar\n\nboolean optional\n\nWhether the extension's action icon is visible on browser windows' top-level\ntoolbar (i.e., whether the extension has been 'pinned' by the user).\n\n## Methods\n\n### disable()\n\nPromise\n\n    \n    \n    chrome.action.disable(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nDisables the action for a tab.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab for which you want to modify the action.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### enable()\n\nPromise\n\n    \n    \n    chrome.action.enable(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nEnables the action for a tab. By default, actions are enabled.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab for which you want to modify the action.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getBadgeBackgroundColor()\n\nPromise\n\n    \n    \n    chrome.action.getBadgeBackgroundColor(  \n      details: TabDetails,  \n      callback?: function,  \n    )\n\nGets the background color of the action.\n\n#### Parameters\n\n  * details\n\nTabDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ColorArray) => void\n\n    * result\n\nColorArray\n\n#### Returns\n\n  * Promise<browserAction.ColorArray>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getBadgeText()\n\nPromise\n\n    \n    \n    chrome.action.getBadgeText(  \n      details: TabDetails,  \n      callback?: function,  \n    )\n\nGets the badge text of the action. If no tab is specified, the non-tab-\nspecific badge text is returned. If displayActionCountAsBadgeText is enabled,\na placeholder text will be returned unless the declarativeNetRequestFeedback\npermission is present or tab-specific badge text was provided.\n\n#### Parameters\n\n  * details\n\nTabDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: string) => void\n\n    * result\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getBadgeTextColor()\n\nPromise Chrome 110+\n\n    \n    \n    chrome.action.getBadgeTextColor(  \n      details: TabDetails,  \n      callback?: function,  \n    )\n\nGets the text color of the action.\n\n#### Parameters\n\n  * details\n\nTabDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ColorArray) => void\n\n    * result\n\nColorArray\n\n#### Returns\n\n  * Promise<browserAction.ColorArray>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPopup()\n\nPromise\n\n    \n    \n    chrome.action.getPopup(  \n      details: TabDetails,  \n      callback?: function,  \n    )\n\nGets the html document set as the popup for this action.\n\n#### Parameters\n\n  * details\n\nTabDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: string) => void\n\n    * result\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getTitle()\n\nPromise\n\n    \n    \n    chrome.action.getTitle(  \n      details: TabDetails,  \n      callback?: function,  \n    )\n\nGets the title of the action.\n\n#### Parameters\n\n  * details\n\nTabDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: string) => void\n\n    * result\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getUserSettings()\n\nPromise Chrome 91+\n\n    \n    \n    chrome.action.getUserSettings(  \n      callback?: function,  \n    )\n\nReturns the user-specified settings relating to an extension's action.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (userSettings: UserSettings) => void\n\n    * userSettings\n\nUserSettings\n\n#### Returns\n\n  * Promise<UserSettings>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### isEnabled()\n\nPromise Chrome 110+\n\n    \n    \n    chrome.action.isEnabled(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nIndicates whether the extension action is enabled for a tab (or globally if no\n`tabId` is provided). Actions enabled using only `declarativeContent` always\nreturn false.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab for which you want check enabled status.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (isEnabled: boolean) => void\n\n    * isEnabled\n\nboolean\n\nTrue if the extension action is enabled.\n\n#### Returns\n\n  * Promise<boolean>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### openPopup()\n\nPromise Chrome 127+\n\n    \n    \n    chrome.action.openPopup(  \n      options?: OpenPopupOptions,  \n      callback?: function,  \n    )\n\nOpens the extension's popup. Between Chrome 118 and Chrome 126, this is only\navailable to policy installed extensions.\n\n#### Parameters\n\n  * options\n\nOpenPopupOptions optional\n\nSpecifies options for opening the popup.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setBadgeBackgroundColor()\n\nPromise\n\n    \n    \n    chrome.action.setBadgeBackgroundColor(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the background color for the badge.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * color\n\nstring | ColorArray\n\nAn array of four integers in the range [0,255] that make up the RGBA color of\nthe badge. For example, opaque red is `[255, 0, 0, 255]`. Can also be a string\nwith a CSS value, with opaque red being `#FF0000` or `#F00`.\n\n    * tabId\n\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets\nwhen the tab is closed.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setBadgeText()\n\nPromise\n\n    \n    \n    chrome.action.setBadgeText(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the badge text for the action. The badge is displayed on top of the icon.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * tabId\n\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets\nwhen the tab is closed.\n\n    * text\n\nstring optional\n\nAny number of characters can be passed, but only about four can fit in the\nspace. If an empty string (`''`) is passed, the badge text is cleared. If\n`tabId` is specified and `text` is null, the text for the specified tab is\ncleared and defaults to the global badge text.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setBadgeTextColor()\n\nPromise Chrome 110+\n\n    \n    \n    chrome.action.setBadgeTextColor(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the text color for the badge.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * color\n\nstring | ColorArray\n\nAn array of four integers in the range [0,255] that make up the RGBA color of\nthe badge. For example, opaque red is `[255, 0, 0, 255]`. Can also be a string\nwith a CSS value, with opaque red being `#FF0000` or `#F00`. Not setting this\nvalue will cause a color to be automatically chosen that will contrast with\nthe badge's background color so the text will be visible. Colors with alpha\nvalues equivalent to 0 will not be set and will return an error.\n\n    * tabId\n\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets\nwhen the tab is closed.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setIcon()\n\nPromise\n\n    \n    \n    chrome.action.setIcon(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the icon for the action. The icon can be specified either as the path to\nan image file or as the pixel data from a canvas element, or as dictionary of\neither one of those. Either the **path** or the **imageData** property must be\nspecified.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * imageData\n\nImageData | object optional\n\nEither an ImageData object or a dictionary {size -> ImageData} representing\nicon to be set. If the icon is specified as a dictionary, the actual image to\nbe used is chosen depending on screen's pixel density. If the number of image\npixels that fit into one screen space unit equals `scale`, then image with\nsize `scale` * n will be selected, where n is the size of the icon in the UI.\nAt least one image must be specified. Note that 'details.imageData = foo' is\nequivalent to 'details.imageData = {'16': foo}'\n\n    * path\n\nstring | object optional\n\nEither a relative image path or a dictionary {size -> relative image path}\npointing to icon to be set. If the icon is specified as a dictionary, the\nactual image to be used is chosen depending on screen's pixel density. If the\nnumber of image pixels that fit into one screen space unit equals `scale`,\nthen image with size `scale` * n will be selected, where n is the size of the\nicon in the UI. At least one image must be specified. Note that 'details.path\n= foo' is equivalent to 'details.path = {'16': foo}'\n\n    * tabId\n\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets\nwhen the tab is closed.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setPopup()\n\nPromise\n\n    \n    \n    chrome.action.setPopup(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the HTML document to be opened as a popup when the user clicks on the\naction's icon.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * popup\n\nstring\n\nThe relative path to the HTML file to show in a popup. If set to the empty\nstring (`''`), no popup is shown.\n\n    * tabId\n\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets\nwhen the tab is closed.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setTitle()\n\nPromise\n\n    \n    \n    chrome.action.setTitle(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the title of the action. This shows up in the tooltip.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * tabId\n\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets\nwhen the tab is closed.\n\n    * title\n\nstring\n\nThe string the action should display when moused over.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onClicked\n\n    \n    \n    chrome.action.onClicked.addListener(  \n      callback: function,  \n    )\n\nFired when an action icon is clicked. This event will not fire if the action\nhas a popup.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (tab: tabs.Tab) => void\n\n    * tab\n\ntabs.Tab\n\n### onUserSettingsChanged\n\nChrome 130+\n\n    \n    \n    chrome.action.onUserSettingsChanged.addListener(  \n      callback: function,  \n    )\n\nFired when user-specified settings relating to an extension's action change.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (change: UserSettingsChange) => void\n\n    * change\n\nUserSettingsChange\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/alarms": "#  chrome.alarms\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Chrome 120:** Starting in Chrome 120, the minimum alarm interval has been\nreduced from 1 minute to 30 seconds. For an alarm to trigger in 30 seconds,\nset `periodInMinutes: 0.5`.  \n**Chrome 117:** Starting in Chrome 117, the number of active alarms is limited\nto 500. Once this limit is reached, `chrome.alarms.create()` will fail. When\nusing a callback, `chrome.runtime.lastError` will be set. When using promises,\nthe promise will be rejected.\n\n## Description\n\nUse the `chrome.alarms` API to schedule code to run periodically or at a\nspecified time in the future.\n\n## Permissions\n\n`alarms`  \n\nTo use the `chrome.alarms` API, declare the `\"alarms\"` permission in the\nmanifest:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"alarms\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nTo ensure reliable behavior, it is helpful to understand how the API behaves.\n\n### Device sleep\n\nAlarms continue to run while a device is sleeping. However, an alarm will not\nwake up a device. When the device wakes up, any missed alarms will fire.\nRepeating alarms will fire at most once and then be rescheduled using the\nspecified period starting from when the device wakes, not taking into account\nany time that has already elapsed since the alarm was originally set to run.\n\n### Persistence\n\nAlarms generally persist until an extension is updated. However, this is not\nguaranteed, and alarms may be cleared when the browser is restarted.\nConsequently, consider setting a value in storage when an alarm is created,\nand then ensure it exists each time your service worker starts up. For\nexample:\n\n    \n    \n    const STORAGE_KEY = \"user-preference-alarm-enabled\";\n    \n    async function checkAlarmState() {\n      const { alarmEnabled } = await chrome.storage.get(STORAGE_KEY);\n    \n      if (alarmEnabled) {\n        const alarm = await chrome.alarms.get(\"my-alarm\");\n    \n        if (!alarm) {\n          await chrome.alarms.create({ periodInMinutes: 1 });\n        }\n      }\n    }\n    \n    checkAlarmState();\n    \n\n## Examples\n\nThe following examples show how to use and respond to an alarm. To try this\nAPI, install the Alarm API example from the chrome-extension-samples\nrepository.\n\n### Set an alarm\n\nThe following example sets an alarm in the service worker when the extension\nis installed:\n\nservice-worker.js:\n\n    \n    \n    chrome.runtime.onInstalled.addListener(async ({ reason }) => {\n      if (reason !== 'install') {\n        return;\n      }\n    \n      // Create an alarm so we have something to look at in the demo\n      await chrome.alarms.create('demo-default-alarm', {\n        delayInMinutes: 1,\n        periodInMinutes: 1\n      });\n    });\n    \n\n### Respond to an alarm\n\nThe following example sets the action toolbar icon based on the name of the\nalarm that went off.\n\nservice-worker.js:\n\n    \n    \n    chrome.alarms.onAlarm.addListener((alarm) => {\n      chrome.action.setIcon({\n        path: getIconPath(alarm.name),\n      });\n    });\n    \n\n## Types\n\n### Alarm\n\n#### Properties\n\n  * name\n\nstring\n\nName of this alarm.\n\n  * periodInMinutes\n\nnumber optional\n\nIf not null, the alarm is a repeating alarm and will fire again in\n`periodInMinutes` minutes.\n\n  * scheduledTime\n\nnumber\n\nTime at which this alarm was scheduled to fire, in milliseconds past the epoch\n(e.g. `Date.now() + n`). For performance reasons, the alarm may have been\ndelayed an arbitrary amount beyond this.\n\n### AlarmCreateInfo\n\n#### Properties\n\n  * delayInMinutes\n\nnumber optional\n\nLength of time in minutes after which the `onAlarm` event should fire.\n\n  * periodInMinutes\n\nnumber optional\n\nIf set, the onAlarm event should fire every `periodInMinutes` minutes after\nthe initial event specified by `when` or `delayInMinutes`. If not set, the\nalarm will only fire once.\n\n  * when\n\nnumber optional\n\nTime at which the alarm should fire, in milliseconds past the epoch (e.g.\n`Date.now() + n`).\n\n## Methods\n\n### clear()\n\nPromise\n\n    \n    \n    chrome.alarms.clear(  \n      name?: string,  \n      callback?: function,  \n    )\n\nClears the alarm with the given name.\n\n#### Parameters\n\n  * name\n\nstring optional\n\nThe name of the alarm to clear. Defaults to the empty string.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (wasCleared: boolean) => void\n\n    * wasCleared\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### clearAll()\n\nPromise\n\n    \n    \n    chrome.alarms.clearAll(  \n      callback?: function,  \n    )\n\nClears all alarms.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (wasCleared: boolean) => void\n\n    * wasCleared\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### create()\n\nPromise\n\n    \n    \n    chrome.alarms.create(  \n      name?: string,  \n      alarmInfo: AlarmCreateInfo,  \n      callback?: function,  \n    )\n\nCreates an alarm. Near the time(s) specified by `alarmInfo`, the `onAlarm`\nevent is fired. If there is another alarm with the same name (or no name if\nnone is specified), it will be cancelled and replaced by this alarm.\n\nIn order to reduce the load on the user's machine, Chrome limits alarms to at\nmost once every 30 seconds but may delay them an arbitrary amount more. That\nis, setting `delayInMinutes` or `periodInMinutes` to less than `0.5` will not\nbe honored and will cause a warning. `when` can be set to less than 30 seconds\nafter \"now\" without warning but won't actually cause the alarm to fire for at\nleast 30 seconds.\n\nTo help you debug your app or extension, when you've loaded it unpacked,\nthere's no limit to how often the alarm can fire.\n\n#### Parameters\n\n  * name\n\nstring optional\n\nOptional name to identify this alarm. Defaults to the empty string.\n\n  * alarmInfo\n\nAlarmCreateInfo\n\nDescribes when the alarm should fire. The initial time must be specified by\neither `when` or `delayInMinutes` (but not both). If `periodInMinutes` is set,\nthe alarm will repeat every `periodInMinutes` minutes after the initial event.\nIf neither `when` or `delayInMinutes` is set for a repeating alarm,\n`periodInMinutes` is used as the default for `delayInMinutes`.\n\n  * callback\n\nfunction optional\n\nChrome 111+\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### get()\n\nPromise\n\n    \n    \n    chrome.alarms.get(  \n      name?: string,  \n      callback?: function,  \n    )\n\nRetrieves details about the specified alarm.\n\n#### Parameters\n\n  * name\n\nstring optional\n\nThe name of the alarm to get. Defaults to the empty string.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (alarm?: Alarm) => void\n\n    * alarm\n\nAlarm optional\n\n#### Returns\n\n  * Promise<Alarm | undefined>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.alarms.getAll(  \n      callback?: function,  \n    )\n\nGets an array of all the alarms.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (alarms: Alarm[]) => void\n\n    * alarms\n\nAlarm[]\n\n#### Returns\n\n  * Promise<Alarm[]>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onAlarm\n\n    \n    \n    chrome.alarms.onAlarm.addListener(  \n      callback: function,  \n    )\n\nFired when an alarm has elapsed. Useful for event pages.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (alarm: Alarm) => void\n\n    * alarm\n\nAlarm\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/audio": "#  chrome.audio\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nThe `chrome.audio` API is provided to allow users to get information about and\ncontrol the audio devices attached to the system. This API is currently only\navailable in kiosk mode for ChromeOS.\n\n## Permissions\n\n`audio`  \n\n## Availability\n\nChrome 59+  ChromeOS only\n\n## Types\n\n### AudioDeviceInfo\n\n#### Properties\n\n  * deviceName\n\nstring\n\nDevice name.\n\n  * deviceType\n\nDeviceType\n\nType of the device.\n\n  * displayName\n\nstring\n\nThe user-friendly name (e.g. \"USB Microphone\").\n\n  * id\n\nstring\n\nThe unique identifier of the audio device.\n\n  * isActive\n\nboolean\n\nTrue if this is the current active device.\n\n  * level\n\nnumber\n\nThe sound level of the device, volume for output, gain for input.\n\n  * stableDeviceId\n\nstring optional\n\nThe stable/persisted device id string when available.\n\n  * streamType\n\nStreamType\n\nStream type associated with this device.\n\n### DeviceFilter\n\n#### Properties\n\n  * isActive\n\nboolean optional\n\nIf set, only audio devices whose active state matches this value will satisfy\nthe filter.\n\n  * streamTypes\n\nStreamType[] optional\n\nIf set, only audio devices whose stream type is included in this list will\nsatisfy the filter.\n\n### DeviceIdLists\n\n#### Properties\n\n  * input\n\nstring[] optional\n\nList of input devices specified by their ID.\n\nTo indicate input devices should be unaffected, leave this property unset.\n\n  * output\n\nstring[] optional\n\nList of output devices specified by their ID.\n\nTo indicate output devices should be unaffected, leave this property unset.\n\n### DeviceProperties\n\n#### Properties\n\n  * level\n\nnumber optional\n\nThe audio device's desired sound level. Defaults to the device's current sound\nlevel.\n\nIf used with audio input device, represents audio device gain.\n\nIf used with audio output device, represents audio device volume.\n\n### DeviceType\n\nAvailable audio device types.\n\n#### Enum\n\n\"HEADPHONE\"  \n\n\"MIC\"  \n\n\"USB\"  \n\n\"BLUETOOTH\"  \n\n\"HDMI\"  \n\n\"INTERNAL_SPEAKER\"  \n\n\"INTERNAL_MIC\"  \n\n\"FRONT_MIC\"  \n\n\"REAR_MIC\"  \n\n\"KEYBOARD_MIC\"  \n\n\"HOTWORD\"  \n\n\"LINEOUT\"  \n\n\"POST_MIX_LOOPBACK\"  \n\n\"POST_DSP_LOOPBACK\"  \n\n\"ALSA_LOOPBACK\"  \n\n\"OTHER\"  \n\n### LevelChangedEvent\n\n#### Properties\n\n  * deviceId\n\nstring\n\nID of device whose sound level has changed.\n\n  * level\n\nnumber\n\nThe device's new sound level.\n\n### MuteChangedEvent\n\n#### Properties\n\n  * isMuted\n\nboolean\n\nWhether or not the stream is now muted.\n\n  * streamType\n\nStreamType\n\nThe type of the stream for which the mute value changed. The updated mute\nvalue applies to all devices with this stream type.\n\n### StreamType\n\nType of stream an audio device provides.\n\n#### Enum\n\n\"INPUT\"  \n\n\"OUTPUT\"  \n\n## Methods\n\n### getDevices()\n\nPromise\n\n    \n    \n    chrome.audio.getDevices(  \n      filter?: DeviceFilter,  \n      callback?: function,  \n    )\n\nGets a list of audio devices filtered based on `filter`.\n\n#### Parameters\n\n  * filter\n\nDeviceFilter optional\n\nDevice properties by which to filter the list of returned audio devices. If\nthe filter is not set or set to `{}`, returned device list will contain all\navailable audio devices.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (devices: AudioDeviceInfo[]) => void\n\n    * devices\n\nAudioDeviceInfo[]\n\n#### Returns\n\n  * Promise<AudioDeviceInfo[]>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getMute()\n\nPromise\n\n    \n    \n    chrome.audio.getMute(  \n      streamType: StreamType,  \n      callback?: function,  \n    )\n\nGets the system-wide mute state for the specified stream type.\n\n#### Parameters\n\n  * streamType\n\nStreamType\n\nStream type for which mute state should be fetched.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (value: boolean) => void\n\n    * value\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setActiveDevices()\n\nPromise\n\n    \n    \n    chrome.audio.setActiveDevices(  \n      ids: DeviceIdLists,  \n      callback?: function,  \n    )\n\nSets lists of active input and/or output devices.\n\n#### Parameters\n\n  * ids\n\nDeviceIdLists\n\nSpecifies IDs of devices that should be active. If either the input or output\nlist is not set, devices in that category are unaffected.\n\nIt is an error to pass in a non-existent device ID.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setMute()\n\nPromise\n\n    \n    \n    chrome.audio.setMute(  \n      streamType: StreamType,  \n      isMuted: boolean,  \n      callback?: function,  \n    )\n\nSets mute state for a stream type. The mute state will apply to all audio\ndevices with the specified audio stream type.\n\n#### Parameters\n\n  * streamType\n\nStreamType\n\nStream type for which mute state should be set.\n\n  * isMuted\n\nboolean\n\nNew mute value.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setProperties()\n\nPromise\n\n    \n    \n    chrome.audio.setProperties(  \n      id: string,  \n      properties: DeviceProperties,  \n      callback?: function,  \n    )\n\nSets the properties for the input or output device.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * properties\n\nDeviceProperties\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onDeviceListChanged\n\n    \n    \n    chrome.audio.onDeviceListChanged.addListener(  \n      callback: function,  \n    )\n\nFired when audio devices change, either new devices being added, or existing\ndevices being removed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (devices: AudioDeviceInfo[]) => void\n\n    * devices\n\nAudioDeviceInfo[]\n\n### onLevelChanged\n\n    \n    \n    chrome.audio.onLevelChanged.addListener(  \n      callback: function,  \n    )\n\nFired when sound level changes for an active audio device.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (event: LevelChangedEvent) => void\n\n    * event\n\nLevelChangedEvent\n\n### onMuteChanged\n\n    \n    \n    chrome.audio.onMuteChanged.addListener(  \n      callback: function,  \n    )\n\nFired when the mute state of the audio input or output changes. Note that mute\nstate is system-wide and the new value applies to every audio device with\nspecified stream type.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (event: MuteChangedEvent) => void\n\n    * event\n\nMuteChangedEvent\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/bookmarks": "#  chrome.bookmarks\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.bookmarks` API to create, organize, and otherwise manipulate\nbookmarks. Also see Override Pages, which you can use to create a custom\nBookmark Manager page.\n\n![Clicking the star adds a\nbookmark](/static/docs/extensions/reference/api/images/bookmarks.png) Clicking\nthe star adds a bookmark.\n\n## Permissions\n\n`bookmarks`  \n\nYou must declare the \"bookmarks\" permission in the extension manifest to use\nthe bookmarks API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"bookmarks\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\n### Objects and properties\n\nBookmarks are organized in a tree, where each node in the tree is either a\nbookmark or a folder (sometimes called a _group_). Each node in the tree is\nrepresented by a bookmarks.BookmarkTreeNode object.\n\n`BookmarkTreeNode` properties are used throughout the `chrome.bookmarks` API.\nFor example, when you call bookmarks.create, you pass in the new node's parent\n(`parentId`), and, optionally, the node's `index`, `title`, and `url`\nproperties. See bookmarks.BookmarkTreeNode for information about the\nproperties a node can have.\n\n**Note:** You cannot use this API to add or remove entries in the root folder.\nYou also cannot rename, move, or remove the special \"Bookmarks Bar\" and \"Other\nBookmarks\" folders.\n\n### Examples\n\nThe following code creates a folder with the title \"Extension bookmarks\". The\nfirst argument to `create()` specifies properties for the new folder. The\nsecond argument defines a function to be executed after the folder is created.\n\n    \n    \n    chrome.bookmarks.create(\n      {'parentId': bookmarkBar.id, 'title': 'Extension bookmarks'},\n      function(newFolder) {\n        console.log(\"added folder: \" + newFolder.title);\n      },\n    );\n    \n\nThe next snippet creates a bookmark pointing to the developer documentation\nfor extensions. Since nothing bad will happen if creating the bookmark fails,\nthis code doesn't bother to define a callback function.\n\n    \n    \n    chrome.bookmarks.create({\n      'parentId': extensionsFolderId,\n      'title': 'Extensions doc',\n      'url': 'https://developer.chrome.com/docs/extensions',\n    });\n    \n\nTo try this API, install the Bookmarks API example from the chrome-extension-\nsamples repository.\n\n## Types\n\n### BookmarkTreeNode\n\nA node (either a bookmark or a folder) in the bookmark tree. Child nodes are\nordered within their parent folder.\n\n#### Properties\n\n  * children\n\nBookmarkTreeNode[] optional\n\nAn ordered list of children of this node.\n\n  * dateAdded\n\nnumber optional\n\nWhen this node was created, in milliseconds since the epoch (`new\nDate(dateAdded)`).\n\n  * dateGroupModified\n\nnumber optional\n\nWhen the contents of this folder last changed, in milliseconds since the\nepoch.\n\n  * dateLastUsed\n\nnumber optional\n\nChrome 114+\n\nWhen this node was last opened, in milliseconds since the epoch. Not set for\nfolders.\n\n  * folderType\n\nFolderType optional\n\nChrome 134+\n\nIf present, this is a folder that is added by the browser and that cannot be\nmodified by the user or the extension. Child nodes may be modified, if this\nnode does not have the `unmodifiable` property set. Omitted if the node can be\nmodified by the user and the extension (default).\n\nThere may be zero, one or multiple nodes of each folder type. A folder may be\nadded or removed by the browser, but not via the extensions API.\n\n  * id\n\nstring\n\nThe unique identifier for the node. IDs are unique within the current profile,\nand they remain valid even after the browser is restarted.\n\n  * index\n\nnumber optional\n\nThe 0-based position of this node within its parent folder.\n\n  * parentId\n\nstring optional\n\nThe `id` of the parent folder. Omitted for the root node.\n\n  * syncing\n\nboolean\n\nChrome 134+\n\nWhether this node is synced with the user's remote account storage by the\nbrowser. This can be used to distinguish between account and local-only\nversions of the same `FolderType`. The value of this property may change for\nan existing node, for example as a result of user action.\n\nNote: this reflects whether the node is saved to the browser's built-in\naccount provider. It is possible that a node could be synced via a third-\nparty, even if this value is false.\n\nFor managed nodes (nodes where `unmodifiable` is set to `true`), this property\nwill always be `false`.\n\n  * title\n\nstring\n\nThe text displayed for the node.\n\n  * unmodifiable\n\n\"managed\"  \n optional\n\nIndicates the reason why this node is unmodifiable. The `managed` value\nindicates that this node was configured by the system administrator or by the\ncustodian of a supervised user. Omitted if the node can be modified by the\nuser and the extension (default).\n\n  * url\n\nstring optional\n\nThe URL navigated to when a user clicks the bookmark. Omitted for folders.\n\n### BookmarkTreeNodeUnmodifiable\n\nChrome 44+\n\nIndicates the reason why this node is unmodifiable. The `managed` value\nindicates that this node was configured by the system administrator. Omitted\nif the node can be modified by the user and the extension (default).\n\n#### Value\n\n\"managed\"  \n\n### CreateDetails\n\nObject passed to the create() function.\n\n#### Properties\n\n  * index\n\nnumber optional\n\n  * parentId\n\nstring optional\n\nDefaults to the Other Bookmarks folder.\n\n  * title\n\nstring optional\n\n  * url\n\nstring optional\n\n### FolderType\n\nChrome 134+\n\nIndicates the type of folder.\n\n#### Enum\n\n\"bookmarks-bar\"  \nThe folder whose contents is displayed at the top of the browser window.\n\n\"other\"  \nBookmarks which are displayed in the full list of bookmarks on all platforms.\n\n\"mobile\"  \nBookmarks generally available on the user's mobile devices, but modifiable by\nextension or in the bookmarks manager.\n\n\"managed\"  \nA top-level folder that may be present if the system administrator or the\ncustodian of a supervised user has configured bookmarks.\n\n## Properties\n\n### MAX_SUSTAINED_WRITE_OPERATIONS_PER_MINUTE\n\nDeprecated\n\nBookmark write operations are no longer limited by Chrome.\n\n#### Value\n\n1000000  \n\n### MAX_WRITE_OPERATIONS_PER_HOUR\n\nDeprecated\n\nBookmark write operations are no longer limited by Chrome.\n\n#### Value\n\n1000000  \n\n## Methods\n\n### create()\n\nPromise\n\n    \n    \n    chrome.bookmarks.create(  \n      bookmark: CreateDetails,  \n      callback?: function,  \n    )\n\nCreates a bookmark or folder under the specified parentId. If url is NULL or\nmissing, it will be a folder.\n\n#### Parameters\n\n  * bookmark\n\nCreateDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: BookmarkTreeNode) => void\n\n    * result\n\nBookmarkTreeNode\n\n#### Returns\n\n  * Promise<BookmarkTreeNode>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### get()\n\nPromise\n\n    \n    \n    chrome.bookmarks.get(  \n      idOrIdList: string | [string, ...string[]],  \n      callback?: function,  \n    )\n\nRetrieves the specified BookmarkTreeNode(s).\n\n#### Parameters\n\n  * idOrIdList\n\nstring | [string, ...string[]]\n\nA single string-valued id, or an array of string-valued ids\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: BookmarkTreeNode[]) => void\n\n    * results\n\nBookmarkTreeNode[]\n\n#### Returns\n\n  * Promise<BookmarkTreeNode[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getChildren()\n\nPromise\n\n    \n    \n    chrome.bookmarks.getChildren(  \n      id: string,  \n      callback?: function,  \n    )\n\nRetrieves the children of the specified BookmarkTreeNode id.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: BookmarkTreeNode[]) => void\n\n    * results\n\nBookmarkTreeNode[]\n\n#### Returns\n\n  * Promise<BookmarkTreeNode[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getRecent()\n\nPromise\n\n    \n    \n    chrome.bookmarks.getRecent(  \n      numberOfItems: number,  \n      callback?: function,  \n    )\n\nRetrieves the recently added bookmarks.\n\n#### Parameters\n\n  * numberOfItems\n\nnumber\n\nThe maximum number of items to return.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: BookmarkTreeNode[]) => void\n\n    * results\n\nBookmarkTreeNode[]\n\n#### Returns\n\n  * Promise<BookmarkTreeNode[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getSubTree()\n\nPromise\n\n    \n    \n    chrome.bookmarks.getSubTree(  \n      id: string,  \n      callback?: function,  \n    )\n\nRetrieves part of the Bookmarks hierarchy, starting at the specified node.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe ID of the root of the subtree to retrieve.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: BookmarkTreeNode[]) => void\n\n    * results\n\nBookmarkTreeNode[]\n\n#### Returns\n\n  * Promise<BookmarkTreeNode[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getTree()\n\nPromise\n\n    \n    \n    chrome.bookmarks.getTree(  \n      callback?: function,  \n    )\n\nRetrieves the entire Bookmarks hierarchy.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: BookmarkTreeNode[]) => void\n\n    * results\n\nBookmarkTreeNode[]\n\n#### Returns\n\n  * Promise<BookmarkTreeNode[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### move()\n\nPromise\n\n    \n    \n    chrome.bookmarks.move(  \n      id: string,  \n      destination: object,  \n      callback?: function,  \n    )\n\nMoves the specified BookmarkTreeNode to the provided location.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * destination\n\nobject\n\n    * index\n\nnumber optional\n\n    * parentId\n\nstring optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: BookmarkTreeNode) => void\n\n    * result\n\nBookmarkTreeNode\n\n#### Returns\n\n  * Promise<BookmarkTreeNode>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### remove()\n\nPromise\n\n    \n    \n    chrome.bookmarks.remove(  \n      id: string,  \n      callback?: function,  \n    )\n\nRemoves a bookmark or an empty bookmark folder.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeTree()\n\nPromise\n\n    \n    \n    chrome.bookmarks.removeTree(  \n      id: string,  \n      callback?: function,  \n    )\n\nRecursively removes a bookmark folder.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### search()\n\nPromise\n\n    \n    \n    chrome.bookmarks.search(  \n      query: string | object,  \n      callback?: function,  \n    )\n\nSearches for BookmarkTreeNodes matching the given query. Queries specified\nwith an object produce BookmarkTreeNodes matching all specified properties.\n\n#### Parameters\n\n  * query\n\nstring | object\n\nEither a string of words and quoted phrases that are matched against bookmark\nURLs and titles, or an object. If an object, the properties `query`, `url`,\nand `title` may be specified and bookmarks matching all specified properties\nwill be produced.\n\n    * query\n\nstring optional\n\nA string of words and quoted phrases that are matched against bookmark URLs\nand titles.\n\n    * title\n\nstring optional\n\nThe title of the bookmark; matches verbatim.\n\n    * url\n\nstring optional\n\nThe URL of the bookmark; matches verbatim. Note that folders have no URL.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: BookmarkTreeNode[]) => void\n\n    * results\n\nBookmarkTreeNode[]\n\n#### Returns\n\n  * Promise<BookmarkTreeNode[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### update()\n\nPromise\n\n    \n    \n    chrome.bookmarks.update(  \n      id: string,  \n      changes: object,  \n      callback?: function,  \n    )\n\nUpdates the properties of a bookmark or folder. Specify only the properties\nthat you want to change; unspecified properties will be left unchanged.\n**Note:** Currently, only 'title' and 'url' are supported.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * changes\n\nobject\n\n    * title\n\nstring optional\n\n    * url\n\nstring optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: BookmarkTreeNode) => void\n\n    * result\n\nBookmarkTreeNode\n\n#### Returns\n\n  * Promise<BookmarkTreeNode>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onChanged\n\n    \n    \n    chrome.bookmarks.onChanged.addListener(  \n      callback: function,  \n    )\n\nFired when a bookmark or folder changes. **Note:** Currently, only title and\nurl changes trigger this.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, changeInfo: object) => void\n\n    * id\n\nstring\n\n    * changeInfo\n\nobject\n\n      * title\n\nstring\n\n      * url\n\nstring optional\n\n### onChildrenReordered\n\n    \n    \n    chrome.bookmarks.onChildrenReordered.addListener(  \n      callback: function,  \n    )\n\nFired when the children of a folder have changed their order due to the order\nbeing sorted in the UI. This is not called as a result of a move().\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, reorderInfo: object) => void\n\n    * id\n\nstring\n\n    * reorderInfo\n\nobject\n\n      * childIds\n\nstring[]\n\n### onCreated\n\n    \n    \n    chrome.bookmarks.onCreated.addListener(  \n      callback: function,  \n    )\n\nFired when a bookmark or folder is created.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, bookmark: BookmarkTreeNode) => void\n\n    * id\n\nstring\n\n    * bookmark\n\nBookmarkTreeNode\n\n### onImportBegan\n\n    \n    \n    chrome.bookmarks.onImportBegan.addListener(  \n      callback: function,  \n    )\n\nFired when a bookmark import session is begun. Expensive observers should\nignore onCreated updates until onImportEnded is fired. Observers should still\nhandle other notifications immediately.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onImportEnded\n\n    \n    \n    chrome.bookmarks.onImportEnded.addListener(  \n      callback: function,  \n    )\n\nFired when a bookmark import session is ended.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onMoved\n\n    \n    \n    chrome.bookmarks.onMoved.addListener(  \n      callback: function,  \n    )\n\nFired when a bookmark or folder is moved to a different parent folder.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, moveInfo: object) => void\n\n    * id\n\nstring\n\n    * moveInfo\n\nobject\n\n      * index\n\nnumber\n\n      * oldIndex\n\nnumber\n\n      * oldParentId\n\nstring\n\n      * parentId\n\nstring\n\n### onRemoved\n\n    \n    \n    chrome.bookmarks.onRemoved.addListener(  \n      callback: function,  \n    )\n\nFired when a bookmark or folder is removed. When a folder is removed\nrecursively, a single notification is fired for the folder, and none for its\ncontents.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, removeInfo: object) => void\n\n    * id\n\nstring\n\n    * removeInfo\n\nobject\n\n      * index\n\nnumber\n\n      * node\n\nBookmarkTreeNode\n\nChrome 48+\n\n      * parentId\n\nstring\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/browsingData": "#  chrome.browsingData\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.browsingData` API to remove browsing data from a user's local\nprofile.\n\n## Permissions\n\n`browsingData`  \n\nYou must declare the `\"browsingData\"` permission in the extension manifest to\nuse this API.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"browsingData\",\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nThe simplest use-case for this API is a a time-based mechanism for clearing a\nuser's browsing data. Your code should provide a timestamp which indicates the\nhistorical date after which the user's browsing data should be removed. This\ntimestamp is formatted as the number of milliseconds since the Unix epoch\n(which can be retrieved from a JavaScript `Date` object using the `getTime()`\nmethod).\n\nFor example, to clear all of a user's browsing data from the last week, you\nmight write code as follows:\n\n    \n    \n    var callback = function () {\n      // Do something clever here once data has been removed.\n    };\n    \n    var millisecondsPerWeek = 1000 * 60 * 60 * 24 * 7;\n    var oneWeekAgo = (new Date()).getTime() - millisecondsPerWeek;\n    chrome.browsingData.remove({\n      \"since\": oneWeekAgo\n    }, {\n      \"appcache\": true,\n      \"cache\": true,\n      \"cacheStorage\": true,\n      \"cookies\": true,\n      \"downloads\": true,\n      \"fileSystems\": true,\n      \"formData\": true,\n      \"history\": true,\n      \"indexedDB\": true,\n      \"localStorage\": true,\n      \"passwords\": true,\n      \"serviceWorkers\": true,\n      \"webSQL\": true\n    }, callback);\n    \n\nThe `chrome.browsingData.remove()` method lets you remove various types of\nbrowsing data with a single call, and will be much faster than calling\nmultiple more specific methods. If, however, you only want to clear one\nspecific type of browsing data (cookies, for example), the more granular\nmethods offer a readable alternative to a call filled with JSON.\n\n    \n    \n    var callback = function () {\n      // Do something clever here once data has been removed.\n    };\n    \n    var millisecondsPerWeek = 1000 * 60 * 60 * 24 * 7;\n    var oneWeekAgo = (new Date()).getTime() - millisecondsPerWeek;\n    chrome.browsingData.removeCookies({\n      \"since\": oneWeekAgo\n    }, callback);\n    \n\nIf the user is syncing their data, `chrome.browsingData.remove()` may\nautomatically rebuild the cookie for the Sync account after clearing it. This\nis to ensure that Sync can continue working, so that the data can be\neventually deleted on the server. However the more specific\n`chrome.browsingData.removeCookies()` can be used to clear the cookie for the\nSync account, and Sync will be paused in this case.\n\n**Important:** Removing browsing data involves a good deal of heavy lifting in\nthe background, and can take _tens of seconds_ to complete, depending on a\nuser's profile. You should use either the returned promise or the callback to\nkeep your users up to date on the removal's status.\n\n### Specific origins\n\nTo remove data for a specific origin or to exclude a set of origins from\ndeletion, you can use the `RemovalOptions.origins` and\n`RemovalOptions.excludeOrigins` parameters. They can only be applied to\ncookies, cache, and storage (CacheStorage, FileSystems, IndexedDB,\nLocalStorage, ServiceWorkers, and WebSQL).\n\n    \n    \n    chrome.browsingData.remove({\n      \"origins\": [\"https://www.example.com\"]\n    }, {\n      \"cacheStorage\": true,\n      \"cookies\": true,\n      \"fileSystems\": true,\n      \"indexedDB\": true,\n      \"localStorage\": true,\n      \"serviceWorkers\": true,\n      \"webSQL\": true\n    }, callback);\n    \n\n**Important:** As cookies are scoped more broadly than other types of storage,\ndeleting cookies for an origin will delete all cookies of the registrable\ndomain. For example, deleting data for `https://www.example.com` will delete\ncookies with a domain of `.example.com` as well.\n\n### Origin types\n\nAdding an `originTypes` property to the APIs options object lets you specify\nwhich types of origins ought to be effected. Origins are divided into three\ncategories:\n\n  * `unprotectedWeb` covers the general case of websites that users visit without taking any special action. If you don't specify an `originTypes`, the API defaults to removing data from unprotected web origins.\n  * `protectedWeb` covers those web origins that have been installed as hosted applications. Installing Angry Birds, for example, protects the origin `https://chrome.angrybirds.com`, and removes it from the `unprotectedWeb` category. Be careful when triggering deletion of data for these origins: make sure your users know what they're getting, as this will irrevocably remove their game data. No one wants to knock tiny pig houses over more often than necessary.\n  * `extension` covers origins under the `chrome-extensions:` scheme. Removing extension data is, again, something you should be very careful about.\n\nWe could adjust the previous example to remove only data from protected\nwebsites as follows:\n\n    \n    \n    var callback = function () {\n      // Do something clever here once data has been removed.\n    };\n    \n    var millisecondsPerWeek = 1000 * 60 * 60 * 24 * 7;\n    var oneWeekAgo = (new Date()).getTime() - millisecondsPerWeek;\n    chrome.browsingData.remove({\n      \"since\": oneWeekAgo,\n      \"originTypes\": {\n        \"protectedWeb\": true\n      }\n    }, {\n      \"appcache\": true,\n      \"cache\": true,\n      \"cacheStorage\": true,\n      \"cookies\": true,\n      \"downloads\": true,\n      \"fileSystems\": true,\n      \"formData\": true,\n      \"history\": true,\n      \"indexedDB\": true,\n      \"localStorage\": true,\n      \"passwords\": true,\n      \"serviceWorkers\": true,\n      \"webSQL\": true\n    }, callback);\n    \n\n**Warning:** Be careful with the `protectedWeb` and `extension` origin types.\nThese are destructive operations that may surprise your users if they're not\nwell-informed about what to expect when your extension removes data on their\nbehalf.\n\n## Examples\n\nTo try this API, install the browsingData API example from the chrome-\nextension-samples repository.\n\n## Types\n\n### DataTypeSet\n\nA set of data types. Missing data types are interpreted as `false`.\n\n#### Properties\n\n  * appcache\n\nboolean optional\n\nWebsites' appcaches.\n\n  * cache\n\nboolean optional\n\nThe browser's cache.\n\n  * cacheStorage\n\nboolean optional\n\nChrome 72+\n\nCache storage\n\n  * cookies\n\nboolean optional\n\nThe browser's cookies.\n\n  * downloads\n\nboolean optional\n\nThe browser's download list.\n\n  * fileSystems\n\nboolean optional\n\nWebsites' file systems.\n\n  * formData\n\nboolean optional\n\nThe browser's stored form data.\n\n  * history\n\nboolean optional\n\nThe browser's history.\n\n  * indexedDB\n\nboolean optional\n\nWebsites' IndexedDB data.\n\n  * localStorage\n\nboolean optional\n\nWebsites' local storage data.\n\n  * passwords\n\nboolean optional\n\nStored passwords.\n\n  * pluginData\n\nboolean optional\n\nDeprecated since Chrome 88\n\nSupport for Flash has been removed. This data type will be ignored.\n\nPlugins' data.\n\n  * serverBoundCertificates\n\nboolean optional\n\nDeprecated since Chrome 76\n\nSupport for server-bound certificates has been removed. This data type will be\nignored.\n\nServer-bound certificates.\n\n  * serviceWorkers\n\nboolean optional\n\nService Workers.\n\n  * webSQL\n\nboolean optional\n\nWebsites' WebSQL data.\n\n### RemovalOptions\n\nOptions that determine exactly what data will be removed.\n\n#### Properties\n\n  * excludeOrigins\n\nstring[] optional\n\nChrome 74+\n\nWhen present, data for origins in this list is excluded from deletion. Can't\nbe used together with `origins`. Only supported for cookies, storage and\ncache. Cookies are excluded for the whole registrable domain.\n\n  * originTypes\n\nobject optional\n\nAn object whose properties specify which origin types ought to be cleared. If\nthis object isn't specified, it defaults to clearing only \"unprotected\"\norigins. Please ensure that you _really_ want to remove application data\nbefore adding 'protectedWeb' or 'extensions'.\n\n    * extension\n\nboolean optional\n\nExtensions and packaged applications a user has installed (be _really_\ncareful!).\n\n    * protectedWeb\n\nboolean optional\n\nWebsites that have been installed as hosted applications (be careful!).\n\n    * unprotectedWeb\n\nboolean optional\n\nNormal websites.\n\n  * origins\n\n[string, ...string[]] optional\n\nChrome 74+\n\nWhen present, only data for origins in this list is deleted. Only supported\nfor cookies, storage and cache. Cookies are cleared for the whole registrable\ndomain.\n\n  * since\n\nnumber optional\n\nRemove data accumulated on or after this date, represented in milliseconds\nsince the epoch (accessible via the `getTime` method of the JavaScript `Date`\nobject). If absent, defaults to 0 (which would remove all browsing data).\n\n## Methods\n\n### remove()\n\nPromise\n\n    \n    \n    chrome.browsingData.remove(  \n      options: RemovalOptions,  \n      dataToRemove: DataTypeSet,  \n      callback?: function,  \n    )\n\nClears various types of browsing data stored in a user's profile.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * dataToRemove\n\nDataTypeSet\n\nThe set of data types to remove.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeAppcache()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeAppcache(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears websites' appcache data.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeCache()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeCache(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears the browser's cache.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeCacheStorage()\n\nPromise Chrome 72+\n\n    \n    \n    chrome.browsingData.removeCacheStorage(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears websites' cache storage data.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeCookies()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeCookies(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears the browser's cookies and server-bound certificates modified within a\nparticular timeframe.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeDownloads()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeDownloads(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears the browser's list of downloaded files (_not_ the downloaded files\nthemselves).\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeFileSystems()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeFileSystems(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears websites' file system data.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeFormData()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeFormData(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears the browser's stored form data (autofill).\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeHistory()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeHistory(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears the browser's history.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeIndexedDB()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeIndexedDB(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears websites' IndexedDB data.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeLocalStorage()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeLocalStorage(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears websites' local storage data.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removePasswords()\n\nPromise\n\n    \n    \n    chrome.browsingData.removePasswords(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears the browser's stored passwords.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removePluginData()\n\nPromise  Deprecated since Chrome 88\n\n    \n    \n    chrome.browsingData.removePluginData(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nSupport for Flash has been removed. This function has no effect.\n\nClears plugins' data.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeServiceWorkers()\n\nPromise Chrome 72+\n\n    \n    \n    chrome.browsingData.removeServiceWorkers(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears websites' service workers.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeWebSQL()\n\nPromise\n\n    \n    \n    chrome.browsingData.removeWebSQL(  \n      options: RemovalOptions,  \n      callback?: function,  \n    )\n\nClears websites' WebSQL data.\n\n#### Parameters\n\n  * options\n\nRemovalOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### settings()\n\nPromise\n\n    \n    \n    chrome.browsingData.settings(  \n      callback?: function,  \n    )\n\nReports which types of data are currently selected in the 'Clear browsing\ndata' settings UI. Note: some of the data types included in this API are not\navailable in the settings UI, and some UI settings control more than one data\ntype listed here.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: object) => void\n\n    * result\n\nobject\n\n      * dataRemovalPermitted\n\nDataTypeSet\n\nAll of the types will be present in the result, with values of `true` if they\nare permitted to be removed (e.g., by enterprise policy) and `false` if not.\n\n      * dataToRemove\n\nDataTypeSet\n\nAll of the types will be present in the result, with values of `true` if they\nare both selected to be removed and permitted to be removed, otherwise\n`false`.\n\n      * options\n\nRemovalOptions\n\n#### Returns\n\n  * Promise<object>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/certificateProvider": "#  chrome.certificateProvider\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse this API to expose certificates to the platform which can use these\ncertificates for TLS authentications.\n\n## Permissions\n\n`certificateProvider`  \n\n## Availability\n\nChrome 46+  ChromeOS only\n\n## Concepts and usage\n\nTypical usage of this API to expose client certificates to ChromeOS follows\nthese steps:\n\n  * The Extension registers for the events `onCertificatesUpdateRequested` and `onSignatureRequested`.\n  * The Extension calls `setCertificates()` to provide the initial list of certificates after the initialization.\n  * The Extension monitors the changes in the list of available certificates and calls `setCertificates()` to notify the browser about every such change.\n  * During a TLS handshake, the browser receives a client certificate request. With an `onCertificatesUpdateRequested` event, the browser asks the Extension to report all certificates that it currently provides.\n  * The Extension reports back with the currently available certificates, using the `setCertificates()` method.\n  * The browser matches all available certificates with the client certificate request from the remote host. The matches are presented to the user in a selection dialog.\n  * The user can select a certificate and thereby approve the authentication or abort the authentication.\n\n![Certificate selection\ndialog](/static/docs/extensions/reference/api/images/certificate_provider_selection_dialog.png)\nCertificate selection dialog.\n\n  * If the user aborts the authentication or no certificate matched the request, the TLS client authentication is aborted.\n  * Otherwise, if the user approves the authentication with a certificate provided by this Extension, the browser requests the Extension to sign the data to continue the TLS handshake. The request is sent as a `onSignatureRequested` event.\n  * This event contains input data, declares which algorithm has to be used to generate the signature, and refers to one of the certificates that were reported by this Extension. The Extension must create a signature for the given data using the private key associated with the referenced certificate. Creating the signature might require prepending a DigestInfo and padding the result before the actual signing.\n  * The Extension sends back the signature to the browser using the `reportSignature()` method. If the signature couldn't be calculated, the method has to be called without signature.\n  * If the signature was provided, the browser completes the TLS handshake.\n\nThe actual sequence of steps can be different. For example, the user will not\nbe asked to select a certificate if the enterprise policy to automatically\nselect a certificate is used (see `AutoSelectCertificateForUrls` and Chrome\npolicies for users).\n\nIn the Extension, this can look similar to the following snippet:\n\n    \n    \n    function collectAvailableCertificates() {\n      // Return all certificates that this Extension can currently provide.\n      // For example:\n      return [{\n        certificateChain: [new Uint8Array(...)],\n        supportedAlgorithms: ['RSASSA_PKCS1_v1_5_SHA256']\n      }];\n    }\n    \n    // The Extension calls this function every time the currently available list of\n    // certificates changes, and also once after the Extension's initialization.\n    function onAvailableCertificatesChanged() {\n      chrome.certificateProvider.setCertificates({\n        clientCertificates: collectAvailableCertificates()\n      });\n    }\n    \n    function handleCertificatesUpdateRequest(request) {\n      // Report the currently available certificates as a response to the request\n      // event. This is important for supporting the case when the Extension is\n      // unable to detect the changes proactively.\n      chrome.certificateProvider.setCertificates({\n        certificatesRequestId: request.certificatesRequestId,\n        clientCertificates: collectAvailableCertificates()\n      });\n    }\n    \n    // Returns a private key handle for the given DER-encoded certificate.\n    // |certificate| is an ArrayBuffer.\n    function getPrivateKeyHandle(certificate) {...}\n    \n    // Digests and signs |input| with the given private key. |input| is an\n    // ArrayBuffer. |algorithm| is an Algorithm.\n    // Returns the signature as ArrayBuffer.\n    function signUnhashedData(privateKey, input, algorithm) {...}\n    \n    function handleSignatureRequest(request) {\n      // Look up the handle to the private key of |request.certificate|.\n      const key = getPrivateKeyHandle(request.certificate);\n      if (!key) {\n        // Handle if the key isn't available.\n        console.error('Key for requested certificate no available.');\n    \n        // Abort the request by reporting the error to the API.\n        chrome.certificateProvider.reportSignature({\n          signRequestId: request.signRequestId,\n          error: 'GENERAL_ERROR'\n        });\n        return;\n      }\n    \n      const signature = signUnhashedData(key, request.input, request.algorithm);\n      chrome.certificateProvider.reportSignature({\n        signRequestId: request.signRequestId,\n        signature: signature\n      });\n    }\n    \n    chrome.certificateProvider.onCertificatesUpdateRequested.addListener(\n        handleCertificatesUpdateRequest);\n    chrome.certificateProvider.onSignatureRequested.addListener(\n        handleSignatureRequest);\n    \n\n## Types\n\n### Algorithm\n\nChrome 86+\n\nTypes of supported cryptographic signature algorithms.\n\n#### Enum\n\n\"RSASSA_PKCS1_v1_5_MD5_SHA1\"  \nSpecifies the RSASSA PKCS#1 v1.5 signature algorithm with the MD5-SHA-1\nhashing. The extension must not prepend a DigestInfo prefix but only add\nPKCS#1 padding. This algorithm is deprecated and will never be requested by\nChrome as of version 109.\n\n\"RSASSA_PKCS1_v1_5_SHA1\"  \nSpecifies the RSASSA PKCS#1 v1.5 signature algorithm with the SHA-1 hash\nfunction.\n\n\"RSASSA_PKCS1_v1_5_SHA256\"  \nSpecifies the RSASSA PKCS#1 v1.5 signature algorithm with the SHA-256 hashing\nfunction.\n\n\"RSASSA_PKCS1_v1_5_SHA384\"  \nSpecifies the RSASSA PKCS#1 v1.5 signature algorithm with the SHA-384 hashing\nfunction.\n\n\"RSASSA_PKCS1_v1_5_SHA512\"  \nSpecifies the RSASSA PKCS#1 v1.5 signature algorithm with the SHA-512 hashing\nfunction.\n\n\"RSASSA_PSS_SHA256\"  \nSpecifies the RSASSA PSS signature algorithm with the SHA-256 hashing\nfunction, MGF1 mask generation function and the salt of the same size as the\nhash.\n\n\"RSASSA_PSS_SHA384\"  \nSpecifies the RSASSA PSS signature algorithm with the SHA-384 hashing\nfunction, MGF1 mask generation function and the salt of the same size as the\nhash.\n\n\"RSASSA_PSS_SHA512\"  \nSpecifies the RSASSA PSS signature algorithm with the SHA-512 hashing\nfunction, MGF1 mask generation function and the salt of the same size as the\nhash.\n\n### CertificateInfo\n\n#### Properties\n\n  * certificate\n\nArrayBuffer\n\nMust be the DER encoding of a X.509 certificate. Currently, only certificates\nof RSA keys are supported.\n\n  * supportedHashes\n\nHash[]\n\nMust be set to all hashes supported for this certificate. This extension will\nonly be asked for signatures of digests calculated with one of these hash\nalgorithms. This should be in order of decreasing hash preference.\n\n### CertificatesUpdateRequest\n\nChrome 86+\n\n#### Properties\n\n  * certificatesRequestId\n\nnumber\n\nRequest identifier to be passed to `setCertificates`.\n\n### ClientCertificateInfo\n\nChrome 86+\n\n#### Properties\n\n  * certificateChain\n\nArrayBuffer[]\n\nThe array must contain the DER encoding of the X.509 client certificate as its\nfirst element.\n\nThis must include exactly one certificate.\n\n  * supportedAlgorithms\n\nAlgorithm[]\n\nAll algorithms supported for this certificate. The extension will only be\nasked for signatures using one of these algorithms.\n\n### Error\n\nChrome 86+\n\nTypes of errors that the extension can report.\n\n#### Value\n\n\"GENERAL_ERROR\"  \n\n### Hash\n\nDeprecated. Replaced by `Algorithm`.\n\n#### Enum\n\n\"MD5_SHA1\"  \nSpecifies the MD5 and SHA1 hashing algorithms.\n\n\"SHA1\"  \nSpecifies the SHA1 hashing algorithm.\n\n\"SHA256\"  \nSpecifies the SHA256 hashing algorithm.\n\n\"SHA384\"  \nSpecifies the SHA384 hashing algorithm.\n\n\"SHA512\"  \nSpecifies the SHA512 hashing algorithm.\n\n### PinRequestErrorType\n\nChrome 57+\n\nThe types of errors that can be presented to the user through the requestPin\nfunction.\n\n#### Enum\n\n\"INVALID_PIN\"  \nSpecifies the PIN is invalid.\n\n\"INVALID_PUK\"  \nSpecifies the PUK is invalid.\n\n\"MAX_ATTEMPTS_EXCEEDED\"  \nSpecifies the maximum attempt number has been exceeded.\n\n\"UNKNOWN_ERROR\"  \nSpecifies that the error cannot be represented by the above types.\n\n### PinRequestType\n\nChrome 57+\n\nThe type of code being requested by the extension with requestPin function.\n\n#### Enum\n\n\"PIN\"  \nSpecifies the requested code is a PIN.\n\n\"PUK\"  \nSpecifies the requested code is a PUK.\n\n### PinResponseDetails\n\nChrome 57+\n\n#### Properties\n\n  * userInput\n\nstring optional\n\nThe code provided by the user. Empty if user closed the dialog or some other\nerror occurred.\n\n### ReportSignatureDetails\n\nChrome 86+\n\n#### Properties\n\n  * error\n\n\"GENERAL_ERROR\"  \n optional\n\nError that occurred while generating the signature, if any.\n\n  * signRequestId\n\nnumber\n\nRequest identifier that was received via the `onSignatureRequested` event.\n\n  * signature\n\nArrayBuffer optional\n\nThe signature, if successfully generated.\n\n### RequestPinDetails\n\nChrome 57+\n\n#### Properties\n\n  * attemptsLeft\n\nnumber optional\n\nThe number of attempts left. This is provided so that any UI can present this\ninformation to the user. Chrome is not expected to enforce this, instead\nstopPinRequest should be called by the extension with errorType =\nMAX_ATTEMPTS_EXCEEDED when the number of pin requests is exceeded.\n\n  * errorType\n\nPinRequestErrorType optional\n\nThe error template displayed to the user. This should be set if the previous\nrequest failed, to notify the user of the failure reason.\n\n  * requestType\n\nPinRequestType optional\n\nThe type of code requested. Default is PIN.\n\n  * signRequestId\n\nnumber\n\nThe ID given by Chrome in SignRequest.\n\n### SetCertificatesDetails\n\nChrome 86+\n\n#### Properties\n\n  * certificatesRequestId\n\nnumber optional\n\nWhen called in response to `onCertificatesUpdateRequested`, should contain the\nreceived `certificatesRequestId` value. Otherwise, should be unset.\n\n  * clientCertificates\n\nClientCertificateInfo[]\n\nList of currently available client certificates.\n\n  * error\n\n\"GENERAL_ERROR\"  \n optional\n\nError that occurred while extracting the certificates, if any. This error will\nbe surfaced to the user when appropriate.\n\n### SignatureRequest\n\nChrome 86+\n\n#### Properties\n\n  * algorithm\n\nAlgorithm\n\nSignature algorithm to be used.\n\n  * certificate\n\nArrayBuffer\n\nThe DER encoding of a X.509 certificate. The extension must sign `input` using\nthe associated private key.\n\n  * input\n\nArrayBuffer\n\nData to be signed. Note that the data is not hashed.\n\n  * signRequestId\n\nnumber\n\nRequest identifier to be passed to `reportSignature`.\n\n### SignRequest\n\n#### Properties\n\n  * certificate\n\nArrayBuffer\n\nThe DER encoding of a X.509 certificate. The extension must sign `digest`\nusing the associated private key.\n\n  * digest\n\nArrayBuffer\n\nThe digest that must be signed.\n\n  * hash\n\nHash\n\nRefers to the hash algorithm that was used to create `digest`.\n\n  * signRequestId\n\nnumber\n\nChrome 57+\n\nThe unique ID to be used by the extension should it need to call a method that\nrequires it, e.g. requestPin.\n\n### StopPinRequestDetails\n\nChrome 57+\n\n#### Properties\n\n  * errorType\n\nPinRequestErrorType optional\n\nThe error template. If present it is displayed to user. Intended to contain\nthe reason for stopping the flow if it was caused by an error, e.g.\nMAX_ATTEMPTS_EXCEEDED.\n\n  * signRequestId\n\nnumber\n\nThe ID given by Chrome in SignRequest.\n\n## Methods\n\n### reportSignature()\n\nPromise Chrome 86+\n\n    \n    \n    chrome.certificateProvider.reportSignature(  \n      details: ReportSignatureDetails,  \n      callback?: function,  \n    )\n\nShould be called as a response to `onSignatureRequested`.\n\nThe extension must eventually call this function for every\n`onSignatureRequested` event; the API implementation will stop waiting for\nthis call after some time and respond with a timeout error when this function\nis called.\n\n#### Parameters\n\n  * details\n\nReportSignatureDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### requestPin()\n\nPromise Chrome 57+\n\n    \n    \n    chrome.certificateProvider.requestPin(  \n      details: RequestPinDetails,  \n      callback?: function,  \n    )\n\nRequests the PIN from the user. Only one ongoing request at a time is allowed.\nThe requests issued while another flow is ongoing are rejected. It's the\nextension's responsibility to try again later if another flow is in progress.\n\n#### Parameters\n\n  * details\n\nRequestPinDetails\n\nContains the details about the requested dialog.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details?: PinResponseDetails) => void\n\n    * details\n\nPinResponseDetails optional\n\n#### Returns\n\n  * Promise<PinResponseDetails | undefined>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setCertificates()\n\nPromise Chrome 86+\n\n    \n    \n    chrome.certificateProvider.setCertificates(  \n      details: SetCertificatesDetails,  \n      callback?: function,  \n    )\n\nSets a list of certificates to use in the browser.\n\nThe extension should call this function after initialization and on every\nchange in the set of currently available certificates. The extension should\nalso call this function in response to `onCertificatesUpdateRequested` every\ntime this event is received.\n\n#### Parameters\n\n  * details\n\nSetCertificatesDetails\n\nThe certificates to set. Invalid certificates will be ignored.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### stopPinRequest()\n\nPromise Chrome 57+\n\n    \n    \n    chrome.certificateProvider.stopPinRequest(  \n      details: StopPinRequestDetails,  \n      callback?: function,  \n    )\n\nStops the pin request started by the `requestPin` function.\n\n#### Parameters\n\n  * details\n\nStopPinRequestDetails\n\nContains the details about the reason for stopping the request flow.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onCertificatesUpdateRequested\n\nChrome 86+\n\n    \n    \n    chrome.certificateProvider.onCertificatesUpdateRequested.addListener(  \n      callback: function,  \n    )\n\nThis event fires if the certificates set via `setCertificates` are\ninsufficient or the browser requests updated information. The extension must\ncall `setCertificates` with the updated list of certificates and the received\n`certificatesRequestId`.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (request: CertificatesUpdateRequest) => void\n\n    * request\n\nCertificatesUpdateRequest\n\n### onSignatureRequested\n\nChrome 86+\n\n    \n    \n    chrome.certificateProvider.onSignatureRequested.addListener(  \n      callback: function,  \n    )\n\nThis event fires every time the browser needs to sign a message using a\ncertificate provided by this extension via `setCertificates`.\n\nThe extension must sign the input data from `request` using the appropriate\nalgorithm and private key and return it by calling `reportSignature` with the\nreceived `signRequestId`.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (request: SignatureRequest) => void\n\n    * request\n\nSignatureRequest\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/commands": "#  chrome.commands\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the commands API to add keyboard shortcuts that trigger actions in your\nextension, for example, an action to open the browser action or send a command\nto the extension.\n\n## Manifest\n\nThe following keys must be declared in the manifest to use this API.\n\n`\"commands\"`  \n\n## Concepts and usage\n\nThe Commands API allows extension developers to define specific commands, and\nbind them to a default key combination. Each command an extension accepts must\nbe declared as properties of the `\"commands\"` object in the extension's\nmanifest.\n\nThe property key is used as the command's name. Command objects can take two\nproperties.\n\n`suggested_key`\n\n    \n\nAn optional property that declares default keyboard shortcuts for the command.\nIf omitted, the command will be unbound. This property can either take a\nstring or an object value.\n\n  * **A string value** specifies the default keyboard shortcut that should be used across all platforms.\n\n  * **An object value** allows the extension developer to customize the keyboard shortcut for each platform. When providing platform-specific shortcuts, valid object properties are `default`, `chromeos`, `linux`, `mac`, and `windows`.\n\nSee Key combination requirements for additional details.\n\n`description`\n\n    \n\nA string used to provide the user with a short description of the command's\npurpose. This string appears in extension keyboard shortcut management UI.\nDescriptions are required for standard commands, but are ignored for Action\ncommands.\n\nAn extension can have many commands, but may specify at most four suggested\nkeyboard shortcuts. The user can manually add more shortcuts from the\n`chrome://extensions/shortcuts` dialog.\n\n### Supported Keys\n\nThe following keys are usable command shortcuts. Key definitions are case\nsensitive. Attempting to load an extension with an incorrectly cased key will\nresult in a manifest parse error at installation time.\n\nAlpha keys\n\n    `A`  `Z`\nNumeric keys\n\n    `0`  `9`\nStandard key strings\n\n    \n\nGeneral`Comma`, `Period`, `Home`, `End`, `PageUp`, `PageDown`, `Space`,\n`Insert`, `Delete`\n\n    \n\nArrow keys`Up`, `Down`, `Left`, `Right`\n\n    \n\nMedia Keys`MediaNextTrack`, `MediaPlayPause`, `MediaPrevTrack`, `MediaStop`\n\nModifier key strings\n\n    \n\n`Ctrl`, `Alt`, `Shift`, `MacCtrl` (macOS only), `Command` (macOS only),\n`Search` (ChromeOS only)\n\n### Key combination requirements\n\n  * Extension command shortcuts must include either `Ctrl` or `Alt`.\n\n    * Modifiers **cannot** be used in combination with Media Keys.\n\n    * On many macOS keyboards, `Alt` refers to the Option key.\n\n    * On macOS, `Command` or `MacCtrl` can also be used in place of `Ctrl` or `Alt` (see next bullet point).\n\n  * On macOS `Ctrl` is automatically converted into `Command`.\n\n    * `Command` can also be used in the `\"mac\"` shortcut to explicitly refer to the Command key.\n\n    * To use the Control key on macOS, replace `Ctrl` with `MacCtrl` when defining the `\"mac\"` shortcut.\n\n    * Using `MacCtrl` in the combination for another platform will cause a validation error and prevent the extension from being installed.\n\n  * `Shift` is an optional modifier on all platforms.\n\n  * `Search` is an optional modifier exclusive to ChromeOS.\n\n  * Certain operating system and Chrome shortcuts (e.g. window management) always take priority over Extension command shortcuts and cannot be overridden.\n\n**Note:** Key combinations that involve `Ctrl+Alt` are not permitted in order\nto avoid conflicts with the `AltGr` key.\n\n### Handle command events\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"commands\": {\n        \"run-foo\": {\n          \"suggested_key\": {\n            \"default\": \"Ctrl+Shift+Y\",\n            \"mac\": \"Command+Shift+Y\"\n          },\n          \"description\": \"Run \\\"foo\\\" on the current page.\"\n        },\n        \"_execute_action\": {\n          \"suggested_key\": {\n            \"windows\": \"Ctrl+Shift+Y\",\n            \"mac\": \"Command+Shift+Y\",\n            \"chromeos\": \"Ctrl+Shift+U\",\n            \"linux\": \"Ctrl+Shift+J\"\n          }\n        }\n      },\n      ...\n    }\n    \n\nIn your service worker, you can bind a handler to each of the commands defined\nin the manifest using `onCommand.addListener`. For example:\n\nservice-worker.js:\n\n    \n    \n    chrome.commands.onCommand.addListener((command) => {\n      console.log(`Command: ${command}`);\n    });\n    \n\n### Action commands\n\nThe `_execute_action` (Manifest V3), `_execute_browser_action` (Manifest V2),\nand `_execute_page_action` (Manifest V2) commands are reserved for the action\nof trigger your action, browser action, or page action respectively. These\ncommands don't dispatch command.onCommand events like standard commands.\n\nIf you need to take action based on your popup opening, consider listening for\na DOMContentLoaded event inside your popup's JavaScript.\n\n### Scope\n\nBy default, commands are scoped to the Chrome browser. This means that when\nthe browser does not have focus, command shortcuts are inactive. Beginning in\nChrome 35, extension developers can optionally mark a command as \"global\".\nGlobal commands also work while Chrome _does not_ have focus.\n\n**Note:** ChromeOS does not support global commands.\n\nKeyboard shortcut suggestions for global commands are limited to\n`Ctrl+Shift+[0..9]`. This is a protective measure to minimize the risk of\noverriding shortcuts in other applications since if, for example, `Alt+P` were\nto be allowed as global, the keyboard shortcut for opening a print dialog\nmight not work in other applications.\n\nEnd users are free to remap global commands to their preferred key combination\nusing the UI exposed at `chrome://extensions/shortcuts`.\n\nExample:\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"commands\": {\n        \"toggle-feature-foo\": {\n          \"suggested_key\": {\n            \"default\": \"Ctrl+Shift+5\"\n          },\n          \"description\": \"Toggle feature foo\",\n          \"global\": true\n        }\n      },\n      ...\n    }\n    \n\n## Examples\n\nThe following examples flex the core functionality of the Commands API.\n\n### Basic command\n\nCommands allow extensions to map logic to keyboard shortcuts that can be\ninvoked by the user. At its most basic, a command only requires a command\ndeclaration in the extension's manifest and a listener registration as shown\nin the following example.\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"Command demo - basic\",\n      \"version\": \"1.0\",\n      \"manifest_version\": 3,\n      \"background\": {\n        \"service_worker\": \"service-worker.js\"\n      },\n      \"commands\": {\n        \"inject-script\": {\n          \"suggested_key\": \"Ctrl+Shift+Y\",\n          \"description\": \"Inject a script on the page\"\n        }\n      }\n    }\n    \n\nservice-worker.js:\n\n    \n    \n    chrome.commands.onCommand.addListener((command) => {\n      console.log(`Command \"${command}\" triggered`);\n    });\n    \n\n### Action command\n\nAs described in the Concepts and usage section, you can also map a command to\nan extension's action. The following example injects a content script that\nshows an alert on the current page when the user either clicks the extension's\naction or triggers the keyboard shortcut.\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"Commands demo - action invocation\",\n      \"version\": \"1.0\",\n      \"manifest_version\": 3,\n      \"background\": {\n        \"service_worker\": \"service-worker.js\"\n      },\n      \"permissions\": [\"activeTab\", \"scripting\"],\n      \"action\": {},\n      \"commands\": {\n        \"_execute_action\": {\n          \"suggested_key\": {\n            \"default\": \"Ctrl+U\",\n            \"mac\": \"Command+U\"\n          }\n        }\n      }\n    }\n    \n\nservice-worker.js:\n\n    \n    \n    chrome.action.onClicked.addListener((tab) => {\n      chrome.scripting.executeScript({\n        target: {tabId: tab.id},\n        func: contentScriptFunc,\n        args: ['action'],\n      });\n    });\n    \n    function contentScriptFunc(name) {\n      alert(`\"${name}\" executed`);\n    }\n    \n    // This callback WILL NOT be called for \"_execute_action\"\n    chrome.commands.onCommand.addListener((command) => {\n      console.log(`Command \"${command}\" called`);\n    });\n    \n\n### Verify commands registered\n\nIf an extension attempts to register a shortcut that is already used by\nanother extension, the second extension's shortcut won't register as expected.\nYou can provide a more robust end user experience by anticipating this\npossibility and checking for collisions at install time.\n\nservice-worker.js:\n\n    \n    \n    chrome.runtime.onInstalled.addListener((details) => {\n      if (details.reason === chrome.runtime.OnInstalledReason.INSTALL) {\n        checkCommandShortcuts();\n      }\n    });\n    \n    // Only use this function during the initial install phase. After\n    // installation the user may have intentionally unassigned commands.\n    function checkCommandShortcuts() {\n      chrome.commands.getAll((commands) => {\n        let missingShortcuts = [];\n    \n        for (let {name, shortcut} of commands) {\n          if (shortcut === '') {\n            missingShortcuts.push(name);\n          }\n        }\n    \n        if (missingShortcuts.length > 0) {\n          // Update the extension UI to inform the user that one or more\n          // commands are currently unassigned.\n        }\n      });\n    }\n    \n\n## Types\n\n### Command\n\n#### Properties\n\n  * description\n\nstring optional\n\nThe Extension Command description\n\n  * name\n\nstring optional\n\nThe name of the Extension Command\n\n  * shortcut\n\nstring optional\n\nThe shortcut active for this command, or blank if not active.\n\n## Methods\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.commands.getAll(  \n      callback?: function,  \n    )\n\nReturns all the registered extension commands for this extension and their\nshortcut (if active). Before Chrome 110, this command did not return\n`_execute_action`.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (commands: Command[]) => void\n\n    * commands\n\nCommand[]\n\n#### Returns\n\n  * Promise<Command[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onCommand\n\n    \n    \n    chrome.commands.onCommand.addListener(  \n      callback: function,  \n    )\n\nFired when a registered command is activated using a keyboard shortcut.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (command: string, tab?: tabs.Tab) => void\n\n    * command\n\nstring\n\n    * tab\n\ntabs.Tab optional\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/contentSettings": "#  chrome.contentSettings\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.contentSettings` API to change settings that control whether\nwebsites can use features such as cookies, JavaScript, and plugins. More\ngenerally speaking, content settings allow you to customize Chrome's behavior\non a per-site basis instead of globally.\n\n## Permissions\n\n`contentSettings`  \n\nYou must declare the `\"contentSettings\"` permission in your extension's\nmanifest to use the API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"contentSettings\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\n### Content setting patterns\n\nYou can use patterns to specify the websites that each content setting\naffects. For example, `https://*.youtube.com/*` specifies youtube.com and all\nof its subdomains. The syntax for content setting patterns is the same as for\nmatch patterns, with a few differences:\n\n  * For `http`, `https`, and `ftp` URLs, the path must be a wildcard (`/*`). For `file` URLs, the path must be completely specified and **must not** contain wildcards.\n  * In contrast to match patterns, content setting patterns can specify a port number. If a port number is specified, the pattern only matches websites with that port. If no port number is specified, the pattern matches all ports.\n\n### Pattern precedence\n\nWhen more than one content setting rule applies for a given site, the rule\nwith the more specific pattern takes precedence.\n\nFor example, the following patterns are ordered by precedence:\n\n  1. `https://www.example.com/*`\n  2. `https://*.example.com/*` (matching example.com and all subdomains)\n  3. `<all_urls>` (matching every URL)\n\nThree kinds of wildcards affect how specific a pattern is:\n\n  * Wildcards in the port (for example `https://www.example.com:*/*`)\n  * Wildcards in the scheme (for example `*://www.example.com:123/*`)\n  * Wildcards in the hostname (for example `https://*.example.com:123/*`)\n\nIf a pattern is more specific than another pattern in one part but less\nspecific in another part, the different parts are checked in the following\norder: hostname, scheme, port. For example, the following patterns are ordered\nby precedence:\n\n  1. `https://www.example.com:*/*` Specifies the hostname and scheme.\n  2. `*:/www.example.com:123/*` Not as high, because although it specifies the hostname, it doesn't specify the scheme.\n  3. `https://*.example.com:123/*` Lower because although it specifies the port and scheme, it has a wildcard in the hostname.\n\n### Primary and secondary patterns\n\nThe URL taken into account when deciding which content setting to apply\ndepends on the content type. For example, for `contentSettings.notifications`\nsettings are based on the URL shown in the omnibox. This URL is called the\n\"primary\" URL.\n\nSome content types can take additional URLs into account. For example, whether\na site is allowed to set a `contentSettings.cookies` is decided based on the\nURL of the HTTP request (which is the primary URL in this case) as well as the\nURL shown in the omnibox (which is called the \"secondary\" URL).\n\nIf multiple rules have primary and secondary patterns, the rule with the more\nspecific primary pattern takes precedence. If there multiple rules have the\nsame primary pattern, the rule with the more specific secondary pattern takes\nprecedence. For example, the following list of primary/secondary pattern pairs\nis ordered by precedence:\n\nPrecedence| Primary pattern| Secondary pattern  \n---|---|---  \n1| `https://www.moose.com/*`,| `https://www.wombat.com/*`  \n2| `https://www.moose.com/*`,| `<all_urls>`  \n3| `<all_urls>`,| `https://www.wombat.com/*`  \n4| `<all_urls>`,| `<all_urls>`  \n  \nSecondary patterns are not supported for the images content setting.\n\n### Resource identifiers\n\nResource identifiers allow you to specify content settings for specific\nsubtypes of a content type. Currently, the only content type that supports\nresource identifiers is `contentSettings.plugins`, where a resource identifier\nidentifies a specific plugin. When applying content settings, first the\nsettings for the specific plugin are checked. If there are no settings found\nfor the specific plugin, the general content settings for plugins are checked.\n\nFor example, if a content setting rule has the resource identifier `adobe-\nflash-player` and the pattern `<all_urls>`, it takes precedence over a rule\nwithout a resource identifier and the pattern `https://www.example.com/*`,\neven if that pattern is more specific.\n\nYou can get a list of resource identifiers for a content type by calling the\n`contentSettings.ContentSetting.getResourceIdentifiers()` method. The returned\nlist can change with the set of installed plugins on the user's machine, but\nChrome tries to keep the identifiers stable across plugin updates.\n\n## Examples\n\nTo try this API, install the contentSettings API example from the chrome-\nextension-samples repository.\n\n## Types\n\n### AutoVerifyContentSetting\n\nChrome 113+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n### CameraContentSetting\n\nChrome 46+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n\"ask\"  \n\n### ClipboardContentSetting\n\nChrome 121+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n\"ask\"  \n\n### ContentSetting\n\n#### Properties\n\n  * clear\n\nvoid\n\nPromise\n\nClear all content setting rules set by this extension.\n\nThe `clear` function looks like:\n\n        \n        (details: object, callback?: function) => {...}\n\n    * details\n\nobject\n\n      * scope\n\nScope optional\n\nWhere to clear the setting (default: regular).\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * get\n\nvoid\n\nPromise\n\nGets the current content setting for a given pair of URLs.\n\nThe `get` function looks like:\n\n        \n        (details: object, callback?: function) => {...}\n\n    * details\n\nobject\n\n      * incognito\n\nboolean optional\n\nWhether to check the content settings for an incognito session. (default\nfalse)\n\n      * primaryUrl\n\nstring\n\nThe primary URL for which the content setting should be retrieved. Note that\nthe meaning of a primary URL depends on the content type.\n\n      * resourceIdentifier\n\nResourceIdentifier optional\n\nA more specific identifier of the type of content for which the settings\nshould be retrieved.\n\n      * secondaryUrl\n\nstring optional\n\nThe secondary URL for which the content setting should be retrieved. Defaults\nto the primary URL. Note that the meaning of a secondary URL depends on the\ncontent type, and not all content types use secondary URLs.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (details: object) => void\n\n      * details\n\nobject\n\n        * setting\n\nT\n\nThe content setting. See the description of the individual ContentSetting\nobjects for the possible values.\n\n    * returns\n\nPromise<object>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * getResourceIdentifiers\n\nvoid\n\nPromise\n\nThe `getResourceIdentifiers` function looks like:\n\n        \n        (callback?: function) => {...}\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (resourceIdentifiers?: ResourceIdentifier[]) => void\n\n      * resourceIdentifiers\n\nResourceIdentifier[] optional\n\nA list of resource identifiers for this content type, or `undefined` if this\ncontent type does not use resource identifiers.\n\n    * returns\n\nPromise<ResourceIdentifier[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * set\n\nvoid\n\nPromise\n\nApplies a new content setting rule.\n\nThe `set` function looks like:\n\n        \n        (details: object, callback?: function) => {...}\n\n    * details\n\nobject\n\n      * primaryPattern\n\nstring\n\nThe pattern for the primary URL. For details on the format of a pattern, see\nContent Setting Patterns.\n\n      * resourceIdentifier\n\nResourceIdentifier optional\n\nThe resource identifier for the content type.\n\n      * scope\n\nScope optional\n\nWhere to set the setting (default: regular).\n\n      * secondaryPattern\n\nstring optional\n\nThe pattern for the secondary URL. Defaults to matching all URLs. For details\non the format of a pattern, see Content Setting Patterns.\n\n      * setting\n\nany\n\nThe setting applied by this rule. See the description of the individual\nContentSetting objects for the possible values.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### CookiesContentSetting\n\nChrome 44+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n\"session_only\"  \n\n### FullscreenContentSetting\n\nChrome 44+\n\n#### Value\n\n\"allow\"  \n\n### ImagesContentSetting\n\nChrome 44+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n### JavascriptContentSetting\n\nChrome 44+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n### LocationContentSetting\n\nChrome 44+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n\"ask\"  \n\n### MicrophoneContentSetting\n\nChrome 46+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n\"ask\"  \n\n### MouselockContentSetting\n\nChrome 44+\n\n#### Value\n\n\"allow\"  \n\n### MultipleAutomaticDownloadsContentSetting\n\nChrome 44+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n\"ask\"  \n\n### NotificationsContentSetting\n\nChrome 44+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n\"ask\"  \n\n### PluginsContentSetting\n\nChrome 44+\n\n#### Value\n\n\"block\"  \n\n### PopupsContentSetting\n\nChrome 44+\n\n#### Enum\n\n\"allow\"  \n\n\"block\"  \n\n### PpapiBrokerContentSetting\n\nChrome 44+\n\n#### Value\n\n\"block\"  \n\n### ResourceIdentifier\n\nThe only content type using resource identifiers is `contentSettings.plugins`.\nFor more information, see Resource Identifiers.\n\n#### Properties\n\n  * description\n\nstring optional\n\nA human readable description of the resource.\n\n  * id\n\nstring\n\nThe resource identifier for the given content type.\n\n### Scope\n\nChrome 44+\n\nThe scope of the ContentSetting. One of `regular`: setting for regular profile\n(which is inherited by the incognito profile if not overridden elsewhere),\n`incognito\\_session\\_only`: setting for incognito profile that can only be set\nduring an incognito session and is deleted when the incognito session ends\n(overrides regular settings).\n\n#### Enum\n\n\"regular\"  \n\n\"incognito_session_only\"  \n\n## Properties\n\n### automaticDownloads\n\nWhether to allow sites to download multiple files automatically. One of\n`allow`: Allow sites to download multiple files automatically, `block`: Don't\nallow sites to download multiple files automatically, `ask`: Ask when a site\nwants to download files automatically after the first file. Default is `ask`.\nThe primary URL is the URL of the top-level frame. The secondary URL is not\nused.\n\n#### Type\n\nContentSetting<MultipleAutomaticDownloadsContentSetting>\n\n### autoVerify\n\nChrome 113+\n\nWhether to allow sites to use the Private State Tokens API. One of `allow`:\nAllow sites to use the Private State Tokens API, `block`: Block sites from\nusing the Private State Tokens API. Default is `allow`. When calling `set()`,\nthe primary URL pattern must be `<all_urls>`. The secondary URL is not used.\n\n#### Type\n\nContentSetting<AutoVerifyContentSetting>\n\n### camera\n\nChrome 46+\n\nWhether to allow sites to access the camera. One of `allow`: Allow sites to\naccess the camera, `block`: Don't allow sites to access the camera, `ask`: Ask\nwhen a site wants to access the camera. Default is `ask`. The primary URL is\nthe URL of the document which requested camera access. The secondary URL is\nnot used. NOTE: The 'allow' setting is not valid if both patterns are\n'<all_urls>'.\n\n#### Type\n\nContentSetting<CameraContentSetting>\n\n### clipboard\n\nChrome 121+\n\nWhether to allow sites to access the clipboard via advanced capabilities of\nthe Async Clipboard API. \"Advanced\" capabilities include anything besides\nwriting built-in formats after a user gesture, i.e. the ability to read, the\nability to write custom formats, and the ability to write without a user\ngesture. One of `allow`: Allow sites to use advanced clipboard capabilities,\n`block`: Don't allow sites to use advanced clipboard capabilties, `ask`: Ask\nwhen a site wants to use advanced clipboard capabilities. Default is `ask`.\nThe primary URL is the URL of the document which requested clipboard access.\nThe secondary URL is not used.\n\n#### Type\n\nContentSetting<ClipboardContentSetting>\n\n### cookies\n\nWhether to allow cookies and other local data to be set by websites. One of\n`allow`: Accept cookies, `block`: Block cookies, `session\\_only`: Accept\ncookies only for the current session. Default is `allow`. The primary URL is\nthe URL representing the cookie origin. The secondary URL is the URL of the\ntop-level frame.\n\n#### Type\n\nContentSetting<CookiesContentSetting>\n\n### fullscreen\n\n_Deprecated._ No longer has any effect. Fullscreen permission is now\nautomatically granted for all sites. Value is always `allow`.\n\n#### Type\n\nContentSetting<FullscreenContentSetting>\n\n### images\n\nWhether to show images. One of `allow`: Show images, `block`: Don't show\nimages. Default is `allow`. The primary URL is the URL of the top-level frame.\nThe secondary URL is the URL of the image.\n\n#### Type\n\nContentSetting<ImagesContentSetting>\n\n### javascript\n\nWhether to run JavaScript. One of `allow`: Run JavaScript, `block`: Don't run\nJavaScript. Default is `allow`. The primary URL is the URL of the top-level\nframe. The secondary URL is not used.\n\n#### Type\n\nContentSetting<JavascriptContentSetting>\n\n### location\n\nWhether to allow Geolocation. One of `allow`: Allow sites to track your\nphysical location, `block`: Don't allow sites to track your physical location,\n`ask`: Ask before allowing sites to track your physical location. Default is\n`ask`. The primary URL is the URL of the document which requested location\ndata. The secondary URL is the URL of the top-level frame (which may or may\nnot differ from the requesting URL).\n\n#### Type\n\nContentSetting<LocationContentSetting>\n\n### microphone\n\nChrome 46+\n\nWhether to allow sites to access the microphone. One of `allow`: Allow sites\nto access the microphone, `block`: Don't allow sites to access the microphone,\n`ask`: Ask when a site wants to access the microphone. Default is `ask`. The\nprimary URL is the URL of the document which requested microphone access. The\nsecondary URL is not used. NOTE: The 'allow' setting is not valid if both\npatterns are '<all_urls>'.\n\n#### Type\n\nContentSetting<MicrophoneContentSetting>\n\n### mouselock\n\n_Deprecated._ No longer has any effect. Mouse lock permission is now\nautomatically granted for all sites. Value is always `allow`.\n\n#### Type\n\nContentSetting<MouselockContentSetting>\n\n### notifications\n\nWhether to allow sites to show desktop notifications. One of `allow`: Allow\nsites to show desktop notifications, `block`: Don't allow sites to show\ndesktop notifications, `ask`: Ask when a site wants to show desktop\nnotifications. Default is `ask`. The primary URL is the URL of the document\nwhich wants to show the notification. The secondary URL is not used.\n\n#### Type\n\nContentSetting<NotificationsContentSetting>\n\n### plugins\n\n_Deprecated._ With Flash support removed in Chrome 88, this permission no\nlonger has any effect. Value is always `block`. Calls to `set()` and `clear()`\nwill be ignored.\n\n#### Type\n\nContentSetting<PluginsContentSetting>\n\n### popups\n\nWhether to allow sites to show pop-ups. One of `allow`: Allow sites to show\npop-ups, `block`: Don't allow sites to show pop-ups. Default is `block`. The\nprimary URL is the URL of the top-level frame. The secondary URL is not used.\n\n#### Type\n\nContentSetting<PopupsContentSetting>\n\n### unsandboxedPlugins\n\n_Deprecated._ Previously, controlled whether to allow sites to run plugins\nunsandboxed, however, with the Flash broker process removed in Chrome 88, this\npermission no longer has any effect. Value is always `block`. Calls to `set()`\nand `clear()` will be ignored.\n\n#### Type\n\nContentSetting<PpapiBrokerContentSetting>\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/contextMenus": "#  chrome.contextMenus\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.contextMenus` API to add items to Google Chrome's context\nmenu. You can choose what types of objects your context menu additions apply\nto, such as images, hyperlinks, and pages.\n\n## Permissions\n\n`contextMenus`  \n\nYou must declare the `\"contextMenus\"` permission in your extension's manifest\nto use the API. Also, you should specify a 16 by 16-pixel icon for display\nnext to your menu item. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"contextMenus\"\n      ],\n      \"icons\": {\n        \"16\": \"icon-bitty.png\",\n        \"48\": \"icon-small.png\",\n        \"128\": \"icon-large.png\"\n      },\n      ...\n    }\n    \n\n## Concepts and usage\n\nContext menu items can appear in any document (or frame within a document),\neven those with file:// or chrome:// URLs. To control which documents your\nitems can appear in, specify the `documentUrlPatterns` field when you call the\n`create()` or `update()` methods.\n\nYou can create as many context menu items as you need, but if more than one\nfrom your extension is visible at once, Google Chrome automatically collapses\nthem into a single parent menu.\n\n## Examples\n\nTo try this API, install the contextMenus API example from the chrome-\nextension-samples repository.\n\n## Types\n\n### ContextType\n\nChrome 44+\n\nThe different contexts a menu can appear in. Specifying 'all' is equivalent to\nthe combination of all other contexts except for 'launcher'. The 'launcher'\ncontext is only supported by apps and is used to add menu items to the context\nmenu that appears when clicking the app icon in the launcher/taskbar/dock/etc.\nDifferent platforms might put limitations on what is actually supported in a\nlauncher context menu.\n\n#### Enum\n\n\"all\"  \n\n\"page\"  \n\n\"frame\"  \n\n\"selection\"  \n\n\"link\"  \n\n\"editable\"  \n\n\"image\"  \n\n\"video\"  \n\n\"audio\"  \n\n\"launcher\"  \n\n\"browser_action\"  \n\n\"page_action\"  \n\n\"action\"  \n\n### CreateProperties\n\nChrome 123+\n\nProperties of the new context menu item.\n\n#### Properties\n\n  * checked\n\nboolean optional\n\nThe initial state of a checkbox or radio button: `true` for selected, `false`\nfor unselected. Only one radio button can be selected at a time in a given\ngroup.\n\n  * contexts\n\n[ContextType, ...ContextType[]] optional\n\nList of contexts this menu item will appear in. Defaults to `['page']`.\n\n  * documentUrlPatterns\n\nstring[] optional\n\nRestricts the item to apply only to documents or frames whose URL matches one\nof the given patterns. For details on pattern formats, see Match Patterns.\n\n  * enabled\n\nboolean optional\n\nWhether this context menu item is enabled or disabled. Defaults to `true`.\n\n  * id\n\nstring optional\n\nThe unique ID to assign to this item. Mandatory for event pages. Cannot be the\nsame as another ID for this extension.\n\n  * parentId\n\nstring | number optional\n\nThe ID of a parent menu item; this makes the item a child of a previously\nadded item.\n\n  * targetUrlPatterns\n\nstring[] optional\n\nSimilar to `documentUrlPatterns`, filters based on the `src` attribute of\n`img`, `audio`, and `video` tags and the `href` attribute of `a` tags.\n\n  * title\n\nstring optional\n\nThe text to display in the item; this is _required_ unless `type` is\n`separator`. When the context is `selection`, use `%s` within the string to\nshow the selected text. For example, if this parameter's value is \"Translate\n'%s' to Pig Latin\" and the user selects the word \"cool\", the context menu item\nfor the selection is \"Translate 'cool' to Pig Latin\".\n\n  * type\n\nItemType optional\n\nThe type of menu item. Defaults to `normal`.\n\n  * visible\n\nboolean optional\n\nWhether the item is visible in the menu.\n\n  * onclick\n\nvoid optional\n\nA function that is called back when the menu item is clicked. This is not\navailable inside of a service worker; instead, you should register a listener\nfor `contextMenus.onClicked`.\n\nThe `onclick` function looks like:\n\n        \n        (info: OnClickData, tab: Tab) => {...}\n\n    * info\n\nOnClickData\n\nInformation about the item clicked and the context where the click happened.\n\n    * tab\n\nTab\n\nThe details of the tab where the click took place. This parameter is not\npresent for platform apps.\n\n### ItemType\n\nChrome 44+\n\nThe type of menu item.\n\n#### Enum\n\n\"normal\"  \n\n\"checkbox\"  \n\n\"radio\"  \n\n\"separator\"  \n\n### OnClickData\n\nInformation sent when a context menu item is clicked.\n\n#### Properties\n\n  * checked\n\nboolean optional\n\nA flag indicating the state of a checkbox or radio item after it is clicked.\n\n  * editable\n\nboolean\n\nA flag indicating whether the element is editable (text input, textarea,\netc.).\n\n  * frameId\n\nnumber optional\n\nChrome 51+\n\nThe ID of the frame of the element where the context menu was clicked, if it\nwas in a frame.\n\n  * frameUrl\n\nstring optional\n\nThe URL of the frame of the element where the context menu was clicked, if it\nwas in a frame.\n\n  * linkUrl\n\nstring optional\n\nIf the element is a link, the URL it points to.\n\n  * mediaType\n\nstring optional\n\nOne of 'image', 'video', or 'audio' if the context menu was activated on one\nof these types of elements.\n\n  * menuItemId\n\nstring | number\n\nThe ID of the menu item that was clicked.\n\n  * pageUrl\n\nstring optional\n\nThe URL of the page where the menu item was clicked. This property is not set\nif the click occured in a context where there is no current page, such as in a\nlauncher context menu.\n\n  * parentMenuItemId\n\nstring | number optional\n\nThe parent ID, if any, for the item clicked.\n\n  * selectionText\n\nstring optional\n\nThe text for the context selection, if any.\n\n  * srcUrl\n\nstring optional\n\nWill be present for elements with a 'src' URL.\n\n  * wasChecked\n\nboolean optional\n\nA flag indicating the state of a checkbox or radio item before it was clicked.\n\n## Properties\n\n### ACTION_MENU_TOP_LEVEL_LIMIT\n\nThe maximum number of top level extension items that can be added to an\nextension action context menu. Any items beyond this limit will be ignored.\n\n#### Value\n\n6  \n\n## Methods\n\n### create()\n\n    \n    \n    chrome.contextMenus.create(  \n      createProperties: CreateProperties,  \n      callback?: function,  \n    )\n\nCreates a new context menu item. If an error occurs during creation, it may\nnot be detected until the creation callback fires; details will be in\n`runtime.lastError`.\n\n#### Parameters\n\n  * createProperties\n\nCreateProperties\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * number | string\n\nThe ID of the newly created item.\n\n### remove()\n\nPromise\n\n    \n    \n    chrome.contextMenus.remove(  \n      menuItemId: string | number,  \n      callback?: function,  \n    )\n\nRemoves a context menu item.\n\n#### Parameters\n\n  * menuItemId\n\nstring | number\n\nThe ID of the context menu item to remove.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 123+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeAll()\n\nPromise\n\n    \n    \n    chrome.contextMenus.removeAll(  \n      callback?: function,  \n    )\n\nRemoves all context menu items added by this extension.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 123+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### update()\n\nPromise\n\n    \n    \n    chrome.contextMenus.update(  \n      id: string | number,  \n      updateProperties: object,  \n      callback?: function,  \n    )\n\nUpdates a previously created context menu item.\n\n#### Parameters\n\n  * id\n\nstring | number\n\nThe ID of the item to update.\n\n  * updateProperties\n\nobject\n\nThe properties to update. Accepts the same values as the `contextMenus.create`\nfunction.\n\n    * checked\n\nboolean optional\n\n    * contexts\n\n[ContextType, ...ContextType[]] optional\n\n    * documentUrlPatterns\n\nstring[] optional\n\n    * enabled\n\nboolean optional\n\n    * parentId\n\nstring | number optional\n\nThe ID of the item to be made this item's parent. Note: You cannot set an item\nto become a child of its own descendant.\n\n    * targetUrlPatterns\n\nstring[] optional\n\n    * title\n\nstring optional\n\n    * type\n\nItemType optional\n\n    * visible\n\nboolean optional\n\nChrome 62+\n\nWhether the item is visible in the menu.\n\n    * onclick\n\nvoid optional\n\nThe `onclick` function looks like:\n\n          \n          (info: OnClickData, tab: Tab) => {...}\n\n      * info\n\nOnClickData\n\nChrome 44+\n\n      * tab\n\nTab\n\nChrome 44+\n\nThe details of the tab where the click took place. This parameter is not\npresent for platform apps.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 123+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onClicked\n\n    \n    \n    chrome.contextMenus.onClicked.addListener(  \n      callback: function,  \n    )\n\nFired when a context menu item is clicked.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (info: OnClickData, tab?: tabs.Tab) => void\n\n    * info\n\nOnClickData\n\n    * tab\n\ntabs.Tab optional\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/cookies": "#  chrome.cookies\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.cookies` API to query and modify cookies, and to be notified\nwhen they change.\n\n## Permissions\n\n`cookies`  \n\nTo use the cookies API, declare the `\"cookies\"` permission in your manifest\nalong with host permissions for any hosts whose cookies you want to access.\nFor example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"host_permissions\": [\n        \"*://*.google.com/\"\n      ],\n      \"permissions\": [\n        \"cookies\"\n      ],\n      ...\n    }\n    \n\n## Partitioning\n\nPartitioned cookies allow a site to mark that certain cookies should be keyed\nagainst the origin of the top-level frame. This means that, for example, if\nsite A is embedded using an iframe in site B and site C, the embedded versions\nof a partitioned cookie from A can have different values on B and C.\n\nBy default, all API methods operate on unpartitioned cookies. The\n`partitionKey` property can be used to override this behavior.\n\nFor details on the general impact of partitioning for extensions, see Storage\nand Cookies.\n\n## Examples\n\nYou can find a simple example of using the cookies API in the\nexamples/api/cookies directory. For other examples and for help in viewing the\nsource code, see Samples.\n\n## Types\n\n### Cookie\n\nRepresents information about an HTTP cookie.\n\n#### Properties\n\n  * domain\n\nstring\n\nThe domain of the cookie (e.g. \"www.google.com\", \"example.com\").\n\n  * expirationDate\n\nnumber optional\n\nThe expiration date of the cookie as the number of seconds since the UNIX\nepoch. Not provided for session cookies.\n\n  * hostOnly\n\nboolean\n\nTrue if the cookie is a host-only cookie (i.e. a request's host must exactly\nmatch the domain of the cookie).\n\n  * httpOnly\n\nboolean\n\nTrue if the cookie is marked as HttpOnly (i.e. the cookie is inaccessible to\nclient-side scripts).\n\n  * name\n\nstring\n\nThe name of the cookie.\n\n  * partitionKey\n\nCookiePartitionKey optional\n\nChrome 119+\n\nThe partition key for reading or modifying cookies with the Partitioned\nattribute.\n\n  * path\n\nstring\n\nThe path of the cookie.\n\n  * sameSite\n\nSameSiteStatus\n\nChrome 51+\n\nThe cookie's same-site status (i.e. whether the cookie is sent with cross-site\nrequests).\n\n  * secure\n\nboolean\n\nTrue if the cookie is marked as Secure (i.e. its scope is limited to secure\nchannels, typically HTTPS).\n\n  * session\n\nboolean\n\nTrue if the cookie is a session cookie, as opposed to a persistent cookie with\nan expiration date.\n\n  * storeId\n\nstring\n\nThe ID of the cookie store containing this cookie, as provided in\ngetAllCookieStores().\n\n  * value\n\nstring\n\nThe value of the cookie.\n\n### CookieDetails\n\nChrome 88+\n\nDetails to identify the cookie.\n\n#### Properties\n\n  * name\n\nstring\n\nThe name of the cookie to access.\n\n  * partitionKey\n\nCookiePartitionKey optional\n\nChrome 119+\n\nThe partition key for reading or modifying cookies with the Partitioned\nattribute.\n\n  * storeId\n\nstring optional\n\nThe ID of the cookie store in which to look for the cookie. By default, the\ncurrent execution context's cookie store will be used.\n\n  * url\n\nstring\n\nThe URL with which the cookie to access is associated. This argument may be a\nfull URL, in which case any data following the URL path (e.g. the query\nstring) is simply ignored. If host permissions for this URL are not specified\nin the manifest file, the API call will fail.\n\n### CookiePartitionKey\n\nChrome 119+\n\nRepresents a partitioned cookie's partition key.\n\n#### Properties\n\n  * hasCrossSiteAncestor\n\nboolean optional\n\nChrome 130+\n\nIndicates if the cookie was set in a cross-cross site context. This prevents a\ntop-level site embedded in a cross-site context from accessing cookies set by\nthe top-level site in a same-site context.\n\n  * topLevelSite\n\nstring optional\n\nThe top-level site the partitioned cookie is available in.\n\n### CookieStore\n\nRepresents a cookie store in the browser. An incognito mode window, for\ninstance, uses a separate cookie store from a non-incognito window.\n\n#### Properties\n\n  * id\n\nstring\n\nThe unique identifier for the cookie store.\n\n  * tabIds\n\nnumber[]\n\nIdentifiers of all the browser tabs that share this cookie store.\n\n### FrameDetails\n\nChrome 132+\n\nDetails to identify the frame.\n\n#### Properties\n\n  * documentId\n\nstring optional\n\nThe unique identifier for the document. If the frameId and/or tabId are\nprovided they will be validated to match the document found by provided\ndocument ID.\n\n  * frameId\n\nnumber optional\n\nThe unique identifier for the frame within the tab.\n\n  * tabId\n\nnumber optional\n\nThe unique identifier for the tab containing the frame.\n\n### OnChangedCause\n\nChrome 44+\n\nThe underlying reason behind the cookie's change. If a cookie was inserted, or\nremoved via an explicit call to \"chrome.cookies.remove\", \"cause\" will be\n\"explicit\". If a cookie was automatically removed due to expiry, \"cause\" will\nbe \"expired\". If a cookie was removed due to being overwritten with an\nalready-expired expiration date, \"cause\" will be set to \"expired_overwrite\".\nIf a cookie was automatically removed due to garbage collection, \"cause\" will\nbe \"evicted\". If a cookie was automatically removed due to a \"set\" call that\noverwrote it, \"cause\" will be \"overwrite\". Plan your response accordingly.\n\n#### Enum\n\n\"evicted\"  \n\n\"expired\"  \n\n\"explicit\"  \n\n\"expired_overwrite\"  \n\n\"overwrite\"  \n\n### SameSiteStatus\n\nChrome 51+\n\nA cookie's 'SameSite' state (https://tools.ietf.org/html/draft-west-first-\nparty-cookies). 'no_restriction' corresponds to a cookie set with\n'SameSite=None', 'lax' to 'SameSite=Lax', and 'strict' to 'SameSite=Strict'.\n'unspecified' corresponds to a cookie set without the SameSite attribute.\n\n#### Enum\n\n\"no_restriction\"  \n\n\"lax\"  \n\n\"strict\"  \n\n\"unspecified\"  \n\n## Methods\n\n### get()\n\nPromise\n\n    \n    \n    chrome.cookies.get(  \n      details: CookieDetails,  \n      callback?: function,  \n    )\n\nRetrieves information about a single cookie. If more than one cookie of the\nsame name exists for the given URL, the one with the longest path will be\nreturned. For cookies with the same path length, the cookie with the earliest\ncreation time will be returned.\n\n#### Parameters\n\n  * details\n\nCookieDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (cookie?: Cookie) => void\n\n    * cookie\n\nCookie optional\n\nContains details about the cookie. This parameter is null if no such cookie\nwas found.\n\n#### Returns\n\n  * Promise<Cookie | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.cookies.getAll(  \n      details: object,  \n      callback?: function,  \n    )\n\nRetrieves all cookies from a single cookie store that match the given\ninformation. The cookies returned will be sorted, with those with the longest\npath first. If multiple cookies have the same path length, those with the\nearliest creation time will be first. This method only retrieves cookies for\ndomains that the extension has host permissions to.\n\n#### Parameters\n\n  * details\n\nobject\n\nInformation to filter the cookies being retrieved.\n\n    * domain\n\nstring optional\n\nRestricts the retrieved cookies to those whose domains match or are subdomains\nof this one.\n\n    * name\n\nstring optional\n\nFilters the cookies by name.\n\n    * partitionKey\n\nCookiePartitionKey optional\n\nChrome 119+\n\nThe partition key for reading or modifying cookies with the Partitioned\nattribute.\n\n    * path\n\nstring optional\n\nRestricts the retrieved cookies to those whose path exactly matches this\nstring.\n\n    * secure\n\nboolean optional\n\nFilters the cookies by their Secure property.\n\n    * session\n\nboolean optional\n\nFilters out session vs. persistent cookies.\n\n    * storeId\n\nstring optional\n\nThe cookie store to retrieve cookies from. If omitted, the current execution\ncontext's cookie store will be used.\n\n    * url\n\nstring optional\n\nRestricts the retrieved cookies to those that would match the given URL.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (cookies: Cookie[]) => void\n\n    * cookies\n\nCookie[]\n\nAll the existing, unexpired cookies that match the given cookie info.\n\n#### Returns\n\n  * Promise<Cookie[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAllCookieStores()\n\nPromise\n\n    \n    \n    chrome.cookies.getAllCookieStores(  \n      callback?: function,  \n    )\n\nLists all existing cookie stores.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (cookieStores: CookieStore[]) => void\n\n    * cookieStores\n\nCookieStore[]\n\nAll the existing cookie stores.\n\n#### Returns\n\n  * Promise<CookieStore[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPartitionKey()\n\nPromise Chrome 132+\n\n    \n    \n    chrome.cookies.getPartitionKey(  \n      details: FrameDetails,  \n      callback?: function,  \n    )\n\nThe partition key for the frame indicated.\n\n#### Parameters\n\n  * details\n\nFrameDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\nContains details about the partition key that's been retrieved.\n\n      * partitionKey\n\nCookiePartitionKey\n\nThe partition key for reading or modifying cookies with the Partitioned\nattribute.\n\n#### Returns\n\n  * Promise<object>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### remove()\n\nPromise\n\n    \n    \n    chrome.cookies.remove(  \n      details: CookieDetails,  \n      callback?: function,  \n    )\n\nDeletes a cookie by name.\n\n#### Parameters\n\n  * details\n\nCookieDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details?: object) => void\n\n    * details\n\nobject optional\n\nContains details about the cookie that's been removed. If removal failed for\nany reason, this will be \"null\", and `runtime.lastError` will be set.\n\n      * name\n\nstring\n\nThe name of the cookie that's been removed.\n\n      * partitionKey\n\nCookiePartitionKey optional\n\nChrome 119+\n\nThe partition key for reading or modifying cookies with the Partitioned\nattribute.\n\n      * storeId\n\nstring\n\nThe ID of the cookie store from which the cookie was removed.\n\n      * url\n\nstring\n\nThe URL associated with the cookie that's been removed.\n\n#### Returns\n\n  * Promise<object | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### set()\n\nPromise\n\n    \n    \n    chrome.cookies.set(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets a cookie with the given cookie data; may overwrite equivalent cookies if\nthey exist.\n\n#### Parameters\n\n  * details\n\nobject\n\nDetails about the cookie being set.\n\n    * domain\n\nstring optional\n\nThe domain of the cookie. If omitted, the cookie becomes a host-only cookie.\n\n    * expirationDate\n\nnumber optional\n\nThe expiration date of the cookie as the number of seconds since the UNIX\nepoch. If omitted, the cookie becomes a session cookie.\n\n    * httpOnly\n\nboolean optional\n\nWhether the cookie should be marked as HttpOnly. Defaults to false.\n\n    * name\n\nstring optional\n\nThe name of the cookie. Empty by default if omitted.\n\n    * partitionKey\n\nCookiePartitionKey optional\n\nChrome 119+\n\nThe partition key for reading or modifying cookies with the Partitioned\nattribute.\n\n    * path\n\nstring optional\n\nThe path of the cookie. Defaults to the path portion of the url parameter.\n\n    * sameSite\n\nSameSiteStatus optional\n\nChrome 51+\n\nThe cookie's same-site status. Defaults to \"unspecified\", i.e., if omitted,\nthe cookie is set without specifying a SameSite attribute.\n\n    * secure\n\nboolean optional\n\nWhether the cookie should be marked as Secure. Defaults to false.\n\n    * storeId\n\nstring optional\n\nThe ID of the cookie store in which to set the cookie. By default, the cookie\nis set in the current execution context's cookie store.\n\n    * url\n\nstring\n\nThe request-URI to associate with the setting of the cookie. This value can\naffect the default domain and path values of the created cookie. If host\npermissions for this URL are not specified in the manifest file, the API call\nwill fail.\n\n    * value\n\nstring optional\n\nThe value of the cookie. Empty by default if omitted.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (cookie?: Cookie) => void\n\n    * cookie\n\nCookie optional\n\nContains details about the cookie that's been set. If setting failed for any\nreason, this will be \"null\", and `runtime.lastError` will be set.\n\n#### Returns\n\n  * Promise<Cookie | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onChanged\n\n    \n    \n    chrome.cookies.onChanged.addListener(  \n      callback: function,  \n    )\n\nFired when a cookie is set or removed. As a special case, note that updating a\ncookie's properties is implemented as a two step process: the cookie to be\nupdated is first removed entirely, generating a notification with \"cause\" of\n\"overwrite\" . Afterwards, a new cookie is written with the updated values,\ngenerating a second notification with \"cause\" \"explicit\".\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (changeInfo: object) => void\n\n    * changeInfo\n\nobject\n\n      * cause\n\nOnChangedCause\n\nThe underlying reason behind the cookie's change.\n\n      * cookie\n\nCookie\n\nInformation about the cookie that was set or removed.\n\n      * removed\n\nboolean\n\nTrue if a cookie was removed.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/debugger": "#  chrome.debugger\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.debugger` API serves as an alternate transport for Chrome's remote\ndebugging protocol. Use `chrome.debugger` to attach to one or more tabs to\ninstrument network interaction, debug JavaScript, mutate the DOM and CSS, and\nmore. Use the `Debuggee` property `tabId` to target tabs with `sendCommand`\nand route events by `tabId` from `onEvent` callbacks.\n\n## Permissions\n\n`debugger`  \n\nYou must declare the `\"debugger\"` permission in your extension's manifest to\nuse this API.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"debugger\",\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nOnce attached, the `chrome.debugger` API lets you send Chrome DevTools\nProtocol (CDP) commands to a given target. Explaining the CDP in depth is out\nof scope for this documentationto learn more about CDP check out the official\nCDP documentation.\n\n### Targets\n\nTargets represent something which is being debuggedthis could include a tab,\nan iframe or a worker. Each target is identified by a UUID and has an\nassociated type (such as `iframe`, `shared_worker`, and more).\n\nWithin a target, there may be multiple execution contextsfor example same\nprocess iframes don't get a unique target but are instead represented as\ndifferent contexts that can be accessed from a single target.\n\n### Restricted domains\n\nFor security reasons, the `chrome.debugger` API does not provide access to all\nChrome DevTools Protocol Domains. The available domains are: Accessibility,\nAudits, CacheStorage, Console, CSS, Database, Debugger, DOM, DOMDebugger,\nDOMSnapshot, Emulation, Fetch, IO, Input, Inspector, Log, Network, Overlay,\nPage, Performance, Profiler, Runtime, Storage, Target, Tracing, WebAudio, and\nWebAuthn.\n\n### Work with frames\n\nThere is not a one to one mapping of frames to targets. Within a single tab,\nmultiple same process frames may share the same target but use a different\nexecution context. On the other hand, a new target may be created for an out-\nof-process iframe.\n\nTo attach to all frames, you need to handle each type of frame separately:\n\n  * Listen for the `Runtime.executionContextCreated` event to identify new execution contexts associated with same process frames.\n\n  * Follow the steps to attach to related targets to identify out-of-process frames.\n\n### Attach to related targets\n\nAfter connecting to a target, you may want to connect to further related\ntargets including out-of-process child frames or associated workers.\n\nStarting in Chrome 125, the `chrome.debugger` API supports flat sessions. This\nlets you add additional targets as children to your main debugger session and\nmessage them without needing another call to `chrome.debugger.attach`.\nInstead, you can add a `sessionId` property when calling\n`chrome.debugger.sendCommand` to identify the child target you would like to\nsend a command to.\n\nTo automatically attach to out of process child frames, first add a listener\nfor the `Target.attachedToTarget` event:\n\n    \n    \n    chrome.debugger.onEvent.addListener((source, method, params) => {\n      if (method === \"Target.attachedToTarget\") {\n        // `source` identifies the parent session, but we need to construct a new\n        // identifier for the child session\n        const session = { ...source, sessionId: params.sessionId };\n    \n        // Call any needed CDP commands for the child session\n        await chrome.debugger.sendCommand(session, \"Runtime.enable\");\n      }\n    });\n    \n\nThen, enable auto attach by sending the `Target.setAutoAttach` command with\nthe `flatten` option set to `true`:\n\n    \n    \n    await chrome.debugger.sendCommand({ tabId }, \"Target.setAutoAttach\", {\n      autoAttach: true,\n      waitForDebuggerOnStart: false,\n      flatten: true,\n      filter: [{ type: \"iframe\", exclude: false }]\n    });\n    \n\nAuto-attach only attaches to frames the target is aware of, which is limited\nto frames which are immediate children of a frame associated with it. For\nexample, with the frame hierarchy A -> B -> C (where all are cross-origin),\ncalling `Target.setAutoAttach` for the target associated with A would result\nin the session also being attached to B. However, this is not recursive, so\n`Target.setAutoAttach` also needs to be called for B to attach the session to\nC.\n\n## Examples\n\nTo try this API, install the debugger API example from the chrome-extension-\nsamples repository.\n\n## Types\n\n### Debuggee\n\nDebuggee identifier. Either tabId, extensionId or targetId must be specified\n\n#### Properties\n\n  * extensionId\n\nstring optional\n\nThe id of the extension which you intend to debug. Attaching to an extension\nbackground page is only possible when the `--silent-debugger-extension-api`\ncommand-line switch is used.\n\n  * tabId\n\nnumber optional\n\nThe id of the tab which you intend to debug.\n\n  * targetId\n\nstring optional\n\nThe opaque id of the debug target.\n\n### DebuggerSession\n\nChrome 125+\n\nDebugger session identifier. One of tabId, extensionId or targetId must be\nspecified. Additionally, an optional sessionId can be provided. If sessionId\nis specified for arguments sent from `onEvent`, it means the event is coming\nfrom a child protocol session within the root debuggee session. If sessionId\nis specified when passed to `sendCommand`, it targets a child protocol session\nwithin the root debuggee session.\n\n#### Properties\n\n  * extensionId\n\nstring optional\n\nThe id of the extension which you intend to debug. Attaching to an extension\nbackground page is only possible when the `--silent-debugger-extension-api`\ncommand-line switch is used.\n\n  * sessionId\n\nstring optional\n\nThe opaque id of the Chrome DevTools Protocol session. Identifies a child\nsession within the root session identified by tabId, extensionId or targetId.\n\n  * tabId\n\nnumber optional\n\nThe id of the tab which you intend to debug.\n\n  * targetId\n\nstring optional\n\nThe opaque id of the debug target.\n\n### DetachReason\n\nChrome 44+\n\nConnection termination reason.\n\n#### Enum\n\n\"target_closed\"  \n\n\"canceled_by_user\"  \n\n### TargetInfo\n\nDebug target information\n\n#### Properties\n\n  * attached\n\nboolean\n\nTrue if debugger is already attached.\n\n  * extensionId\n\nstring optional\n\nThe extension id, defined if type = 'background_page'.\n\n  * faviconUrl\n\nstring optional\n\nTarget favicon URL.\n\n  * id\n\nstring\n\nTarget id.\n\n  * tabId\n\nnumber optional\n\nThe tab id, defined if type == 'page'.\n\n  * title\n\nstring\n\nTarget page title.\n\n  * type\n\nTargetInfoType\n\nTarget type.\n\n  * url\n\nstring\n\nTarget URL.\n\n### TargetInfoType\n\nChrome 44+\n\nTarget type.\n\n#### Enum\n\n\"page\"  \n\n\"background_page\"  \n\n\"worker\"  \n\n\"other\"  \n\n## Methods\n\n### attach()\n\nPromise\n\n    \n    \n    chrome.debugger.attach(  \n      target: Debuggee,  \n      requiredVersion: string,  \n      callback?: function,  \n    )\n\nAttaches debugger to the given target.\n\n#### Parameters\n\n  * target\n\nDebuggee\n\nDebugging target to which you want to attach.\n\n  * requiredVersion\n\nstring\n\nRequired debugging protocol version (\"0.1\"). One can only attach to the\ndebuggee with matching major version and greater or equal minor version. List\nof the protocol versions can be obtained here.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### detach()\n\nPromise\n\n    \n    \n    chrome.debugger.detach(  \n      target: Debuggee,  \n      callback?: function,  \n    )\n\nDetaches debugger from the given target.\n\n#### Parameters\n\n  * target\n\nDebuggee\n\nDebugging target from which you want to detach.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getTargets()\n\nPromise\n\n    \n    \n    chrome.debugger.getTargets(  \n      callback?: function,  \n    )\n\nReturns the list of available debug targets.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: TargetInfo[]) => void\n\n    * result\n\nTargetInfo[]\n\nArray of TargetInfo objects corresponding to the available debug targets.\n\n#### Returns\n\n  * Promise<TargetInfo[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### sendCommand()\n\nPromise\n\n    \n    \n    chrome.debugger.sendCommand(  \n      target: DebuggerSession,  \n      method: string,  \n      commandParams?: object,  \n      callback?: function,  \n    )\n\nSends given command to the debugging target.\n\n#### Parameters\n\n  * target\n\nDebuggerSession\n\nDebugging target to which you want to send the command.\n\n  * method\n\nstring\n\nMethod name. Should be one of the methods defined by the remote debugging\nprotocol.\n\n  * commandParams\n\nobject optional\n\nJSON object with request parameters. This object must conform to the remote\ndebugging params scheme for given method.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result?: object) => void\n\n    * result\n\nobject optional\n\nJSON object with the response. Structure of the response varies depending on\nthe method name and is defined by the 'returns' attribute of the command\ndescription in the remote debugging protocol.\n\n#### Returns\n\n  * Promise<object | undefined>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onDetach\n\n    \n    \n    chrome.debugger.onDetach.addListener(  \n      callback: function,  \n    )\n\nFired when browser terminates debugging session for the tab. This happens when\neither the tab is being closed or Chrome DevTools is being invoked for the\nattached tab.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (source: Debuggee, reason: DetachReason) => void\n\n    * source\n\nDebuggee\n\n    * reason\n\nDetachReason\n\n### onEvent\n\n    \n    \n    chrome.debugger.onEvent.addListener(  \n      callback: function,  \n    )\n\nFired whenever debugging target issues instrumentation event.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (source: DebuggerSession, method: string, params?: object) => void\n\n    * source\n\nDebuggerSession\n\n    * method\n\nstring\n\n    * params\n\nobject optional\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/declarativeContent": "#  chrome.declarativeContent\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.declarativeContent` API to take actions depending on the\ncontent of a page, without requiring permission to read the page's content.\n\n## Permissions\n\n`declarativeContent`  \n\n## Concepts and usage\n\n**Key term:** An extension's _action_ controls the extension's toolbar icon.\n\nThe Declarative Content API lets you enable your extension's action depending\non the URL of a web page, or if a CSS selector matches an element on the page,\nwithout needing to add host permissions or inject a content script.\n\nUse the activeTab permission to interact with a page after the user clicks on\nthe extension's action.\n\n### Rules\n\nRules consists of conditions and actions. If any of the conditions is\nfulfilled, all actions are executed. The actions are `setIcon()` and\n`showAction()`.\n\nThe `PageStateMatcher` matches web pages if and only if all listed criteria\nare met. It can match a page url, a css compound selector or the bookmarked\nstate of a page. The following rule enables the extension's action on Google\npages when a password field is present:\n\n    \n    \n    let rule1 = {\n      conditions: [\n        new chrome.declarativeContent.PageStateMatcher({\n          pageUrl: { hostSuffix: '.google.com', schemes: ['https'] },\n          css: [\"input[type='password']\"]\n        })\n      ],\n      actions: [ new chrome.declarativeContent.ShowAction() ]\n    };\n    \n    \n\n**Success:** All conditions and actions are created using a constructor as\nshown in the previous example.\n\nTo also enable the extension's action for Google sites with a video, you can\nadd a second condition, as each condition is sufficient to trigger all\nspecified actions:\n\n    \n    \n    let rule2 = {\n      conditions: [\n        new chrome.declarativeContent.PageStateMatcher({\n          pageUrl: { hostSuffix: '.google.com', schemes: ['https'] },\n          css: [\"input[type='password']\"]\n        }),\n        new chrome.declarativeContent.PageStateMatcher({\n          css: [\"video\"]\n        })\n      ],\n      actions: [ new chrome.declarativeContent.ShowAction() ]\n    };\n    \n\nThe `onPageChanged` event tests whether any rule has at least one fulfilled\ncondition and executes the actions. Rules persist across browsing sessions;\ntherefore, during extension installation time you should first use\n`removeRules` to clear previously installed rules and then use `addRules` to\nregister new ones.\n\n    \n    \n    chrome.runtime.onInstalled.addListener(function(details) {\n      chrome.declarativeContent.onPageChanged.removeRules(undefined, function() {\n        chrome.declarativeContent.onPageChanged.addRules([rule2]);\n      });\n    });\n    \n\n**Note:** You should always register or unregister rules in bulk because each\nof these operations recreates internal data structures. This re-creation is\ncomputationally expensive but facilitates a faster matching algorithm.\n\nWith the activeTab permission, your extension won't display any permission\nwarnings and when the user clicks the extension action, it will only run on\nrelevant pages.\n\n### Page URL matching\n\nThe `PageStateMatcher.pageurl` matches when the URL criteria are fulfilled.\nThe most common criteria are a concatenation of either host, path, or URL,\nfollowed by Contains, Equals, Prefix, or Suffix. The following table contains\na few examples:\n\nCriteria | Matches  \n---|---  \n`{ hostSuffix: 'google.com' }` | All Google URLs  \n`{ pathPrefix: '/docs/extensions'` } | Extension docs URLs  \n`{ urlContains: 'developer.chrome.com'` } | All chrome developers docs URLs  \n  \nAll criteria are case sensitive. For a complete list of criteria, see\nUrlFilter.\n\n### CSS Matching\n\n`PageStateMatcher.css` conditions must be _compound selectors_ , meaning that\nyou can't include combinators like whitespace or \"`>`\" in your selectors. This\nhelps Chrome match the selectors more efficiently.\n\nCompound Selectors (OK) | Complex Selectors (Not OK)  \n---|---  \n`a` | `div p`  \n`iframe.special[src^='http']` | `p>span.highlight`  \n`ns|*` | `p + ol`  \n`#abcd:checked` | `p::first-line`  \n  \nCSS conditions only match displayed elements: if an element that matches your\nselector is `display:none` or one of its parent elements is `display:none`, it\ndoesn't cause the condition to match. Elements styled with\n`visibility:hidden`, positioned off-screen, or hidden by other elements can\nstill make your condition match.\n\n### Bookmarked state matching\n\nThe `PageStateMatcher.isBookmarked` condition allows matching of the\nbookmarked state of the current URL in the user's profile. To make use of this\ncondition the \"bookmarks\" permission must be declared in the extension\nmanifest.\n\n## Types\n\n### ImageDataType\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ImageData.\n\n#### Type\n\nImageData\n\n### PageStateMatcher\n\nMatches the state of a web page based on various criteria.\n\n#### Properties\n\n  * constructor\n\nvoid\n\nThe `constructor` function looks like:\n\n        \n        (arg: PageStateMatcher) => {...}\n\n    * arg\n\nPageStateMatcher\n\n    * returns\n\nPageStateMatcher\n\n  * css\n\nstring[] optional\n\nMatches if all of the CSS selectors in the array match displayed elements in a\nframe with the same origin as the page's main frame. All selectors in this\narray must be compound selectors to speed up matching. Note: Listing hundreds\nof CSS selectors or listing CSS selectors that match hundreds of times per\npage can slow down web sites.\n\n  * isBookmarked\n\nboolean optional\n\nChrome 45+\n\nMatches if the bookmarked state of the page is equal to the specified value.\nRequres the bookmarks permission.\n\n  * pageUrl\n\nUrlFilter optional\n\nMatches if the conditions of the `UrlFilter` are fulfilled for the top-level\nURL of the page.\n\n### RequestContentScript\n\nDeclarative event action that injects a content script.\n\n**WARNING:** This action is still experimental and is not supported on stable\nbuilds of Chrome.\n\n#### Properties\n\n  * constructor\n\nvoid\n\nThe `constructor` function looks like:\n\n        \n        (arg: RequestContentScript) => {...}\n\n    * arg\n\nRequestContentScript\n\n    * returns\n\nRequestContentScript\n\n  * allFrames\n\nboolean optional\n\nWhether the content script runs in all frames of the matching page, or in only\nthe top frame. Default is `false`.\n\n  * css\n\nstring[] optional\n\nNames of CSS files to be injected as a part of the content script.\n\n  * js\n\nstring[] optional\n\nNames of JavaScript files to be injected as a part of the content script.\n\n  * matchAboutBlank\n\nboolean optional\n\nWhether to insert the content script on `about:blank` and `about:srcdoc`.\nDefault is `false`.\n\n### SetIcon\n\nDeclarative event action that sets the n-dip square icon for the extension's\npage action or browser action while the corresponding conditions are met. This\naction can be used without host permissions, but the extension must have a\npage or browser action.\n\nExactly one of `imageData` or `path` must be specified. Both are dictionaries\nmapping a number of pixels to an image representation. The image\nrepresentation in `imageData` is an ImageData object; for example, from a\n`canvas` element, while the image representation in `path` is the path to an\nimage file relative to the extension's manifest. If `scale` screen pixels fit\ninto a device-independent pixel, the `scale * n` icon is used. If that scale\nis missing, another image is resized to the required size.\n\n#### Properties\n\n  * constructor\n\nvoid\n\nThe `constructor` function looks like:\n\n        \n        (arg: SetIcon) => {...}\n\n    * arg\n\nSetIcon\n\n    * returns\n\nSetIcon\n\n  * imageData\n\nImageData | object optional\n\nEither an `ImageData` object or a dictionary {size -> ImageData} representing\nan icon to be set. If the icon is specified as a dictionary, the image used is\nchosen depending on the screen's pixel density. If the number of image pixels\nthat fit into one screen space unit equals `scale`, then an image with size\n`scale * n` is selected, where _n_ is the size of the icon in the UI. At least\none image must be specified. Note that `details.imageData = foo` is equivalent\nto `details.imageData = {'16': foo}`.\n\n### ShowAction\n\nChrome 97+\n\nA declarative event action that sets the extension's toolbar action to an\nenabled state while the corresponding conditions are met. This action can be\nused without host permissions. If the extension has the activeTab permission,\nclicking the page action grants access to the active tab.\n\nOn pages where the conditions are not met the extension's toolbar action will\nbe grey-scale, and clicking it will open the context menu, instead of\ntriggering the action.\n\n#### Properties\n\n  * constructor\n\nvoid\n\nThe `constructor` function looks like:\n\n        \n        (arg: ShowAction) => {...}\n\n    * arg\n\nShowAction\n\n    * returns\n\nShowAction\n\n### ShowPageAction\n\nDeprecated since Chrome 97\n\nPlease use `declarativeContent.ShowAction`.\n\nA declarative event action that sets the extension's page action to an enabled\nstate while the corresponding conditions are met. This action can be used\nwithout host permissions, but the extension must have a page action. If the\nextension has the activeTab permission, clicking the page action grants access\nto the active tab.\n\nOn pages where the conditions are not met the extension's toolbar action will\nbe grey-scale, and clicking it will open the context menu, instead of\ntriggering the action.\n\n#### Properties\n\n  * constructor\n\nvoid\n\nThe `constructor` function looks like:\n\n        \n        (arg: ShowPageAction) => {...}\n\n    * arg\n\nShowPageAction\n\n    * returns\n\nShowPageAction\n\n## Events\n\n### onPageChanged\n\nProvides the Declarative Event API consisting of `addRules`, `removeRules`,\nand `getRules`.\n\n#### Conditions\n\nPageStateMatcher\n\n#### Actions\n\nRequestContentScript\n\nSetIcon\n\nShowPageAction\n\nShowAction\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/declarativeNetRequest": "#  chrome.declarativeNetRequest\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.declarativeNetRequest` API is used to block or modify network\nrequests by specifying declarative rules. This lets extensions modify network\nrequests without intercepting them and viewing their content, thus providing\nmore privacy.\n\n## Permissions\n\n`declarativeNetRequest`  \n`declarativeNetRequestWithHostAccess`  \n\nThe \"`declarativeNetRequest`\" and \"`declarativeNetRequestWithHostAccess`\"\npermissions provide the same capabilities. The differences between them is\nwhen permissions are requested or granted.\n\n`\"declarativeNetRequest\"`\n\n    Triggers a permission warning at install time but provides implicit access to `allow`, `allowAllRequests` and `block` rules. Use this when possible to avoid needing to request full access to hosts.\n`\"declarativeNetRequestFeedback\"`\n\n    Enables debugging features for unpacked extensions, specifically `getMatchedRules()` and `onRuleMatchedDebug`.\n`\"declarativeNetRequestWithHostAccess\"`\n\n    A permission warning is not shown at install time, but you must request host permissions before you can perform any action on a host. This is appropriate when you want to use declarative net request rules in an extension which already has host permissions without generating additional warnings.\n\n## Availability\n\nChrome 84+\n\n## Manifest\n\nIn addition to the permissions described previously, certain types of\nrulesets, static rulesets specifically, require declaring the\n`\"declarative_net_request\"` manifest key, which should be a dictionary with a\nsingle key called `\"rule_resources\"`. This key is an array containing\ndictionaries of type `Ruleset`, as shown in the following. (Note that the name\n'Ruleset' does not appear in the manifest's JSON since it is merely an array.)\nStatic rulesets are explained later in this document.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n    \n      \"declarative_net_request\" : {\n        \"rule_resources\" : [{\n          \"id\": \"ruleset_1\",\n          \"enabled\": true,\n          \"path\": \"rules_1.json\"\n        }, {\n          \"id\": \"ruleset_2\",\n          \"enabled\": false,\n          \"path\": \"rules_2.json\"\n        }]\n      },\n      \"permissions\": [\n        \"declarativeNetRequest\",\n        \"declarativeNetRequestFeedback\"\n      ],\n      \"host_permissions\": [\n        \"http://www.blogger.com/*\",\n        \"http://*.google.com/*\"\n      ],\n      ...\n    }\n    \n\n## Rules and rulesets\n\nTo use this API, specify one or more rulesets. A ruleset contains an array of\nrules. A single rule does one of the following:\n\n  * Block a network request.\n  * Upgrade the schema (http to https).\n  * Prevent a request from getting blocked by negating any matching blocked rules.\n  * Redirect a network request.\n  * Modify request or response headers.\n\nThere are three types of rulesets, managed in slightly different ways.\n\nDynamic\n\n    Persist across browser sessions and extension upgrades and are managed using JavaScript while an extension is in use.\nSession\n\n    Cleared when the browser shuts down and when a new version of the extension is installed. Session rules are managed using JavaScript while an extension is in use.\nStatic\n\n    Packaged, installed, and updated when an extension is installed or upgraded. Static rules are stored in JSON-formatted rule files and listed in the manifest file.\n\n### Dynamic and session-scoped rulesets\n\nDynamic and session rulesets are managed using JavaScript while an extension\nis in use.\n\n  * Dynamic rules persist across browser sessions and extension upgrades.\n  * Session rules are cleared when the browser shuts down and when a new version of the extension is installed.\n\nThere is only one each of these ruleset types. An extension can add or remove\nrules to them dynamically by calling `updateDynamicRules()` and\n`updateSessionRules()`, provided the rule limits aren't exceeded. For\ninformation on rule limits, see Rule limits. You can see an example of this\nunder code examples.\n\n### Static rulesets\n\nUnlike dynamic and session rules, static rules are packaged, installed, and\nupdated when an extension is installed or upgraded. They're stored in rule\nfiles in JSON format, which are indicated to the extension using the\n`\"declarative_net_request\"` and `\"rule_resources\"` keys as described above, as\nwell as one or more `Ruleset` dictionaries. A `Ruleset` dictionary contains a\npath to the rule file, an ID for the ruleset contained in the file, and\nwhether the ruleset is enabled or disabled. The last two are important when\nyou enable or disable a ruleset programmatically.\n\n    \n    \n    {\n      ...\n      \"declarative_net_request\" : {\n        \"rule_resources\" : [{\n          \"id\": \"ruleset_1\",\n          \"enabled\": true,\n          \"path\": \"rules_1.json\"\n        },\n        ...\n        ]\n      }\n      ...\n    }\n    \n\nTo test rule files, load your extension unpacked. Errors and warnings about\ninvalid static rules are only displayed for unpacked extensions. Invalid\nstatic rules in packed extensions are ignored.\n\n## Expedited review\n\nChanges to static rulesets may be eligible for expedited review. See expedited\nreview for eligible changes.\n\n## Enable and disable static rules and rulesets\n\nBoth individual static rules and complete static rulesets may be enabled or\ndisabled at runtime.\n\nThe set of enabled static rules and rulesets is persisted across browser\nsessions. Neither are persisted across extension updates, meaning that only\nrules you chose to leave in your rule files are available after an update.\n\nFor performance reasons there are also limits to the number of rules and\nrulesets that may be enabled at one time. Call `getAvailableStaticRuleCount()`\nto check the number of additional rules that may be enabled. For information\non rule limits, see Rule limits.\n\nTo enable or disable static _rules_ , call `updateStaticRules()`. This method\ntakes an `UpdateStaticRulesOptions` object, which contains arrays of IDs of\nrules to enable or disable. The IDs are defined using the `\"id\"` key of the\n`Ruleset` dictionary. There is a maximum limit of 5000 disabled static rules.\n\nTo enable or disable static _rulesets_ , call `updateEnabledRulesets()`. This\nmethod takes an `UpdateRulesetOptions` object, which contains arrays of IDs of\nrulesets to enable or disable. The IDs are defined using the `\"id\"` key of the\n`Ruleset` dictionary.\n\n## Build rules\n\nRegardless of type, a rule starts with four fields as shown in the following.\nWhile the `\"id\"` and `\"priority\"` keys take a number, the `\"action\"` and\n`\"condition\"` keys may provide several blocking and redirecting conditions.\nThe following rule blocks all script requests originating from `\"foo.com\"` to\nany URL with `\"abc\"` as a substring.\n\n    \n    \n    {\n      \"id\" : 1,\n      \"priority\": 1,\n      \"action\" : { \"type\" : \"block\" },\n      \"condition\" : {\n        \"urlFilter\" : \"abc\",\n        \"initiatorDomains\" : [\"foo.com\"],\n        \"resourceTypes\" : [\"script\"]\n      }\n    }\n    \n\n## URL matching\n\nDeclarative Net Request provides the ability to match URLs with either a\npattern matching syntax or regular expressions.\n\n### URL filter syntax\n\nA rule's `\"condition\"` key allows a `\"urlFilter\"` key for acting on URLs under\na specified domain. You create patterns using pattern matching tokens. Here\nare a few examples.\n\n`**urlFilter**` | Matches | Does not match  \n---|---|---  \n`\"abc\"` | https://abcd.com  \nhttps://example.com/abcd | https://ab.com  \n`\"abc*d\"` | https://abcd.com  \nhttps://example.com/abcxyzd | https://abc.com  \n`\"||a.example.com\"` | https://a.example.com/  \nhttps://b.a.example.com/xyz  \nhttps://a.example.company | https://example.com/  \n`\"|https*\"` | https://example.com | http://example.com/  \nhttp://https.com  \n`\"example*^123|\"` | https://example.com/123  \nhttp://abc.com/example?123 | https://example.com/1234  \nhttps://abc.com/example0123  \n  \n### Regular expressions\n\nConditions can also use regular expressions. See the `\"regexFilter\"` key. To\nlearn about the limits that apply to these conditions, see Rules that use\nregular expressions.\n\n### Write good URL conditions\n\nTake care when writing rules to always match an entire domain. Otherwise, your\nrule may match in situations that are unexpected. For example, when using the\npattern matching syntax:\n\n  * `google.com` incorrectly matches `https://example.com/?param=google.com`\n  * `||google.com` incorrectly matches `https://google.company`\n  * `https://www.google.com` incorrectly matches `https://example.com/?param=https://www.google.com`\n\nConsider using:\n\n  * `||google.com/`, which matches all paths and all subdomains.\n  * `|https://www.google.com/` which matches all paths and no subdomains.\n\nSimilarly, use the `^` and `/` characters to anchor a regular expression. For\nexample, `^https:\\/\\/www\\.google\\.com\\/` matches any path on\nhttps://www.google.com.\n\n## Rule evaluation\n\nDNR rules are applied by the browser across various stages of the network\nrequest lifecycle.\n\n### Before the request\n\nBefore a request is made, an extension can block or redirect (including\nupgrading the scheme from HTTP to HTTPS) it with a matching rule.\n\nFor each extension, the browser determines a list of matching rules. Rules\nwith a `modifyHeaders` action are not included here as they will be handled\nlater. Additionally, rules with a `responseHeaders` condition will be\nconsidered later (when response headers are available) and are not included.\n\nThen, for each extension, Chrome picks at most one candidate per request.\nChrome finds a matching rule, by ordering all matching rules by priority.\nRules with the same priority are ordered by action (`allow` or\n`allowAllRequests` > `block` > `upgradeScheme` > `redirect`).\n\nIf the candidate is an `allow` or `allowAllRequests` rule, or the frame the\nrequest is being made in previously matched an `allowAllRequests` rule of\nhigher or equal priority from this extension, the request is \"allowed\" and the\nextension won't have any effect on the request.\n\nIf more than one extension wants to block or redirect this request, a single\naction to take is chosen. Chrome does this by sorting the rules in the order\n`block` > `redirect` or `upgradeScheme` > `allow` or `allowAllRequests`. If\ntwo rules are of the same type, Chrome chooses the rule from the most recently\ninstalled extension.\n\n**Caution:** Browser vendors have agreed not to standardize the order in which\nrules with the same action and priority run. This can change between runs or\nbrowser versions, even when spread between multiple types of ruleset (such as\na static rule and a session rule). When ordering is important, you should\nalways explicitly specify a priority.\n\n### Before request headers are sent\n\nBefore Chrome sends request headers to the server, the headers are updated\nbased on matching `modifyHeaders` rules.\n\nWithin a single extension, Chrome builds the list of modifications to perform\nby finding all matching `modifyHeaders` rules. Similar to before, only rules\nwhich have a higher priority than any matching `allow` or `allowAllRequests`\nrules are included.\n\nThese rules are applied by Chrome in an order such that rules from a more\nrecently installed extension are always evaluated before rules from an older\nextension. Additionally, rules of a higher priority from one extension are\nalways applied before rules of a lower priority from the same extension.\nNotably, even across extensions:\n\n  * If a rule appends to a header, then lower priority rules can only append to that header. Set and remove operations are not allowed.\n  * If a rule sets a header, then only lower priority rules from the same extension can append to that header. No other modifications are allowed.\n  * If a rule removes a header, then lower priority rules cannot further modify the header.\n\n### Once a response is received\n\nOnce the response headers have been received, Chrome evaluates rules with a\n`responseHeaders` condition.\n\nAfter sorting these rules by `action` and `priority` and excluding any rules\nmade redundant by a matching `allow` or `allowAllRequests` rule (this happens\nidentically to the steps in \"Before the request\"), Chrome may block or\nredirect the request on behalf of an extension.\n\nNote that if a request made it to this stage, the request has already been\nsent to the server and the server has received data like the request body. A\nblock or redirect rule with a response headers condition will still runbut\ncannot actually block or redirect the request.\n\nIn the case of a block rule, this is handled by the page which made the\nrequest receiving a blocked response and Chrome terminating the request early.\nIn the case of a redirect rule, Chrome makes a new request to the redirected\nURL. Make sure to consider if these behaviors meet the privacy expectations\nfor your extension.\n\nIf the request is not blocked or redirected, Chrome applies any\n`modifyHeaders` rules. Applying modifications to response headers works in the\nsame way as described in \"Before request headers are sent\". Applying\nmodifications to request headers does nothing, since the request has already\nbeen made.\n\n## Safe rules\n\nSafe rules are defined as rules with an action of `block`, `allow`,\n`allowAllRequests` or `upgradeScheme`. These rules are subject to an increased\ndynamic rules quota.\n\n## Rule limits\n\nThere is a performance overhead to loading and evaluating rules in the\nbrowser, so some limits apply when using the API. Limits depend on the type of\nrule you're using.\n\n### Static rules\n\nStatic rules are those specified in rule files declared in the manifest file.\nAn extension can specify up to 100 static rulesets as part of the\n`\"rule_resources\"` manifest key, but only 50 of these rulesets can be enabled\nat a time. The latter is called the `MAX_NUMBER_OF_ENABLED_STATIC_RULESETS`.\nCollectively, those rulesets are guaranteed at least 30,000 rules. This is\ncalled the `GUARANTEED_MINIMUM_STATIC_RULES`.\n\n**Note:** Prior to Chrome 120, extensions were limited to a total of 50 static\nrulesets, and only 10 of these could be enabled at the same time. Use the\n`minimum_chrome_version` manifest field to limit which Chrome versions can\ninstall your extension.\n\nThe number of rules available after that depends on how many rules are enabled\nby all the extensions installed on a user's browser. You can find this number\nat runtime by calling `getAvailableStaticRuleCount()`. You can see an example\nof this under code examples.\n\n**Note:** Starting with Chrome 128, if a user disables an extension through\nchrome://extensions, the extension's static rules will no longer count towards\nthe global static rule limit. This potentially frees up static rule quota for\nother extensions, but also means that when the extension gets re-enabled, it\nmight have fewer static rules available than before.\n\n### Session rules\n\nAn extension can have up to 5000 session rules. This is exposed as the\n`MAX_NUMBER_OF_SESSION_RULES`.\n\nBefore Chrome 120, there was a limit of 5000 combined dynamic and session\nrules.\n\n### Dynamic rules\n\nAn extension can have at least 5000 dynamic rules. This is exposed as the\n`MAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES`.\n\nStarting in Chrome 121, there is a larger limit of 30,000 rules available for\nsafe dynamic rules, exposed as the `MAX_NUMBER_OF_DYNAMIC_RULES`. Any unsafe\nrules added within the limit of 5000 will also count towards this limit.\n\nBefore Chrome 120, there was a 5000 combined dynamic and session rules limit.\n\n### Rules that use regular expressions\n\nAll types of rules can use regular expressions; however, the total number of\nregular expression rules of each type cannot exceed 1000. This is called the\nMAX_NUMBER_OF_REGEX_RULES.\n\nAdditionally, each rule must be less than 2KB once compiled. This roughly\ncorrelates with the complexity of the rule. If you try to load a rule that\nexceeds this limit, you will see a warning like the following and the rule\nwill be ignored.\n\n    \n    \n    rules_1.json: Rule with id 1 specified a more complex regex than allowed\n    as part of the \"regexFilter\" key.\n    \n\n## Interactions with service workers\n\nA declarativeNetRequest only applies to requests that reach the network stack.\nThis includes responses from the HTTP cache, but may not include responses\nthat go through a service worker's `onfetch` handler. declarativeNetRequest\nwon't affect responses generated by the service worker or retrieved from\n`CacheStorage`, but it will affect calls to `fetch()` made in a service\nworker.\n\n## Web accessible resources\n\nA declarativeNetRequest rule cannot redirect from a public resource request to\na resource that is not web accessible. Doing so triggers an error. This is\ntrue even if the specified web accessible resource is owned by the redirecting\nextension. To declare resources for declarativeNetRequest, use the manifest's\n`\"web_accessible_resources\"` array.\n\n## Header modification\n\nThe append operation is only supported for the following headers: `accept`,\n`accept-encoding`, `accept-language`, `access-control-request-headers`,\n`cache-control`, `connection`, `content-language`, `cookie`, `forwarded`, `if-\nmatch`, `if-none-match`, `keep-alive`, `range`, `te`, `trailer`, `transfer-\nencoding`, `upgrade`, `user-agent`, `via`, `want-digest`, `x-forwarded-for`.\n\n## Examples\n\n### Code examples\n\n#### Update dynamic rules\n\nThe following example shows how to call `updateDynamicRules()`. The procedure\nfor `updateSessionRules()` is the same.\n\n    \n    \n    // Get arrays containing new and old rules\n    const newRules = await getNewRules();\n    const oldRules = await chrome.declarativeNetRequest.getDynamicRules();\n    const oldRuleIds = oldRules.map(rule => rule.id);\n    \n    // Use the arrays to update the dynamic rules\n    await chrome.declarativeNetRequest.updateDynamicRules({\n      removeRuleIds: oldRuleIds,\n      addRules: newRules\n    });\n    \n\n#### Update static rulesets\n\nThe following example shows how to enable and disable rulesets while\nconsidering the number of available and the maximum number of enabled static\nrulesets. You would do this when the number of static rules you need exceeds\nthe number allowed. For this to work, some of your rulesets should be\ninstalled with some of your rulesets disabled (setting `\"Enabled\"` to `false`\nwithin the manifest file).\n\n    \n    \n    async function updateStaticRules(enableRulesetIds, disableCandidateIds) {\n      // Create the options structure for the call to updateEnabledRulesets()\n      let options = { enableRulesetIds: enableRulesetIds }\n      // Get the number of enabled static rules\n      const enabledStaticCount = await chrome.declarativeNetRequest.getEnabledRulesets();\n      // Compare rule counts to determine if anything needs to be disabled so that\n      // new rules can be enabled\n      const proposedCount = enableRulesetIds.length;\n      if (enabledStaticCount + proposedCount > chrome.declarativeNetRequest.MAX_NUMBER_OF_ENABLED_STATIC_RULESETS) {\n        options.disableRulesetIds = disableCandidateIds\n      }\n      // Update the enabled static rules\n      await chrome.declarativeNetRequest.updateEnabledRulesets(options);\n    }\n    \n\n### Rule examples\n\nThe following examples illustrate how Chrome prioritizes rules in an\nextension. When reviewing them, you may want to open the prioritization rules\nin a separate window.\n\n#### The \"priority\" key\n\nThese examples require host permission to `*://*.example.com/*`.\n\nTo work out the priority of a particular URL, look at the (developer-defined)\n`\"priority\"` key, the `\"action\"` key and the `\"urlFilter\"` key. These examples\nrefer to the example rule file shown below them.\n\nNavigation to https://google.com\n\n    Two rules cover this URL: the rules with IDs 1 and 4. The rule with ID 1 applies because `\"block\"` actions have a higher priority than `\"redirect\"` actions. The remaining rules don't apply because they are for longer URLs.\nNavigation to https://google.com/1234\n\n    Because of the longer URL, the rule with ID 2 now matches in addition to the rules with IDs 1 and 4. The rule with ID 2 applies because `\"allow\"` has a higher priority than `\"block\"` and `\"redirect\"`.\nNavigation to https://google.com/12345\n\n    All four rules match this URL. The rule with ID 3 applies because its developer-defined priority is the highest of the group.\n    \n    \n    [\n      {\n        \"id\": 1,\n        \"priority\": 1,\n        \"action\": { \"type\": \"block\" },\n        \"condition\": {\"urlFilter\": \"||google.com/\", \"resourceTypes\": [\"main_frame\"] }\n      },\n      {\n        \"id\": 2,\n        \"priority\": 1,\n        \"action\": { \"type\": \"allow\" },\n        \"condition\": { \"urlFilter\": \"||google.com/123\", \"resourceTypes\": [\"main_frame\"] }\n      },\n      {\n        \"id\": 3,\n        \"priority\": 2,\n        \"action\": { \"type\": \"block\" },\n        \"condition\": { \"urlFilter\": \"||google.com/12345\", \"resourceTypes\": [\"main_frame\"] }\n      },\n      {\n        \"id\": 4,\n        \"priority\": 1,\n        \"action\": { \"type\": \"redirect\", \"redirect\": { \"url\": \"https://example.com\" } },\n        \"condition\": { \"urlFilter\": \"||google.com/\", \"resourceTypes\": [\"main_frame\"] }\n      },\n    ]\n    \n\n#### Redirects\n\nThe example below requires host permission to `*://*.example.com/*`.\n\nThe following example shows how to redirect a request from example.com to a\npage within the extension itself. The extension path `/a.jpg` resolves to\n`chrome-extension://EXTENSION_ID/a.jpg`, where `EXTENSION_ID` is the ID of\nyour extension. For this to work the manifest should declare `/a.jpg` as a web\naccessible resource.\n\n    \n    \n    {\n      \"id\": 1,\n      \"priority\": 1,\n      \"action\": { \"type\": \"redirect\", \"redirect\": { \"extensionPath\": \"/a.jpg\" } },\n      \"condition\": {\n        \"urlFilter\": \"||https://www.example.com/\",\n        \"resourceTypes\": [\"main_frame\"]\n      }\n    }\n    \n\nThe following uses the `\"transform\"` key to redirect to a subdomain of\nexample.com. It uses a domain name anchor (\"||\") to intercept requests with\nany scheme from example.com. The `\"scheme\"` key in `\"transform\"` specifies\nthat redirects to the subdomain will always use \"https\".\n\n    \n    \n    {\n      \"id\": 1,\n      \"priority\": 1,\n      \"action\": {\n        \"type\": \"redirect\",\n        \"redirect\": {\n          \"transform\": { \"scheme\": \"https\", \"host\": \"new.example.com\" }\n        }\n      },\n      \"condition\": {\n        \"urlFilter\": \"||example.com/\",\n        \"resourceTypes\": [\"main_frame\"]\n      }\n    }\n    \n\nThe following example uses regular expressions to redirect from\n`https://www.abc.xyz.com/path` to `https://abc.xyz.com/path`. In the\n`\"regexFilter\"` key, notice how periods are escaped and that the capturing\ngroup selects either \"abc\" or \"def\". The `\"regexSubstitution\"` key specifies\nthe first returned match of the regular expression using \"\\1\". In this case,\n\"abc\" is captured from the redirected URL and placed in the substitution.\n\n    \n    \n    {\n      \"id\": 1,\n      \"priority\": 1,\n      \"action\": {\n        \"type\": \"redirect\",\n        \"redirect\": {\n          \"regexSubstitution\": \"https://\\\\1.xyz.com/\"\n        }\n      },\n      \"condition\": {\n        \"regexFilter\": \"^https://www\\\\.(abc|def)\\\\.xyz\\\\.com/\",\n        \"resourceTypes\": [\n          \"main_frame\"\n        ]\n      }\n    }\n    \n\n#### Headers\n\nThe following example removes all cookies from both a main frame and any sub\nframes.\n\n    \n    \n    {\n      \"id\": 1,\n      \"priority\": 1,\n      \"action\": {\n        \"type\": \"modifyHeaders\",\n        \"requestHeaders\": [{ \"header\": \"cookie\", \"operation\": \"remove\" }]\n      },\n      \"condition\": { \"resourceTypes\": [\"main_frame\", \"sub_frame\"] }\n    }\n    \n\n## Types\n\n### DomainType\n\nThis describes whether the request is first or third party to the frame in\nwhich it originated. A request is said to be first party if it has the same\ndomain (eTLD+1) as the frame in which the request originated.\n\n#### Enum\n\n\"firstParty\"  \nThe network request is first party to the frame in which it originated.\n\n\"thirdParty\"  \nThe network request is third party to the frame in which it originated.\n\n### ExtensionActionOptions\n\nChrome 88+\n\n#### Properties\n\n  * displayActionCountAsBadgeText\n\nboolean optional\n\nWhether to automatically display the action count for a page as the\nextension's badge text. This preference is persisted across sessions.\n\n  * tabUpdate\n\nTabActionCountUpdate optional\n\nChrome 89+\n\nDetails of how the tab's action count should be adjusted.\n\n### GetDisabledRuleIdsOptions\n\nChrome 111+\n\n#### Properties\n\n  * rulesetId\n\nstring\n\nThe id corresponding to a static `Ruleset`.\n\n### GetRulesFilter\n\nChrome 111+\n\n#### Properties\n\n  * ruleIds\n\nnumber[] optional\n\nIf specified, only rules with matching IDs are included.\n\n### HeaderInfo\n\nChrome 128+\n\n#### Properties\n\n  * excludedValues\n\nstring[] optional\n\nIf specified, this condition is not matched if the header exists but its value\ncontains at least one element in this list. This uses the same match pattern\nsyntax as `values`.\n\n  * header\n\nstring\n\nThe name of the header. This condition matches on the name only if both\n`values` and `excludedValues` are not specified.\n\n  * values\n\nstring[] optional\n\nIf specified, this condition matches if the header's value matches at least\none pattern in this list. This supports case-insensitive header value matching\nplus the following constructs:\n\n**'*'** : Matches any number of characters.\n\n**'?'** : Matches zero or one character(s).\n\n'*' and '?' can be escaped with a backslash, e.g. '\\\\*' and '\\?'\n\n### HeaderOperation\n\nChrome 86+\n\nThis describes the possible operations for a \"modifyHeaders\" rule.\n\n#### Enum\n\n\"append\"  \nAdds a new entry for the specified header. This operation is not supported for\nrequest headers.\n\n\"set\"  \nSets a new value for the specified header, removing any existing headers with\nthe same name.\n\n\"remove\"  \nRemoves all entries for the specified header.\n\n### IsRegexSupportedResult\n\nChrome 87+\n\n#### Properties\n\n  * isSupported\n\nboolean\n\n  * reason\n\nUnsupportedRegexReason optional\n\nSpecifies the reason why the regular expression is not supported. Only\nprovided if `isSupported` is false.\n\n### MatchedRule\n\n#### Properties\n\n  * ruleId\n\nnumber\n\nA matching rule's ID.\n\n  * rulesetId\n\nstring\n\nID of the `Ruleset` this rule belongs to. For a rule originating from the set\nof dynamic rules, this will be equal to `DYNAMIC_RULESET_ID`.\n\n### MatchedRuleInfo\n\n#### Properties\n\n  * rule\n\nMatchedRule\n\n  * tabId\n\nnumber\n\nThe tabId of the tab from which the request originated if the tab is still\nactive. Else -1.\n\n  * timeStamp\n\nnumber\n\nThe time the rule was matched. Timestamps will correspond to the Javascript\nconvention for times, i.e. number of milliseconds since the epoch.\n\n### MatchedRuleInfoDebug\n\n#### Properties\n\n  * request\n\nRequestDetails\n\nDetails about the request for which the rule was matched.\n\n  * rule\n\nMatchedRule\n\n### MatchedRulesFilter\n\n#### Properties\n\n  * minTimeStamp\n\nnumber optional\n\nIf specified, only matches rules after the given timestamp.\n\n  * tabId\n\nnumber optional\n\nIf specified, only matches rules for the given tab. Matches rules not\nassociated with any active tab if set to -1.\n\n### ModifyHeaderInfo\n\nChrome 86+\n\n#### Properties\n\n  * header\n\nstring\n\nThe name of the header to be modified.\n\n  * operation\n\nHeaderOperation\n\nThe operation to be performed on a header.\n\n  * value\n\nstring optional\n\nThe new value for the header. Must be specified for `append` and `set`\noperations.\n\n### QueryKeyValue\n\n#### Properties\n\n  * key\n\nstring\n\n  * replaceOnly\n\nboolean optional\n\nChrome 94+\n\nIf true, the query key is replaced only if it's already present. Otherwise,\nthe key is also added if it's missing. Defaults to false.\n\n  * value\n\nstring\n\n### QueryTransform\n\n#### Properties\n\n  * addOrReplaceParams\n\nQueryKeyValue[] optional\n\nThe list of query key-value pairs to be added or replaced.\n\n  * removeParams\n\nstring[] optional\n\nThe list of query keys to be removed.\n\n### Redirect\n\n#### Properties\n\n  * extensionPath\n\nstring optional\n\nPath relative to the extension directory. Should start with '/'.\n\n  * regexSubstitution\n\nstring optional\n\nSubstitution pattern for rules which specify a `regexFilter`. The first match\nof `regexFilter` within the url will be replaced with this pattern. Within\n`regexSubstitution`, backslash-escaped digits (\\1 to \\9) can be used to insert\nthe corresponding capture groups. \\0 refers to the entire matching text.\n\n  * transform\n\nURLTransform optional\n\nUrl transformations to perform.\n\n  * url\n\nstring optional\n\nThe redirect url. Redirects to JavaScript urls are not allowed.\n\n### RegexOptions\n\nChrome 87+\n\n#### Properties\n\n  * isCaseSensitive\n\nboolean optional\n\nWhether the `regex` specified is case sensitive. Default is true.\n\n  * regex\n\nstring\n\nThe regular expresson to check.\n\n  * requireCapturing\n\nboolean optional\n\nWhether the `regex` specified requires capturing. Capturing is only required\nfor redirect rules which specify a `regexSubstition` action. The default is\nfalse.\n\n### RequestDetails\n\n#### Properties\n\n  * documentId\n\nstring optional\n\nChrome 106+\n\nThe unique identifier for the frame's document, if this request is for a\nframe.\n\n  * documentLifecycle\n\nDocumentLifecycle optional\n\nChrome 106+\n\nThe lifecycle of the frame's document, if this request is for a frame.\n\n  * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n  * frameType\n\nFrameType optional\n\nChrome 106+\n\nThe type of the frame, if this request is for a frame.\n\n  * initiator\n\nstring optional\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n  * method\n\nstring\n\nStandard HTTP method.\n\n  * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe unique identifier for the frame's parent document, if this request is for\na frame and has a parent.\n\n  * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n  * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session.\n\n  * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n  * type\n\nResourceType\n\nThe resource type of the request.\n\n  * url\n\nstring\n\nThe URL of the request.\n\n### RequestMethod\n\nChrome 91+\n\nThis describes the HTTP request method of a network request.\n\n#### Enum\n\n\"connect\"  \n\n\"delete\"  \n\n\"get\"  \n\n\"head\"  \n\n\"options\"  \n\n\"patch\"  \n\n\"post\"  \n\n\"put\"  \n\n\"other\"  \n\n### ResourceType\n\nThis describes the resource type of the network request.\n\n#### Enum\n\n\"main_frame\"  \n\n\"sub_frame\"  \n\n\"stylesheet\"  \n\n\"script\"  \n\n\"image\"  \n\n\"font\"  \n\n\"object\"  \n\n\"xmlhttprequest\"  \n\n\"ping\"  \n\n\"csp_report\"  \n\n\"media\"  \n\n\"websocket\"  \n\n\"webtransport\"  \n\n\"webbundle\"  \n\n\"other\"  \n\n### Rule\n\n#### Properties\n\n  * action\n\nRuleAction\n\nThe action to take if this rule is matched.\n\n  * condition\n\nRuleCondition\n\nThe condition under which this rule is triggered.\n\n  * id\n\nnumber\n\nAn id which uniquely identifies a rule. Mandatory and should be >= 1.\n\n  * priority\n\nnumber optional\n\nRule priority. Defaults to 1. When specified, should be >= 1.\n\n### RuleAction\n\n#### Properties\n\n  * redirect\n\nRedirect optional\n\nDescribes how the redirect should be performed. Only valid for redirect rules.\n\n  * requestHeaders\n\nModifyHeaderInfo[] optional\n\nChrome 86+\n\nThe request headers to modify for the request. Only valid if RuleActionType is\n\"modifyHeaders\".\n\n  * responseHeaders\n\nModifyHeaderInfo[] optional\n\nChrome 86+\n\nThe response headers to modify for the request. Only valid if RuleActionType\nis \"modifyHeaders\".\n\n  * type\n\nRuleActionType\n\nThe type of action to perform.\n\n### RuleActionType\n\nDescribes the kind of action to take if a given RuleCondition matches.\n\n#### Enum\n\n\"block\"  \nBlock the network request.\n\n\"redirect\"  \nRedirect the network request.\n\n\"allow\"  \nAllow the network request. The request won't be intercepted if there is an\nallow rule which matches it.\n\n\"upgradeScheme\"  \nUpgrade the network request url's scheme to https if the request is http or\nftp.\n\n\"modifyHeaders\"  \nModify request/response headers from the network request.\n\n\"allowAllRequests\"  \nAllow all requests within a frame hierarchy, including the frame request\nitself.\n\n### RuleCondition\n\n#### Properties\n\n  * domainType\n\nDomainType optional\n\nSpecifies whether the network request is first-party or third-party to the\ndomain from which it originated. If omitted, all requests are accepted.\n\n  * domains\n\nstring[] optional\n\nDeprecated since Chrome 101\n\nUse `initiatorDomains` instead\n\nThe rule will only match network requests originating from the list of\n`domains`.\n\n  * excludedDomains\n\nstring[] optional\n\nDeprecated since Chrome 101\n\nUse `excludedInitiatorDomains` instead\n\nThe rule will not match network requests originating from the list of\n`excludedDomains`.\n\n  * excludedInitiatorDomains\n\nstring[] optional\n\nChrome 101+\n\nThe rule will not match network requests originating from the list of\n`excludedInitiatorDomains`. If the list is empty or omitted, no domains are\nexcluded. This takes precedence over `initiatorDomains`.\n\nNotes:\n\n    * Sub-domains like \"a.example.com\" are also allowed.\n    * The entries must consist of only ascii characters.\n    * Use punycode encoding for internationalized domains.\n    * This matches against the request initiator and not the request url.\n    * Sub-domains of the listed domains are also excluded.\n  * excludedRequestDomains\n\nstring[] optional\n\nChrome 101+\n\nThe rule will not match network requests when the domains matches one from the\nlist of `excludedRequestDomains`. If the list is empty or omitted, no domains\nare excluded. This takes precedence over `requestDomains`.\n\nNotes:\n\n    * Sub-domains like \"a.example.com\" are also allowed.\n    * The entries must consist of only ascii characters.\n    * Use punycode encoding for internationalized domains.\n    * Sub-domains of the listed domains are also excluded.\n  * excludedRequestMethods\n\nRequestMethod[] optional\n\nChrome 91+\n\nList of request methods which the rule won't match. Only one of\n`requestMethods` and `excludedRequestMethods` should be specified. If neither\nof them is specified, all request methods are matched.\n\n  * excludedResourceTypes\n\nResourceType[] optional\n\nList of resource types which the rule won't match. Only one of `resourceTypes`\nand `excludedResourceTypes` should be specified. If neither of them is\nspecified, all resource types except \"main_frame\" are blocked.\n\n  * excludedResponseHeaders\n\nHeaderInfo[] optional\n\nChrome 128+\n\nRule does not match if the request matches any response header condition in\nthis list (if specified). If both `excludedResponseHeaders` and\n`responseHeaders` are specified, then the `excludedResponseHeaders` property\ntakes precedence.\n\n  * excludedTabIds\n\nnumber[] optional\n\nChrome 92+\n\nList of `tabs.Tab.id` which the rule should not match. An ID of\n`tabs.TAB_ID_NONE` excludes requests which don't originate from a tab. Only\nsupported for session-scoped rules.\n\n  * initiatorDomains\n\nstring[] optional\n\nChrome 101+\n\nThe rule will only match network requests originating from the list of\n`initiatorDomains`. If the list is omitted, the rule is applied to requests\nfrom all domains. An empty list is not allowed.\n\nNotes:\n\n    * Sub-domains like \"a.example.com\" are also allowed.\n    * The entries must consist of only ascii characters.\n    * Use punycode encoding for internationalized domains.\n    * This matches against the request initiator and not the request url.\n    * Sub-domains of the listed domains are also matched.\n  * isUrlFilterCaseSensitive\n\nboolean optional\n\nWhether the `urlFilter` or `regexFilter` (whichever is specified) is case\nsensitive. Default is false.\n\n  * regexFilter\n\nstring optional\n\nRegular expression to match against the network request url. This follows the\nRE2 syntax.\n\nNote: Only one of `urlFilter` or `regexFilter` can be specified.\n\nNote: The `regexFilter` must be composed of only ASCII characters. This is\nmatched against a url where the host is encoded in the punycode format (in\ncase of internationalized domains) and any other non-ascii characters are url\nencoded in utf-8.\n\n  * requestDomains\n\nstring[] optional\n\nChrome 101+\n\nThe rule will only match network requests when the domain matches one from the\nlist of `requestDomains`. If the list is omitted, the rule is applied to\nrequests from all domains. An empty list is not allowed.\n\nNotes:\n\n    * Sub-domains like \"a.example.com\" are also allowed.\n    * The entries must consist of only ascii characters.\n    * Use punycode encoding for internationalized domains.\n    * Sub-domains of the listed domains are also matched.\n  * requestMethods\n\nRequestMethod[] optional\n\nChrome 91+\n\nList of HTTP request methods which the rule can match. An empty list is not\nallowed.\n\nNote: Specifying a `requestMethods` rule condition will also exclude non-\nHTTP(s) requests, whereas specifying `excludedRequestMethods` will not.\n\n  * resourceTypes\n\nResourceType[] optional\n\nList of resource types which the rule can match. An empty list is not allowed.\n\nNote: this must be specified for `allowAllRequests` rules and may only include\nthe `sub_frame` and `main_frame` resource types.\n\n  * responseHeaders\n\nHeaderInfo[] optional\n\nChrome 128+\n\nRule matches if the request matches any response header condition in this list\n(if specified).\n\n  * tabIds\n\nnumber[] optional\n\nChrome 92+\n\nList of `tabs.Tab.id` which the rule should match. An ID of `tabs.TAB_ID_NONE`\nmatches requests which don't originate from a tab. An empty list is not\nallowed. Only supported for session-scoped rules.\n\n  * urlFilter\n\nstring optional\n\nThe pattern which is matched against the network request url. Supported\nconstructs:\n\n**'*'** : Wildcard: Matches any number of characters.\n\n**'|'** : Left/right anchor: If used at either end of the pattern, specifies\nthe beginning/end of the url respectively.\n\n**'||'** : Domain name anchor: If used at the beginning of the pattern,\nspecifies the start of a (sub-)domain of the URL.\n\n**'^'** : Separator character: This matches anything except a letter, a digit,\nor one of the following: `_`, `-`, `.`, or `%`. This also match the end of the\nURL.\n\nTherefore `urlFilter` is composed of the following parts: (optional\nLeft/Domain name anchor) + pattern + (optional Right anchor).\n\nIf omitted, all urls are matched. An empty string is not allowed.\n\nA pattern beginning with `||*` is not allowed. Use `*` instead.\n\nNote: Only one of `urlFilter` or `regexFilter` can be specified.\n\nNote: The `urlFilter` must be composed of only ASCII characters. This is\nmatched against a url where the host is encoded in the punycode format (in\ncase of internationalized domains) and any other non-ascii characters are url\nencoded in utf-8. For example, when the request url is http://abc.?q=, the\n`urlFilter` will be matched against the url http://abc.xn--p1ai/?q=%D1%84.\n\n### Ruleset\n\n#### Properties\n\n  * enabled\n\nboolean\n\nWhether the ruleset is enabled by default.\n\n  * id\n\nstring\n\nA non-empty string uniquely identifying the ruleset. IDs beginning with '_'\nare reserved for internal use.\n\n  * path\n\nstring\n\nThe path of the JSON ruleset relative to the extension directory.\n\n### RulesMatchedDetails\n\n#### Properties\n\n  * rulesMatchedInfo\n\nMatchedRuleInfo[]\n\nRules matching the given filter.\n\n### TabActionCountUpdate\n\nChrome 89+\n\n#### Properties\n\n  * increment\n\nnumber\n\nThe amount to increment the tab's action count by. Negative values will\ndecrement the count.\n\n  * tabId\n\nnumber\n\nThe tab for which to update the action count.\n\n### TestMatchOutcomeResult\n\nChrome 103+\n\n#### Properties\n\n  * matchedRules\n\nMatchedRule[]\n\nThe rules (if any) that match the hypothetical request.\n\n### TestMatchRequestDetails\n\nChrome 103+\n\n#### Properties\n\n  * initiator\n\nstring optional\n\nThe initiator URL (if any) for the hypothetical request.\n\n  * method\n\nRequestMethod optional\n\nStandard HTTP method of the hypothetical request. Defaults to \"get\" for HTTP\nrequests and is ignored for non-HTTP requests.\n\n  * responseHeaders\n\nobject optional\n\nChrome 129+\n\nThe headers provided by a hypothetical response if the request does not get\nblocked or redirected before it is sent. Represented as an object which maps a\nheader name to a list of string values. If not specified, the hypothetical\nresponse would return empty response headers, which can match rules which\nmatch on the non-existence of headers. E.g. `{\"content-type\": [\"text/html;\ncharset=utf-8\", \"multipart/form-data\"]}`\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab in which the hypothetical request takes place. Does not need\nto correspond to a real tab ID. Default is -1, meaning that the request isn't\nrelated to a tab.\n\n  * type\n\nResourceType\n\nThe resource type of the hypothetical request.\n\n  * url\n\nstring\n\nThe URL of the hypothetical request.\n\n### UnsupportedRegexReason\n\nChrome 87+\n\nDescribes the reason why a given regular expression isn't supported.\n\n#### Enum\n\n\"syntaxError\"  \nThe regular expression is syntactically incorrect, or uses features not\navailable in the RE2 syntax.\n\n\"memoryLimitExceeded\"  \nThe regular expression exceeds the memory limit.\n\n### UpdateRuleOptions\n\nChrome 87+\n\n#### Properties\n\n  * addRules\n\nRule[] optional\n\nRules to add.\n\n  * removeRuleIds\n\nnumber[] optional\n\nIDs of the rules to remove. Any invalid IDs will be ignored.\n\n### UpdateRulesetOptions\n\nChrome 87+\n\n#### Properties\n\n  * disableRulesetIds\n\nstring[] optional\n\nThe set of ids corresponding to a static `Ruleset` that should be disabled.\n\n  * enableRulesetIds\n\nstring[] optional\n\nThe set of ids corresponding to a static `Ruleset` that should be enabled.\n\n### UpdateStaticRulesOptions\n\nChrome 111+\n\n#### Properties\n\n  * disableRuleIds\n\nnumber[] optional\n\nSet of ids corresponding to rules in the `Ruleset` to disable.\n\n  * enableRuleIds\n\nnumber[] optional\n\nSet of ids corresponding to rules in the `Ruleset` to enable.\n\n  * rulesetId\n\nstring\n\nThe id corresponding to a static `Ruleset`.\n\n### URLTransform\n\n#### Properties\n\n  * fragment\n\nstring optional\n\nThe new fragment for the request. Should be either empty, in which case the\nexisting fragment is cleared; or should begin with '#'.\n\n  * host\n\nstring optional\n\nThe new host for the request.\n\n  * password\n\nstring optional\n\nThe new password for the request.\n\n  * path\n\nstring optional\n\nThe new path for the request. If empty, the existing path is cleared.\n\n  * port\n\nstring optional\n\nThe new port for the request. If empty, the existing port is cleared.\n\n  * query\n\nstring optional\n\nThe new query for the request. Should be either empty, in which case the\nexisting query is cleared; or should begin with '?'.\n\n  * queryTransform\n\nQueryTransform optional\n\nAdd, remove or replace query key-value pairs.\n\n  * scheme\n\nstring optional\n\nThe new scheme for the request. Allowed values are \"http\", \"https\", \"ftp\" and\n\"chrome-extension\".\n\n  * username\n\nstring optional\n\nThe new username for the request.\n\n## Properties\n\n### DYNAMIC_RULESET_ID\n\nRuleset ID for the dynamic rules added by the extension.\n\n#### Value\n\n\"_dynamic\"  \n\n### GETMATCHEDRULES_QUOTA_INTERVAL\n\nTime interval within which `MAX_GETMATCHEDRULES_CALLS_PER_INTERVAL\ngetMatchedRules` calls can be made, specified in minutes. Additional calls\nwill fail immediately and set `runtime.lastError`. Note: `getMatchedRules`\ncalls associated with a user gesture are exempt from the quota.\n\n#### Value\n\n10  \n\n### GUARANTEED_MINIMUM_STATIC_RULES\n\nChrome 89+\n\nThe minimum number of static rules guaranteed to an extension across its\nenabled static rulesets. Any rules above this limit will count towards the\nglobal static rule limit.\n\n#### Value\n\n30000  \n\n### MAX_GETMATCHEDRULES_CALLS_PER_INTERVAL\n\nThe number of times `getMatchedRules` can be called within a period of\n`GETMATCHEDRULES_QUOTA_INTERVAL`.\n\n#### Value\n\n20  \n\n### MAX_NUMBER_OF_DYNAMIC_RULES\n\nThe maximum number of dynamic rules that an extension can add.\n\n#### Value\n\n30000  \n\n### MAX_NUMBER_OF_ENABLED_STATIC_RULESETS\n\nChrome 94+\n\nThe maximum number of static `Rulesets` an extension can enable at any one\ntime.\n\n#### Value\n\n50  \n\n### MAX_NUMBER_OF_REGEX_RULES\n\nThe maximum number of regular expression rules that an extension can add. This\nlimit is evaluated separately for the set of dynamic rules and those specified\nin the rule resources file.\n\n#### Value\n\n1000  \n\n### MAX_NUMBER_OF_SESSION_RULES\n\nChrome 120+\n\nThe maximum number of session scoped rules that an extension can add.\n\n#### Value\n\n5000  \n\n### MAX_NUMBER_OF_STATIC_RULESETS\n\nThe maximum number of static `Rulesets` an extension can specify as part of\nthe `\"rule_resources\"` manifest key.\n\n#### Value\n\n100  \n\n### MAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES\n\nChrome 120+\n\nThe maximum number of \"unsafe\" dynamic rules that an extension can add.\n\n#### Value\n\n5000  \n\n### MAX_NUMBER_OF_UNSAFE_SESSION_RULES\n\nChrome 120+\n\nThe maximum number of \"unsafe\" session scoped rules that an extension can add.\n\n#### Value\n\n5000  \n\n### SESSION_RULESET_ID\n\nChrome 90+\n\nRuleset ID for the session-scoped rules added by the extension.\n\n#### Value\n\n\"_session\"  \n\n## Methods\n\n### getAvailableStaticRuleCount()\n\nPromise Chrome 89+\n\n    \n    \n    chrome.declarativeNetRequest.getAvailableStaticRuleCount(  \n      callback?: function,  \n    )\n\nReturns the number of static rules an extension can enable before the global\nstatic rule limit is reached.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (count: number) => void\n\n    * count\n\nnumber\n\n#### Returns\n\n  * Promise<number>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDisabledRuleIds()\n\nPromise Chrome 111+\n\n    \n    \n    chrome.declarativeNetRequest.getDisabledRuleIds(  \n      options: GetDisabledRuleIdsOptions,  \n      callback?: function,  \n    )\n\nReturns the list of static rules in the given `Ruleset` that are currently\ndisabled.\n\n#### Parameters\n\n  * options\n\nGetDisabledRuleIdsOptions\n\nSpecifies the ruleset to query.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (disabledRuleIds: number[]) => void\n\n    * disabledRuleIds\n\nnumber[]\n\n#### Returns\n\n  * Promise<number[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDynamicRules()\n\nPromise\n\n    \n    \n    chrome.declarativeNetRequest.getDynamicRules(  \n      filter?: GetRulesFilter,  \n      callback?: function,  \n    )\n\nReturns the current set of dynamic rules for the extension. Callers can\noptionally filter the list of fetched rules by specifying a `filter`.\n\n#### Parameters\n\n  * filter\n\nGetRulesFilter optional\n\nChrome 111+\n\nAn object to filter the list of fetched rules.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (rules: Rule[]) => void\n\n    * rules\n\nRule[]\n\n#### Returns\n\n  * Promise<Rule[]>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getEnabledRulesets()\n\nPromise\n\n    \n    \n    chrome.declarativeNetRequest.getEnabledRulesets(  \n      callback?: function,  \n    )\n\nReturns the ids for the current set of enabled static rulesets.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (rulesetIds: string[]) => void\n\n    * rulesetIds\n\nstring[]\n\n#### Returns\n\n  * Promise<string[]>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getMatchedRules()\n\nPromise\n\n    \n    \n    chrome.declarativeNetRequest.getMatchedRules(  \n      filter?: MatchedRulesFilter,  \n      callback?: function,  \n    )\n\nReturns all rules matched for the extension. Callers can optionally filter the\nlist of matched rules by specifying a `filter`. This method is only available\nto extensions with the `\"declarativeNetRequestFeedback\"` permission or having\nthe `\"activeTab\"` permission granted for the `tabId` specified in `filter`.\nNote: Rules not associated with an active document that were matched more than\nfive minutes ago will not be returned.\n\n#### Parameters\n\n  * filter\n\nMatchedRulesFilter optional\n\nAn object to filter the list of matched rules.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details: RulesMatchedDetails) => void\n\n    * details\n\nRulesMatchedDetails\n\n#### Returns\n\n  * Promise<RulesMatchedDetails>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getSessionRules()\n\nPromise Chrome 90+\n\n    \n    \n    chrome.declarativeNetRequest.getSessionRules(  \n      filter?: GetRulesFilter,  \n      callback?: function,  \n    )\n\nReturns the current set of session scoped rules for the extension. Callers can\noptionally filter the list of fetched rules by specifying a `filter`.\n\n#### Parameters\n\n  * filter\n\nGetRulesFilter optional\n\nChrome 111+\n\nAn object to filter the list of fetched rules.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (rules: Rule[]) => void\n\n    * rules\n\nRule[]\n\n#### Returns\n\n  * Promise<Rule[]>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### isRegexSupported()\n\nPromise Chrome 87+\n\n    \n    \n    chrome.declarativeNetRequest.isRegexSupported(  \n      regexOptions: RegexOptions,  \n      callback?: function,  \n    )\n\nChecks if the given regular expression will be supported as a `regexFilter`\nrule condition.\n\n#### Parameters\n\n  * regexOptions\n\nRegexOptions\n\nThe regular expression to check.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: IsRegexSupportedResult) => void\n\n    * result\n\nIsRegexSupportedResult\n\n#### Returns\n\n  * Promise<IsRegexSupportedResult>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setExtensionActionOptions()\n\nPromise Chrome 88+\n\n    \n    \n    chrome.declarativeNetRequest.setExtensionActionOptions(  \n      options: ExtensionActionOptions,  \n      callback?: function,  \n    )\n\nConfigures if the action count for tabs should be displayed as the extension\naction's badge text and provides a way for that action count to be\nincremented.\n\n#### Parameters\n\n  * options\n\nExtensionActionOptions\n\n  * callback\n\nfunction optional\n\nChrome 89+\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### testMatchOutcome()\n\nPromise Chrome 103+\n\n    \n    \n    chrome.declarativeNetRequest.testMatchOutcome(  \n      request: TestMatchRequestDetails,  \n      callback?: function,  \n    )\n\nChecks if any of the extension's declarativeNetRequest rules would match a\nhypothetical request. Note: Only available for unpacked extensions as this is\nonly intended to be used during extension development.\n\n#### Parameters\n\n  * request\n\nTestMatchRequestDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: TestMatchOutcomeResult) => void\n\n    * result\n\nTestMatchOutcomeResult\n\n#### Returns\n\n  * Promise<TestMatchOutcomeResult>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### updateDynamicRules()\n\nPromise\n\n    \n    \n    chrome.declarativeNetRequest.updateDynamicRules(  \n      options: UpdateRuleOptions,  \n      callback?: function,  \n    )\n\nModifies the current set of dynamic rules for the extension. The rules with\nIDs listed in `options.removeRuleIds` are first removed, and then the rules\ngiven in `options.addRules` are added. Notes:\n\n  * This update happens as a single atomic operation: either all specified rules are added and removed, or an error is returned.\n  * These rules are persisted across browser sessions and across extension updates.\n  * Static rules specified as part of the extension package can not be removed using this function.\n  * `MAX_NUMBER_OF_DYNAMIC_RULES` is the maximum number of dynamic rules an extension can add. The number of unsafe rules must not exceed `MAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES`.\n\n#### Parameters\n\n  * options\n\nUpdateRuleOptions\n\nChrome 87+\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### updateEnabledRulesets()\n\nPromise\n\n    \n    \n    chrome.declarativeNetRequest.updateEnabledRulesets(  \n      options: UpdateRulesetOptions,  \n      callback?: function,  \n    )\n\nUpdates the set of enabled static rulesets for the extension. The rulesets\nwith IDs listed in `options.disableRulesetIds` are first removed, and then the\nrulesets listed in `options.enableRulesetIds` are added. Note that the set of\nenabled static rulesets is persisted across sessions but not across extension\nupdates, i.e. the `rule_resources` manifest key will determine the set of\nenabled static rulesets on each extension update.\n\n#### Parameters\n\n  * options\n\nUpdateRulesetOptions\n\nChrome 87+\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### updateSessionRules()\n\nPromise Chrome 90+\n\n    \n    \n    chrome.declarativeNetRequest.updateSessionRules(  \n      options: UpdateRuleOptions,  \n      callback?: function,  \n    )\n\nModifies the current set of session scoped rules for the extension. The rules\nwith IDs listed in `options.removeRuleIds` are first removed, and then the\nrules given in `options.addRules` are added. Notes:\n\n  * This update happens as a single atomic operation: either all specified rules are added and removed, or an error is returned.\n  * These rules are not persisted across sessions and are backed in memory.\n  * `MAX_NUMBER_OF_SESSION_RULES` is the maximum number of session rules an extension can add.\n\n#### Parameters\n\n  * options\n\nUpdateRuleOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### updateStaticRules()\n\nPromise Chrome 111+\n\n    \n    \n    chrome.declarativeNetRequest.updateStaticRules(  \n      options: UpdateStaticRulesOptions,  \n      callback?: function,  \n    )\n\nDisables and enables individual static rules in a `Ruleset`. Changes to rules\nbelonging to a disabled `Ruleset` will take effect the next time that it\nbecomes enabled.\n\n#### Parameters\n\n  * options\n\nUpdateStaticRulesOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onRuleMatchedDebug\n\n    \n    \n    chrome.declarativeNetRequest.onRuleMatchedDebug.addListener(  \n      callback: function,  \n    )\n\nFired when a rule is matched with a request. Only available for unpacked\nextensions with the `\"declarativeNetRequestFeedback\"` permission as this is\nintended to be used for debugging purposes only.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (info: MatchedRuleInfoDebug) => void\n\n    * info\n\nMatchedRuleInfoDebug\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/desktopCapture": "#  chrome.desktopCapture\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe Desktop Capture API captures the content of the screen, individual\nwindows, or individual tabs.\n\n## Permissions\n\n`desktopCapture`  \n\n## Types\n\n### DesktopCaptureSourceType\n\nEnum used to define set of desktop media sources used in chooseDesktopMedia().\n\n#### Enum\n\n\"screen\"  \n\n\"window\"  \n\n\"tab\"  \n\n\"audio\"  \n\n### SelfCapturePreferenceEnum\n\nChrome 107+\n\nMirrors SelfCapturePreferenceEnum.\n\n#### Enum\n\n\"include\"  \n\n\"exclude\"  \n\n### SystemAudioPreferenceEnum\n\nChrome 105+\n\nMirrors SystemAudioPreferenceEnum.\n\n#### Enum\n\n\"include\"  \n\n\"exclude\"  \n\n## Methods\n\n### cancelChooseDesktopMedia()\n\n    \n    \n    chrome.desktopCapture.cancelChooseDesktopMedia(  \n      desktopMediaRequestId: number,  \n    )\n\nHides desktop media picker dialog shown by chooseDesktopMedia().\n\n#### Parameters\n\n  * desktopMediaRequestId\n\nnumber\n\nId returned by chooseDesktopMedia()\n\n### chooseDesktopMedia()\n\n    \n    \n    chrome.desktopCapture.chooseDesktopMedia(  \n      sources: DesktopCaptureSourceType[],  \n      targetTab?: Tab,  \n      callback: function,  \n    )\n\nShows desktop media picker UI with the specified set of sources.\n\n#### Parameters\n\n  * sources\n\nDesktopCaptureSourceType[]\n\nSet of sources that should be shown to the user. The sources order in the set\ndecides the tab order in the picker.\n\n  * targetTab\n\nTab optional\n\nOptional tab for which the stream is created. If not specified then the\nresulting stream can be used only by the calling extension. The stream can\nonly be used by frames in the given tab whose security origin matches\n`tab.url`. The tab's origin must be a secure origin, e.g. HTTPS.\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (streamId: string, options: object) => void\n\n    * streamId\n\nstring\n\nAn opaque string that can be passed to `getUserMedia()` API to generate media\nstream that corresponds to the source selected by the user. If user didn't\nselect any source (i.e. canceled the prompt) then the callback is called with\nan empty `streamId`. The created `streamId` can be used only once and expires\nafter a few seconds when it is not used.\n\n    * options\n\nobject\n\nChrome 57+\n\nContains properties that describe the stream.\n\n      * canRequestAudioTrack\n\nboolean\n\nTrue if \"audio\" is included in parameter sources, and the end user does not\nuncheck the \"Share audio\" checkbox. Otherwise false, and in this case, one\nshould not ask for audio stream through getUserMedia call.\n\n#### Returns\n\n  * number\n\nAn id that can be passed to cancelChooseDesktopMedia() in case the prompt need\nto be canceled.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/devtools/inspectedWindow": "#  chrome.devtools.inspectedWindow\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.devtools.inspectedWindow` API to interact with the inspected\nwindow: obtain the tab ID for the inspected page, evaluate the code in the\ncontext of the inspected window, reload the page, or obtain the list of\nresources within the page.\n\nSee DevTools APIs summary for general introduction to using Developer Tools\nAPIs.\n\nThe `tabId` property provides the tab identifier that you can use with the\n`chrome.tabs.*` API calls. However, please note that `chrome.tabs.*` API is\nnot exposed to the Developer Tools extension pages due to security\nconsiderationsyou will need to pass the tab ID to the background page and\ninvoke the `chrome.tabs.*` API functions from there.\n\nThe `reload` method may be used to reload the inspected page. Additionally,\nthe caller can specify an override for the user agent string, a script that\nwill be injected early upon page load, or an option to force reload of cached\nresources.\n\nUse the `getResources` call and the `onResourceContent` event to obtain the\nlist of resources (documents, stylesheets, scripts, images etc) within the\ninspected page. The `getContent` and `setContent` methods of the `Resource`\nclass along with the `onResourceContentCommitted` event may be used to support\nmodification of the resource content, for example, by an external editor.\n\n## Manifest\n\nThe following keys must be declared in the manifest to use this API.\n\n`\"devtools_page\"`  \n\n## Execute code in the inspected window\n\nThe `eval` method provides the ability for extensions to execute JavaScript\ncode in the context of the inspected page. This method is powerful when used\nin the right context and dangerous when used inappropriately. Use the\n`tabs.executeScript` method unless you need the specific functionality that\nthe `eval` method provides.\n\nHere are the main differences between the `eval` and `tabs.executeScript`\nmethods:\n\n  * The `eval` method does not use an isolated world for the code being evaluated, so the JavaScript state of the inspected window is accessible to the code. Use this method when access to the JavaScript state of the inspected page is required.\n  * The execution context of the code being evaluated includes the Developer Tools console API. For example, the code can use `inspect` and `$0`.\n  * The evaluated code may return a value that is passed to the extension callback. The returned value has to be a valid JSON object (it may contain only primitive JavaScript types and acyclic references to other JSON objects). _Please observe extra care while processing the data received from the inspected pagethe execution context is essentially controlled by the inspected page; a malicious page may affect the data being returned to the extension._\n\n**Caution:** Due to the security considerations explained above, the\n`scripting.executeScript` method is the preferred way for an extension to\naccess DOM data of the inspected page in cases where the access to JavaScript\nstate of the inspected page is not required.\n\nNote that a page can include multiple different JavaScript execution contexts.\nEach frame has its own context, plus an additional context for each extension\nthat has content scripts running in that frame.\n\nBy default, the `eval` method executes in the context of the main frame of the\ninspected page.\n\nThe `eval` method takes an optional second argument that you can use to\nspecify the context in which the code is evaluated. This _options_ object can\ncontain one or more of the following keys:\n\n`frameURL`\n\n    Use to specify a frame other than the inspected page's main frame.\n`contextSecurityOrigin`\n\n    Use to select a context within the specified frame according to its web origin.\n`useContentScriptContext`\n\n    If true, execute the script in the same context as the extensions's content scripts. (Equivalent to specifying the extensions's own web orgin as the context security origin.) This can be used to exchange data with the content script.\n\n## Examples\n\nThe following code checks for the version of jQuery used by the inspected\npage:\n\n    \n    \n    chrome.devtools.inspectedWindow.eval(\n      \"jQuery.fn.jquery\",\n      function(result, isException) {\n        if (isException) {\n          console.log(\"the page is not using jQuery\");\n        } else {\n          console.log(\"The page is using jQuery v\" + result);\n        }\n      }\n    );\n    \n\nTo try this API, install the devtools API examples from the chrome-extension-\nsamples repository.\n\n## Types\n\n### Resource\n\nA resource within the inspected page, such as a document, a script, or an\nimage.\n\n#### Properties\n\n  * url\n\nstring\n\nThe URL of the resource.\n\n  * getContent\n\nvoid\n\nGets the content of the resource.\n\nThe `getContent` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (content: string, encoding: string) => void\n\n      * content\n\nstring\n\nContent of the resource (potentially encoded).\n\n      * encoding\n\nstring\n\nEmpty if the content is not encoded, encoding name otherwise. Currently, only\nbase64 is supported.\n\n  * setContent\n\nvoid\n\nSets the content of the resource.\n\nThe `setContent` function looks like:\n\n        \n        (content: string, commit: boolean, callback?: function) => {...}\n\n    * content\n\nstring\n\nNew content of the resource. Only resources with the text type are currently\nsupported.\n\n    * commit\n\nboolean\n\nTrue if the user has finished editing the resource, and the new content of the\nresource should be persisted; false if this is a minor change sent in progress\nof the user editing the resource.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (error?: object) => void\n\n      * error\n\nobject optional\n\nSet to undefined if the resource content was set successfully; describes error\notherwise.\n\n## Properties\n\n### tabId\n\nThe ID of the tab being inspected. This ID may be used with chrome.tabs.* API.\n\n#### Type\n\nnumber\n\n## Methods\n\n### eval()\n\n    \n    \n    chrome.devtools.inspectedWindow.eval(  \n      expression: string,  \n      options?: object,  \n      callback?: function,  \n    )\n\nEvaluates a JavaScript expression in the context of the main frame of the\ninspected page. The expression must evaluate to a JSON-compliant object,\notherwise an exception is thrown. The eval function can report either a\nDevTools-side error or a JavaScript exception that occurs during evaluation.\nIn either case, the `result` parameter of the callback is `undefined`. In the\ncase of a DevTools-side error, the `isException` parameter is non-null and has\n`isError` set to true and `code` set to an error code. In the case of a\nJavaScript error, `isException` is set to true and `value` is set to the\nstring value of thrown object.\n\n#### Parameters\n\n  * expression\n\nstring\n\nAn expression to evaluate.\n\n  * options\n\nobject optional\n\nThe options parameter can contain one or more options.\n\n    * frameURL\n\nstring optional\n\nIf specified, the expression is evaluated on the iframe whose URL matches the\none specified. By default, the expression is evaluated in the top frame of the\ninspected page.\n\n    * scriptExecutionContext\n\nstring optional\n\nChrome 107+\n\nEvaluate the expression in the context of a content script of an extension\nthat matches the specified origin. If given, scriptExecutionContext overrides\nthe 'true' setting on useContentScriptContext.\n\n    * useContentScriptContext\n\nboolean optional\n\nEvaluate the expression in the context of the content script of the calling\nextension, provided that the content script is already injected into the\ninspected page. If not, the expression is not evaluated and the callback is\ninvoked with the exception parameter set to an object that has the `isError`\nfield set to true and the `code` field set to `E_NOTFOUND`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: object, exceptionInfo: object) => void\n\n    * result\n\nobject\n\nThe result of evaluation.\n\n    * exceptionInfo\n\nobject\n\nAn object providing details if an exception occurred while evaluating the\nexpression.\n\n      * code\n\nstring\n\nSet if the error occurred on the DevTools side before the expression is\nevaluated.\n\n      * description\n\nstring\n\nSet if the error occurred on the DevTools side before the expression is\nevaluated.\n\n      * details\n\nany[]\n\nSet if the error occurred on the DevTools side before the expression is\nevaluated, contains the array of the values that may be substituted into the\ndescription string to provide more information about the cause of the error.\n\n      * isError\n\nboolean\n\nSet if the error occurred on the DevTools side before the expression is\nevaluated.\n\n      * isException\n\nboolean\n\nSet if the evaluated code produces an unhandled exception.\n\n      * value\n\nstring\n\nSet if the evaluated code produces an unhandled exception.\n\n### getResources()\n\n    \n    \n    chrome.devtools.inspectedWindow.getResources(  \n      callback: function,  \n    )\n\nRetrieves the list of resources from the inspected page.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (resources: Resource[]) => void\n\n    * resources\n\nResource[]\n\nThe resources within the page.\n\n### reload()\n\n    \n    \n    chrome.devtools.inspectedWindow.reload(  \n      reloadOptions?: object,  \n    )\n\nReloads the inspected page.\n\n#### Parameters\n\n  * reloadOptions\n\nobject optional\n\n    * ignoreCache\n\nboolean optional\n\nWhen true, the loader will bypass the cache for all inspected page resources\nloaded before the `load` event is fired. The effect is similar to pressing\nCtrl+Shift+R in the inspected window or within the Developer Tools window.\n\n    * injectedScript\n\nstring optional\n\nIf specified, the script will be injected into every frame of the inspected\npage immediately upon load, before any of the frame's scripts. The script will\nnot be injected after subsequent reloadsfor example, if the user presses\nCtrl+R.\n\n    * userAgent\n\nstring optional\n\nIf specified, the string will override the value of the `User-Agent` HTTP\nheader that's sent while loading the resources of the inspected page. The\nstring will also override the value of the `navigator.userAgent` property\nthat's returned to any scripts that are running within the inspected page.\n\n## Events\n\n### onResourceAdded\n\n    \n    \n    chrome.devtools.inspectedWindow.onResourceAdded.addListener(  \n      callback: function,  \n    )\n\nFired when a new resource is added to the inspected page.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (resource: Resource) => void\n\n    * resource\n\nResource\n\n### onResourceContentCommitted\n\n    \n    \n    chrome.devtools.inspectedWindow.onResourceContentCommitted.addListener(  \n      callback: function,  \n    )\n\nFired when a new revision of the resource is committed (e.g. user saves an\nedited version of the resource in the Developer Tools).\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (resource: Resource, content: string) => void\n\n    * resource\n\nResource\n\n    * content\n\nstring\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/devtools/network": "#  chrome.devtools.network\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.devtools.network` API to retrieve the information about\nnetwork requests displayed by the Developer Tools in the Network panel.\n\nNetwork requests information is represented in the HTTP Archive format\n(_HAR_). The description of HAR is outside of scope of this document, refer to\nHAR v1.2 Specification.\n\nIn terms of HAR, the `chrome.devtools.network.getHAR()` method returns entire\n_HAR log_ , while `chrome.devtools.network.onRequestFinished` event provides\n_HAR entry_ as an argument to the event callback.\n\nNote that request content is not provided as part of HAR for efficiency\nreasons. You may call request's `getContent()` method to retrieve content.\n\nIf the Developer Tools window is opened after the page is loaded, some\nrequests may be missing in the array of entries returned by `getHAR()`. Reload\nthe page to get all requests. In general, the list of requests returned by\n`getHAR()` should match that displayed in the Network panel.\n\nSee DevTools APIs summary for general introduction to using Developer Tools\nAPIs.\n\n## Manifest\n\nThe following keys must be declared in the manifest to use this API.\n\n`\"devtools_page\"`  \n\n## Examples\n\nThe following code logs URLs of all images larger than 40KB as they are\nloaded:\n\n    \n    \n    chrome.devtools.network.onRequestFinished.addListener(\n      function(request) {\n        if (request.response.bodySize > 40*1024) {\n          chrome.devtools.inspectedWindow.eval(\n              'console.log(\"Large image: \" + unescape(\"' +\n              escape(request.request.url) + '\"))');\n        }\n      }\n    );\n    \n\nTo try this API, install the devtools API examples from the chrome-extension-\nsamples repository.\n\n## Types\n\n### Request\n\nRepresents a network request for a document resource (script, image and so\non). See HAR Specification for reference.\n\n#### Properties\n\n  * getContent\n\nvoid\n\nReturns content of the response body.\n\nThe `getContent` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (content: string, encoding: string) => void\n\n      * content\n\nstring\n\nContent of the response body (potentially encoded).\n\n      * encoding\n\nstring\n\nEmpty if content is not encoded, encoding name otherwise. Currently, only\nbase64 is supported.\n\n## Methods\n\n### getHAR()\n\n    \n    \n    chrome.devtools.network.getHAR(  \n      callback: function,  \n    )\n\nReturns HAR log that contains all known network requests.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (harLog: object) => void\n\n    * harLog\n\nobject\n\nA HAR log. See HAR specification for details.\n\n## Events\n\n### onNavigated\n\n    \n    \n    chrome.devtools.network.onNavigated.addListener(  \n      callback: function,  \n    )\n\nFired when the inspected window navigates to a new page.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (url: string) => void\n\n    * url\n\nstring\n\n### onRequestFinished\n\n    \n    \n    chrome.devtools.network.onRequestFinished.addListener(  \n      callback: function,  \n    )\n\nFired when a network request is finished and all request data are available.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (request: Request) => void\n\n    * request\n\nRequest\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/devtools/panels": "#  chrome.devtools.panels\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.devtools.panels` API to integrate your extension into\nDeveloper Tools window UI: create your own panels, access existing panels, and\nadd sidebars.\n\nEach extension panel and sidebar is displayed as a separate HTML page. All\nextension pages displayed in the Developer Tools window have access to all\nparts of the `chrome.devtools` API, as well as all other extension APIs.\n\nYou can use the `devtools.panels.setOpenResourceHandler` method to install a\ncallback function that handles user requests to open a resource (typically, a\nclick a resource link in the Developer Tools window). At most one of the\ninstalled handlers gets called; users can specify (using the Developer Tools\nSettings dialog) either the default behavior or an extension to handle\nresource open requests. If an extension calls `setOpenResourceHandler()`\nmultiple times, only the last handler is retained.\n\nSee DevTools APIs summary for general introduction to using Developer Tools\nAPIs.\n\n## Manifest\n\nThe following keys must be declared in the manifest to use this API.\n\n`\"devtools_page\"`  \n\n## Example\n\nThe following code adds a panel contained in `Panel.html`, represented by\n`FontPicker.png` on the Developer Tools toolbar and labeled as _Font Picker_ :\n\n    \n    \n    chrome.devtools.panels.create(\"Font Picker\",\n                                  \"FontPicker.png\",\n                                  \"Panel.html\",\n                                  function(panel) { ... });\n    \n\nThe following code adds a sidebar pane contained in `Sidebar.html` and titled\n_Font Properties_ to the Elements panel, then sets its height to `8ex`:\n\n    \n    \n    chrome.devtools.panels.elements.createSidebarPane(\"Font Properties\",\n      function(sidebar) {\n        sidebar.setPage(\"Sidebar.html\");\n        sidebar.setHeight(\"8ex\");\n      }\n    );\n    \n\nThe screenshot illustrates the effect this example would have on Developer\nTools window:\n\n![Extension icon panel on DevTools\ntoolbar](/static/docs/extensions/reference/api/devtools/panels/images/devtools-\npanels.png) Extension icon panel on DevTools toolbar.\n\nTo try this API, install the devtools panels API example from the chrome-\nextension-samples repository.\n\n## Types\n\n### Button\n\nA button created by the extension.\n\n#### Properties\n\n  * onClicked\n\nEvent<functionvoidvoid>\n\nFired when the button is clicked.\n\nThe `onClicked.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * update\n\nvoid\n\nUpdates the attributes of the button. If some of the arguments are omitted or\n`null`, the corresponding attributes are not updated.\n\nThe `update` function looks like:\n\n        \n        (iconPath?: string, tooltipText?: string, disabled?: boolean) => {...}\n\n    * iconPath\n\nstring optional\n\nPath to the new icon of the button.\n\n    * tooltipText\n\nstring optional\n\nText shown as a tooltip when user hovers the mouse over the button.\n\n    * disabled\n\nboolean optional\n\nWhether the button is disabled.\n\n### ElementsPanel\n\nRepresents the Elements panel.\n\n#### Properties\n\n  * onSelectionChanged\n\nEvent<functionvoidvoid>\n\nFired when an object is selected in the panel.\n\nThe `onSelectionChanged.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * createSidebarPane\n\nvoid\n\nCreates a pane within panel's sidebar.\n\nThe `createSidebarPane` function looks like:\n\n        \n        (title: string, callback?: function) => {...}\n\n    * title\n\nstring\n\nText that is displayed in sidebar caption.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (result: ExtensionSidebarPane) => void\n\n      * result\n\nExtensionSidebarPane\n\nAn ExtensionSidebarPane object for created sidebar pane.\n\n### ExtensionPanel\n\nRepresents a panel created by extension.\n\n#### Properties\n\n  * onHidden\n\nEvent<functionvoidvoid>\n\nFired when the user switches away from the panel.\n\nThe `onHidden.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * onSearch\n\nEvent<functionvoidvoid>\n\nFired upon a search action (start of a new search, search result navigation,\nor search being canceled).\n\nThe `onSearch.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (action: string, queryString?: string) => void\n\n      * action\n\nstring\n\n      * queryString\n\nstring optional\n\n  * onShown\n\nEvent<functionvoidvoid>\n\nFired when the user switches to the panel.\n\nThe `onShown.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (window: Window) => void\n\n      * window\n\nWindow\n\n  * createStatusBarButton\n\nvoid\n\nAppends a button to the status bar of the panel.\n\nThe `createStatusBarButton` function looks like:\n\n        \n        (iconPath: string, tooltipText: string, disabled: boolean) => {...}\n\n    * iconPath\n\nstring\n\nPath to the icon of the button. The file should contain a 64x24-pixel image\ncomposed of two 32x24 icons. The left icon is used when the button is\ninactive; the right icon is displayed when the button is pressed.\n\n    * tooltipText\n\nstring\n\nText shown as a tooltip when user hovers the mouse over the button.\n\n    * disabled\n\nboolean\n\nWhether the button is disabled.\n\n    * returns\n\nButton\n\n### ExtensionSidebarPane\n\nA sidebar created by the extension.\n\n#### Properties\n\n  * onHidden\n\nEvent<functionvoidvoid>\n\nFired when the sidebar pane becomes hidden as a result of the user switching\naway from the panel that hosts the sidebar pane.\n\nThe `onHidden.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * onShown\n\nEvent<functionvoidvoid>\n\nFired when the sidebar pane becomes visible as a result of user switching to\nthe panel that hosts it.\n\nThe `onShown.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (window: Window) => void\n\n      * window\n\nWindow\n\n  * setExpression\n\nvoid\n\nSets an expression that is evaluated within the inspected page. The result is\ndisplayed in the sidebar pane.\n\nThe `setExpression` function looks like:\n\n        \n        (expression: string, rootTitle?: string, callback?: function) => {...}\n\n    * expression\n\nstring\n\nAn expression to be evaluated in context of the inspected page. JavaScript\nobjects and DOM nodes are displayed in an expandable tree similar to the\nconsole/watch.\n\n    * rootTitle\n\nstring optional\n\nAn optional title for the root of the expression tree.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * setHeight\n\nvoid\n\nSets the height of the sidebar.\n\nThe `setHeight` function looks like:\n\n        \n        (height: string) => {...}\n\n    * height\n\nstring\n\nA CSS-like size specification, such as `'100px'` or `'12ex'`.\n\n  * setObject\n\nvoid\n\nSets a JSON-compliant object to be displayed in the sidebar pane.\n\nThe `setObject` function looks like:\n\n        \n        (jsonObject: string, rootTitle?: string, callback?: function) => {...}\n\n    * jsonObject\n\nstring\n\nAn object to be displayed in context of the inspected page. Evaluated in the\ncontext of the caller (API client).\n\n    * rootTitle\n\nstring optional\n\nAn optional title for the root of the expression tree.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * setPage\n\nvoid\n\nSets an HTML page to be displayed in the sidebar pane.\n\nThe `setPage` function looks like:\n\n        \n        (path: string) => {...}\n\n    * path\n\nstring\n\nRelative path of an extension page to display within the sidebar.\n\n### SourcesPanel\n\nRepresents the Sources panel.\n\n#### Properties\n\n  * onSelectionChanged\n\nEvent<functionvoidvoid>\n\nFired when an object is selected in the panel.\n\nThe `onSelectionChanged.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * createSidebarPane\n\nvoid\n\nCreates a pane within panel's sidebar.\n\nThe `createSidebarPane` function looks like:\n\n        \n        (title: string, callback?: function) => {...}\n\n    * title\n\nstring\n\nText that is displayed in sidebar caption.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (result: ExtensionSidebarPane) => void\n\n      * result\n\nExtensionSidebarPane\n\nAn ExtensionSidebarPane object for created sidebar pane.\n\n## Properties\n\n### elements\n\nElements panel.\n\n#### Type\n\nElementsPanel\n\n### sources\n\nSources panel.\n\n#### Type\n\nSourcesPanel\n\n### themeName\n\nChrome 59+\n\nThe name of the color theme set in user's DevTools settings. Possible values:\n`default` (the default) and `dark`.\n\n#### Type\n\nstring\n\n## Methods\n\n### create()\n\n    \n    \n    chrome.devtools.panels.create(  \n      title: string,  \n      iconPath: string,  \n      pagePath: string,  \n      callback?: function,  \n    )\n\nCreates an extension panel.\n\n#### Parameters\n\n  * title\n\nstring\n\nTitle that is displayed next to the extension icon in the Developer Tools\ntoolbar.\n\n  * iconPath\n\nstring\n\nPath of the panel's icon relative to the extension directory.\n\n  * pagePath\n\nstring\n\nPath of the panel's HTML page relative to the extension directory.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (panel: ExtensionPanel) => void\n\n    * panel\n\nExtensionPanel\n\nAn ExtensionPanel object representing the created panel.\n\n### openResource()\n\n    \n    \n    chrome.devtools.panels.openResource(  \n      url: string,  \n      lineNumber: number,  \n      columnNumber?: number,  \n      callback?: function,  \n    )\n\nRequests DevTools to open a URL in a Developer Tools panel.\n\n#### Parameters\n\n  * url\n\nstring\n\nThe URL of the resource to open.\n\n  * lineNumber\n\nnumber\n\nSpecifies the line number to scroll to when the resource is loaded.\n\n  * columnNumber\n\nnumber optional\n\nChrome 114+\n\nSpecifies the column number to scroll to when the resource is loaded.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### setOpenResourceHandler()\n\n    \n    \n    chrome.devtools.panels.setOpenResourceHandler(  \n      callback?: function,  \n    )\n\nSpecifies the function to be called when the user clicks a resource link in\nthe Developer Tools window. To unset the handler, either call the method with\nno parameters or pass null as the parameter.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (resource: Resource) => void\n\n    * resource\n\nResource\n\nA `devtools.inspectedWindow.Resource` object for the resource that was\nclicked.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/devtools/performance": "#  chrome.devtools.performance\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.devtools.performance` API to listen to recording status\nupdates in the Performance panel in DevTools.\n\nSee DevTools APIs summary for general introduction to using Developer Tools\nAPIs.\n\n## Availability\n\nChrome 129+\n\nStarting from Chrome 128, you can listen to notifications of the recording\nstatus of the Performance panel.\n\n## Concepts and usage\n\nThe chrome.devtools.performance API allows developers to interact with the\nrecording features of the **Performance panel** panel in Chrome DevTools. You\ncan use this API to get notifications when recording starts or stops.\n\nTwo events are available:\n\n  * onProfilingStarted: This event is fired when the **Performance** panel begins recording performance data.\n  * onProfilingStopped: This event is fired when the **Performance** panel stops recording performance data. stance that associates the current stack trace with the cre Both events don't have any associated parameters.\n\nBy listening to these events, developers can create extensions that react to\nthe recording status in the **Performance** panel, providing additional\nautomation during performance profiling.\n\n## Examples\n\nThis is how you can use the API to listen to recording status updates\n\n    \n    \n    chrome.devtools.performance.onProfilingStarted.addListener(() => {\n      // Profiling started listener implementation\n    });\n    \n    chrome.devtools.performance.onProfilingStopped.addListener(() => {\n      // Profiling stopped listener implementation\n    })\n    \n\n## Events\n\n### onProfilingStarted\n\n    \n    \n    chrome.devtools.performance.onProfilingStarted.addListener(  \n      callback: function,  \n    )\n\nFired when the Performance panel starts recording.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onProfilingStopped\n\n    \n    \n    chrome.devtools.performance.onProfilingStopped.addListener(  \n      callback: function,  \n    )\n\nFired when the Performance panel stops recording.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/devtools/recorder": "#  chrome.devtools.recorder\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.devtools.recorder` API to customize the Recorder panel in\nDevTools.\n\n`devtools.recorder` API is a preview feature that allows you to extend the\nRecorder panel in Chrome DevTools.\n\nSee DevTools APIs summary for general introduction to using Developer Tools\nAPIs.\n\n## Availability\n\nChrome 105+\n\nStarting from Chrome 105, you can extend the export functionality. Starting\nfrom Chrome 112, you can extend the replay button.\n\n## Concepts and usage\n\n### Customizing the export feature\n\nTo register an extension plugin, use the `registerRecorderExtensionPlugin`\nfunction. This function requires a plugin instance, a `name` and a `mediaType`\nas parameters. The plugin instance must implement two methods: `stringify` and\n`stringifyStep`.\n\nThe `name` provided by the extension shows up in the **Export** menu in the\n**Recorder** panel.\n\nDepending on the export context, when the user clicks the export option\nprovided by the extension, the **Recorder** panel invokes one of the two\nfunctions:\n\n  * `stringify` that receives an entire user flow recording\n  * `stringifyStep` that receives a single recorded step\n\nThe `mediaType` parameter allows the extension to specify the kind of output\nit generates with the `stringify` and `stringifyStep` functions. For example,\n`application/javascript` if the result is a JavaScript program.\n\n### Customizing the replay button\n\nTo customize the replay button in the **Recorder** , use the\n`registerRecorderExtensionPlugin` function. The plugin must implement the\n`replay` method for the customization to take effect. If the method is\ndetected, a replay button will appear in the **Recorder**. Upon clicking the\nbutton, the current recording object will be passed as the first argument to\nthe `replay` method.\n\nAt this point, the extension can display a `RecorderView` for handling the\nreplay or use other extension APIs to process the replay request. To create a\nnew `RecorderView`, invoke `chrome.devtools.recorder.createView`.\n\n## Examples\n\n### Export plugin\n\nThe following code implements an extension plugin that stringifes a recording\nusing `JSON.stringify`:\n\n    \n    \n    class MyPlugin {\n      stringify(recording) {\n        return Promise.resolve(JSON.stringify(recording));\n      }\n      stringifyStep(step) {\n        return Promise.resolve(JSON.stringify(step));\n      }\n    }\n    \n    chrome.devtools.recorder.registerRecorderExtensionPlugin(\n      new MyPlugin(),\n      /*name=*/'MyPlugin',\n      /*mediaType=*/'application/json'\n    );\n    \n\n### Replay plugin\n\nThe following code implements an extension plugin that creates a dummy\nRecorder view and displays it upon a replay request:\n\n    \n    \n    const view = await chrome.devtools.recorder.createView(\n      /* name= */ 'ExtensionName',\n      /* pagePath= */ 'Replay.html'\n    );\n    \n    let latestRecording;\n    \n    view.onShown.addListener(() => {\n      // Recorder has shown the view. Send additional data to the view if needed.\n      chrome.runtime.sendMessage(JSON.stringify(latestRecording));\n    });\n    \n    view.onHidden.addListener(() => {\n      // Recorder has hidden the view.\n    });\n    \n    export class RecorderPlugin {\n      replay(recording) {\n        // Share the data with the view.\n        latestRecording = recording;\n        // Request to show the view.\n        view.show();\n      }\n    }\n    \n    chrome.devtools.recorder.registerRecorderExtensionPlugin(\n      new RecorderPlugin(),\n      /* name=*/ 'CoffeeTest'\n    );\n    \n\nFind a complete extension example on GitHub.\n\n## Types\n\n### RecorderExtensionPlugin\n\nA plugin interface that the Recorder panel invokes to customize the Recorder\npanel.\n\n#### Properties\n\n  * replay\n\nvoid\n\nChrome 112+\n\nAllows the extension to implement custom replay functionality.\n\nThe `replay` function looks like:\n\n        \n        (recording: object) => {...}\n\n    * recording\n\nobject\n\nA recording of the user interaction with the page. This should match\nPuppeteer's recording schema.\n\n  * stringify\n\nvoid\n\nConverts a recording from the Recorder panel format into a string.\n\nThe `stringify` function looks like:\n\n        \n        (recording: object) => {...}\n\n    * recording\n\nobject\n\nA recording of the user interaction with the page. This should match\nPuppeteer's recording schema.\n\n  * stringifyStep\n\nvoid\n\nConverts a step of the recording from the Recorder panel format into a string.\n\nThe `stringifyStep` function looks like:\n\n        \n        (step: object) => {...}\n\n    * step\n\nobject\n\nA step of the recording of a user interaction with the page. This should match\nPuppeteer's step schema.\n\n### RecorderView\n\nChrome 112+\n\nRepresents a view created by extension to be embedded inside the Recorder\npanel.\n\n#### Properties\n\n  * onHidden\n\nEvent<functionvoidvoid>\n\nFired when the view is hidden.\n\nThe `onHidden.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * onShown\n\nEvent<functionvoidvoid>\n\nFired when the view is shown.\n\nThe `onShown.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n  * show\n\nvoid\n\nIndicates that the extension wants to show this view in the Recorder panel.\n\nThe `show` function looks like:\n\n        \n        () => {...}\n\n## Methods\n\n### createView()\n\nChrome 112+\n\n    \n    \n    chrome.devtools.recorder.createView(  \n      title: string,  \n      pagePath: string,  \n    )\n\nCreates a view that can handle the replay. This view will be embedded inside\nthe Recorder panel.\n\n#### Parameters\n\n  * title\n\nstring\n\nTitle that is displayed next to the extension icon in the Developer Tools\ntoolbar.\n\n  * pagePath\n\nstring\n\nPath of the panel's HTML page relative to the extension directory.\n\n#### Returns\n\n  * RecorderView\n\n### registerRecorderExtensionPlugin()\n\n    \n    \n    chrome.devtools.recorder.registerRecorderExtensionPlugin(  \n      plugin: RecorderExtensionPlugin,  \n      name: string,  \n      mediaType: string,  \n    )\n\nRegisters a Recorder extension plugin.\n\n#### Parameters\n\n  * plugin\n\nRecorderExtensionPlugin\n\nAn instance implementing the RecorderExtensionPlugin interface.\n\n  * name\n\nstring\n\nThe name of the plugin.\n\n  * mediaType\n\nstring\n\nThe media type of the string content that the plugin produces.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/dns": "#  chrome.dns\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.dns` API for dns resolution.\n\n## Permissions\n\n`dns`  \n\n## Availability\n\nDev channel\n\nTo use this API, you must declare the `\"dns\"` permission in the manifest.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"dns\"\n      ],\n      ...\n    }\n    \n\n**Note:** This API is only available in Chrome Dev. There are no foreseeable\nplans to move this API from the dev channel into Chrome stable.\n\n## Usage\n\nThe following code calls `resolve()` to retrieve the IP address of\n`example.com`.\n\nservice-worker.js:\n\n    \n    \n    const resolveDNS = async () => {\n        let record = await chrome.dns.resolve('example.com');\n        console.log(record.address); // \"192.0.2.172\"\n    };\n    \n    resolveDNS();\n    \n\n**Key point:** Do not include the scheme or trailing slash in the hostname.\nFor example, `https://example.com/` is invalid.\n\n## Types\n\n### ResolveCallbackResolveInfo\n\n#### Properties\n\n  * address\n\nstring optional\n\nA string representing the IP address literal. Supplied only if resultCode\nindicates success.\n\n  * resultCode\n\nnumber\n\nThe result code. Zero indicates success.\n\n## Methods\n\n### resolve()\n\nPromise\n\n    \n    \n    chrome.dns.resolve(  \n      hostname: string,  \n      callback?: function,  \n    )\n\nResolves the given hostname or IP address literal.\n\n#### Parameters\n\n  * hostname\n\nstring\n\nThe hostname to resolve.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (resolveInfo: ResolveCallbackResolveInfo) => void\n\n    * resolveInfo\n\nResolveCallbackResolveInfo\n\n#### Returns\n\n  * Promise<ResolveCallbackResolveInfo>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/documentScan": "#  chrome.documentScan\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.documentScan` API to discover and retrieve images from\nattached document scanners.\n\nThe Document Scan API is designed to allow apps and extensions to view the\ncontent of paper documents on an attached document scanner.\n\n## Permissions\n\n`documentScan`  \n\n## Availability\n\nChrome 44+  ChromeOS only\n\nAvailability for API members added later is shown with those members.\n\n## Concepts and usage\n\nThis API supports two means of scanning documents. If your use case can work\nwith any scanner and doesn't require control of the configuration, use the\n`scan()` method. More complicated use cases require a combination of methods,\nwhich are only supported in Chrome 124 and later.\n\n### Simple scanning\n\nFor simple use cases, meaning those that can work with any scanner and don't\nrequire control of configuration, call `scan()`. This method takes a\n`ScanOptions` object and returns a Promise that resolves with a `ScanResults`\nobject. The capabilities of this option are limited to the number of scans and\nthe MIME types that will be accepted by the caller. Scans are returned as URLs\nfor display in an `<img>` tag for a user interface.\n\n### Complex scanning\n\nComplex scans are accomplished in three phases as described in this section.\nThis outline does not describe every method argument or every property\nreturned in a response. It is only intended to give you a general guide to\nwriting scanner code.\n\n**Note:** Calling `openScanner()`, `getScannerList()`, or `startScan()` more\nthan once will cancel operations initiated by previous calls to these methods.\nSee the descriptions of these methods for specifics.\n\n#### Discovery\n\n  1. Call `getScannerList()`. Available scanners are returned in a Promise that resolves with a `GetScannerListResponse`.\n\n     * The response object contains an array of `ScannerInfo` objects.\n     * The array may contain multiple entries for a single scanner if that scanner supports multiple protocols or connection methods.\n  2. Select a scanner from the returned array and save the value of its `scannerId` property.\n\nUse the properties of individual `ScannerInfo` objects to distinguish among\nmultiple objects for the same scanner. Objects from the same scanner will have\nthe same value for the `deviceUuid` property. `ScannerInfo` also contains an\n`imageFormats` property containing an array of supported image types.\n\n#### Scanner configuration\n\n  1. Call `openScanner()`, passing in the saved scanner ID. It returns a Promise that resolves with an `OpenScannerResponse`. The response object contains:\n\n     * A `scannerHandle` property, which you'll need to save.\n\n     * An options property containing scanner-specific properties, which you'll need to set. See Retrieve scanner options for more information.\n\n  2. (Optional) If you need the user to provide values for scanner options, construct a user interface. You will need the scanner options provided by the previous step, and you'll need to retrieve option groups provided by the scanner. See Construct a user interface for more information.\n\n  3. Construct an array of `OptionSetting` objects using programmatic or user-provided values. See Set scanner options for more information.\n\n  4. Pass the array of `OptionSetting` objects to `setOptions()` to set options for the scanner. It returns a Promise that resolves with a `SetOptionsResponse`. This object contains an updated version of the scanner options retrieved in step 1 of scanner configuration.\n\nSince changing one option can alter constraints on another option, you may\nneed to repeat these steps several times.\n\n#### Scanning\n\n  1. Construct a `StartScanOptions` object and pass it to `startScan()`. It returns a Promise that resolves with a `StartScanResponse`. Its `job` property is a handle that you will use to either read scan data or cancel the scan.\n\n  2. Pass the job handle to `readScanData()`. It returns a Promise that resolves with a `ReadScanDataResponse` object. If data was read successfully, its `result` property equals `SUCCESS` and its `data` property contains an `ArrayBuffer` with part of the scan. Note that `estimatedCompletion` contains an estimated percentage of the total data that has been delivered so far.\n\n**Note:** If `result` is `SUCCESS`, but `data` is empty, delay briefly before\ncalling `readScanData()` again.\n\n  3. Repeat the previous step until the `result` property equals `EOF` or an error.\n\nWhen the end of the scan is reached, call `closeScanner()` with the scanner\nhandle saved in step 3\\. It returns a Promise that resolves with a\n`CloseScannerResponse`. Calling `cancelScan()` at any time after the job is\ncreated will end scanning.\n\n### Response objects\n\nAll methods return a Promise that resolves with a response object of some\nkind. Most of these contain a `result` property whose value is a member of\n`OperationResult`. Some properties of response objects won't contain values\nunless the value of `result` has a specific value. These relationships are\ndescribed in the reference for each response object.\n\nFor example, `OpenScannerResponse.scannerHandle` will only have a value when\n`OpenScannerResponse.result` equals `SUCCESS`.\n\n### Scanner options\n\nScanner options vary considerably by device. Consequently, it's not possible\nto reflect scanner options directly within the documentScan API. To get around\nthis, the `OpenScannerResponse` (retrieved using `openScanner()`) and the\n`SetOptionsResponse` (the response object for `setOptions()`) contain an\n`options` property which is an object containing scanner-specific options.\nEach option is a key-value mapping where the key is a device-specific option\nand the value is an instance of `ScannerOption`.\n\nThe structure generally looks like this:\n\n    \n    \n    {\n      \"key1\": { scannerOptionInstance }\n      \"key2\": { scannerOptionInstance }\n    }\n    \n\nFor example, imagine a scanner that returns options named \"source\" and\n\"resolution\". The structure of the returned `options` object will look\nsomething like the following example. For simplicity, only partial\n`ScannerOption` responses are shown.\n\n    \n    \n    {\n      \"source\": {\n        \"name\": \"source\",\n        \"type\": OptionType.STRING,\n    ...\n    },\n      \"resolution\": {\n        \"name\": \"resolution\",\n        \"type\": OptionType.INT,\n    ...\n      },\n    ...\n    }\n    \n\n### Construct a user interface\n\nThough not required to use this API, you may want a user to choose the value\nfor a particular option. This requires a user interface. Use the\n`OpenScannerResponse` (opened by `openScanner()`) to retrieve the options for\nthe attached scanner as described in the previous section.\n\nSome scanners group options in device-specific ways. They don't affect option\nbehaviors, but since these groups may be mentioned in a scanner's product\ndocumentation, such groups should be shown to the user. You can retrieve these\ngroups by calling `getOptionGroups()`. This returns a Promise that resolves\nwith a `GetOptionGroupsResponse` object. Its `groups` property contains a\nscanner-specific array of groups. Use the information in these groups to\norganize the options in the `OpenScannerResponse` for display.\n\n    \n    \n    {\n      scannerHandle: \"123456\",\n      result: SUCCESS,\n      groups: [\n        {\n          title: \"Standard\",\n          members: [ \"resolution\", \"mode\", \"source\" ]\n        }\n      ]\n    }\n    \n\nAs stated under Scanner configuration, changing one option can alter\nconstraints on another option. This is why `setOptionsResponse` (the response\nobject for `setOptions()`) contains another `options` property. Use this to\nupdate the user interface. Then repeat as needed until all options are set.\n\n### Set scanner options\n\nSet scanner options by passing an array of `OptionSetting` objects to\n`setOptions()`. For an example, see the following Scan one letter-size page\nsection.\n\n## Examples\n\n### Retrieve a page as a blob\n\nThis example shows one way to retrieve a page from the scanner as a blob and\ndemonstrates use of `startScan()` and `readScanData()` using the value of\n`OperationResult`.\n\n    \n    \n    async function pageAsBlob(handle) {\n      let response = await chrome.documentScan.startScan(\n          handle, {format: \"image/jpeg\"});\n      if (response.result != chrome.documentScan.OperationResult.SUCCESS) {\n        return null;\n      }\n      const job = response.job;\n    \n      let imgParts = [];\n      response = await chrome.documentScan.readScanData(job);\n      while (response.result == chrome.documentScan.OperationResult.SUCCESS) {\n        if (response.data && response.data.byteLength > 0) {\n            imgParts.push(response.data);\n        } else {\n          // Delay so hardware can make progress.\n          await new Promise(r => setTimeout(r, 100));\n        }\n        response = await chrome.documentScan.readScanData(job);\n      }\n      if (response.result != chrome.documentScan.OperationResult.EOF) {\n        return null;\n      }\n      if (response.data && response.data.byteLength > 0) {\n        imgParts.push(response.data);\n      }\n      return new Blob(imgParts, { type: \"image/jpeg\" });\n    }\n    \n\n### Scan one letter-size page\n\nThis example shows how to select a scanner, set its options, and open it. It\nthen retrieves the contents of a single page and closes the scanner. This\nprocess demonstrates using `getScannerList()`, `openScanner()`,\n`setOptions()`, and `closeScanner()`. Note that the contents of the page are\nretrieved by calling the `pageAsBlob()` function from the previous example.\n\n    \n    \n    async function scan() {\n        let response = await chrome.documentScan.getScannerList({ secure: true });\n        let scanner = await chrome.documentScan.openScanner(\n            response.scanners[0].scannerId);\n        const handle = scanner.scannerHandle;\n    \n        let options = [];\n        for (source of scanner.options[\"source\"].constraint.list) {\n            if (source.includes(\"ADF\")) {\n                options.push({\n                    name: \"source\",\n                    type: chrome.documentScan.OptionType.STRING,\n                    value: { value: source }\n                });\n                break;\n            }\n        }\n        options.push({\n            name: \"tl-x\",\n            type: chrome.documentScan.OptionType.FIXED,\n            value: 0.0\n        });\n        options.push({\n            name: \"br-x\",\n            type: chrome.documentScan.OptionType.FIXED,\n            value: 215.9  // 8.5\" in mm\n        });\n        options.push({\n            name: \"tl-y\",\n            type: chrome.documentScan.OptionType.FIXED,\n            value: 0.0\n        });\n        options.push({\n            name: \"br-y\",\n            type: chrome.documentScan.OptionType.FIXED,\n            value: 279.4  // 11\" in mm\n        });\n        response = await chrome.documentScan.setOptions(handle, options);\n    \n        let imgBlob = await pageAsBlob(handle);\n        if (imgBlob != null) {\n            // Insert imgBlob into DOM, save to disk, etc\n        }\n        await chrome.documentScan.closeScanner(handle);\n    }\n    \n\n### Show the configuration\n\nAs stated elsewhere, showing a scanner's configuration options to a user\nrequires calling `getOptionGroups()` in addition to the scanner options\nreturned from a call to `openScanner()`. This is so that options can be shown\nto users in manufacturer-defined groups. This example shows how to do that.\n\n    \n    \n    async function showConfig() {\n      let response = await chrome.documentScan.getScannerList({ secure: true });\n      let scanner = await chrome.documentScan.openScanner(\n          response.scanners[0].scannerId);\n      let groups = await chrome.documentScan.getOptionGroups(scanner.scannerHandle);\n    \n      for (const group of groups.groups) {\n        console.log(\"=== \" + group.title + \" ===\");\n        for (const member of group.members) {\n          const option = scanner.options[member];\n          if (option.isActive) {\n            console.log(\"  \" + option.name + \" = \" + option.value);\n          } else {\n            console.log(\"  \" + option.name + \" is inactive\");\n          }\n        }\n      }\n    }\n    \n\n## Types\n\n### CancelScanResponse\n\nChrome 125+\n\n#### Properties\n\n  * job\n\nstring\n\nProvides the same job handle that was passed to `cancelScan()`.\n\n  * result\n\nOperationResult\n\nThe backend's cancel scan result. If the result is `OperationResult.SUCCESS`\nor `OperationResult.CANCELLED`, the scan has been cancelled and the scanner is\nready to start a new scan. If the result is `OperationResult.DEVICE_BUSY` ,\nthe scanner is still processing the requested cancellation; the caller should\nwait a short time and try the request again. Other result values indicate a\npermanent error that should not be retried.\n\n### CloseScannerResponse\n\nChrome 125+\n\n#### Properties\n\n  * result\n\nOperationResult\n\nThe result of closing the scanner. Even if this value is not `SUCCESS`, the\nhandle will be invalid and should not be used for any further operations.\n\n  * scannerHandle\n\nstring\n\nThe same scanner handle as was passed to `closeScanner`.\n\n### Configurability\n\nChrome 125+\n\nHow an option can be changed.\n\n#### Enum\n\n\"NOT_CONFIGURABLE\"  \nThe option is read-only.\n\n\"SOFTWARE_CONFIGURABLE\"  \nThe option can be set in software.\n\n\"HARDWARE_CONFIGURABLE\"  \nThe option can be set by the user toggling or pushing a button on the scanner.\n\n### ConnectionType\n\nChrome 125+\n\nIndicates how the scanner is connected to the computer.\n\n#### Enum\n\n\"UNSPECIFIED\"  \n\n\"USB\"  \n\n\"NETWORK\"  \n\n### ConstraintType\n\nChrome 125+\n\nThe data type of constraint represented by an `OptionConstraint`.\n\n#### Enum\n\n\"INT_RANGE\"  \nThe constraint on a range of `OptionType.INT` values. The `min`, `max`, and\n`quant` properties of `OptionConstraint` will be `long`, and its `list`\npropety will be unset.\n\n\"FIXED_RANGE\"  \nThe constraint on a range of `OptionType.FIXED` values. The `min`, `max`, and\n`quant` properties of `OptionConstraint` will be `double`, and its `list`\nproperty will be unset.\n\n\"INT_LIST\"  \nThe constraint on a specific list of `OptionType.INT` values. The\n`OptionConstraint.list` property will contain `long` values, and the other\nproperties will be unset.\n\n\"FIXED_LIST\"  \nThe constraint on a specific list of `OptionType.FIXED` values. The\n`OptionConstraint.list` property will contain `double` values, and the other\nproperties will be unset.\n\n\"STRING_LIST\"  \nThe constraint on a specific list of `OptionType.STRING` values. The\n`OptionConstraint.list` property will contain `DOMString` values, and the\nother properties will be unset.\n\n### DeviceFilter\n\nChrome 125+\n\n#### Properties\n\n  * local\n\nboolean optional\n\nOnly return scanners that are directly attached to the computer.\n\n  * secure\n\nboolean optional\n\nOnly return scanners that use a secure transport, such as USB or TLS.\n\n### GetOptionGroupsResponse\n\nChrome 125+\n\n#### Properties\n\n  * groups\n\nOptionGroup[] optional\n\nIf `result` is `SUCCESS`, provides a list of option groups in the order\nsupplied by the scanner driver.\n\n  * result\n\nOperationResult\n\nThe result of getting the option groups. If the value of this is `SUCCESS`,\nthe `groups` property will be populated.\n\n  * scannerHandle\n\nstring\n\nThe same scanner handle as was passed to `getOptionGroups`.\n\n### GetScannerListResponse\n\nChrome 125+\n\n#### Properties\n\n  * result\n\nOperationResult\n\nThe enumeration result. Note that partial results could be returned even if\nthis indicates an error.\n\n  * scanners\n\nScannerInfo[]\n\nA possibly-empty list of scanners that match the provided `DeviceFilter`.\n\n### OpenScannerResponse\n\nChrome 125+\n\n#### Properties\n\n  * options\n\nobject optional\n\nIf `result` is `SUCCESS`, provides a key-value mapping where the key is a\ndevice-specific option and the value is an instance of `ScannerOption`.\n\n  * result\n\nOperationResult\n\nThe result of opening the scanner. If the value of this is `SUCCESS`, the\n`scannerHandle` and `options` properties will be populated.\n\n  * scannerHandle\n\nstring optional\n\nIf `result` is `SUCCESS`, a handle to the scanner that can be used for further\noperations.\n\n  * scannerId\n\nstring\n\nThe scanner ID passed to `openScanner()`.\n\n### OperationResult\n\nChrome 125+\n\nAn enum that indicates the result of each operation.\n\n#### Enum\n\n\"UNKNOWN\"  \nAn unknown or generic failure occurred.\n\n\"SUCCESS\"  \nThe operation succeeded.\n\n\"UNSUPPORTED\"  \nThe operation is not supported.\n\n\"CANCELLED\"  \nThe operation was cancelled.\n\n\"DEVICE_BUSY\"  \nThe device is busy.\n\n\"INVALID\"  \nEither the data or an argument passed to the method is not valid.\n\n\"WRONG_TYPE\"  \nThe supplied value is the wrong data type for the underlying option.\n\n\"EOF\"  \nNo more data is available.\n\n\"ADF_JAMMED\"  \nThe document feeder is jammed.\n\n\"ADF_EMPTY\"  \nThe document feeder is empty.\n\n\"COVER_OPEN\"  \nThe flatbed cover is open.\n\n\"IO_ERROR\"  \nAn error occurred while communicating with the device.\n\n\"ACCESS_DENIED\"  \nThe device requires authentication.\n\n\"NO_MEMORY\"  \nNot enough memory is available on the Chromebook to complete the operation.\n\n\"UNREACHABLE\"  \nThe device is not reachable.\n\n\"MISSING\"  \nThe device is disconnected.\n\n\"INTERNAL_ERROR\"  \nAn error has occurred somewhere other than the calling application.\n\n### OptionConstraint\n\nChrome 125+\n\n#### Properties\n\n  * list\n\nstring[] | number[] optional\n\n  * max\n\nnumber optional\n\n  * min\n\nnumber optional\n\n  * quant\n\nnumber optional\n\n  * type\n\nConstraintType\n\n### OptionGroup\n\nChrome 125+\n\n#### Properties\n\n  * members\n\nstring[]\n\nAn array of option names in driver-provided order.\n\n  * title\n\nstring\n\nProvides a printable title, for example \"Geometry options\".\n\n### OptionSetting\n\nChrome 125+\n\n#### Properties\n\n  * name\n\nstring\n\nIndicates the name of the option to set.\n\n  * type\n\nOptionType\n\nIndicates the data type of the option. The requested data type must match the\nreal data type of the underlying option.\n\n  * value\n\nstring | number | boolean | number[] optional\n\nIndicates the value to set. Leave unset to request automatic setting for\noptions that have `autoSettable` enabled. The data type supplied for `value`\nmust match `type`.\n\n### OptionType\n\nChrome 125+\n\nThe data type of an option.\n\n#### Enum\n\n\"UNKNOWN\"  \nThe option's data type is unknown. The `value` property will be unset.\n\n\"BOOL\"  \nThe `value` property will be one of `true`false.\n\n\"INT\"  \nA signed 32-bit integer. The `value` property will be long or long[],\ndepending on whether the option takes more than one value.\n\n\"FIXED\"  \nA double in the range -32768-32767.9999 with a resolution of 1/65535. The\n`value` property will be double or double[] depending on whether the option\ntakes more than one value. Double values that can't be exactly represented\nwill be rounded to the available range and precision.\n\n\"STRING\"  \nA sequence of any bytes except NUL ('\\0'). The `value` property will be a\nDOMString.\n\n\"BUTTON\"  \nAn option of this type has no value. Instead, setting an option of this type\ncauses an option-specific side effect in the scanner driver. For example, a\nbutton-typed option could be used by a scanner driver to provide a means to\nselect default values or to tell an automatic document feeder to advance to\nthe next sheet of paper.\n\n\"GROUP\"  \nGrouping option. No value. This is included for compatibility, but will not\nnormally be returned in `ScannerOption` values. Use `getOptionGroups()` to\nretrieve the list of groups with their member options.\n\n### OptionUnit\n\nChrome 125+\n\nIndicates the data type for `ScannerOption.unit`.\n\n#### Enum\n\n\"UNITLESS\"  \nThe value is a unitless number. For example, it can be a threshold.\n\n\"PIXEL\"  \nThe value is a number of pixels, for example, scan dimensions.\n\n\"BIT\"  \nThe value is the number of bits, for example, color depth.\n\n\"MM\"  \nThe value is measured in millimeters, for example, scan dimensions.\n\n\"DPI\"  \nThe value is measured in dots per inch, for example, resolution.\n\n\"PERCENT\"  \nThe value is a percent, for example, brightness.\n\n\"MICROSECOND\"  \nThe value is measured in microseconds, for example, exposure time.\n\n### ReadScanDataResponse\n\nChrome 125+\n\n#### Properties\n\n  * data\n\nArrayBuffer optional\n\nIf `result` is `SUCCESS`, contains the _next_ chunk of scanned image data. If\n`result` is `EOF`, contains the _last_ chunk of scanned image data.\n\n  * estimatedCompletion\n\nnumber optional\n\nIf `result` is `SUCCESS`, an estimate of how much of the total scan data has\nbeen delivered so far, in the range 0 to 100.\n\n  * job\n\nstring\n\nProvides the job handle passed to `readScanData()`.\n\n  * result\n\nOperationResult\n\nThe result of reading data. If its value is `SUCCESS`, then `data` contains\nthe _next_ (possibly zero-length) chunk of image data that is ready for\nreading. If its value is `EOF`, the `data` contains the _last_ chunk of image\ndata.\n\n### ScannerInfo\n\nChrome 125+\n\n#### Properties\n\n  * connectionType\n\nConnectionType\n\nIndicates how the scanner is connected to the computer.\n\n  * deviceUuid\n\nstring\n\nFor matching against other `ScannerInfo` entries that point to the same\nphysical device.\n\n  * imageFormats\n\nstring[]\n\nAn array of MIME types that can be requested for returned scans.\n\n  * manufacturer\n\nstring\n\nThe scanner manufacturer.\n\n  * model\n\nstring\n\nThe scanner model if it is available, or a generic description.\n\n  * name\n\nstring\n\nA human-readable name for the scanner to display in the UI.\n\n  * protocolType\n\nstring\n\nA human-readable description of the protocol or driver used to access the\nscanner, such as Mopria, WSD, or epsonds. This is primarily useful for\nallowing a user to choose between protocols if a device supports multiple\nprotocols.\n\n  * scannerId\n\nstring\n\nThe ID of a specific scanner.\n\n  * secure\n\nboolean\n\nIf true, the scanner connection's transport cannot be intercepted by a passive\nlistener, such as TLS or USB.\n\n### ScannerOption\n\nChrome 125+\n\n#### Properties\n\n  * configurability\n\nConfigurability\n\nIndicates whether and how the option can be changed.\n\n  * constraint\n\nOptionConstraint optional\n\nDefines `OptionConstraint` on the current scanner option.\n\n  * description\n\nstring\n\nA longer description of the option.\n\n  * isActive\n\nboolean\n\nIndicates the option is active and can be set or retrieved. If false, the\n`value` property will not be set.\n\n  * isAdvanced\n\nboolean\n\nIndicates that the UI should not display this option by default.\n\n  * isAutoSettable\n\nboolean\n\nCan be automatically set by the scanner driver.\n\n  * isDetectable\n\nboolean\n\nIndicates that this option can be detected from software.\n\n  * isEmulated\n\nboolean\n\nEmulated by the scanner driver if true.\n\n  * name\n\nstring\n\nThe option name using lowercase ASCII letters, numbers, and dashes. Diacritics\nare not allowed.\n\n  * title\n\nstring\n\nA printable one-line title.\n\n  * type\n\nOptionType\n\nThe data type contained in the `value` property, which is needed for setting\nthis option.\n\n  * unit\n\nOptionUnit\n\nThe unit of measurement for this option.\n\n  * value\n\nstring | number | boolean | number[] optional\n\nThe current value of the option, if relevant. Note that the data type of this\nproperty must match the data type specified in `type`.\n\n### ScanOptions\n\n#### Properties\n\n  * maxImages\n\nnumber optional\n\nThe number of scanned images allowed. The default is 1.\n\n  * mimeTypes\n\nstring[] optional\n\nThe MIME types that are accepted by the caller.\n\n### ScanResults\n\n#### Properties\n\n  * dataUrls\n\nstring[]\n\nAn array of data image URLs in a form that can be passed as the \"src\" value to\nan image tag.\n\n  * mimeType\n\nstring\n\nThe MIME type of the `dataUrls`.\n\n### SetOptionResult\n\nChrome 125+\n\n#### Properties\n\n  * name\n\nstring\n\nIndicates the name of the option that was set.\n\n  * result\n\nOperationResult\n\nIndicates the result of setting the option.\n\n### SetOptionsResponse\n\nChrome 125+\n\n#### Properties\n\n  * options\n\nobject optional\n\nAn updated key-value mapping from option names to `ScannerOption` values\ncontaining the new configuration after attempting to set all supplied options.\nThis has the same structure as the `options` property in\n`OpenScannerResponse`.\n\nThis property will be set even if some options were not set successfully, but\nwill be unset if retrieving the updated configuration fails (for example, if\nthe scanner is disconnected in the middle of scanning).\n\n  * results\n\nSetOptionResult[]\n\nAn array of results, one each for every passed-in `OptionSetting`.\n\n  * scannerHandle\n\nstring\n\nProvides the scanner handle passed to `setOptions()`.\n\n### StartScanOptions\n\nChrome 125+\n\n#### Properties\n\n  * format\n\nstring\n\nSpecifies the MIME type to return scanned data in.\n\n  * maxReadSize\n\nnumber optional\n\nIf a non-zero value is specified, limits the maximum scanned bytes returned in\na single `readScanData` response to that value. The smallest allowed value is\n32768 (32 KB). If this property is not specified, the size of a returned chunk\nmay be as large as the entire scanned image.\n\n### StartScanResponse\n\nChrome 125+\n\n#### Properties\n\n  * job\n\nstring optional\n\nIf `result` is `SUCCESS`, provides a handle that can be used to read scan data\nor cancel the job.\n\n  * result\n\nOperationResult\n\nThe result of starting a scan. If the value of this is `SUCCESS`, the `job`\nproperty will be populated.\n\n  * scannerHandle\n\nstring\n\nProvides the same scanner handle that was passed to `startScan()`.\n\n## Methods\n\n### cancelScan()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.cancelScan(  \n      job: string,  \n      callback?: function,  \n    )\n\nCancels a started scan and returns a Promise that resolves with a\n`CancelScanResponse` object. If a callback is used, the object is passed to it\ninstead.\n\n#### Parameters\n\n  * job\n\nstring\n\nThe handle of an active scan job previously returned from a call to\n`startScan`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: CancelScanResponse) => void\n\n    * response\n\nCancelScanResponse\n\n#### Returns\n\n  * Promise<CancelScanResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### closeScanner()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.closeScanner(  \n      scannerHandle: string,  \n      callback?: function,  \n    )\n\nCloses the scanner with the passed in handle and returns a Promise that\nresolves with a `CloseScannerResponse` object. If a callback is used, the\nobject is passed to it instead. Even if the response is not a success, the\nsupplied handle becomes invalid and should not be used for further operations.\n\n#### Parameters\n\n  * scannerHandle\n\nstring\n\nSpecifies the handle of an open scanner that was previously returned from a\ncall to `openScanner`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: CloseScannerResponse) => void\n\n    * response\n\nCloseScannerResponse\n\n#### Returns\n\n  * Promise<CloseScannerResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getOptionGroups()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.getOptionGroups(  \n      scannerHandle: string,  \n      callback?: function,  \n    )\n\nGets the group names and member options from a scanner previously opened by\n`openScanner`. This method returns a Promise that resolves with a\n`GetOptionGroupsResponse` object. If a callback is passed to this function,\nreturned data is passed to it instead.\n\n#### Parameters\n\n  * scannerHandle\n\nstring\n\nThe handle of an open scanner returned from a call to `openScanner`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: GetOptionGroupsResponse) => void\n\n    * response\n\nGetOptionGroupsResponse\n\n#### Returns\n\n  * Promise<GetOptionGroupsResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getScannerList()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.getScannerList(  \n      filter: DeviceFilter,  \n      callback?: function,  \n    )\n\nGets the list of available scanners and returns a Promise that resolves with a\n`GetScannerListResponse` object. If a callback is passed to this function,\nreturned data is passed to it instead.\n\n#### Parameters\n\n  * filter\n\nDeviceFilter\n\nA `DeviceFilter` indicating which types of scanners should be returned.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: GetScannerListResponse) => void\n\n    * response\n\nGetScannerListResponse\n\n#### Returns\n\n  * Promise<GetScannerListResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### openScanner()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.openScanner(  \n      scannerId: string,  \n      callback?: function,  \n    )\n\nOpens a scanner for exclusive access and returns a Promise that resolves with\nan `OpenScannerResponse` object. If a callback is passed to this function,\nreturned data is passed to it instead.\n\n#### Parameters\n\n  * scannerId\n\nstring\n\nThe ID of a scanner to be opened. This value is one returned from a previous\ncall to `getScannerList`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: OpenScannerResponse) => void\n\n    * response\n\nOpenScannerResponse\n\n#### Returns\n\n  * Promise<OpenScannerResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### readScanData()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.readScanData(  \n      job: string,  \n      callback?: function,  \n    )\n\nReads the next chunk of available image data from an active job handle, and\nreturns a Promise that resolves with a `ReadScanDataResponse` object. If a\ncallback is used, the object is passed to it instead.\n\n**Note:**It is valid for a response result to be `SUCCESS` with a zero-length\n`data` member. This means the scanner is still working but does not yet have\nadditional data ready. The caller should wait a short time and try again.\n\nWhen the scan job completes, the response will have the result value of `EOF`.\nThis response may contain a final non-zero `data` member.\n\n#### Parameters\n\n  * job\n\nstring\n\nActive job handle previously returned from `startScan`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: ReadScanDataResponse) => void\n\n    * response\n\nReadScanDataResponse\n\n#### Returns\n\n  * Promise<ReadScanDataResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### scan()\n\nPromise\n\n    \n    \n    chrome.documentScan.scan(  \n      options: ScanOptions,  \n      callback?: function,  \n    )\n\nPerforms a document scan and returns a Promise that resolves with a\n`ScanResults` object. If a callback is passed to this function, the returned\ndata is passed to it instead.\n\n#### Parameters\n\n  * options\n\nScanOptions\n\nAn object containing scan parameters.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ScanResults) => void\n\n    * result\n\nScanResults\n\n#### Returns\n\n  * Promise<ScanResults>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setOptions()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.setOptions(  \n      scannerHandle: string,  \n      options: OptionSetting[],  \n      callback?: function,  \n    )\n\nSets options on the specified scanner and returns a Promise that resolves with\na `SetOptionsResponse` object containing the result of trying to set every\nvalue in the order of the passed-in `OptionSetting` object. If a callback is\nused, the object is passed to it instead.\n\n#### Parameters\n\n  * scannerHandle\n\nstring\n\nThe handle of the scanner to set options on. This should be a value previously\nreturned from a call to `openScanner`.\n\n  * options\n\nOptionSetting[]\n\nA list of `OptionSetting` objects to be applied to the scanner.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: SetOptionsResponse) => void\n\n    * response\n\nSetOptionsResponse\n\n#### Returns\n\n  * Promise<SetOptionsResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### startScan()\n\nPromise Chrome 125+\n\n    \n    \n    chrome.documentScan.startScan(  \n      scannerHandle: string,  \n      options: StartScanOptions,  \n      callback?: function,  \n    )\n\nStarts a scan on the specified scanner and returns a Promise that resolves\nwith a `StartScanResponse`. If a callback is used, the object is passed to it\ninstead. If the call was successful, the response includes a job handle that\ncan be used in subsequent calls to read scan data or cancel a scan.\n\n#### Parameters\n\n  * scannerHandle\n\nstring\n\nThe handle of an open scanner. This should be a value previously returned from\na call to `openScanner`.\n\n  * options\n\nStartScanOptions\n\nA `StartScanOptions` object indicating the options to be used for the scan.\nThe `StartScanOptions.format` property must match one of the entries returned\nin the scanner's `ScannerInfo`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: StartScanResponse) => void\n\n    * response\n\nStartScanResponse\n\n#### Returns\n\n  * Promise<StartScanResponse>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/dom": "#  chrome.dom\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.dom` API to access special DOM APIs for Extensions\n\n## Availability\n\nChrome 88+\n\n## Methods\n\n### openOrClosedShadowRoot()\n\n    \n    \n    chrome.dom.openOrClosedShadowRoot(  \n      element: HTMLElement,  \n    )\n\nGets the open shadow root or the closed shadow root hosted by the specified\nelement. If the element doesn't attach the shadow root, it will return null.\n\n#### Parameters\n\n  * element\n\nHTMLElement\n\n#### Returns\n\n  * object\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/downloads": "#  chrome.downloads\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.downloads` API to programmatically initiate, monitor,\nmanipulate, and search for downloads.\n\n## Permissions\n\n`downloads`  \n\nYou must declare the `\"downloads\"` permission in the extension manifest to use\nthis API.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"downloads\"\n      ],\n    }\n    \n\n## Examples\n\nYou can find simple examples of using the `chrome.downloads` API in the\nexamples/api/downloads directory. For other examples and for help in viewing\nthe source code, see Samples.\n\n## Types\n\n### BooleanDelta\n\n#### Properties\n\n  * current\n\nboolean optional\n\n  * previous\n\nboolean optional\n\n### DangerType\n\nfile\n\nThe download's filename is suspicious.\n\nurl\n\nThe download's URL is known to be malicious.\n\ncontent\n\nThe downloaded file is known to be malicious.\n\nuncommon\n\nThe download's URL is not commonly downloaded and could be dangerous.\n\nhost\n\nThe download came from a host known to distribute malicious binaries and is\nlikely dangerous.\n\nunwanted\n\nThe download is potentially unwanted or unsafe. E.g. it could make changes to\nbrowser or computer settings.\n\nsafe\n\nThe download presents no known danger to the user's computer.\n\naccepted\n\nThe user has accepted the dangerous download.\n\n#### Enum\n\n\"file\"  \n\n\"url\"  \n\n\"content\"  \n\n\"uncommon\"  \n\n\"host\"  \n\n\"unwanted\"  \n\n\"safe\"  \n\n\"accepted\"  \n\n\"allowlistedByPolicy\"  \n\n\"asyncScanning\"  \n\n\"asyncLocalPasswordScanning\"  \n\n\"passwordProtected\"  \n\n\"blockedTooLarge\"  \n\n\"sensitiveContentWarning\"  \n\n\"sensitiveContentBlock\"  \n\n\"deepScannedFailed\"  \n\n\"deepScannedSafe\"  \n\n\"deepScannedOpenedDangerous\"  \n\n\"promptForScanning\"  \n\n\"promptForLocalPasswordScanning\"  \n\n\"accountCompromise\"  \n\n\"blockedScanFailed\"  \n\n### DoubleDelta\n\n#### Properties\n\n  * current\n\nnumber optional\n\n  * previous\n\nnumber optional\n\n### DownloadDelta\n\n#### Properties\n\n  * canResume\n\nBooleanDelta optional\n\nThe change in `canResume`, if any.\n\n  * danger\n\nStringDelta optional\n\nThe change in `danger`, if any.\n\n  * endTime\n\nStringDelta optional\n\nThe change in `endTime`, if any.\n\n  * error\n\nStringDelta optional\n\nThe change in `error`, if any.\n\n  * exists\n\nBooleanDelta optional\n\nThe change in `exists`, if any.\n\n  * fileSize\n\nDoubleDelta optional\n\nThe change in `fileSize`, if any.\n\n  * filename\n\nStringDelta optional\n\nThe change in `filename`, if any.\n\n  * finalUrl\n\nStringDelta optional\n\nChrome 54+\n\nThe change in `finalUrl`, if any.\n\n  * id\n\nnumber\n\nThe `id` of the `DownloadItem` that changed.\n\n  * mime\n\nStringDelta optional\n\nThe change in `mime`, if any.\n\n  * paused\n\nBooleanDelta optional\n\nThe change in `paused`, if any.\n\n  * startTime\n\nStringDelta optional\n\nThe change in `startTime`, if any.\n\n  * state\n\nStringDelta optional\n\nThe change in `state`, if any.\n\n  * totalBytes\n\nDoubleDelta optional\n\nThe change in `totalBytes`, if any.\n\n  * url\n\nStringDelta optional\n\nThe change in `url`, if any.\n\n### DownloadItem\n\n#### Properties\n\n  * byExtensionId\n\nstring optional\n\nThe identifier for the extension that initiated this download if this download\nwas initiated by an extension. Does not change once it is set.\n\n  * byExtensionName\n\nstring optional\n\nThe localized name of the extension that initiated this download if this\ndownload was initiated by an extension. May change if the extension changes\nits name or if the user changes their locale.\n\n  * bytesReceived\n\nnumber\n\nNumber of bytes received so far from the host, without considering file\ncompression.\n\n  * canResume\n\nboolean\n\nTrue if the download is in progress and paused, or else if it is interrupted\nand can be resumed starting from where it was interrupted.\n\n  * danger\n\nDangerType\n\nIndication of whether this download is thought to be safe or known to be\nsuspicious.\n\n  * endTime\n\nstring optional\n\nThe time when the download ended in ISO 8601 format. May be passed directly to\nthe Date constructor: `chrome.downloads.search({},\nfunction(items){items.forEach(function(item){if (item.endTime) console.log(new\nDate(item.endTime))})})`\n\n  * error\n\nInterruptReason optional\n\nWhy the download was interrupted. Several kinds of HTTP errors may be grouped\nunder one of the errors beginning with `SERVER_`. Errors relating to the\nnetwork begin with `NETWORK_`, errors relating to the process of writing the\nfile to the file system begin with `FILE_`, and interruptions initiated by the\nuser begin with `USER_`.\n\n  * estimatedEndTime\n\nstring optional\n\nEstimated time when the download will complete in ISO 8601 format. May be\npassed directly to the Date constructor: `chrome.downloads.search({},\nfunction(items){items.forEach(function(item){if (item.estimatedEndTime)\nconsole.log(new Date(item.estimatedEndTime))})})`\n\n  * exists\n\nboolean\n\nWhether the downloaded file still exists. This information may be out of date\nbecause Chrome does not automatically watch for file removal. Call `search`()\nin order to trigger the check for file existence. When the existence check\ncompletes, if the file has been deleted, then an `onChanged` event will fire.\nNote that `search`() does not wait for the existence check to finish before\nreturning, so results from `search`() may not accurately reflect the file\nsystem. Also, `search`() may be called as often as necessary, but will not\ncheck for file existence any more frequently than once every 10 seconds.\n\n  * fileSize\n\nnumber\n\nNumber of bytes in the whole file post-decompression, or -1 if unknown.\n\n  * filename\n\nstring\n\nAbsolute local path.\n\n  * finalUrl\n\nstring\n\nChrome 54+\n\nThe absolute URL that this download is being made from, after all redirects.\n\n  * id\n\nnumber\n\nAn identifier that is persistent across browser sessions.\n\n  * incognito\n\nboolean\n\nFalse if this download is recorded in the history, true if it is not recorded.\n\n  * mime\n\nstring\n\nThe file's MIME type.\n\n  * paused\n\nboolean\n\nTrue if the download has stopped reading data from the host, but kept the\nconnection open.\n\n  * referrer\n\nstring\n\nAbsolute URL.\n\n  * startTime\n\nstring\n\nThe time when the download began in ISO 8601 format. May be passed directly to\nthe Date constructor: `chrome.downloads.search({},\nfunction(items){items.forEach(function(item){console.log(new\nDate(item.startTime))})})`\n\n  * state\n\nState\n\nIndicates whether the download is progressing, interrupted, or complete.\n\n  * totalBytes\n\nnumber\n\nNumber of bytes in the whole file, without considering file compression, or -1\nif unknown.\n\n  * url\n\nstring\n\nThe absolute URL that this download initiated from, before any redirects.\n\n### DownloadOptions\n\n#### Properties\n\n  * body\n\nstring optional\n\nPost body.\n\n  * conflictAction\n\nFilenameConflictAction optional\n\nThe action to take if `filename` already exists.\n\n  * filename\n\nstring optional\n\nA file path relative to the Downloads directory to contain the downloaded\nfile, possibly containing subdirectories. Absolute paths, empty paths, and\npaths containing back-references \"..\" will cause an error.\n`onDeterminingFilename` allows suggesting a filename after the file's MIME\ntype and a tentative filename have been determined.\n\n  * headers\n\nHeaderNameValuePair[] optional\n\nExtra HTTP headers to send with the request if the URL uses the HTTP[s]\nprotocol. Each header is represented as a dictionary containing the keys\n`name` and either `value` or `binaryValue`, restricted to those allowed by\nXMLHttpRequest.\n\n  * method\n\nHttpMethod optional\n\nThe HTTP method to use if the URL uses the HTTP[S] protocol.\n\n  * saveAs\n\nboolean optional\n\nUse a file-chooser to allow the user to select a filename regardless of\nwhether `filename` is set or already exists.\n\n  * url\n\nstring\n\nThe URL to download.\n\n### DownloadQuery\n\n#### Properties\n\n  * bytesReceived\n\nnumber optional\n\nNumber of bytes received so far from the host, without considering file\ncompression.\n\n  * danger\n\nDangerType optional\n\nIndication of whether this download is thought to be safe or known to be\nsuspicious.\n\n  * endTime\n\nstring optional\n\nThe time when the download ended in ISO 8601 format.\n\n  * endedAfter\n\nstring optional\n\nLimits results to `DownloadItem` that ended after the given ms in ISO 8601\nformat\n\n  * endedBefore\n\nstring optional\n\nLimits results to `DownloadItem` that ended before the given ms in ISO 8601\nformat.\n\n  * error\n\nInterruptReason optional\n\nWhy a download was interrupted.\n\n  * exists\n\nboolean optional\n\nWhether the downloaded file exists;\n\n  * fileSize\n\nnumber optional\n\nNumber of bytes in the whole file post-decompression, or -1 if unknown.\n\n  * filename\n\nstring optional\n\nAbsolute local path.\n\n  * filenameRegex\n\nstring optional\n\nLimits results to `DownloadItem` whose `filename` matches the given regular\nexpression.\n\n  * finalUrl\n\nstring optional\n\nChrome 54+\n\nThe absolute URL that this download is being made from, after all redirects.\n\n  * finalUrlRegex\n\nstring optional\n\nChrome 54+\n\nLimits results to `DownloadItem` whose `finalUrl` matches the given regular\nexpression.\n\n  * id\n\nnumber optional\n\nThe `id` of the `DownloadItem` to query.\n\n  * limit\n\nnumber optional\n\nThe maximum number of matching `DownloadItem` returned. Defaults to 1000. Set\nto 0 in order to return all matching `DownloadItem`. See `search` for how to\npage through results.\n\n  * mime\n\nstring optional\n\nThe file's MIME type.\n\n  * orderBy\n\nstring[] optional\n\nSet elements of this array to `DownloadItem` properties in order to sort\nsearch results. For example, setting `orderBy=['startTime']` sorts the\n`DownloadItem` by their start time in ascending order. To specify descending\norder, prefix with a hyphen: '-startTime'.\n\n  * paused\n\nboolean optional\n\nTrue if the download has stopped reading data from the host, but kept the\nconnection open.\n\n  * query\n\nstring[] optional\n\nThis array of search terms limits results to `DownloadItem` whose `filename`\nor `url` or `finalUrl` contain all of the search terms that do not begin with\na dash '-' and none of the search terms that do begin with a dash.\n\n  * startTime\n\nstring optional\n\nThe time when the download began in ISO 8601 format.\n\n  * startedAfter\n\nstring optional\n\nLimits results to `DownloadItem` that started after the given ms in ISO 8601\nformat.\n\n  * startedBefore\n\nstring optional\n\nLimits results to `DownloadItem` that started before the given ms in ISO 8601\nformat.\n\n  * state\n\nState optional\n\nIndicates whether the download is progressing, interrupted, or complete.\n\n  * totalBytes\n\nnumber optional\n\nNumber of bytes in the whole file, without considering file compression, or -1\nif unknown.\n\n  * totalBytesGreater\n\nnumber optional\n\nLimits results to `DownloadItem` whose `totalBytes` is greater than the given\ninteger.\n\n  * totalBytesLess\n\nnumber optional\n\nLimits results to `DownloadItem` whose `totalBytes` is less than the given\ninteger.\n\n  * url\n\nstring optional\n\nThe absolute URL that this download initiated from, before any redirects.\n\n  * urlRegex\n\nstring optional\n\nLimits results to `DownloadItem` whose `url` matches the given regular\nexpression.\n\n### FilenameConflictAction\n\nuniquify\n\nTo avoid duplication, the `filename` is changed to include a counter before\nthe filename extension.\n\noverwrite\n\nThe existing file will be overwritten with the new file.\n\nprompt\n\nThe user will be prompted with a file chooser dialog.\n\n#### Enum\n\n\"uniquify\"  \n\n\"overwrite\"  \n\n\"prompt\"  \n\n### FilenameSuggestion\n\n#### Properties\n\n  * conflictAction\n\nFilenameConflictAction optional\n\nThe action to take if `filename` already exists.\n\n  * filename\n\nstring\n\nThe `DownloadItem`'s new target `DownloadItem.filename`, as a path relative to\nthe user's default Downloads directory, possibly containing subdirectories.\nAbsolute paths, empty paths, and paths containing back-references \"..\" will be\nignored. `filename` is ignored if there are any `onDeterminingFilename`\nlisteners registered by any extensions.\n\n### GetFileIconOptions\n\n#### Properties\n\n  * size\n\nnumber optional\n\nThe size of the returned icon. The icon will be square with dimensions size *\nsize pixels. The default and largest size for the icon is 32x32 pixels. The\nonly supported sizes are 16 and 32. It is an error to specify any other size.\n\n### HeaderNameValuePair\n\n#### Properties\n\n  * name\n\nstring\n\nName of the HTTP header.\n\n  * value\n\nstring\n\nValue of the HTTP header.\n\n### HttpMethod\n\n#### Enum\n\n\"GET\"  \n\n\"POST\"  \n\n### InterruptReason\n\n#### Enum\n\n\"FILE_FAILED\"  \n\n\"FILE_ACCESS_DENIED\"  \n\n\"FILE_NO_SPACE\"  \n\n\"FILE_NAME_TOO_LONG\"  \n\n\"FILE_TOO_LARGE\"  \n\n\"FILE_VIRUS_INFECTED\"  \n\n\"FILE_TRANSIENT_ERROR\"  \n\n\"FILE_BLOCKED\"  \n\n\"FILE_SECURITY_CHECK_FAILED\"  \n\n\"FILE_TOO_SHORT\"  \n\n\"FILE_HASH_MISMATCH\"  \n\n\"FILE_SAME_AS_SOURCE\"  \n\n\"NETWORK_FAILED\"  \n\n\"NETWORK_TIMEOUT\"  \n\n\"NETWORK_DISCONNECTED\"  \n\n\"NETWORK_SERVER_DOWN\"  \n\n\"NETWORK_INVALID_REQUEST\"  \n\n\"SERVER_FAILED\"  \n\n\"SERVER_NO_RANGE\"  \n\n\"SERVER_BAD_CONTENT\"  \n\n\"SERVER_UNAUTHORIZED\"  \n\n\"SERVER_CERT_PROBLEM\"  \n\n\"SERVER_FORBIDDEN\"  \n\n\"SERVER_UNREACHABLE\"  \n\n\"SERVER_CONTENT_LENGTH_MISMATCH\"  \n\n\"SERVER_CROSS_ORIGIN_REDIRECT\"  \n\n\"USER_CANCELED\"  \n\n\"USER_SHUTDOWN\"  \n\n\"CRASH\"  \n\n### State\n\nin_progress\n\nThe download is currently receiving data from the server.\n\ninterrupted\n\nAn error broke the connection with the file host.\n\ncomplete\n\nThe download completed successfully.\n\n#### Enum\n\n\"in_progress\"  \n\n\"interrupted\"  \n\n\"complete\"  \n\n### StringDelta\n\n#### Properties\n\n  * current\n\nstring optional\n\n  * previous\n\nstring optional\n\n### UiOptions\n\nChrome 105+\n\n#### Properties\n\n  * enabled\n\nboolean\n\nEnable or disable the download UI.\n\n## Methods\n\n### acceptDanger()\n\nPromise\n\n    \n    \n    chrome.downloads.acceptDanger(  \n      downloadId: number,  \n      callback?: function,  \n    )\n\nPrompt the user to accept a dangerous download. Can only be called from a\nvisible context (tab, window, or page/browser action popup). Does not\nautomatically accept dangerous downloads. If the download is accepted, then an\n`onChanged` event will fire, otherwise nothing will happen. When all the data\nis fetched into a temporary file and either the download is not dangerous or\nthe danger has been accepted, then the temporary file is renamed to the target\nfilename, the `state` changes to 'complete', and `onChanged` fires.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\nThe identifier for the `DownloadItem`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### cancel()\n\nPromise\n\n    \n    \n    chrome.downloads.cancel(  \n      downloadId: number,  \n      callback?: function,  \n    )\n\nCancel a download. When `callback` is run, the download is cancelled,\ncompleted, interrupted or doesn't exist anymore.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\nThe id of the download to cancel.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### download()\n\nPromise\n\n    \n    \n    chrome.downloads.download(  \n      options: DownloadOptions,  \n      callback?: function,  \n    )\n\nDownload a URL. If the URL uses the HTTP[S] protocol, then the request will\ninclude all cookies currently set for its hostname. If both `filename` and\n`saveAs` are specified, then the Save As dialog will be displayed, pre-\npopulated with the specified `filename`. If the download started successfully,\n`callback` will be called with the new `DownloadItem`'s `downloadId`. If there\nwas an error starting the download, then `callback` will be called with\n`downloadId=undefined` and `runtime.lastError` will contain a descriptive\nstring. The error strings are not guaranteed to remain backwards compatible\nbetween releases. Extensions must not parse it.\n\n#### Parameters\n\n  * options\n\nDownloadOptions\n\nWhat to download and how.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (downloadId: number) => void\n\n    * downloadId\n\nnumber\n\n#### Returns\n\n  * Promise<number>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### erase()\n\nPromise\n\n    \n    \n    chrome.downloads.erase(  \n      query: DownloadQuery,  \n      callback?: function,  \n    )\n\nErase matching `DownloadItem` from history without deleting the downloaded\nfile. An `onErased` event will fire for each `DownloadItem` that matches\n`query`, then `callback` will be called.\n\n#### Parameters\n\n  * query\n\nDownloadQuery\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (erasedIds: number[]) => void\n\n    * erasedIds\n\nnumber[]\n\n#### Returns\n\n  * Promise<number[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getFileIcon()\n\nPromise\n\n    \n    \n    chrome.downloads.getFileIcon(  \n      downloadId: number,  \n      options?: GetFileIconOptions,  \n      callback?: function,  \n    )\n\nRetrieve an icon for the specified download. For new downloads, file icons are\navailable after the `onCreated` event has been received. The image returned by\nthis function while a download is in progress may be different from the image\nreturned after the download is complete. Icon retrieval is done by querying\nthe underlying operating system or toolkit depending on the platform. The icon\nthat is returned will therefore depend on a number of factors including state\nof the download, platform, registered file types and visual theme. If a file\nicon cannot be determined, `runtime.lastError` will contain an error message.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\nThe identifier for the download.\n\n  * options\n\nGetFileIconOptions optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (iconURL?: string) => void\n\n    * iconURL\n\nstring optional\n\n#### Returns\n\n  * Promise<string | undefined>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### open()\n\nPromise\n\n    \n    \n    chrome.downloads.open(  \n      downloadId: number,  \n      callback?: function,  \n    )\n\nOpens the downloaded file now if the `DownloadItem` is complete; otherwise\nreturns an error through `runtime.lastError`. This method requires the\n`\"downloads.open\"` permission in addition to the `\"downloads\"` permission. An\n`onChanged` event fires when the item is opened for the first time. This\nmethod can only be called in response to a user gesture.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\nThe identifier for the downloaded file.\n\n  * callback\n\nfunction optional\n\nChrome 123+\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 123+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### pause()\n\nPromise\n\n    \n    \n    chrome.downloads.pause(  \n      downloadId: number,  \n      callback?: function,  \n    )\n\nPause the download. If the request was successful the download is in a paused\nstate. Otherwise `runtime.lastError` contains an error message. The request\nwill fail if the download is not active.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\nThe id of the download to pause.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeFile()\n\nPromise\n\n    \n    \n    chrome.downloads.removeFile(  \n      downloadId: number,  \n      callback?: function,  \n    )\n\nRemove the downloaded file if it exists and the `DownloadItem` is complete;\notherwise return an error through `runtime.lastError`.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### resume()\n\nPromise\n\n    \n    \n    chrome.downloads.resume(  \n      downloadId: number,  \n      callback?: function,  \n    )\n\nResume a paused download. If the request was successful the download is in\nprogress and unpaused. Otherwise `runtime.lastError` contains an error\nmessage. The request will fail if the download is not active.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\nThe id of the download to resume.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### search()\n\nPromise\n\n    \n    \n    chrome.downloads.search(  \n      query: DownloadQuery,  \n      callback?: function,  \n    )\n\nFind `DownloadItem`. Set `query` to the empty object to get all\n`DownloadItem`. To get a specific `DownloadItem`, set only the `id` field. To\npage through a large number of items, set `orderBy: ['-startTime']`, set\n`limit` to the number of items per page, and set `startedAfter` to the\n`startTime` of the last item from the last page.\n\n#### Parameters\n\n  * query\n\nDownloadQuery\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: DownloadItem[]) => void\n\n    * results\n\nDownloadItem[]\n\n#### Returns\n\n  * Promise<DownloadItem[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setShelfEnabled()\n\nDeprecated since Chrome 117\n\n    \n    \n    chrome.downloads.setShelfEnabled(  \n      enabled: boolean,  \n    )\n\nUse `setUiOptions` instead.\n\nEnable or disable the gray shelf at the bottom of every window associated with\nthe current browser profile. The shelf will be disabled as long as at least\none extension has disabled it. Enabling the shelf while at least one other\nextension has disabled it will return an error through `runtime.lastError`.\nRequires the `\"downloads.shelf\"` permission in addition to the `\"downloads\"`\npermission.\n\n#### Parameters\n\n  * enabled\n\nboolean\n\n### setUiOptions()\n\nPromise Chrome 105+\n\n    \n    \n    chrome.downloads.setUiOptions(  \n      options: UiOptions,  \n      callback?: function,  \n    )\n\nChange the download UI of every window associated with the current browser\nprofile. As long as at least one extension has set `UiOptions.enabled` to\nfalse, the download UI will be hidden. Setting `UiOptions.enabled` to true\nwhile at least one other extension has disabled it will return an error\nthrough `runtime.lastError`. Requires the `\"downloads.ui\"` permission in\naddition to the `\"downloads\"` permission.\n\n#### Parameters\n\n  * options\n\nUiOptions\n\nEncapsulate a change to the download UI.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### show()\n\n    \n    \n    chrome.downloads.show(  \n      downloadId: number,  \n    )\n\nShow the downloaded file in its folder in a file manager.\n\n#### Parameters\n\n  * downloadId\n\nnumber\n\nThe identifier for the downloaded file.\n\n### showDefaultFolder()\n\n    \n    \n    chrome.downloads.showDefaultFolder()\n\nShow the default Downloads folder in a file manager.\n\n## Events\n\n### onChanged\n\n    \n    \n    chrome.downloads.onChanged.addListener(  \n      callback: function,  \n    )\n\nWhen any of a `DownloadItem`'s properties except `bytesReceived` and\n`estimatedEndTime` changes, this event fires with the `downloadId` and an\nobject containing the properties that changed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (downloadDelta: DownloadDelta) => void\n\n    * downloadDelta\n\nDownloadDelta\n\n### onCreated\n\n    \n    \n    chrome.downloads.onCreated.addListener(  \n      callback: function,  \n    )\n\nThis event fires with the `DownloadItem` object when a download begins.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (downloadItem: DownloadItem) => void\n\n    * downloadItem\n\nDownloadItem\n\n### onDeterminingFilename\n\n    \n    \n    chrome.downloads.onDeterminingFilename.addListener(  \n      callback: function,  \n    )\n\nDuring the filename determination process, extensions will be given the\nopportunity to override the target `DownloadItem.filename`. Each extension may\nnot register more than one listener for this event. Each listener must call\n`suggest` exactly once, either synchronously or asynchronously. If the\nlistener calls `suggest` asynchronously, then it must return `true`. If the\nlistener neither calls `suggest` synchronously nor returns `true`, then\n`suggest` will be called automatically. The `DownloadItem` will not complete\nuntil all listeners have called `suggest`. Listeners may call `suggest`\nwithout any arguments in order to allow the download to use\n`downloadItem.filename` for its filename, or pass a `suggestion` object to\n`suggest` in order to override the target filename. If more than one extension\noverrides the filename, then the last extension installed whose listener\npasses a `suggestion` object to `suggest` wins. In order to avoid confusion\nregarding which extension will win, users should not install extensions that\nmay conflict. If the download is initiated by `download` and the target\nfilename is known before the MIME type and tentative filename have been\ndetermined, pass `filename` to `download` instead.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (downloadItem: DownloadItem, suggest: function) => void\n\n    * downloadItem\n\nDownloadItem\n\n    * suggest\n\nfunction\n\nThe `suggest` parameter looks like:\n\n          \n          (suggestion?: FilenameSuggestion) => void\n\n      * suggestion\n\nFilenameSuggestion optional\n\n### onErased\n\n    \n    \n    chrome.downloads.onErased.addListener(  \n      callback: function,  \n    )\n\nFires with the `downloadId` when a download is erased from history.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (downloadId: number) => void\n\n    * downloadId\n\nnumber\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/enterprise/deviceAttributes": "#  chrome.enterprise.deviceAttributes\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\nThis API is only for extensions installed by a policy.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.enterprise.deviceAttributes` API to read device attributes.\nNote: This API is only available to extensions force-installed by enterprise\npolicy.\n\n## Permissions\n\n`enterprise.deviceAttributes`  \n\n## Availability\n\nChrome 46+  ChromeOS only  Requires policy\n\n## Methods\n\n### getDeviceAnnotatedLocation()\n\nPromise Chrome 66+\n\n    \n    \n    chrome.enterprise.deviceAttributes.getDeviceAnnotatedLocation(  \n      callback?: function,  \n    )\n\nFetches the administrator-annotated Location. If the current user is not\naffiliated or no Annotated Location has been set by the administrator, returns\nan empty string.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (annotatedLocation: string) => void\n\n    * annotatedLocation\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDeviceAssetId()\n\nPromise Chrome 66+\n\n    \n    \n    chrome.enterprise.deviceAttributes.getDeviceAssetId(  \n      callback?: function,  \n    )\n\nFetches the administrator-annotated Asset Id. If the current user is not\naffiliated or no Asset Id has been set by the administrator, returns an empty\nstring.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (assetId: string) => void\n\n    * assetId\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDeviceHostname()\n\nPromise Chrome 82+\n\n    \n    \n    chrome.enterprise.deviceAttributes.getDeviceHostname(  \n      callback?: function,  \n    )\n\nFetches the device's hostname as set by DeviceHostnameTemplate policy. If the\ncurrent user is not affiliated or no hostname has been set by the enterprise\npolicy, returns an empty string.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (hostname: string) => void\n\n    * hostname\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDeviceSerialNumber()\n\nPromise Chrome 66+\n\n    \n    \n    chrome.enterprise.deviceAttributes.getDeviceSerialNumber(  \n      callback?: function,  \n    )\n\nFetches the device's serial number. Please note the purpose of this API is to\nadministrate the device (e.g. generating Certificate Sign Requests for device-\nwide certificates). This API may not be used for tracking devices without the\nconsent of the device's administrator. If the current user is not affiliated,\nreturns an empty string.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (serialNumber: string) => void\n\n    * serialNumber\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDirectoryDeviceId()\n\nPromise\n\n    \n    \n    chrome.enterprise.deviceAttributes.getDirectoryDeviceId(  \n      callback?: function,  \n    )\n\nFetches the value of the device identifier of the directory API, that is\ngenerated by the server and identifies the cloud record of the device for\nquerying in the cloud directory API. If the current user is not affiliated,\nreturns an empty string.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (deviceId: string) => void\n\n    * deviceId\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/enterprise/hardwarePlatform": "#  chrome.enterprise.hardwarePlatform\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\nThis API is only for extensions installed by a policy. The\n`EnterpriseHardwarePlatformAPIEnabled` key must also be set.\n\n## Description\n\nUse the `chrome.enterprise.hardwarePlatform` API to get the manufacturer and\nmodel of the hardware platform where the browser runs. Note: This API is only\navailable to extensions installed by enterprise policy.\n\n## Permissions\n\n`enterprise.hardwarePlatform`  \n\n## Availability\n\nChrome 71+  Requires policy\n\n## Types\n\n### HardwarePlatformInfo\n\n#### Properties\n\n  * manufacturer\n\nstring\n\n  * model\n\nstring\n\n## Methods\n\n### getHardwarePlatformInfo()\n\nPromise\n\n    \n    \n    chrome.enterprise.hardwarePlatform.getHardwarePlatformInfo(  \n      callback?: function,  \n    )\n\nObtains the manufacturer and model for the hardware platform and, if the\nextension is authorized, returns it via `callback`.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (info: HardwarePlatformInfo) => void\n\n    * info\n\nHardwarePlatformInfo\n\n#### Returns\n\n  * Promise<HardwarePlatformInfo>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/enterprise/networkingAttributes": "#  chrome.enterprise.networkingAttributes\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\nThis API is only for extensions installed by a policy.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.enterprise.networkingAttributes` API to read information about\nyour current network. Note: This API is only available to extensions force-\ninstalled by enterprise policy.\n\n## Permissions\n\n`enterprise.networkingAttributes`  \n\n## Availability\n\nChrome 85+  ChromeOS only  Requires policy\n\n## Types\n\n### NetworkDetails\n\n#### Properties\n\n  * ipv4\n\nstring optional\n\nThe device's local IPv4 address (undefined if not configured).\n\n  * ipv6\n\nstring optional\n\nThe device's local IPv6 address (undefined if not configured).\n\n  * macAddress\n\nstring\n\nThe device's MAC address.\n\n## Methods\n\n### getNetworkDetails()\n\nPromise\n\n    \n    \n    chrome.enterprise.networkingAttributes.getNetworkDetails(  \n      callback?: function,  \n    )\n\nRetrieves the network details of the device's default network. If the user is\nnot affiliated or the device is not connected to a network,\n`runtime.lastError` will be set with a failure reason.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (networkAddresses: NetworkDetails) => void\n\n    * networkAddresses\n\nNetworkDetails\n\n#### Returns\n\n  * Promise<NetworkDetails>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/enterprise/platformKeys": "#  chrome.enterprise.platformKeys\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\nThis API is only for extensions installed by a policy.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.enterprise.platformKeys` API to generate keys and install\ncertificates for these keys. The certificates will be managed by the platform\nand can be used for TLS authentication, network access or by other extension\nthrough chrome.platformKeys.\n\n## Permissions\n\n`enterprise.platformKeys`  \n\n## Availability\n\nChromeOS only  Requires policy\n\n## Concepts and usage\n\nTypical usage of this API to enroll a client certificate follows these steps:\n\n  * Get all available tokens using `enterprise.platformKeys.getTokens()`.\n\n  * Find the Token with `id` equal to `\"user\"`. Use this Token subsequently.\n\n  * Generate a key pair using the `generateKey()` Token method (defined in SubtleCrypto). This will return handle to the key.\n\n  * Export the public key using the `exportKey()` Token method (defined in SubtleCrypto).\n\n  * Create the signature of the certification request's data using the `sign()` Token method (defined in SubtleCrypto).\n\n  * Complete the certification request and send it to the certification authority.\n\n  * If a certificate is received, import it using [`enterprise.platformKeys.importCertificate()``[3]\n\nHere's an example that shows the major API interaction except the building and\nsending of the certification request:\n\n    \n    \n    function getUserToken(callback) {\n      chrome.enterprise.platformKeys.getTokens(function(tokens) {\n        for (var i = 0; i < tokens.length; i++) {\n          if (tokens[i].id == \"user\") {\n            callback(tokens[i]);\n            return;\n          }\n        }\n        callback(undefined);\n      });\n    }\n    \n    function generateAndSign(userToken) {\n      var data = new Uint8Array([0, 5, 1, 2, 3, 4, 5, 6]);\n      var algorithm = {\n        name: \"RSASSA-PKCS1-v1_5\",\n        // RsaHashedKeyGenParams\n        modulusLength: 2048,\n        publicExponent:\n            new Uint8Array([0x01, 0x00, 0x01]),  // Equivalent to 65537\n        hash: {\n          name: \"SHA-256\",\n        }\n      };\n      var cachedKeyPair;\n      userToken.subtleCrypto.generateKey(algorithm, false, [\"sign\"])\n        .then(function(keyPair) {\n                cachedKeyPair = keyPair;\n                return userToken.subtleCrypto.exportKey(\"spki\", keyPair.publicKey);\n              },\n              console.log.bind(console))\n        .then(function(publicKeySpki) {\n                // Build the Certification Request using the public key.\n                return userToken.subtleCrypto.sign(\n                    {name : \"RSASSA-PKCS1-v1_5\"}, cachedKeyPair.privateKey, data);\n              },\n              console.log.bind(console))\n        .then(function(signature) {\n                  // Complete the Certification Request with |signature|.\n                  // Send out the request to the CA, calling back\n                  // onClientCertificateReceived.\n              },\n              console.log.bind(console));\n    }\n    \n    function onClientCertificateReceived(userToken, certificate) {\n      chrome.enterprise.platformKeys.importCertificate(userToken.id, certificate);\n    }\n    \n    getUserToken(generateAndSign);\n    \n\n## Types\n\n### Algorithm\n\nChrome 110+\n\nType of key to generate.\n\n#### Enum\n\n\"RSA\"  \n\n\"ECDSA\"  \n\n### ChallengeKeyOptions\n\nChrome 110+\n\n#### Properties\n\n  * challenge\n\nArrayBuffer\n\nA challenge as emitted by the Verified Access Web API.\n\n  * registerKey\n\nRegisterKeyOptions optional\n\nIf present, registers the challenged key with the specified `scope`'s token.\nThe key can then be associated with a certificate and used like any other\nsigning key. Subsequent calls to this function will then generate a new\nEnterprise Key in the specified `scope`.\n\n  * scope\n\nScope\n\nWhich Enterprise Key to challenge.\n\n### RegisterKeyOptions\n\nChrome 110+\n\n#### Properties\n\n  * algorithm\n\nAlgorithm\n\nWhich algorithm the registered key should use.\n\n### Scope\n\nChrome 110+\n\nWhether to use the Enterprise User Key or the Enterprise Machine Key.\n\n#### Enum\n\n\"USER\"  \n\n\"MACHINE\"  \n\n### Token\n\n#### Properties\n\n  * id\n\nstring\n\nUniquely identifies this `Token`.\n\nStatic IDs are `\"user\"` and `\"system\"`, referring to the platform's user-\nspecific and the system-wide hardware token, respectively. Any other tokens\n(with other identifiers) might be returned by\n`enterprise.platformKeys.getTokens`.\n\n  * softwareBackedSubtleCrypto\n\nSubtleCrypto\n\nChrome 97+\n\nImplements the WebCrypto's SubtleCrypto interface. The cryptographic\noperations, including key generation, are software-backed. Protection of the\nkeys, and thus implementation of the non-extractable property, is done in\nsoftware, so the keys are less protected than hardware-backed keys.\n\nOnly non-extractable keys can be generated. The supported key types are\nRSASSA-PKCS1-V1_5 and RSA-OAEP (on Chrome versions 135+) with `modulusLength`\nup to 2048. Each RSASSA-PKCS1-V1_5 key can be used for signing data at most\nonce, unless the extension is allowlisted through the KeyPermissions policy,\nin which case the key can be used indefinitely. RSA-OAEP keys are supported\nsince Chrome version 135 and can be used by extensions allowlisted through\nthat same policy to unwrap other keys.\n\nKeys generated on a specific `Token` cannot be used with any other Tokens, nor\ncan they be used with `window.crypto.subtle`. Equally, `Key` objects created\nwith `window.crypto.subtle` cannot be used with this interface.\n\n  * subtleCrypto\n\nSubtleCrypto\n\nImplements the WebCrypto's SubtleCrypto interface. The cryptographic\noperations, including key generation, are hardware-backed.\n\nOnly non-extractable keys can be generated. The supported key types are\nRSASSA-PKCS1-V1_5 and RSA-OAEP (on Chrome versions 135+) with `modulusLength`\nup to 2048 and ECDSA with `namedCurve` P-256. Each RSASSA-PKCS1-V1_5 and ECDSA\nkey can be used for signing data at most once, unless the extension is\nallowlisted through the KeyPermissions policy, in which case the key can be\nused indefinitely. RSA-OAEP keys are supported since Chrome version 135 and\ncan be used by extensions allowlisted through that same policy to unwrap other\nkeys.\n\nKeys generated on a specific `Token` cannot be used with any other Tokens, nor\ncan they be used with `window.crypto.subtle`. Equally, `Key` objects created\nwith `window.crypto.subtle` cannot be used with this interface.\n\n## Methods\n\n### challengeKey()\n\nPromise Chrome 110+\n\n    \n    \n    chrome.enterprise.platformKeys.challengeKey(  \n      options: ChallengeKeyOptions,  \n      callback?: function,  \n    )\n\nSimilar to `challengeMachineKey` and `challengeUserKey`, but allows specifying\nthe algorithm of a registered key. Challenges a hardware-backed Enterprise\nMachine Key and emits the response as part of a remote attestation protocol.\nOnly useful on ChromeOS and in conjunction with the Verified Access Web API\nwhich both issues challenges and verifies responses.\n\nA successful verification by the Verified Access Web API is a strong signal\nthat the current device is a legitimate ChromeOS device, the current device is\nmanaged by the domain specified during verification, the current signed-in\nuser is managed by the domain specified during verification, and the current\ndevice state complies with enterprise device policy. For example, a policy may\nspecify that the device must not be in developer mode. Any device identity\nemitted by the verification is tightly bound to the hardware of the current\ndevice. If `\"user\"` Scope is specified, the identity is also tightly bound to\nthe current signed-in user.\n\nThis function is highly restricted and will fail if the current device is not\nmanaged, the current user is not managed, or if this operation has not\nexplicitly been enabled for the caller by enterprise device policy. The\nchallenged key does not reside in the `\"system\"` or `\"user\"` token and is not\naccessible by any other API.\n\n#### Parameters\n\n  * options\n\nChallengeKeyOptions\n\nObject containing the fields defined in `ChallengeKeyOptions`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: ArrayBuffer) => void\n\n    * response\n\nArrayBuffer\n\nThe challenge response.\n\n#### Returns\n\n  * Promise<ArrayBuffer>\n\nChrome 131+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### challengeMachineKey()\n\nPromise Chrome 50+  Deprecated since Chrome 110\n\n    \n    \n    chrome.enterprise.platformKeys.challengeMachineKey(  \n      challenge: ArrayBuffer,  \n      registerKey?: boolean,  \n      callback?: function,  \n    )\n\nUse `challengeKey` instead.\n\nChallenges a hardware-backed Enterprise Machine Key and emits the response as\npart of a remote attestation protocol. Only useful on ChromeOS and in\nconjunction with the Verified Access Web API which both issues challenges and\nverifies responses. A successful verification by the Verified Access Web API\nis a strong signal of all of the following: * The current device is a\nlegitimate ChromeOS device. * The current device is managed by the domain\nspecified during verification. * The current signed-in user is managed by the\ndomain specified during verification. * The current device state complies with\nenterprise device policy. For example, a policy may specify that the device\nmust not be in developer mode. * Any device identity emitted by the\nverification is tightly bound to the hardware of the current device. This\nfunction is highly restricted and will fail if the current device is not\nmanaged, the current user is not managed, or if this operation has not\nexplicitly been enabled for the caller by enterprise device policy. The\nEnterprise Machine Key does not reside in the `\"system\"` token and is not\naccessible by any other API.\n\n#### Parameters\n\n  * challenge\n\nArrayBuffer\n\nA challenge as emitted by the Verified Access Web API.\n\n  * registerKey\n\nboolean optional\n\nChrome 59+\n\nIf set, the current Enterprise Machine Key is registered with the `\"system\"`\ntoken and relinquishes the Enterprise Machine Key role. The key can then be\nassociated with a certificate and used like any other signing key. This key is\n2048-bit RSA. Subsequent calls to this function will then generate a new\nEnterprise Machine Key.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: ArrayBuffer) => void\n\n    * response\n\nArrayBuffer\n\nThe challenge response.\n\n#### Returns\n\n  * Promise<ArrayBuffer>\n\nChrome 131+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### challengeUserKey()\n\nPromise Chrome 50+  Deprecated since Chrome 110\n\n    \n    \n    chrome.enterprise.platformKeys.challengeUserKey(  \n      challenge: ArrayBuffer,  \n      registerKey: boolean,  \n      callback?: function,  \n    )\n\nUse `challengeKey` instead.\n\nChallenges a hardware-backed Enterprise User Key and emits the response as\npart of a remote attestation protocol. Only useful on ChromeOS and in\nconjunction with the Verified Access Web API which both issues challenges and\nverifies responses. A successful verification by the Verified Access Web API\nis a strong signal of all of the following: * The current device is a\nlegitimate ChromeOS device. * The current device is managed by the domain\nspecified during verification. * The current signed-in user is managed by the\ndomain specified during verification. * The current device state complies with\nenterprise user policy. For example, a policy may specify that the device must\nnot be in developer mode. * The public key emitted by the verification is\ntightly bound to the hardware of the current device and to the current signed-\nin user. This function is highly restricted and will fail if the current\ndevice is not managed, the current user is not managed, or if this operation\nhas not explicitly been enabled for the caller by enterprise user policy. The\nEnterprise User Key does not reside in the `\"user\"` token and is not\naccessible by any other API.\n\n#### Parameters\n\n  * challenge\n\nArrayBuffer\n\nA challenge as emitted by the Verified Access Web API.\n\n  * registerKey\n\nboolean\n\nIf set, the current Enterprise User Key is registered with the `\"user\"` token\nand relinquishes the Enterprise User Key role. The key can then be associated\nwith a certificate and used like any other signing key. This key is 2048-bit\nRSA. Subsequent calls to this function will then generate a new Enterprise\nUser Key.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: ArrayBuffer) => void\n\n    * response\n\nArrayBuffer\n\nThe challenge response.\n\n#### Returns\n\n  * Promise<ArrayBuffer>\n\nChrome 131+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getCertificates()\n\nPromise\n\n    \n    \n    chrome.enterprise.platformKeys.getCertificates(  \n      tokenId: string,  \n      callback?: function,  \n    )\n\nReturns the list of all client certificates available from the given token.\nCan be used to check for the existence and expiration of client certificates\nthat are usable for a certain authentication.\n\n#### Parameters\n\n  * tokenId\n\nstring\n\nThe id of a Token returned by `getTokens`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (certificates: ArrayBuffer[]) => void\n\n    * certificates\n\nArrayBuffer[]\n\nThe list of certificates, each in DER encoding of a X.509 certificate.\n\n#### Returns\n\n  * Promise<ArrayBuffer[]>\n\nChrome 131+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getTokens()\n\nPromise\n\n    \n    \n    chrome.enterprise.platformKeys.getTokens(  \n      callback?: function,  \n    )\n\nReturns the available Tokens. In a regular user's session the list will always\ncontain the user's token with `id` `\"user\"`. If a system-wide TPM token is\navailable, the returned list will also contain the system-wide token with `id`\n`\"system\"`. The system-wide token will be the same for all sessions on this\ndevice (device in the sense of e.g. a Chromebook).\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tokens: Token[]) => void\n\n    * tokens\n\nToken[]\n\nThe list of available tokens.\n\n#### Returns\n\n  * Promise<Token[]>\n\nChrome 131+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### importCertificate()\n\nPromise\n\n    \n    \n    chrome.enterprise.platformKeys.importCertificate(  \n      tokenId: string,  \n      certificate: ArrayBuffer,  \n      callback?: function,  \n    )\n\nImports `certificate` to the given token if the certified key is already\nstored in this token. After a successful certification request, this function\nshould be used to store the obtained certificate and to make it available to\nthe operating system and browser for authentication.\n\n#### Parameters\n\n  * tokenId\n\nstring\n\nThe id of a Token returned by `getTokens`.\n\n  * certificate\n\nArrayBuffer\n\nThe DER encoding of a X.509 certificate.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 131+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeCertificate()\n\nPromise\n\n    \n    \n    chrome.enterprise.platformKeys.removeCertificate(  \n      tokenId: string,  \n      certificate: ArrayBuffer,  \n      callback?: function,  \n    )\n\nRemoves `certificate` from the given token if present. Should be used to\nremove obsolete certificates so that they are not considered during\nauthentication and do not clutter the certificate choice. Should be used to\nfree storage in the certificate store.\n\n#### Parameters\n\n  * tokenId\n\nstring\n\nThe id of a Token returned by `getTokens`.\n\n  * certificate\n\nArrayBuffer\n\nThe DER encoding of a X.509 certificate.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 131+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/events": "#  chrome.events\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.events` namespace contains common types used by APIs dispatching\nevents to notify you when something interesting happens.\n\n## Concepts and usage\n\nAn `Event` is an object that lets you be notified when something interesting\nhappens. Here's an example of using the `chrome.alarms.onAlarm` event to be\nnotified whenever an alarm has elapsed:\n\n    \n    \n    chrome.alarms.onAlarm.addListener((alarm) => {\n      appendToLog(`alarms.onAlarm -- name: ${alarm.name}, scheduledTime: ${alarm.scheduledTime}`);\n    });\n    \n\nAs the example shows, you register for notification using `addListener()`. The\nargument to `addListener()` is always a function that you define to handle the\nevent, but the parameters to the function depend on which event you're\nhandling. Checking the documentation for `alarms.onAlarm`, you can see that\nthe function has a single parameter: an `alarms.Alarm` object that has details\nabout the elapsed alarm.\n\nExample APIs using Events: alarms, i18n, identity, runtime. Most chrome APIs\ndo.\n\n### Declarative Event Handlers\n\nThe declarative event handlers provide a means to define rules consisting of\ndeclarative conditions and actions. Conditions are evaluated in the browser\nrather than the JavaScript engine which reduces roundtrip latencies and allows\nfor very high efficiency.\n\nDeclarative event handlers are used for example in the Declarative Content\nAPI. This page describes the underlying concepts of all declarative event\nhandlers.\n\n#### Rules\n\nThe simplest possible rule consists of one or more conditions and one or more\nactions:\n\n    \n    \n    const rule = {\n      conditions: [ /* my conditions */ ],\n      actions: [ /* my actions */ ]\n    };\n    \n\nIf any of the conditions is fulfilled, all actions are executed.\n\nIn addition to conditions and actions you may give each rule an identifier,\nwhich simplifies unregistering previously registered rules, and a priority to\ndefine precedences among rules. Priorities are only considered if rules\nconflict each other or need to be executed in a specific order. Actions are\nexecuted in descending order of the priority of their rules.\n\n    \n    \n    const rule = {\n      id: \"my rule\",  // optional, will be generated if not set.\n      priority: 100,  // optional, defaults to 100.\n      conditions: [ /* my conditions */ ],\n      actions: [ /* my actions */ ]\n    };\n    \n\n#### Event objects\n\nEvent objects may support rules. These event objects don't call a callback\nfunction when events happen but test whether any registered rule has at least\none fulfilled condition and execute the actions associated with this rule.\nEvent objects supporting the declarative API have three relevant methods:\n`events.Event.addRules()`, `events.Event.removeRules()`, and\n`events.Event.getRules()`.\n\n#### Add rules\n\nTo add rules call the `addRules()` function of the event object. It takes an\narray of rule instances as its first parameter and a callback function that is\ncalled on completion.\n\n    \n    \n    const rule_list = [rule1, rule2, ...];\n    addRules(rule_list, (details) => {...});\n    \n\nIf the rules were inserted successfully, the `details` parameter contains an\narray of inserted rules appearing in the same order as in the passed\n`rule_list` where the optional parameters `id` and `priority` were filled with\nthe generated values. If any rule is invalid, for example, because it\ncontained an invalid condition or action, none of the rules are added and the\nruntime.lastError variable is set when the callback function is called. Each\nrule in `rule_list` must contain a unique identifier that is not already used\nby another rule or an empty identifier.\n\n**Note:** Rules are persistent across browsing sessions. Therefore, you should\ninstall rules during extension installation time using the\n`runtime.onInstalled` event. Note that this event is also triggered when an\nextension is updated. Therefore, you should first clear previously installed\nrules and then register new rules.\n\n#### Remove rules\n\nTo remove rules call the `removeRules()` function. It accepts an optional\narray of rule identifiers as its first parameter and a callback function as\nits second parameter.\n\n    \n    \n    const rule_ids = [\"id1\", \"id2\", ...];\n    removeRules(rule_ids, () => {...});\n    \n\nIf `rule_ids` is an array of identifiers, all rules having identifiers listed\nin the array are removed. If `rule_ids` lists an identifier, that is unknown,\nthis identifier is silently ignored. If `rule_ids` is `undefined`, all\nregistered rules of this extension are removed. The `callback()` function is\ncalled when the rules were removed.\n\n#### Retrieve rules\n\nTo retrieve a list of registered rules, call the `getRules()` function. It\naccepts an optional array of rule identifiers with the same semantics as\n`removeRules()` and a callback function.\n\n    \n    \n    const rule_ids = [\"id1\", \"id2\", ...];\n    getRules(rule_ids, (details) => {...});\n    \n\nThe `details` parameter passed to the `callback()` function refers to an array\nof rules including filled optional parameters.\n\n#### Performance\n\nTo achieve maximum performance, you should keep the following guidelines in\nmind.\n\n**Register and unregister rules in bulk.** After each registration or\nunregistration, Chrome needs to update internal data structures. This update\nis an expensive operation.\n\nInstead of\n\n    \n    \n    const rule1 = {...};\n    const rule2 = {...};\n    chrome.declarativeWebRequest.onRequest.addRules([rule1]);\n    chrome.declarativeWebRequest.onRequest.addRules([rule2]);\n\nPrefer\n\n    \n    \n    const rule1 = {...};\n    const rule2 = {...};\n    chrome.declarativeWebRequest.onRequest.addRules([rule1, rule2]);\n\n**Prefer substring matching over regular expressions in anevents.UrlFilter.**\nSubstring based matching is extremely fast.\n\nInstead of\n\n    \n    \n    const match = new chrome.declarativeWebRequest.RequestMatcher({\n      url: {urlMatches: \"example.com/[^?]*foo\" }\n    });\n\nPrefer\n\n    \n    \n    const match = new chrome.declarativeWebRequest.RequestMatcher({\n      url: {hostSuffix: \"example.com\", pathContains: \"foo\"}\n    });\n\nIf there are many rules that share the same actions, merge the rules into one.\nRules trigger their actions as soon as a single condition is fulfilled. This\nspeeds up the matching and reduces memory consumption for duplicate action\nsets.\n\nInstead of\n\n    \n    \n    const condition1 = new chrome.declarativeWebRequest.RequestMatcher({\n      url: { hostSuffix: 'example.com' }\n    });\n    const condition2 = new chrome.declarativeWebRequest.RequestMatcher({\n      url: { hostSuffix: 'foobar.com' }\n    });\n    const rule1 = { conditions: [condition1],\n                    actions: [new chrome.declarativeWebRequest.CancelRequest()]\n                  };\n    const rule2 = { conditions: [condition2],\n                    actions: [new chrome.declarativeWebRequest.CancelRequest()]\n                  };\n    chrome.declarativeWebRequest.onRequest.addRules([rule1, rule2]);\n\nPrefer\n\n    \n    \n    const condition1 = new chrome.declarativeWebRequest.RequestMatcher({\n      url: { hostSuffix: 'example.com' }\n    });\n    const condition2 = new chrome.declarativeWebRequest.RequestMatcher({\n      url: { hostSuffix: 'foobar.com' }\n    });\n    const rule = { conditions: [condition1, condition2],\n                  actions: [new chrome.declarativeWebRequest.CancelRequest()]\n                 };\n    chrome.declarativeWebRequest.onRequest.addRules([rule]);\n\n### Filtered events\n\nFiltered events are a mechanism that allows listeners to specify a subset of\nevents that they are interested in. A listener that uses a filter won't be\ninvoked for events that don't pass the filter, which makes the listening code\nmore declarative and efficient. A service worker need not be woken up to\nhandle events it doesn't care about.\n\nFiltered events are intended to allow a transition from manual filtering code.\n\nInstead of\n\n    \n    \n    chrome.webNavigation.onCommitted.addListener((event) => {\n      if (hasHostSuffix(event.url, 'google.com') ||\n          hasHostSuffix(event.url, 'google.com.au')) {\n        // ...\n      }\n    });\n\nPrefer\n\n    \n    \n    chrome.webNavigation.onCommitted.addListener((event) => {\n      // ...\n    }, {url: [{hostSuffix: 'google.com'},\n              {hostSuffix: 'google.com.au'}]});\n\nEvents support specific filters that are meaningful to that event. The list of\nfilters that an event supports will be listed in the documentation for that\nevent in the \"filters\" section.\n\nWhen matching URLs (as in the example above), event filters support the same\nURL matching capabilities as expressible with a `events.UrlFilter`, except for\nscheme and port matching.\n\n## Types\n\n### Event\n\nAn object which allows the addition and removal of listeners for a Chrome\nevent.\n\n#### Properties\n\n  * addListener\n\nvoid\n\nRegisters an event listener _callback_ to an event.\n\nThe `addListener` function looks like:\n\n        \n        (callback: H) => {...}\n\n    * callback\n\nH\n\nCalled when an event occurs. The parameters of this function depend on the\ntype of event.\n\n  * addRules\n\nvoid\n\nRegisters rules to handle events.\n\nThe `addRules` function looks like:\n\n        \n        (rules: Rule<anyany>[], callback?: function) => {...}\n\n    * rules\n\nRule<anyany>[]\n\nRules to be registered. These do not replace previously registered rules.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (rules: Rule<anyany>[]) => void\n\n      * rules\n\nRule<anyany>[]\n\nRules that were registered, the optional parameters are filled with values.\n\n  * getRules\n\nvoid\n\nReturns currently registered rules.\n\nThe `getRules` function looks like:\n\n        \n        (ruleIdentifiers?: string[], callback: function) => {...}\n\n    * ruleIdentifiers\n\nstring[] optional\n\nIf an array is passed, only rules with identifiers contained in this array are\nreturned.\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (rules: Rule<anyany>[]) => void\n\n      * rules\n\nRule<anyany>[]\n\nRules that were registered, the optional parameters are filled with values.\n\n  * hasListener\n\nvoid\n\nThe `hasListener` function looks like:\n\n        \n        (callback: H) => {...}\n\n    * callback\n\nH\n\nListener whose registration status shall be tested.\n\n    * returns\n\nboolean\n\nTrue if _callback_ is registered to the event.\n\n  * hasListeners\n\nvoid\n\nThe `hasListeners` function looks like:\n\n        \n        () => {...}\n\n    * returns\n\nboolean\n\nTrue if any event listeners are registered to the event.\n\n  * removeListener\n\nvoid\n\nDeregisters an event listener _callback_ from an event.\n\nThe `removeListener` function looks like:\n\n        \n        (callback: H) => {...}\n\n    * callback\n\nH\n\nListener that shall be unregistered.\n\n  * removeRules\n\nvoid\n\nUnregisters currently registered rules.\n\nThe `removeRules` function looks like:\n\n        \n        (ruleIdentifiers?: string[], callback?: function) => {...}\n\n    * ruleIdentifiers\n\nstring[] optional\n\nIf an array is passed, only rules with identifiers contained in this array are\nunregistered.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n### Rule\n\nDescription of a declarative rule for handling events.\n\n#### Properties\n\n  * actions\n\nany[]\n\nList of actions that are triggered if one of the conditions is fulfilled.\n\n  * conditions\n\nany[]\n\nList of conditions that can trigger the actions.\n\n  * id\n\nstring optional\n\nOptional identifier that allows referencing this rule.\n\n  * priority\n\nnumber optional\n\nOptional priority of this rule. Defaults to 100.\n\n  * tags\n\nstring[] optional\n\nTags can be used to annotate rules and perform operations on sets of rules.\n\n### UrlFilter\n\nFilters URLs for various criteria. See event filtering. All criteria are case\nsensitive.\n\n#### Properties\n\n  * cidrBlocks\n\nstring[] optional\n\nChrome 123+\n\nMatches if the host part of the URL is an IP address and is contained in any\nof the CIDR blocks specified in the array.\n\n  * hostContains\n\nstring optional\n\nMatches if the host name of the URL contains a specified string. To test\nwhether a host name component has a prefix 'foo', use hostContains: '.foo'.\nThis matches 'www.foobar.com' and 'foo.com', because an implicit dot is added\nat the beginning of the host name. Similarly, hostContains can be used to\nmatch against component suffix ('foo.') and to exactly match against\ncomponents ('.foo.'). Suffix- and exact-matching for the last components need\nto be done separately using hostSuffix, because no implicit dot is added at\nthe end of the host name.\n\n  * hostEquals\n\nstring optional\n\nMatches if the host name of the URL is equal to a specified string.\n\n  * hostPrefix\n\nstring optional\n\nMatches if the host name of the URL starts with a specified string.\n\n  * hostSuffix\n\nstring optional\n\nMatches if the host name of the URL ends with a specified string.\n\n  * originAndPathMatches\n\nstring optional\n\nMatches if the URL without query segment and fragment identifier matches a\nspecified regular expression. Port numbers are stripped from the URL if they\nmatch the default port number. The regular expressions use the RE2 syntax.\n\n  * pathContains\n\nstring optional\n\nMatches if the path segment of the URL contains a specified string.\n\n  * pathEquals\n\nstring optional\n\nMatches if the path segment of the URL is equal to a specified string.\n\n  * pathPrefix\n\nstring optional\n\nMatches if the path segment of the URL starts with a specified string.\n\n  * pathSuffix\n\nstring optional\n\nMatches if the path segment of the URL ends with a specified string.\n\n  * ports\n\n(number | number[])[] optional\n\nMatches if the port of the URL is contained in any of the specified port\nlists. For example `[80, 443, [1000, 1200]]` matches all requests on port 80,\n443 and in the range 1000-1200.\n\n  * queryContains\n\nstring optional\n\nMatches if the query segment of the URL contains a specified string.\n\n  * queryEquals\n\nstring optional\n\nMatches if the query segment of the URL is equal to a specified string.\n\n  * queryPrefix\n\nstring optional\n\nMatches if the query segment of the URL starts with a specified string.\n\n  * querySuffix\n\nstring optional\n\nMatches if the query segment of the URL ends with a specified string.\n\n  * schemes\n\nstring[] optional\n\nMatches if the scheme of the URL is equal to any of the schemes specified in\nthe array.\n\n  * urlContains\n\nstring optional\n\nMatches if the URL (without fragment identifier) contains a specified string.\nPort numbers are stripped from the URL if they match the default port number.\n\n  * urlEquals\n\nstring optional\n\nMatches if the URL (without fragment identifier) is equal to a specified\nstring. Port numbers are stripped from the URL if they match the default port\nnumber.\n\n  * urlMatches\n\nstring optional\n\nMatches if the URL (without fragment identifier) matches a specified regular\nexpression. Port numbers are stripped from the URL if they match the default\nport number. The regular expressions use the RE2 syntax.\n\n  * urlPrefix\n\nstring optional\n\nMatches if the URL (without fragment identifier) starts with a specified\nstring. Port numbers are stripped from the URL if they match the default port\nnumber.\n\n  * urlSuffix\n\nstring optional\n\nMatches if the URL (without fragment identifier) ends with a specified string.\nPort numbers are stripped from the URL if they match the default port number.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/extension": "#  chrome.extension\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.extension` API has utilities that can be used by any extension\npage. It includes support for exchanging messages between an extension and its\ncontent scripts or between extensions, as described in detail in Message\nPassing.\n\n## Types\n\n### ViewType\n\nChrome 44+\n\nThe type of extension view.\n\n#### Enum\n\n\"tab\"  \n\n\"popup\"  \n\n## Properties\n\n### inIncognitoContext\n\nTrue for content scripts running inside incognito tabs, and for extension\npages running inside an incognito process. The latter only applies to\nextensions with 'split' incognito_behavior.\n\n#### Type\n\nboolean\n\n## Methods\n\n### getBackgroundPage()\n\nForeground only\n\n    \n    \n    chrome.extension.getBackgroundPage()\n\nReturns the JavaScript 'window' object for the background page running inside\nthe current extension. Returns null if the extension has no background page.\n\n#### Returns\n\n  * Window | undefined\n\n### getViews()\n\nForeground only\n\n    \n    \n    chrome.extension.getViews(  \n      fetchProperties?: object,  \n    )\n\nReturns an array of the JavaScript 'window' objects for each of the pages\nrunning inside the current extension.\n\n#### Parameters\n\n  * fetchProperties\n\nobject optional\n\n    * tabId\n\nnumber optional\n\nChrome 54+\n\nFind a view according to a tab id. If this field is omitted, returns all\nviews.\n\n    * type\n\nViewType optional\n\nThe type of view to get. If omitted, returns all views (including background\npages and tabs).\n\n    * windowId\n\nnumber optional\n\nThe window to restrict the search to. If omitted, returns all views.\n\n#### Returns\n\n  * Window[]\n\nArray of global objects\n\n### isAllowedFileSchemeAccess()\n\nPromise\n\n    \n    \n    chrome.extension.isAllowedFileSchemeAccess(  \n      callback?: function,  \n    )\n\nRetrieves the state of the extension's access to the 'file://' scheme. This\ncorresponds to the user-controlled per-extension 'Allow access to File URLs'\nsetting accessible via the chrome://extensions page.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (isAllowedAccess: boolean) => void\n\n    * isAllowedAccess\n\nboolean\n\nTrue if the extension can access the 'file://' scheme, false otherwise.\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### isAllowedIncognitoAccess()\n\nPromise\n\n    \n    \n    chrome.extension.isAllowedIncognitoAccess(  \n      callback?: function,  \n    )\n\nRetrieves the state of the extension's access to Incognito-mode. This\ncorresponds to the user-controlled per-extension 'Allowed in Incognito'\nsetting accessible via the chrome://extensions page.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (isAllowedAccess: boolean) => void\n\n    * isAllowedAccess\n\nboolean\n\nTrue if the extension has access to Incognito mode, false otherwise.\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setUpdateUrlData()\n\n    \n    \n    chrome.extension.setUpdateUrlData(  \n      data: string,  \n    )\n\nSets the value of the ap CGI parameter used in the extension's update URL.\nThis value is ignored for extensions that are hosted in the Chrome Extension\nGallery.\n\n#### Parameters\n\n  * data\n\nstring\n\n## Events\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/extensionTypes": "#  chrome.extensionTypes\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.extensionTypes` API contains type declarations for Chrome\nextensions.\n\n## Types\n\n### CSSOrigin\n\nChrome 66+\n\nThe origin of injected CSS.\n\n#### Enum\n\n\"author\"  \n\n\"user\"  \n\n### DeleteInjectionDetails\n\nChrome 87+\n\nDetails of the CSS to remove. Either the code or the file property must be\nset, but both may not be set at the same time.\n\n#### Properties\n\n  * allFrames\n\nboolean optional\n\nIf allFrames is `true`, implies that the CSS should be removed from all frames\nof current page. By default, it's `false` and is only removed from the top\nframe. If `true` and `frameId` is set, then the code is removed from the\nselected frame and all of its child frames.\n\n  * code\n\nstring optional\n\nCSS code to remove.\n\n  * cssOrigin\n\nCSSOrigin optional\n\nThe origin of the CSS to remove. Defaults to `\"author\"`.\n\n  * file\n\nstring optional\n\nCSS file to remove.\n\n  * frameId\n\nnumber optional\n\nThe frame from where the CSS should be removed. Defaults to 0 (the top-level\nframe).\n\n  * matchAboutBlank\n\nboolean optional\n\nIf matchAboutBlank is true, then the code is also removed from about:blank and\nabout:srcdoc frames if your extension has access to its parent document. By\ndefault it is `false`.\n\n### DocumentLifecycle\n\nChrome 106+\n\nThe document lifecycle of the frame.\n\n#### Enum\n\n\"prerender\"  \n\n\"active\"  \n\n\"cached\"  \n\n\"pending_deletion\"  \n\n### ExecutionWorld\n\nChrome 111+\n\nThe JavaScript world for a script to execute within. Can either be an isolated\nworld unique to this extension, the main world of the DOM which is shared with\nthe page's JavaScript, or a user scripts world that is only available for\nscripts registered with the User Scripts API.\n\n#### Enum\n\n\"ISOLATED\"  \n\n\"MAIN\"  \n\n\"USER_SCRIPT\"  \n\n### FrameType\n\nChrome 106+\n\nThe type of frame.\n\n#### Enum\n\n\"outermost_frame\"  \n\n\"fenced_frame\"  \n\n\"sub_frame\"  \n\n### ImageDetails\n\nDetails about the format and quality of an image.\n\n#### Properties\n\n  * format\n\nImageFormat optional\n\nThe format of the resulting image. Default is `\"jpeg\"`.\n\n  * quality\n\nnumber optional\n\nWhen format is `\"jpeg\"`, controls the quality of the resulting image. This\nvalue is ignored for PNG images. As quality is decreased, the resulting image\nwill have more visual artifacts, and the number of bytes needed to store it\nwill decrease.\n\n### ImageFormat\n\nChrome 44+\n\nThe format of an image.\n\n#### Enum\n\n\"jpeg\"  \n\n\"png\"  \n\n### InjectDetails\n\nDetails of the script or CSS to inject. Either the code or the file property\nmust be set, but both may not be set at the same time.\n\n#### Properties\n\n  * allFrames\n\nboolean optional\n\nIf allFrames is `true`, implies that the JavaScript or CSS should be injected\ninto all frames of current page. By default, it's `false` and is only injected\ninto the top frame. If `true` and `frameId` is set, then the code is inserted\nin the selected frame and all of its child frames.\n\n  * code\n\nstring optional\n\nJavaScript or CSS code to inject.\n\n**Warning:** Be careful using the `code` parameter. Incorrect use of it may\nopen your extension to cross site scripting attacks\n\n  * cssOrigin\n\nCSSOrigin optional\n\nChrome 66+\n\nThe origin of the CSS to inject. This may only be specified for CSS, not\nJavaScript. Defaults to `\"author\"`.\n\n  * file\n\nstring optional\n\nJavaScript or CSS file to inject.\n\n  * frameId\n\nnumber optional\n\nChrome 50+\n\nThe frame where the script or CSS should be injected. Defaults to 0 (the top-\nlevel frame).\n\n  * matchAboutBlank\n\nboolean optional\n\nIf matchAboutBlank is true, then the code is also injected in about:blank and\nabout:srcdoc frames if your extension has access to its parent document. Code\ncannot be inserted in top-level about:-frames. By default it is `false`.\n\n  * runAt\n\nRunAt optional\n\nThe soonest that the JavaScript or CSS will be injected into the tab. Defaults\nto \"document_idle\".\n\n### RunAt\n\nChrome 44+\n\nThe soonest that the JavaScript or CSS will be injected into the tab.\n\n#### Enum\n\n\"document_start\"  \nScript is injected after any files from css, but before any other DOM is\nconstructed or any other script is run.\n\n\"document_end\"  \nScript is injected immediately after the DOM is complete, but before\nsubresources like images and frames have loaded.\n\n\"document_idle\"  \nThe browser chooses a time to inject the script between \"document_end\" and\nimmediately after the `window.onload` event fires. The exact moment of\ninjection depends on how complex the document is and how long it is taking to\nload, and is optimized for page load speed. Content scripts running at\n\"document_idle\" don't need to listen for the `window.onload` event; they are\nguaranteed to run after the DOM completes. If a script definitely needs to run\nafter `window.onload`, the extension can check if `onload` has already fired\nby using the `document.readyState` property.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/fileBrowserHandler": "#  chrome.fileBrowserHandler\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.fileBrowserHandler` API to extend the Chrome OS file browser.\nFor example, you can use this API to enable users to upload files to your\nwebsite.\n\n## Concepts and usage\n\nThe ChromeOS file browser comes up when the user either presses Alt+Shift+M or\nconnects an external storage device, such as an SD card, USB key, external\ndrive, or digital camera. Besides showing the files on external devices, the\nfile browser can also display files that the user has previously saved to the\nsystem.\n\nWhen the user selects one or more files, the file browser adds buttons\nrepresenting the valid handlers for those files. For example, in the following\nscreenshot, selecting a file with a \".png\" suffix results in an \"Save to\nGallery\" button that the user can click.\n\n![A ChromeOS file\nbrowser.](/static/docs/extensions/reference/api/fileBrowserHandler/images/filebrowserhandler.png)\nA ChromeOS file browser.\n\n## Permissions\n\n`fileBrowserHandler`  \n\nYou must declare the `\"fileBrowserHandler\"` permission in the extension\nmanifest.\n\n## Availability\n\nChromeOS only  Foreground only\n\nYou must use the `\"file_browser_handlers\"` field to register the extension as\na handler of at least one file type. You should also provide a 16 by 16 icon\nto be displayed on the button. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"file_browser_handlers\": [\n        {\n          \"id\": \"upload\",\n          \"default_title\": \"Save to Gallery\", // What the button will display\n          \"file_filters\": [\n            \"filesystem:*.jpg\",  // To match all files, use \"filesystem:*.*\"\n            \"filesystem:*.jpeg\",\n            \"filesystem:*.png\"\n          ]\n        }\n      ],\n      \"permissions\" : [\n        \"fileBrowserHandler\"\n      ],\n      \"icons\": {\n        \"16\": \"icon16.png\",\n        \"48\": \"icon48.png\",\n        \"128\": \"icon128.png\"\n      },\n      ...\n    }\n    \n\n**Note:** You can specify locale-specific strings for the value of\n\"default_title\". See Internationalization (i18n) for details.\n\n### Implement a file browser handler\n\nTo use this API, you must implement a function that handles the `onExecute`\nevent of `chrome.fileBrowserHandler`. Your function will be called whenever\nthe user clicks the button that represents your file browser handler. In your\nfunction, use the File System API to get access to the file contents. Here is\nan example:\n\n    \n    \n    chrome.fileBrowserHandler.onExecute.addListener(async (id, details) => {\n      if (id !== 'upload') {\n        return;  // check if you have multiple file_browser_handlers\n      }\n    \n      for (const entry of detail.entries) {\n        // the FileSystemFileEntry doesn't have a Promise API, wrap in one\n        const file = await new Promise((resolve, reject) => {\n          entry.file(resolve, reject);\n        });\n        const buffer = await file.arrayBuffer();\n        // do something with buffer\n      }\n    });\n    \n\nYour event handler is passed two arguments:\n\n`id`\n\n    The `id` value from the manifest file. If your extension implements multiple handlers, you can check the ID value to see which handler has been triggered.\n`details`\n\n    An object describing the event. You can get the file or files that the user has selected from the `entries` field of this object, which is an array of `FileSystemFileEntry` objects.\n\n## Types\n\n### FileHandlerExecuteEventDetails\n\nEvent details payload for fileBrowserHandler.onExecute event.\n\n#### Properties\n\n  * entries\n\nany[]\n\nArray of Entry instances representing files that are targets of this action\n(selected in ChromeOS file browser).\n\n  * tab_id\n\nnumber optional\n\nThe ID of the tab that raised this event. Tab IDs are unique within a browser\nsession.\n\n## Events\n\n### onExecute\n\n    \n    \n    chrome.fileBrowserHandler.onExecute.addListener(  \n      callback: function,  \n    )\n\nFired when file system action is executed from ChromeOS file browser.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, details: FileHandlerExecuteEventDetails) => void\n\n    * id\n\nstring\n\n    * details\n\nFileHandlerExecuteEventDetails\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/fileSystemProvider": "#  chrome.fileSystemProvider\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.fileSystemProvider` API to create file systems, that can be\naccessible from the file manager on Chrome OS.\n\n## Permissions\n\n`fileSystemProvider`  \n\n## Availability\n\nChromeOS only\n\nYou must declare the \"fileSystemProvider\" permission and section in the\nextension manifest to use the File System Provider API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"fileSystemProvider\"\n      ],\n      ...\n      \"file_system_provider_capabilities\": {\n        \"configurable\": true,\n        \"watchable\": false,\n        \"multiple_mounts\": true,\n        \"source\": \"network\"\n      },\n      ...\n    }\n    \n\nThe file_system_provider section must be declared as follows:\n\n**`configurable` (boolean)** \\- optional\n\n    Whether configuring via onConfigureRequested is supported. By default: false.\n**`multiple_mounts` (boolean)** \\- optional\n\n    Whether multiple (more than one) mounted file systems are supported. By default: false.\n**`watchable` (boolean)** \\- optional\n\n    Whether setting watchers and notifying about changes is supported. By default: false.\n**`source` (enum of \"file\", \"device\", or \"network\")** \\- required\n\n    Source of data for mounted file systems.\n\nFiles app uses above information in order to render related UI elements\nappropriately. For example, if `configurable` is set to true, then a menu item\nfor configuring volumes will be rendered. Similarly, if `multiple_mounts` is\nset to `true`, then Files app will allow to add more than one mount points\nfrom the UI. If `watchable` is `false`, then a refresh button will be\nrendered. Note, that if possible you should add support for watchers, so\nchanges on the file system can be reflected immediately and automatically.\n\n## Overview\n\nFile System Provider API allows extensions to support virtual file systems,\nwhich are available in the file manager on ChromeOS. Use cases include\ndecompressing archives and accessing files in a cloud service other than\nDrive.\n\n## Mounting file systems\n\nProviding extensions can either provide file system contents from an external\nsource (such as a remote server or a USB device), or using a local file (such\nas an archive) as its input.\n\nIn order to write file systems which are file handlers (source is `\"file\"`)\nthe provider must be a packaged app, as the `onLaunched` event is not\navailable to extensions.\n\nIf the source is network or a device, then the file system should be mounted\nwhen onMountRequested event is called.\n\nSource of the file system data | Entry point  \n---|---  \n`\"file\"` | Available to packaged apps only.  \n`\"device\"` or `\"network\"` | onMountRequested  \n  \n## Configuring file systems\n\nProvided file systems once mounted can be configured via the\nonConfigureRequested event. It's especially useful for file systems which\nprovide contents via network in order to set proper credentials. Handling this\nevent is optional.\n\n## Life cycle\n\nProvided file systems once mounted are remembered by Chrome and remounted\nautomatically after reboot or restart. Hence, once a file system is mounted by\na providing extension, it will stay until either the extension is unloaded, or\nthe extension calls the unmount method.\n\n## Types\n\n### AbortRequestedOptions\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * operationRequestId\n\nnumber\n\nAn ID of the request to be aborted.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### Action\n\nChrome 45+\n\n#### Properties\n\n  * id\n\nstring\n\nThe identifier of the action. Any string or `CommonActionId` for common\nactions.\n\n  * title\n\nstring optional\n\nThe title of the action. It may be ignored for common actions.\n\n### AddWatcherRequestedOptions\n\n#### Properties\n\n  * entryPath\n\nstring\n\nThe path of the entry to be observed.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * recursive\n\nboolean\n\nWhether observing should include all child entries recursively. It can be true\nfor directories only.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### Change\n\n#### Properties\n\n  * changeType\n\nChangeType\n\nThe type of the change which happened to the entry.\n\n  * cloudFileInfo\n\nCloudFileInfo optional\n\nChrome 125+\n\nInformation relating to the file if backed by a cloud file system.\n\n  * entryPath\n\nstring\n\nThe path of the changed entry.\n\n### ChangeType\n\nType of a change detected on the observed directory.\n\n#### Enum\n\n\"CHANGED\"  \n\n\"DELETED\"  \n\n### CloseFileRequestedOptions\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * openRequestId\n\nnumber\n\nA request ID used to open the file.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### CloudFileInfo\n\nChrome 125+\n\n#### Properties\n\n  * versionTag\n\nstring optional\n\nA tag that represents the version of the file.\n\n### CloudIdentifier\n\nChrome 117+\n\n#### Properties\n\n  * id\n\nstring\n\nThe provider's identifier for the given file/directory.\n\n  * providerName\n\nstring\n\nIdentifier for the cloud storage provider (e.g. 'drive.google.com').\n\n### CommonActionId\n\nChrome 45+\n\nList of common actions. `\"SHARE\"` is for sharing files with others.\n`\"SAVE_FOR_OFFLINE\"` for pinning (saving for offline access).\n`\"OFFLINE_NOT_NECESSARY\"` for notifying that the file doesn't need to be\nstored for offline access anymore. Used by `onGetActionsRequested` and\n`onExecuteActionRequested`.\n\n#### Enum\n\n\"SAVE_FOR_OFFLINE\"  \n\n\"OFFLINE_NOT_NECESSARY\"  \n\n\"SHARE\"  \n\n### ConfigureRequestedOptions\n\nChrome 44+\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system to be configured.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### CopyEntryRequestedOptions\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n  * sourcePath\n\nstring\n\nThe source path of the entry to be copied.\n\n  * targetPath\n\nstring\n\nThe destination path for the copy operation.\n\n### CreateDirectoryRequestedOptions\n\n#### Properties\n\n  * directoryPath\n\nstring\n\nThe path of the directory to be created.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * recursive\n\nboolean\n\nWhether the operation is recursive (for directories only).\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### CreateFileRequestedOptions\n\n#### Properties\n\n  * filePath\n\nstring\n\nThe path of the file to be created.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### DeleteEntryRequestedOptions\n\n#### Properties\n\n  * entryPath\n\nstring\n\nThe path of the entry to be deleted.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * recursive\n\nboolean\n\nWhether the operation is recursive (for directories only).\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### EntryMetadata\n\n#### Properties\n\n  * cloudFileInfo\n\nCloudFileInfo optional\n\nChrome 125+\n\nInformation that identifies a specific file in the underlying cloud file\nsystem. Must be provided if requested in `options` and the file is backed by\ncloud storage.\n\n  * cloudIdentifier\n\nCloudIdentifier optional\n\nChrome 117+\n\nCloud storage representation of this entry. Must be provided if requested in\n`options` and the file is backed by cloud storage. For local files not backed\nby cloud storage, it should be undefined when requested.\n\n  * isDirectory\n\nboolean optional\n\nTrue if it is a directory. Must be provided if requested in `options`.\n\n  * mimeType\n\nstring optional\n\nMime type for the entry. Always optional, but should be provided if requested\nin `options`.\n\n  * modificationTime\n\nDate optional\n\nThe last modified time of this entry. Must be provided if requested in\n`options`.\n\n  * name\n\nstring optional\n\nName of this entry (not full path name). Must not contain '/'. For root it\nmust be empty. Must be provided if requested in `options`.\n\n  * size\n\nnumber optional\n\nFile size in bytes. Must be provided if requested in `options`.\n\n  * thumbnail\n\nstring optional\n\nThumbnail image as a data URI in either PNG, JPEG or WEBP format, at most 32\nKB in size. Optional, but can be provided only when explicitly requested by\nthe `onGetMetadataRequested` event.\n\n### ExecuteActionRequestedOptions\n\nChrome 45+\n\n#### Properties\n\n  * actionId\n\nstring\n\nThe identifier of the action to be executed.\n\n  * entryPaths\n\nstring[]\n\nChrome 47+\n\nThe set of paths of the entries to be used for the action.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### FileSystemInfo\n\n#### Properties\n\n  * displayName\n\nstring\n\nA human-readable name for the file system.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system.\n\n  * openedFiles\n\nOpenedFile[]\n\nList of currently opened files.\n\n  * openedFilesLimit\n\nnumber\n\nThe maximum number of files that can be opened at once. If 0, then not\nlimited.\n\n  * supportsNotifyTag\n\nboolean optional\n\nChrome 45+\n\nWhether the file system supports the `tag` field for observing directories.\n\n  * watchers\n\nWatcher[]\n\nChrome 45+\n\nList of watchers.\n\n  * writable\n\nboolean\n\nWhether the file system supports operations which may change contents of the\nfile system (such as creating, deleting or writing to files).\n\n### GetActionsRequestedOptions\n\nChrome 45+\n\n#### Properties\n\n  * entryPaths\n\nstring[]\n\nChrome 47+\n\nList of paths of entries for the list of actions.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### GetMetadataRequestedOptions\n\n#### Properties\n\n  * cloudFileInfo\n\nboolean\n\nChrome 125+\n\nSet to `true` if `cloudFileInfo` value is requested.\n\n  * cloudIdentifier\n\nboolean\n\nChrome 117+\n\nSet to `true` if `cloudIdentifier` value is requested.\n\n  * entryPath\n\nstring\n\nThe path of the entry to fetch metadata about.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * isDirectory\n\nboolean\n\nChrome 49+\n\nSet to `true` if `is_directory` value is requested.\n\n  * mimeType\n\nboolean\n\nChrome 49+\n\nSet to `true` if `mimeType` value is requested.\n\n  * modificationTime\n\nboolean\n\nChrome 49+\n\nSet to `true` if `modificationTime` value is requested.\n\n  * name\n\nboolean\n\nChrome 49+\n\nSet to `true` if `name` value is requested.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n  * size\n\nboolean\n\nChrome 49+\n\nSet to `true` if `size` value is requested.\n\n  * thumbnail\n\nboolean\n\nSet to `true` if `thumbnail` value is requested.\n\n### MountOptions\n\n#### Properties\n\n  * displayName\n\nstring\n\nA human-readable name for the file system.\n\n  * fileSystemId\n\nstring\n\nThe string indentifier of the file system. Must be unique per each extension.\n\n  * openedFilesLimit\n\nnumber optional\n\nThe maximum number of files that can be opened at once. If not specified, or\n0, then not limited.\n\n  * persistent\n\nboolean optional\n\nChrome 64+\n\nWhether the framework should resume the file system at the next sign-in\nsession. True by default.\n\n  * supportsNotifyTag\n\nboolean optional\n\nChrome 45+\n\nWhether the file system supports the `tag` field for observed directories.\n\n  * writable\n\nboolean optional\n\nWhether the file system supports operations which may change contents of the\nfile system (such as creating, deleting or writing to files).\n\n### MoveEntryRequestedOptions\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n  * sourcePath\n\nstring\n\nThe source path of the entry to be moved into a new place.\n\n  * targetPath\n\nstring\n\nThe destination path for the copy operation.\n\n### NotifyOptions\n\n#### Properties\n\n  * changeType\n\nChangeType\n\nThe type of the change which happened to the observed entry. If it is DELETED,\nthen the observed entry will be automatically removed from the list of\nobserved entries.\n\n  * changes\n\nChange[] optional\n\nList of changes to entries within the observed directory (including the entry\nitself)\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this change.\n\n  * observedPath\n\nstring\n\nThe path of the observed entry.\n\n  * recursive\n\nboolean\n\nMode of the observed entry.\n\n  * tag\n\nstring optional\n\nTag for the notification. Required if the file system was mounted with the\n`supportsNotifyTag` option. Note, that this flag is necessary to provide\nnotifications about changes which changed even when the system was shutdown.\n\n### OpenedFile\n\n#### Properties\n\n  * filePath\n\nstring\n\nThe path of the opened file.\n\n  * mode\n\nOpenFileMode\n\nWhether the file was opened for reading or writing.\n\n  * openRequestId\n\nnumber\n\nA request ID to be be used by consecutive read/write and close requests.\n\n### OpenFileMode\n\nMode of opening a file. Used by `onOpenFileRequested`.\n\n#### Enum\n\n\"READ\"  \n\n\"WRITE\"  \n\n### OpenFileRequestedOptions\n\n#### Properties\n\n  * filePath\n\nstring\n\nThe path of the file to be opened.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * mode\n\nOpenFileMode\n\nWhether the file will be used for reading or writing.\n\n  * requestId\n\nnumber\n\nA request ID which will be used by consecutive read/write and close requests.\n\n### ProviderError\n\nError codes used by providing extensions in response to requests as well as in\ncase of errors when calling methods of the API. For success, `\"OK\"` must be\nused.\n\n#### Enum\n\n\"OK\"  \n\n\"FAILED\"  \n\n\"IN_USE\"  \n\n\"EXISTS\"  \n\n\"NOT_FOUND\"  \n\n\"ACCESS_DENIED\"  \n\n\"TOO_MANY_OPENED\"  \n\n\"NO_MEMORY\"  \n\n\"NO_SPACE\"  \n\n\"NOT_A_DIRECTORY\"  \n\n\"INVALID_OPERATION\"  \n\n\"SECURITY\"  \n\n\"ABORT\"  \n\n\"NOT_A_FILE\"  \n\n\"NOT_EMPTY\"  \n\n\"INVALID_URL\"  \n\n\"IO\"  \n\n### ReadDirectoryRequestedOptions\n\n#### Properties\n\n  * directoryPath\n\nstring\n\nThe path of the directory which contents are requested.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * isDirectory\n\nboolean\n\nChrome 49+\n\nSet to `true` if `is_directory` value is requested.\n\n  * mimeType\n\nboolean\n\nChrome 49+\n\nSet to `true` if `mimeType` value is requested.\n\n  * modificationTime\n\nboolean\n\nChrome 49+\n\nSet to `true` if `modificationTime` value is requested.\n\n  * name\n\nboolean\n\nChrome 49+\n\nSet to `true` if `name` value is requested.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n  * size\n\nboolean\n\nChrome 49+\n\nSet to `true` if `size` value is requested.\n\n  * thumbnail\n\nboolean\n\nChrome 49+\n\nSet to `true` if `thumbnail` value is requested.\n\n### ReadFileRequestedOptions\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * length\n\nnumber\n\nNumber of bytes to be returned.\n\n  * offset\n\nnumber\n\nPosition in the file (in bytes) to start reading from.\n\n  * openRequestId\n\nnumber\n\nA request ID used to open the file.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### RemoveWatcherRequestedOptions\n\n#### Properties\n\n  * entryPath\n\nstring\n\nThe path of the watched entry.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * recursive\n\nboolean\n\nMode of the watcher.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### TruncateRequestedOptions\n\n#### Properties\n\n  * filePath\n\nstring\n\nThe path of the file to be truncated.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * length\n\nnumber\n\nNumber of bytes to be retained after the operation completes.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### UnmountOptions\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system to be unmounted.\n\n### UnmountRequestedOptions\n\n#### Properties\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system to be unmounted.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n### Watcher\n\n#### Properties\n\n  * entryPath\n\nstring\n\nThe path of the entry being observed.\n\n  * lastTag\n\nstring optional\n\nTag used by the last notification for the watcher.\n\n  * recursive\n\nboolean\n\nWhether watching should include all child entries recursively. It can be true\nfor directories only.\n\n### WriteFileRequestedOptions\n\n#### Properties\n\n  * data\n\nArrayBuffer\n\nBuffer of bytes to be written to the file.\n\n  * fileSystemId\n\nstring\n\nThe identifier of the file system related to this operation.\n\n  * offset\n\nnumber\n\nPosition in the file (in bytes) to start writing the bytes from.\n\n  * openRequestId\n\nnumber\n\nA request ID used to open the file.\n\n  * requestId\n\nnumber\n\nThe unique identifier of this request.\n\n## Methods\n\n### get()\n\nPromise\n\n    \n    \n    chrome.fileSystemProvider.get(  \n      fileSystemId: string,  \n      callback?: function,  \n    )\n\nReturns information about a file system with the passed `fileSystemId`.\n\n#### Parameters\n\n  * fileSystemId\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (fileSystem: FileSystemInfo) => void\n\n    * fileSystem\n\nFileSystemInfo\n\n#### Returns\n\n  * Promise<FileSystemInfo>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.fileSystemProvider.getAll(  \n      callback?: function,  \n    )\n\nReturns all file systems mounted by the extension.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (fileSystems: FileSystemInfo[]) => void\n\n    * fileSystems\n\nFileSystemInfo[]\n\n#### Returns\n\n  * Promise<FileSystemInfo[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### mount()\n\nPromise\n\n    \n    \n    chrome.fileSystemProvider.mount(  \n      options: MountOptions,  \n      callback?: function,  \n    )\n\nMounts a file system with the given `fileSystemId` and `displayName`.\n`displayName` will be shown in the left panel of the Files app. `displayName`\ncan contain any characters including '/', but cannot be an empty string.\n`displayName` must be descriptive but doesn't have to be unique. The\n`fileSystemId` must not be an empty string.\n\nDepending on the type of the file system being mounted, the `source` option\nmust be set appropriately.\n\nIn case of an error, `runtime.lastError` will be set with a corresponding\nerror code.\n\n#### Parameters\n\n  * options\n\nMountOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### notify()\n\nPromise Chrome 45+\n\n    \n    \n    chrome.fileSystemProvider.notify(  \n      options: NotifyOptions,  \n      callback?: function,  \n    )\n\nNotifies about changes in the watched directory at `observedPath` in\n`recursive` mode. If the file system is mounted with `supportsNotifyTag`, then\n`tag` must be provided, and all changes since the last notification always\nreported, even if the system was shutdown. The last tag can be obtained with\n`getAll`.\n\nTo use, the `file_system_provider.notify` manifest option must be set to true.\n\nValue of `tag` can be any string which is unique per call, so it's possible to\nidentify the last registered notification. Eg. if the providing extension\nstarts after a reboot, and the last registered notification's tag is equal to\n\"123\", then it should call `notify` for all changes which happened since the\nchange tagged as \"123\". It cannot be an empty string.\n\nNot all providers are able to provide a tag, but if the file system has a\nchangelog, then the tag can be eg. a change number, or a revision number.\n\nNote that if a parent directory is removed, then all descendant entries are\nalso removed, and if they are watched, then the API must be notified about the\nfact. Also, if a directory is renamed, then all descendant entries are in fact\nremoved, as there is no entry under their original paths anymore.\n\nIn case of an error, `runtime.lastError` will be set will a corresponding\nerror code.\n\n#### Parameters\n\n  * options\n\nNotifyOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### unmount()\n\nPromise\n\n    \n    \n    chrome.fileSystemProvider.unmount(  \n      options: UnmountOptions,  \n      callback?: function,  \n    )\n\nUnmounts a file system with the given `fileSystemId`. It must be called after\n`onUnmountRequested` is invoked. Also, the providing extension can decide to\nperform unmounting if not requested (eg. in case of lost connection, or a file\nerror).\n\nIn case of an error, `runtime.lastError` will be set with a corresponding\nerror code.\n\n#### Parameters\n\n  * options\n\nUnmountOptions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onAbortRequested\n\n    \n    \n    chrome.fileSystemProvider.onAbortRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when aborting an operation with `operationRequestId` is requested. The\noperation executed with `operationRequestId` must be immediately stopped and\n`successCallback` of this abort request executed. If aborting fails, then\n`errorCallback` must be called. Note, that callbacks of the aborted operation\nmust not be called, as they will be ignored. Despite calling `errorCallback`,\nthe request may be forcibly aborted.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: AbortRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nAbortRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onAddWatcherRequested\n\nChrome 45+\n\n    \n    \n    chrome.fileSystemProvider.onAddWatcherRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when setting a new directory watcher is requested. If an error occurs,\nthen `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: AddWatcherRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nAddWatcherRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onCloseFileRequested\n\n    \n    \n    chrome.fileSystemProvider.onCloseFileRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when opening a file previously opened with `openRequestId` is requested\nto be closed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: CloseFileRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nCloseFileRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onConfigureRequested\n\nChrome 44+\n\n    \n    \n    chrome.fileSystemProvider.onConfigureRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when showing a configuration dialog for `fileSystemId` is requested. If\nit's handled, the `file_system_provider.configurable` manfiest option must be\nset to true.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: ConfigureRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nConfigureRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onCopyEntryRequested\n\n    \n    \n    chrome.fileSystemProvider.onCopyEntryRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when copying an entry (recursively if a directory) is requested. If an\nerror occurs, then `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: CopyEntryRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nCopyEntryRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onCreateDirectoryRequested\n\n    \n    \n    chrome.fileSystemProvider.onCreateDirectoryRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when creating a directory is requested. The operation must fail with\nthe EXISTS error if the target directory already exists. If `recursive` is\ntrue, then all of the missing directories on the directory path must be\ncreated.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: CreateDirectoryRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nCreateDirectoryRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onCreateFileRequested\n\n    \n    \n    chrome.fileSystemProvider.onCreateFileRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when creating a file is requested. If the file already exists, then\n`errorCallback` must be called with the `\"EXISTS\"` error code.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: CreateFileRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nCreateFileRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onDeleteEntryRequested\n\n    \n    \n    chrome.fileSystemProvider.onDeleteEntryRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when deleting an entry is requested. If `recursive` is true, and the\nentry is a directory, then all of the entries inside must be recursively\ndeleted as well.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: DeleteEntryRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nDeleteEntryRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onExecuteActionRequested\n\nChrome 48+\n\n    \n    \n    chrome.fileSystemProvider.onExecuteActionRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when executing an action for a set of files or directories is\\\nrequested. After the action is completed, `successCallback` must be called. On\nerror, `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: ExecuteActionRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nExecuteActionRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onGetActionsRequested\n\nChrome 48+\n\n    \n    \n    chrome.fileSystemProvider.onGetActionsRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when a list of actions for a set of files or directories at\n`entryPaths` is requested. All of the returned actions must be applicable to\neach entry. If there are no such actions, an empty array should be returned.\nThe actions must be returned with the `successCallback` call. In case of an\nerror, `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: GetActionsRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nGetActionsRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          (actions: Action[]) => void\n\n      * actions\n\nAction[]\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onGetMetadataRequested\n\n    \n    \n    chrome.fileSystemProvider.onGetMetadataRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when metadata of a file or a directory at `entryPath` is requested. The\nmetadata must be returned with the `successCallback` call. In case of an\nerror, `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: GetMetadataRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nGetMetadataRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          (metadata: EntryMetadata) => void\n\n      * metadata\n\nEntryMetadata\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onMountRequested\n\nChrome 44+\n\n    \n    \n    chrome.fileSystemProvider.onMountRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when showing a dialog for mounting a new file system is requested. If\nthe extension/app is a file handler, then this event shouldn't be handled.\nInstead `app.runtime.onLaunched` should be handled in order to mount new file\nsystems when a file is opened. For multiple mounts, the\n`file_system_provider.multiple_mounts` manifest option must be set to true.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (successCallback: function, errorCallback: function) => void\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onMoveEntryRequested\n\n    \n    \n    chrome.fileSystemProvider.onMoveEntryRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when moving an entry (recursively if a directory) is requested. If an\nerror occurs, then `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: MoveEntryRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nMoveEntryRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onOpenFileRequested\n\n    \n    \n    chrome.fileSystemProvider.onOpenFileRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when opening a file at `filePath` is requested. If the file does not\nexist, then the operation must fail. Maximum number of files opened at once\ncan be specified with `MountOptions`.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: OpenFileRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nOpenFileRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          (metadata?: EntryMetadata) => void\n\n      * metadata\n\nEntryMetadata optional\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onReadDirectoryRequested\n\n    \n    \n    chrome.fileSystemProvider.onReadDirectoryRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when contents of a directory at `directoryPath` are requested. The\nresults must be returned in chunks by calling the `successCallback` several\ntimes. In case of an error, `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: ReadDirectoryRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nReadDirectoryRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          (entries: EntryMetadata[], hasMore: boolean) => void\n\n      * entries\n\nEntryMetadata[]\n\n      * hasMore\n\nboolean\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onReadFileRequested\n\n    \n    \n    chrome.fileSystemProvider.onReadFileRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when reading contents of a file opened previously with `openRequestId`\nis requested. The results must be returned in chunks by calling\n`successCallback` several times. In case of an error, `errorCallback` must be\ncalled.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: ReadFileRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nReadFileRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          (data: ArrayBuffer, hasMore: boolean) => void\n\n      * data\n\nArrayBuffer\n\n      * hasMore\n\nboolean\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onRemoveWatcherRequested\n\nChrome 45+\n\n    \n    \n    chrome.fileSystemProvider.onRemoveWatcherRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when the watcher should be removed. If an error occurs, then\n`errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: RemoveWatcherRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nRemoveWatcherRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onTruncateRequested\n\n    \n    \n    chrome.fileSystemProvider.onTruncateRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when truncating a file to a desired length is requested. If an error\noccurs, then `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: TruncateRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nTruncateRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onUnmountRequested\n\n    \n    \n    chrome.fileSystemProvider.onUnmountRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when unmounting for the file system with the `fileSystemId` identifier\nis requested. In the response, the `unmount` API method must be called\ntogether with `successCallback`. If unmounting is not possible (eg. due to a\npending operation), then `errorCallback` must be called.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: UnmountRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nUnmountRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n### onWriteFileRequested\n\n    \n    \n    chrome.fileSystemProvider.onWriteFileRequested.addListener(  \n      callback: function,  \n    )\n\nRaised when writing contents to a file opened previously with `openRequestId`\nis requested.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (options: WriteFileRequestedOptions, successCallback: function, errorCallback: function) => void\n\n    * options\n\nWriteFileRequestedOptions\n\n    * successCallback\n\nfunction\n\nThe `successCallback` parameter looks like:\n\n          \n          () => void\n\n    * errorCallback\n\nfunction\n\nThe `errorCallback` parameter looks like:\n\n          \n          (error: ProviderError) => void\n\n      * error\n\nProviderError\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/fontSettings": "#  chrome.fontSettings\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.fontSettings` API to manage Chrome's font settings.\n\n## Permissions\n\n`fontSettings`  \n\nTo use the Font Settings API, you must declare the `\"fontSettings\"` permission\nin the extension manifest. For example:\n\n    \n    \n    {\n      \"name\": \"My Font Settings Extension\",\n      \"description\": \"Customize your fonts\",\n      \"version\": \"0.2\",\n      \"permissions\": [\n        \"fontSettings\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nChrome allows for some font settings to depend on certain generic font\nfamilies and language scripts. For example, the font used for sans-serif\nSimplified Chinese may be different than the font used for serif Japanese.\n\nThe generic font families supported by Chrome are based on CSS generic font\nfamilies and are listed under `GenericReference`. When a web page specifies a\ngeneric font family, Chrome selects the font based on the corresponding\nsetting. If no generic font family is specified, Chrome uses the setting for\nthe \"standard\" generic font family.\n\nWhen a web page specifies a language, Chrome selects the font based on the\nsetting for the corresponding language script. If no language is specified,\nChrome uses the setting for the default, or global, script.\n\nThe supported language scripts are specified by ISO 15924 script code and\nlisted under `ScriptCode`. Technically, Chrome settings are not strictly per-\nscript but also depend on language. For example, Chrome chooses the font for\nCyrillic (ISO 15924 script code \"Cyrl\") when a web page specifies the Russian\nlanguage, and uses this font not just for Cyrillic script but for everything\nthe font covers, such as Latin.\n\n## Examples\n\nThe following code gets the standard font for Arabic.\n\n    \n    \n    chrome.fontSettings.getFont(\n      { genericFamily: 'standard', script: 'Arab' },\n      function(details) { console.log(details.fontId); }\n    );\n    \n\nThe next snippet sets the sans-serif font for Japanese.\n\n    \n    \n    chrome.fontSettings.setFont(\n      { genericFamily: 'sansserif', script: 'Jpan', fontId: 'MS PGothic' }\n    );\n    \n\nTo try this API, install the fontSettings API example from the chrome-\nextension-samples repository.\n\n## Types\n\n### FontName\n\nRepresents a font name.\n\n#### Properties\n\n  * displayName\n\nstring\n\nThe display name of the font.\n\n  * fontId\n\nstring\n\nThe font ID.\n\n### GenericFamily\n\nA CSS generic font family.\n\n#### Enum\n\n\"standard\"  \n\n\"sansserif\"  \n\n\"serif\"  \n\n\"fixed\"  \n\n\"cursive\"  \n\n\"fantasy\"  \n\n\"math\"  \n\n### LevelOfControl\n\nOne of `not\\_controllable`: cannot be controlled by any extension\n`controlled\\_by\\_other\\_extensions`: controlled by extensions with higher\nprecedence `controllable\\_by\\_this\\_extension`: can be controlled by this\nextension `controlled\\_by\\_this\\_extension`: controlled by this extension\n\n#### Enum\n\n\"not_controllable\"  \n\n\"controlled_by_other_extensions\"  \n\n\"controllable_by_this_extension\"  \n\n\"controlled_by_this_extension\"  \n\n### ScriptCode\n\nAn ISO 15924 script code. The default, or global, script is represented by\nscript code \"Zyyy\".\n\n#### Enum\n\n\"Afak\"  \n\n\"Arab\"  \n\n\"Armi\"  \n\n\"Armn\"  \n\n\"Avst\"  \n\n\"Bali\"  \n\n\"Bamu\"  \n\n\"Bass\"  \n\n\"Batk\"  \n\n\"Beng\"  \n\n\"Blis\"  \n\n\"Bopo\"  \n\n\"Brah\"  \n\n\"Brai\"  \n\n\"Bugi\"  \n\n\"Buhd\"  \n\n\"Cakm\"  \n\n\"Cans\"  \n\n\"Cari\"  \n\n\"Cham\"  \n\n\"Cher\"  \n\n\"Cirt\"  \n\n\"Copt\"  \n\n\"Cprt\"  \n\n\"Cyrl\"  \n\n\"Cyrs\"  \n\n\"Deva\"  \n\n\"Dsrt\"  \n\n\"Dupl\"  \n\n\"Egyd\"  \n\n\"Egyh\"  \n\n\"Egyp\"  \n\n\"Elba\"  \n\n\"Ethi\"  \n\n\"Geor\"  \n\n\"Geok\"  \n\n\"Glag\"  \n\n\"Goth\"  \n\n\"Gran\"  \n\n\"Grek\"  \n\n\"Gujr\"  \n\n\"Guru\"  \n\n\"Hang\"  \n\n\"Hani\"  \n\n\"Hano\"  \n\n\"Hans\"  \n\n\"Hant\"  \n\n\"Hebr\"  \n\n\"Hluw\"  \n\n\"Hmng\"  \n\n\"Hung\"  \n\n\"Inds\"  \n\n\"Ital\"  \n\n\"Java\"  \n\n\"Jpan\"  \n\n\"Jurc\"  \n\n\"Kali\"  \n\n\"Khar\"  \n\n\"Khmr\"  \n\n\"Khoj\"  \n\n\"Knda\"  \n\n\"Kpel\"  \n\n\"Kthi\"  \n\n\"Lana\"  \n\n\"Laoo\"  \n\n\"Latf\"  \n\n\"Latg\"  \n\n\"Latn\"  \n\n\"Lepc\"  \n\n\"Limb\"  \n\n\"Lina\"  \n\n\"Linb\"  \n\n\"Lisu\"  \n\n\"Loma\"  \n\n\"Lyci\"  \n\n\"Lydi\"  \n\n\"Mand\"  \n\n\"Mani\"  \n\n\"Maya\"  \n\n\"Mend\"  \n\n\"Merc\"  \n\n\"Mero\"  \n\n\"Mlym\"  \n\n\"Moon\"  \n\n\"Mong\"  \n\n\"Mroo\"  \n\n\"Mtei\"  \n\n\"Mymr\"  \n\n\"Narb\"  \n\n\"Nbat\"  \n\n\"Nkgb\"  \n\n\"Nkoo\"  \n\n\"Nshu\"  \n\n\"Ogam\"  \n\n\"Olck\"  \n\n\"Orkh\"  \n\n\"Orya\"  \n\n\"Osma\"  \n\n\"Palm\"  \n\n\"Perm\"  \n\n\"Phag\"  \n\n\"Phli\"  \n\n\"Phlp\"  \n\n\"Phlv\"  \n\n\"Phnx\"  \n\n\"Plrd\"  \n\n\"Prti\"  \n\n\"Rjng\"  \n\n\"Roro\"  \n\n\"Runr\"  \n\n\"Samr\"  \n\n\"Sara\"  \n\n\"Sarb\"  \n\n\"Saur\"  \n\n\"Sgnw\"  \n\n\"Shaw\"  \n\n\"Shrd\"  \n\n\"Sind\"  \n\n\"Sinh\"  \n\n\"Sora\"  \n\n\"Sund\"  \n\n\"Sylo\"  \n\n\"Syrc\"  \n\n\"Syre\"  \n\n\"Syrj\"  \n\n\"Syrn\"  \n\n\"Tagb\"  \n\n\"Takr\"  \n\n\"Tale\"  \n\n\"Talu\"  \n\n\"Taml\"  \n\n\"Tang\"  \n\n\"Tavt\"  \n\n\"Telu\"  \n\n\"Teng\"  \n\n\"Tfng\"  \n\n\"Tglg\"  \n\n\"Thaa\"  \n\n\"Thai\"  \n\n\"Tibt\"  \n\n\"Tirh\"  \n\n\"Ugar\"  \n\n\"Vaii\"  \n\n\"Visp\"  \n\n\"Wara\"  \n\n\"Wole\"  \n\n\"Xpeo\"  \n\n\"Xsux\"  \n\n\"Yiii\"  \n\n\"Zmth\"  \n\n\"Zsym\"  \n\n\"Zyyy\"  \n\n## Methods\n\n### clearDefaultFixedFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.clearDefaultFixedFontSize(  \n      details?: object,  \n      callback?: function,  \n    )\n\nClears the default fixed font size set by this extension, if any.\n\n#### Parameters\n\n  * details\n\nobject optional\n\nThis parameter is currently unused.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### clearDefaultFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.clearDefaultFontSize(  \n      details?: object,  \n      callback?: function,  \n    )\n\nClears the default font size set by this extension, if any.\n\n#### Parameters\n\n  * details\n\nobject optional\n\nThis parameter is currently unused.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### clearFont()\n\nPromise\n\n    \n    \n    chrome.fontSettings.clearFont(  \n      details: object,  \n      callback?: function,  \n    )\n\nClears the font set by this extension, if any.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * genericFamily\n\nGenericFamily\n\nThe generic font family for which the font should be cleared.\n\n    * script\n\nScriptCode optional\n\nThe script for which the font should be cleared. If omitted, the global script\nfont setting is cleared.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### clearMinimumFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.clearMinimumFontSize(  \n      details?: object,  \n      callback?: function,  \n    )\n\nClears the minimum font size set by this extension, if any.\n\n#### Parameters\n\n  * details\n\nobject optional\n\nThis parameter is currently unused.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDefaultFixedFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.getDefaultFixedFontSize(  \n      details?: object,  \n      callback?: function,  \n    )\n\nGets the default size for fixed width fonts.\n\n#### Parameters\n\n  * details\n\nobject optional\n\nThis parameter is currently unused.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n      * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n#### Returns\n\n  * Promise<object>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getDefaultFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.getDefaultFontSize(  \n      details?: object,  \n      callback?: function,  \n    )\n\nGets the default font size.\n\n#### Parameters\n\n  * details\n\nobject optional\n\nThis parameter is currently unused.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n      * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n#### Returns\n\n  * Promise<object>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getFont()\n\nPromise\n\n    \n    \n    chrome.fontSettings.getFont(  \n      details: object,  \n      callback?: function,  \n    )\n\nGets the font for a given script and generic font family.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * genericFamily\n\nGenericFamily\n\nThe generic font family for which the font should be retrieved.\n\n    * script\n\nScriptCode optional\n\nThe script for which the font should be retrieved. If omitted, the font\nsetting for the global script (script code \"Zyyy\") is retrieved.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * fontId\n\nstring\n\nThe font ID. Rather than the literal font ID preference value, this may be the\nID of the font that the system resolves the preference value to. So, `fontId`\ncan differ from the font passed to `setFont`, if, for example, the font is not\navailable on the system. The empty string signifies fallback to the global\nscript font setting.\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n#### Returns\n\n  * Promise<object>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getFontList()\n\nPromise\n\n    \n    \n    chrome.fontSettings.getFontList(  \n      callback?: function,  \n    )\n\nGets a list of fonts on the system.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: FontName[]) => void\n\n    * results\n\nFontName[]\n\n#### Returns\n\n  * Promise<FontName[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getMinimumFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.getMinimumFontSize(  \n      details?: object,  \n      callback?: function,  \n    )\n\nGets the minimum font size.\n\n#### Parameters\n\n  * details\n\nobject optional\n\nThis parameter is currently unused.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n      * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n#### Returns\n\n  * Promise<object>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setDefaultFixedFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.setDefaultFixedFontSize(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the default size for fixed width fonts.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setDefaultFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.setDefaultFontSize(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the default font size.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setFont()\n\nPromise\n\n    \n    \n    chrome.fontSettings.setFont(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the font for a given script and generic font family.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * fontId\n\nstring\n\nThe font ID. The empty string means to fallback to the global script font\nsetting.\n\n    * genericFamily\n\nGenericFamily\n\nThe generic font family for which the font should be set.\n\n    * script\n\nScriptCode optional\n\nThe script code which the font should be set. If omitted, the font setting for\nthe global script (script code \"Zyyy\") is set.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setMinimumFontSize()\n\nPromise\n\n    \n    \n    chrome.fontSettings.setMinimumFontSize(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets the minimum font size.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onDefaultFixedFontSizeChanged\n\n    \n    \n    chrome.fontSettings.onDefaultFixedFontSizeChanged.addListener(  \n      callback: function,  \n    )\n\nFired when the default fixed font size setting changes.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n      * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n### onDefaultFontSizeChanged\n\n    \n    \n    chrome.fontSettings.onDefaultFontSizeChanged.addListener(  \n      callback: function,  \n    )\n\nFired when the default font size setting changes.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n      * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n### onFontChanged\n\n    \n    \n    chrome.fontSettings.onFontChanged.addListener(  \n      callback: function,  \n    )\n\nFired when a font setting changes.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * fontId\n\nstring\n\nThe font ID. See the description in `getFont`.\n\n      * genericFamily\n\nGenericFamily\n\nThe generic font family for which the font setting has changed.\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n      * script\n\nScriptCode optional\n\nThe script code for which the font setting has changed.\n\n### onMinimumFontSizeChanged\n\n    \n    \n    chrome.fontSettings.onMinimumFontSizeChanged.addListener(  \n      callback: function,  \n    )\n\nFired when the minimum font size setting changes.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * levelOfControl\n\nLevelOfControl\n\nThe level of control this extension has over the setting.\n\n      * pixelSize\n\nnumber\n\nThe font size in pixels.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/gcm": "#  chrome.gcm\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse `chrome.gcm` to enable apps and extensions to send and receive messages\nthrough Firebase Cloud Messaging (FCM).\n\n## Permissions\n\n`gcm`  \n\n## Properties\n\n### MAX_MESSAGE_SIZE\n\nThe maximum size (in bytes) of all key/value pairs in a message.\n\n#### Value\n\n4096  \n\n## Methods\n\n### register()\n\nPromise\n\n    \n    \n    chrome.gcm.register(  \n      senderIds: string[],  \n      callback?: function,  \n    )\n\nRegisters the application with FCM. The registration ID will be returned by\nthe `callback`. If `register` is called again with the same list of\n`senderIds`, the same registration ID will be returned.\n\n#### Parameters\n\n  * senderIds\n\nstring[]\n\nA list of server IDs that are allowed to send messages to the application. It\nshould contain at least one and no more than 100 sender IDs.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (registrationId: string) => void\n\n    * registrationId\n\nstring\n\nA registration ID assigned to the application by the FCM.\n\n#### Returns\n\n  * Promise<string>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### send()\n\nPromise\n\n    \n    \n    chrome.gcm.send(  \n      message: object,  \n      callback?: function,  \n    )\n\nSends a message according to its contents.\n\n#### Parameters\n\n  * message\n\nobject\n\nA message to send to the other party via FCM.\n\n    * data\n\nobject\n\nMessage data to send to the server. Case-insensitive `goog.` and `google`, as\nwell as case-sensitive `collapse_key` are disallowed as key prefixes. Sum of\nall key/value pairs should not exceed `gcm.MAX_MESSAGE_SIZE`.\n\n    * destinationId\n\nstring\n\nThe ID of the server to send the message to as assigned by Google API Console.\n\n    * messageId\n\nstring\n\nThe ID of the message. It must be unique for each message in scope of the\napplications. See the Cloud Messaging documentation for advice for picking and\nhandling an ID.\n\n    * timeToLive\n\nnumber optional\n\nTime-to-live of the message in seconds. If it is not possible to send the\nmessage within that time, an onSendError event will be raised. A time-to-live\nof 0 indicates that the message should be sent immediately or fail if it's not\npossible. The default value of time-to-live is 86,400 seconds (1 day) and the\nmaximum value is 2,419,200 seconds (28 days).\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (messageId: string) => void\n\n    * messageId\n\nstring\n\nThe ID of the message that the callback was issued for.\n\n#### Returns\n\n  * Promise<string>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### unregister()\n\nPromise\n\n    \n    \n    chrome.gcm.unregister(  \n      callback?: function,  \n    )\n\nUnregisters the application from FCM.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onMessage\n\n    \n    \n    chrome.gcm.onMessage.addListener(  \n      callback: function,  \n    )\n\nFired when a message is received through FCM.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (message: object) => void\n\n    * message\n\nobject\n\n      * collapseKey\n\nstring optional\n\nThe collapse key of a message. See the Non-collapsible and collapsible\nmessages for details.\n\n      * data\n\nobject\n\nThe message data.\n\n      * from\n\nstring optional\n\nThe sender who issued the message.\n\n### onMessagesDeleted\n\n    \n    \n    chrome.gcm.onMessagesDeleted.addListener(  \n      callback: function,  \n    )\n\nFired when a FCM server had to delete messages sent by an app server to the\napplication. See Lifetime of a message for details on handling this event.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onSendError\n\n    \n    \n    chrome.gcm.onSendError.addListener(  \n      callback: function,  \n    )\n\nFired when it was not possible to send a message to the FCM server.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (error: object) => void\n\n    * error\n\nobject\n\n      * details\n\nobject\n\nAdditional details related to the error, when available.\n\n      * errorMessage\n\nstring\n\nThe error message describing the problem.\n\n      * messageId\n\nstring optional\n\nThe ID of the message with this error, if error is related to a specific\nmessage.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/history": "#  chrome.history\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.history` API to interact with the browser's record of visited\npages. You can add, remove, and query for URLs in the browser's history. To\noverride the history page with your own version, see Override Pages.\n\n## Permissions\n\n`history`  \n\nTo interact with the user's browser history, use the history API.\n\nTo use the history API, declare the `\"history\"` permission in the extension\nmanifest. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"history\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\n### Transition types\n\nThe history API uses transition types to describe how the browser navigated to\na particular URL on a particular visit. For example, if a user visits a page\nby clicking a link on another page, the transition type is \"link\". See the\nreference content for a list of transition types.\n\n## Examples\n\nTo try this API, install the history API example from the chrome-extension-\nsamples repository.\n\n## Types\n\n### HistoryItem\n\nAn object encapsulating one result of a history query.\n\n#### Properties\n\n  * id\n\nstring\n\nThe unique identifier for the item.\n\n  * lastVisitTime\n\nnumber optional\n\nWhen this page was last loaded, represented in milliseconds since the epoch.\n\n  * title\n\nstring optional\n\nThe title of the page when it was last loaded.\n\n  * typedCount\n\nnumber optional\n\nThe number of times the user has navigated to this page by typing in the\naddress.\n\n  * url\n\nstring optional\n\nThe URL navigated to by a user.\n\n  * visitCount\n\nnumber optional\n\nThe number of times the user has navigated to this page.\n\n### TransitionType\n\nChrome 44+\n\nThe transition type for this visit from its referrer.\n\n#### Enum\n\n\"link\"  \nThe user arrived at this page by clicking a link on another page.\n\n\"typed\"  \nThe user arrived at this page by typing the URL in the address bar. This is\nalso used for other explicit navigation actions.\n\n\"auto_bookmark\"  \nThe user arrived at this page through a suggestion in the UI, for example,\nthrough a menu item.\n\n\"auto_subframe\"  \nThe user arrived at this page through subframe navigation that they didn't\nrequest, such as through an ad loading in a frame on the previous page. These\ndon't always generate new navigation entries in the back and forward menus.\n\n\"manual_subframe\"  \nThe user arrived at this page by selecting something in a subframe.\n\n\"generated\"  \nThe user arrived at this page by typing in the address bar and selecting an\nentry that didn't look like a URL, such as a Google Search suggestion. For\nexample, a match might have the URL of a Google Search result page, but it\nmight appear to the user as \"Search Google for ...\". These are different from\ntyped navigations because the user didn't type or see the destination URL.\nThey're also related to keyword navigations.\n\n\"auto_toplevel\"  \nThe page was specified in the command line or is the start page.\n\n\"form_submit\"  \nThe user arrived at this page by filling out values in a form and submitting\nthe form. Not all form submissions use this transition type.\n\n\"reload\"  \nThe user reloaded the page, either by clicking the reload button or by\npressing Enter in the address bar. Session restore and Reopen closed tab also\nuse this transition type.\n\n\"keyword\"  \nThe URL for this page was generated from a replaceable keyword other than the\ndefault search provider.\n\n\"keyword_generated\"  \nCorresponds to a visit generated for a keyword.\n\n### UrlDetails\n\nChrome 88+\n\n#### Properties\n\n  * url\n\nstring\n\nThe URL for the operation. It must be in the format as returned from a call to\n`history.search()`.\n\n### VisitItem\n\nAn object encapsulating one visit to a URL.\n\n#### Properties\n\n  * id\n\nstring\n\nThe unique identifier for the corresponding `history.HistoryItem`.\n\n  * isLocal\n\nboolean\n\nChrome 115+\n\nTrue if the visit originated on this device. False if it was synced from a\ndifferent device.\n\n  * referringVisitId\n\nstring\n\nThe visit ID of the referrer.\n\n  * transition\n\nTransitionType\n\nThe transition type for this visit from its referrer.\n\n  * visitId\n\nstring\n\nThe unique identifier for this visit.\n\n  * visitTime\n\nnumber optional\n\nWhen this visit occurred, represented in milliseconds since the epoch.\n\n## Methods\n\n### addUrl()\n\nPromise\n\n    \n    \n    chrome.history.addUrl(  \n      details: UrlDetails,  \n      callback?: function,  \n    )\n\nAdds a URL to the history at the current time with a transition type of\n\"link\".\n\n#### Parameters\n\n  * details\n\nUrlDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### deleteAll()\n\nPromise\n\n    \n    \n    chrome.history.deleteAll(  \n      callback?: function,  \n    )\n\nDeletes all items from the history.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### deleteRange()\n\nPromise\n\n    \n    \n    chrome.history.deleteRange(  \n      range: object,  \n      callback?: function,  \n    )\n\nRemoves all items within the specified date range from the history. Pages will\nnot be removed from the history unless all visits fall within the range.\n\n#### Parameters\n\n  * range\n\nobject\n\n    * endTime\n\nnumber\n\nItems added to history before this date, represented in milliseconds since the\nepoch.\n\n    * startTime\n\nnumber\n\nItems added to history after this date, represented in milliseconds since the\nepoch.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### deleteUrl()\n\nPromise\n\n    \n    \n    chrome.history.deleteUrl(  \n      details: UrlDetails,  \n      callback?: function,  \n    )\n\nRemoves all occurrences of the given URL from the history.\n\n#### Parameters\n\n  * details\n\nUrlDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getVisits()\n\nPromise\n\n    \n    \n    chrome.history.getVisits(  \n      details: UrlDetails,  \n      callback?: function,  \n    )\n\nRetrieves information about visits to a URL.\n\n#### Parameters\n\n  * details\n\nUrlDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: VisitItem[]) => void\n\n    * results\n\nVisitItem[]\n\n#### Returns\n\n  * Promise<VisitItem[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### search()\n\nPromise\n\n    \n    \n    chrome.history.search(  \n      query: object,  \n      callback?: function,  \n    )\n\nSearches the history for the last visit time of each page matching the query.\n\n#### Parameters\n\n  * query\n\nobject\n\n    * endTime\n\nnumber optional\n\nLimit results to those visited before this date, represented in milliseconds\nsince the epoch.\n\n    * maxResults\n\nnumber optional\n\nThe maximum number of results to retrieve. Defaults to 100.\n\n    * startTime\n\nnumber optional\n\nLimit results to those visited after this date, represented in milliseconds\nsince the epoch. If property is not specified, it will default to 24 hours.\n\n    * text\n\nstring\n\nA free-text query to the history service. Leave this empty to retrieve all\npages.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: HistoryItem[]) => void\n\n    * results\n\nHistoryItem[]\n\n#### Returns\n\n  * Promise<HistoryItem[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onVisited\n\n    \n    \n    chrome.history.onVisited.addListener(  \n      callback: function,  \n    )\n\nFired when a URL is visited, providing the `HistoryItem` data for that URL.\nThis event fires before the page has loaded.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (result: HistoryItem) => void\n\n    * result\n\nHistoryItem\n\n### onVisitRemoved\n\n    \n    \n    chrome.history.onVisitRemoved.addListener(  \n      callback: function,  \n    )\n\nFired when one or more URLs are removed from history. When all visits have\nbeen removed the URL is purged from history.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (removed: object) => void\n\n    * removed\n\nobject\n\n      * allHistory\n\nboolean\n\nTrue if all history was removed. If true, then urls will be empty.\n\n      * urls\n\nstring[] optional\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/i18n": "#  chrome.i18n\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.i18n` infrastructure to implement internationalization across\nyour whole app or extension.\n\n## Manifest\n\nIf an extension has a `/_locales` directory, the manifest must define\n`\"default_locale\"`.\n\n## Concepts and usage\n\nYou need to put all of its user-visible strings into a file named\n`messages.json`. Each time you add a new locale, you add a messages file under\na directory named `/_locales/_localeCode_`, where _localeCode_ is a code such\nas `en` for English.\n\nHere's the file hierarchy for an internationalized extension that supports\nEnglish (`en`), Spanish (`es`), and Korean (`ko`):\n\n![In the extension directory: manifest.json, *.html, *.js, /_locales\ndirectory. In the /_locales directory: en, es, and ko directories, each with a\nmessages.json\nfile.](/static/docs/extensions/mv2/reference/i18n/images/i18n-hierarchy.gif)\n\n### Support multiple languages\n\nSay you have an extension with the files shown in the following figure:\n\n![A manifest.json file and a file with JavaScript. The .json file has 'Hello\nWorld'. The JavaScript file has title = 'Hello\nWorld'.](/static/docs/extensions/mv2/reference/i18n/images/i18n-before.gif)\n\nTo internationalize this extension, you name each user-visible string and put\nit into a messages file. The extension's manifest, CSS files, and JavaScript\ncode use each string's name to get its localized version.\n\nHere's what the extension looks like when it's internationalized (note that it\nstill has only English strings):\n\n![In the manifest.json file, 'Hello World' has been changed to\n'__MSG_extName__', and a new default_locale' item has the value 'en'. In the\nJavaScript file, 'Hello World' has been changed to\nchrome.i18n.getMessage\\('extName'\\). A new file named\n/_locales/en/messages.json defines\n'extName'.](/static/docs/extensions/mv2/reference/i18n/images/i18n-after-1.gif)\n\nSome notes about internationalizing:\n\n  * You can use any of the supported locales. If you use an unsupported locale, Google Chrome ignores it.\n  * In `manifest.json` and CSS files, refer to a string named _messagename_ like this:\n        \n        __MSG_messagename__\n        \n\n  * In your extension or app's JavaScript code, refer to a string named _messagename_ like this:\n        \n        chrome.i18n.getMessage(\"messagename\")\n        \n\n  * In each call to `getMessage()`, you can supply up to 9 strings to be included in the message. See Examples: getMessage for details.\n\n  * Some messages, such as `@@bidi_dir` and `@@ui_locale`, are provided by the internationalization system. See the Predefined messages section for a full list of predefined message names.\n\n  * In `messages.json`, each user-visible string has a name, a \"message\" item, and an optional \"description\" item. The name is a key such as \"extName\" or \"search_string\" that identifies the string. The \"message\" specifies the value of the string in this locale. The optional \"description\" provides help to translators, who might not be able to see how the string is used in your extension. For example:\n        \n        {\n          \"search_string\": {\n            \"message\": \"hello%20world\",\n            \"description\": \"The string we search for. Put %20 between words that go together.\"\n          },\n          ...\n        }\n        \n\nFor more information, see Formats: Locale-Specific Messages.\n\nOnce an extension is internationalized, translating it is straightforward. You\ncopy `messages.json`, translate it, and put the copy into a new directory\nunder `/_locales`. For example, to support Spanish, just put a translated copy\nof `messages.json` under `/_locales/es`. The following figure shows the\nprevious extension with a new Spanish translation.\n\n![This looks the same as the previous figure, but with a new file at\n/_locales/es/messages.json that contains a Spanish translation of the\nmessages.](/static/docs/extensions/mv2/reference/i18n/images/i18n-after-2.gif)\n\n### Predefined messages\n\nThe internationalization system provides a few predefined messages to help you\nlocalize. These include `@@ui_locale`, so you can detect the current UI\nlocale, and a few `@@bidi_...` messages that let you detect the text\ndirection. The latter messages have similar names to constants in the gadgets\nBIDI (bi-directional) API.\n\nThe special message `@@extension_id` can be used in the CSS and JavaScript\nfiles, whether or not the extension or app is localized. This message doesn't\nwork in manifest files.\n\nThe following table describes each predefined message.\n\nMessage name| Description  \n---|---  \n`@@extension_id`| The extension or app ID; you might use this string to\nconstruct URLs for resources inside the extension. Even unlocalized extensions\ncan use this message.  \n**Note:** You can't use this message in a manifest file.  \n`@@ui_locale`| The current locale; you might use this string to construct\nlocale-specific URLs.  \n`@@bidi_dir`| The text direction for the current locale, either \"ltr\" for\nleft-to-right languages such as English or \"rtl\" for right-to-left languages\nsuch as Arabic.  \n`@@bidi_reversed_dir`| If the `@@bidi_dir` is \"ltr\", then this is \"rtl\";\notherwise, it's \"ltr\".  \n`@@bidi_start_edge`| If the `@@bidi_dir` is \"ltr\", then this is \"left\";\notherwise, it's \"right\".  \n`@@bidi_end_edge`| If the `@@bidi_dir` is \"ltr\", then this is \"right\";\notherwise, it's \"left\".  \n  \nHere's an example of using `@@extension_id` in a CSS file to construct a URL:\n\n    \n    \n    body {\n      background-image:url('chrome-extension://__MSG_@@extension_id__/background.png');\n    }\n    \n\nIf the extension ID is abcdefghijklmnopqrstuvwxyzabcdef, then the bold line in\nthe previous code snippet becomes:\n\n    \n    \n      background-image:url('chrome-extension://abcdefghijklmnopqrstuvwxyzabcdef/background.png');\n    \n\nHere's an example of using `@@bidi_*` messages in a CSS file:\n\n    \n    \n    body {\n      direction: __MSG_@@bidi_dir__;\n    }\n    \n    div#header {\n      margin-bottom: 1.05em;\n      overflow: hidden;\n      padding-bottom: 1.5em;\n      padding-__MSG_@@bidi_start_edge__: 0;\n      padding-__MSG_@@bidi_end_edge__: 1.5em;\n      position: relative;\n    }\n    \n\nFor left-to-right languages such as English, the bold lines become:\n\n    \n    \n      dir: ltr;\n      padding-left: 0;\n      padding-right: 1.5em;\n    \n\n### Locales\n\nYou can choose from many locales, including some (such as `en`) that let a\nsingle translation support multiple variations of a language (such as `en_GB`\nand `en_US`).\n\nYou can localize your extension to any locale that is supported by the Chrome\nWeb Store. If your locale is not listed here, choose the closest alternative.\nFor example, if the default locale of your extension is `\"de_CH\"`, choose\n`\"de\"` in the Chrome Web Store.\n\nLocale code | Language (region)  \n---|---  \n`ar` | Arabic  \n`am` | Amharic  \n`bg` | Bulgarian  \n`bn` | Bengali  \n`ca` | Catalan  \n`cs` | Czech  \n`da` | Danish  \n`de` | German  \n`el` | Greek  \n`en` | English  \n`en_AU` | English (Australia)  \n`en_GB` | English (Great Britain)  \n`en_US` | English (USA)  \n`es` | Spanish  \n`es_419` | Spanish (Latin America and Caribbean)  \n`et` | Estonian  \n`fa` | Persian  \n`fi` | Finnish  \n`fil` | Filipino  \n`fr` | French  \n`gu` | Gujarati  \n`he` | Hebrew  \n`hi` | Hindi  \n`hr` | Croatian  \n`hu` | Hungarian  \n`id` | Indonesian  \n`it` | Italian  \n`ja` | Japanese  \n`kn` | Kannada  \n`ko` | Korean  \n`lt` | Lithuanian  \n`lv` | Latvian  \n`ml` | Malayalam  \n`mr` | Marathi  \n`ms` | Malay  \n`nl` | Dutch  \n`no` | Norwegian  \n`pl` | Polish  \n`pt_BR` | Portuguese (Brazil)  \n`pt_PT` | Portuguese (Portugal)  \n`ro` | Romanian  \n`ru` | Russian  \n`sk` | Slovak  \n`sl` | Slovenian  \n`sr` | Serbian  \n`sv` | Swedish  \n`sw` | Swahili  \n`ta` | Tamil  \n`te` | Telugu  \n`th` | Thai  \n`tr` | Turkish  \n`uk` | Ukrainian  \n`vi` | Vietnamese  \n`zh_CN` | Chinese (China)  \n`zh_TW` | Chinese (Taiwan)  \n  \n### Search for messages\n\nYou don't have to define every string for every supported locale. As long as\nthe default locale's `messages.json` file has a value for every string, your\nextension or app will run no matter how sparse a translation is. Here's how\nthe extension system searches for a message:\n\n  1. Search the messages file (if any) for the user's preferred locale. For example, when Google Chrome's locale is set to British English (`en_GB`), the system first looks for the message in `/_locales/en_GB/messages.json`. If that file exists and the message is there, the system looks no further.\n  2. If the user's preferred locale has a region (that is, the locale has an underscore: _), search the locale without that region. For example, if the `en_GB` messages file doesn't exist or doesn't contain the message, the system looks in the `en` messages file. If that file exists and the message is there, the system looks no further.\n  3. Search the messages file for the default locale. For example, if the extension's \"default_locale\" is set to \"es\", and neither `/_locales/en_GB/messages.json` nor `/_locales/en/messages.json` contains the message, the extension uses the message from `/_locales/es/messages.json`.\n\nIn the following figure, the message named \"colores\" is in all three locales\nthat the extension supports, but \"extName\" is in only two of the locales.\nWherever a user running Google Chrome in US English sees the label \"Colors\", a\nuser of British English sees \"Colours\". Both US English and British English\nusers see the extension name \"Hello World\". Because the default language is\nSpanish, users running Google Chrome in any non-English language see the label\n\"Colores\" and the extension name \"Hola mundo\".\n\n![Four files: manifest.json and three messages.json files \\(for es, en, and\nen_GB\\). The es and en files show entries for messages named 'extName' and\n'colores'; the en_GB file has just one entry \\(for\n'colores'\\).](/static/docs/extensions/mv2/reference/i18n/images/i18n-strings.gif)\n\n### Set your browser's locale\n\nTo test translations, you might want to set your browser's locale. This\nsection tells you how to set the locale in Windows, Mac OS, Linux, and\nChromeOS.\n\n#### Windows\n\nYou can change the locale using either a locale-specific shortcut or the\nGoogle Chrome UI. The shortcut approach is quicker, once you've set it up, and\nit lets you use several languages at once.\n\n##### Use a locale-specific shortcut\n\nTo create and use a shortcut that launches Google Chrome with a particular\nlocale:\n\n  1. Make a copy of the Google Chrome shortcut that's already on your desktop.\n  2. Rename the new shortcut to match the new locale.\n  3. Change the shortcut's properties so that the Target field specifies the `--lang` and `--user-data-dir` flags. The target should look something like this:\n         \n         path_to_chrome.exe --lang=locale --user-data-dir=c:\\locale_profile_dir\n         \n\n  4. Launch Google Chrome by double-clicking the shortcut.\n\nFor example, to create a shortcut that launches Google Chrome in Spanish\n(`es`), you might create a shortcut named `chrome-es` that has the following\ntarget:\n\n    \n    \n    path_to_chrome.exe --lang=es --user-data-dir=c:\\chrome-profile-es\n    \n\nYou can create as many shortcuts as you like, making it straightforward to\ntest in multiple languages. For example:\n\n    \n    \n    path_to_chrome.exe --lang=en --user-data-dir=c:\\chrome-profile-en\n    path_to_chrome.exe --lang=en_GB --user-data-dir=c:\\chrome-profile-en_GB\n    path_to_chrome.exe --lang=ko --user-data-dir=c:\\chrome-profile-ko\n    \n\n**Note:** Specifying `--user-data-dir` is optional but handy. Having one data\ndirectory per locale lets you run the browser in several languages at the same\ntime. A disadvantage is that because the locales' data isn't shared, you have\nto install your extension multiple timesonce per locale, which can be\nchallenging when you don't speak the language. For more information, see\nCreating and Using Profiles.\n\n##### Use the UI\n\nHere's how to change the locale using the UI on Google Chrome for Windows:\n\n  1. App icon > **Options**\n  2. Choose the **Under the Hood** tab\n  3. Scroll to **Web Content**\n  4. Click **Change font and language settings**\n  5. Choose the **Languages** tab\n  6. Use the drop down to set the **Google Chrome language**\n  7. Restart Chrome\n\n#### Mac OS\n\nTo change the locale on Mac, you use the system preferences.\n\n  1. From the Apple menu, choose **System Preferences**\n  2. Under the **Personal** section, choose **International**\n  3. Choose your language and location\n  4. Restart Chrome\n\n#### Linux\n\nTo change the locale on Linux, first quit Google Chrome. Then, all in one\nline, set the LANGUAGE environment variable and launch Google Chrome. For\nexample:\n\n    \n    \n    LANGUAGE=es ./chrome\n    \n\n#### ChromeOS\n\nTo change the locale on ChromeOS:\n\n  1. From the system tray, choose **Settings**.\n  2. Under the **Languages and input** section, choose the **Language** drop-down.\n  3. If your language is not listed, click **Add languages** and add it.\n  4. Once added, click the 3-dot **More actions** menu item next to your language and choose **Display ChromeOS in this language**.\n  5. Click the **Restart** button that appears next to the set language to restart ChromeOS.\n\n## Examples\n\nYou can find examples of internationalization in the examples/api/i18n\ndirectory. For a complete example, see examples/extensions/news. For other\nexamples and for help in viewing the source code, see Samples.\n\n### getMessage()\n\nThe following code gets a localized message from the browser and displays it\nas a string. It replaces two placeholders within the message with the strings\n\"string1\" and \"string2\".\n\n    \n    \n    function getMessage() {\n      var message = chrome.i18n.getMessage(\"click_here\", [\"string1\", \"string2\"]);\n      document.getElementById(\"languageSpan\").innerHTML = message;\n    }\n    \n\nHere's how you'd supply and use a single string:\n\n    \n    \n      // In JavaScript code\n      status.innerText = chrome.i18n.getMessage(\"error\", errorDetails);\n    \n    \n    \n    \"error\": {\n      \"message\": \"Error: $details$\",\n      \"description\": \"Generic error template. Expects error parameter to be passed in.\",\n      \"placeholders\": {\n        \"details\": {\n          \"content\": \"$1\",\n          \"example\": \"Failed to fetch RSS feed.\"\n        }\n      }\n    }\n    \n\nFor more information about placeholders, see the Locale-Specific Messages\npage. For details on calling `getMessage()`, see the API reference.\n\n### getAcceptLanguages()\n\nThe following code gets accept-languages from the browser and displays them as\na string by separating each accept-language with ','.\n\n    \n    \n    function getAcceptLanguages() {\n      chrome.i18n.getAcceptLanguages(function(languageList) {\n        var languages = languageList.join(\",\");\n        document.getElementById(\"languageSpan\").innerHTML = languages;\n      })\n    }\n    \n\nFor details on calling `getAcceptLanguages()`, see the API reference.\n\n### detectLanguage()\n\nThe following code detects up to 3 languages from the given string and\ndisplays the result as strings separated by new lines.\n\n    \n    \n    function detectLanguage(inputText) {\n      chrome.i18n.detectLanguage(inputText, function(result) {\n        var outputLang = \"Detected Language: \";\n        var outputPercent = \"Language Percentage: \";\n        for(i = 0; i < result.languages.length; i++) {\n          outputLang += result.languages[i].language + \" \";\n          outputPercent +=result.languages[i].percentage + \" \";\n        }\n        document.getElementById(\"languageSpan\").innerHTML = outputLang + \"\\n\" + outputPercent + \"\\nReliable: \" + result.isReliable;\n      });\n    }\n    \n\nFor more details on calling `detectLanguage(inputText)`, see the API\nreference.\n\n## Types\n\n### LanguageCode\n\nChrome 47+\n\nAn ISO language code such as `en` or `fr`. For a complete list of languages\nsupported by this method, see kLanguageInfoTable. For an unknown language,\n`und` will be returned, which means that [percentage] of the text is unknown\nto CLD\n\n#### Type\n\nstring\n\n## Methods\n\n### detectLanguage()\n\nPromise Chrome 47+\n\n    \n    \n    chrome.i18n.detectLanguage(  \n      text: string,  \n      callback?: function,  \n    )\n\nDetects the language of the provided text using CLD.\n\n#### Parameters\n\n  * text\n\nstring\n\nUser input string to be translated.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: object) => void\n\n    * result\n\nobject\n\nLanguageDetectionResult object that holds detected langugae reliability and\narray of DetectedLanguage\n\n      * isReliable\n\nboolean\n\nCLD detected language reliability\n\n      * languages\n\nobject[]\n\narray of detectedLanguage\n\n        * language\n\nstring\n\n        * percentage\n\nnumber\n\nThe percentage of the detected language\n\n#### Returns\n\n  * Promise<object>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAcceptLanguages()\n\nPromise\n\n    \n    \n    chrome.i18n.getAcceptLanguages(  \n      callback?: function,  \n    )\n\nGets the accept-languages of the browser. This is different from the locale\nused by the browser; to get the locale, use `i18n.getUILanguage`.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (languages: string[]) => void\n\n    * languages\n\nstring[]\n\nArray of LanguageCode\n\n#### Returns\n\n  * Promise<LanguageCode[]>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getMessage()\n\n    \n    \n    chrome.i18n.getMessage(  \n      messageName: string,  \n      substitutions?: any,  \n      options?: object,  \n    )\n\nGets the localized string for the specified message. If the message is\nmissing, this method returns an empty string (''). If the format of the\n`getMessage()` call is wrong  for example, _messageName_ is not a string or\nthe _substitutions_ array has more than 9 elements  this method returns\n`undefined`.\n\n#### Parameters\n\n  * messageName\n\nstring\n\nThe name of the message, as specified in the `messages.json` file.\n\n  * substitutions\n\nany optional\n\nUp to 9 substitution strings, if the message requires any.\n\n  * options\n\nobject optional\n\nChrome 79+\n\n    * escapeLt\n\nboolean optional\n\nEscape `<` in translation to `&lt;`. This applies only to the message itself,\nnot to the placeholders. Developers might want to use this if the translation\nis used in an HTML context. Closure Templates used with Closure Compiler\ngenerate this automatically.\n\n#### Returns\n\n  * string\n\nMessage localized for current locale.\n\n### getUILanguage()\n\n    \n    \n    chrome.i18n.getUILanguage()\n\nGets the browser UI language of the browser. This is different from\n`i18n.getAcceptLanguages` which returns the preferred user languages.\n\n#### Returns\n\n  * string\n\nThe browser UI language code such as en-US or fr-FR.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/identity": "#  chrome.identity\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.identity` API to get OAuth2 access tokens.\n\n## Permissions\n\n`identity`  \n\n## Types\n\n### AccountInfo\n\n#### Properties\n\n  * id\n\nstring\n\nA unique identifier for the account. This ID will not change for the lifetime\nof the account.\n\n### AccountStatus\n\nChrome 84+\n\n#### Enum\n\n\"SYNC\"  \nSpecifies that Sync is enabled for the primary account.\n\n\"ANY\"  \nSpecifies the existence of a primary account, if any.\n\n### GetAuthTokenResult\n\nChrome 105+\n\n#### Properties\n\n  * grantedScopes\n\nstring[] optional\n\nA list of OAuth2 scopes granted to the extension.\n\n  * token\n\nstring optional\n\nThe specific token associated with the request.\n\n### InvalidTokenDetails\n\n#### Properties\n\n  * token\n\nstring\n\nThe specific token that should be removed from the cache.\n\n### ProfileDetails\n\nChrome 84+\n\n#### Properties\n\n  * accountStatus\n\nAccountStatus optional\n\nA status of the primary account signed into a profile whose `ProfileUserInfo`\nshould be returned. Defaults to `SYNC` account status.\n\n### ProfileUserInfo\n\n#### Properties\n\n  * email\n\nstring\n\nAn email address for the user account signed into the current profile. Empty\nif the user is not signed in or the `identity.email` manifest permission is\nnot specified.\n\n  * id\n\nstring\n\nA unique identifier for the account. This ID will not change for the lifetime\nof the account. Empty if the user is not signed in or (in M41+) the\n`identity.email` manifest permission is not specified.\n\n### TokenDetails\n\n#### Properties\n\n  * account\n\nAccountInfo optional\n\nThe account ID whose token should be returned. If not specified, the function\nwill use an account from the Chrome profile: the Sync account if there is one,\nor otherwise the first Google web account.\n\n  * enableGranularPermissions\n\nboolean optional\n\nChrome 87+\n\nThe `enableGranularPermissions` flag allows extensions to opt-in early to the\ngranular permissions consent screen, in which requested permissions are\ngranted or denied individually.\n\n  * interactive\n\nboolean optional\n\nFetching a token may require the user to sign-in to Chrome, or approve the\napplication's requested scopes. If the interactive flag is `true`,\n`getAuthToken` will prompt the user as necessary. When the flag is `false` or\nomitted, `getAuthToken` will return failure any time a prompt would be\nrequired.\n\n  * scopes\n\nstring[] optional\n\nA list of OAuth2 scopes to request.\n\nWhen the `scopes` field is present, it overrides the list of scopes specified\nin manifest.json.\n\n### WebAuthFlowDetails\n\n#### Properties\n\n  * abortOnLoadForNonInteractive\n\nboolean optional\n\nChrome 113+\n\nWhether to terminate `launchWebAuthFlow` for non-interactive requests after\nthe page loads. This parameter does not affect interactive flows.\n\nWhen set to `true` (default) the flow will terminate immediately after the\npage loads. When set to `false`, the flow will only terminate after the\n`timeoutMsForNonInteractive` passes. This is useful for identity providers\nthat use JavaScript to perform redirections after the page loads.\n\n  * interactive\n\nboolean optional\n\nWhether to launch auth flow in interactive mode.\n\nSince some auth flows may immediately redirect to a result URL,\n`launchWebAuthFlow` hides its web view until the first navigation either\nredirects to the final URL, or finishes loading a page meant to be displayed.\n\nIf the `interactive` flag is `true`, the window will be displayed when a page\nload completes. If the flag is `false` or omitted, `launchWebAuthFlow` will\nreturn with an error if the initial navigation does not complete the flow.\n\nFor flows that use JavaScript for redirection, `abortOnLoadForNonInteractive`\ncan be set to `false` in combination with setting `timeoutMsForNonInteractive`\nto give the page a chance to perform any redirects.\n\n  * timeoutMsForNonInteractive\n\nnumber optional\n\nChrome 113+\n\nThe maximum amount of time, in miliseconds, `launchWebAuthFlow` is allowed to\nrun in non-interactive mode in total. Only has an effect if `interactive` is\n`false`.\n\n  * url\n\nstring\n\nThe URL that initiates the auth flow.\n\n## Methods\n\n### clearAllCachedAuthTokens()\n\nPromise Chrome 87+\n\n    \n    \n    chrome.identity.clearAllCachedAuthTokens(  \n      callback?: function,  \n    )\n\nResets the state of the Identity API:\n\n  * Removes all OAuth2 access tokens from the token cache\n  * Removes user's account preferences\n  * De-authorizes the user from all auth flows\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 106+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAccounts()\n\nPromise  Dev channel\n\n    \n    \n    chrome.identity.getAccounts(  \n      callback?: function,  \n    )\n\nRetrieves a list of AccountInfo objects describing the accounts present on the\nprofile.\n\n`getAccounts` is only supported on dev channel.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (accounts: AccountInfo[]) => void\n\n    * accounts\n\nAccountInfo[]\n\n#### Returns\n\n  * Promise<AccountInfo[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAuthToken()\n\nPromise\n\n    \n    \n    chrome.identity.getAuthToken(  \n      details?: TokenDetails,  \n      callback?: function,  \n    )\n\nGets an OAuth2 access token using the client ID and scopes specified in the\n`oauth2` section of manifest.json.\n\nThe Identity API caches access tokens in memory, so it's ok to call\n`getAuthToken` non-interactively any time a token is required. The token cache\nautomatically handles expiration.\n\nFor a good user experience it is important interactive token requests are\ninitiated by UI in your app explaining what the authorization is for. Failing\nto do this will cause your users to get authorization requests, or Chrome sign\nin screens if they are not signed in, with with no context. In particular, do\nnot use `getAuthToken` interactively when your app is first launched.\n\nNote: When called with a callback, instead of returning an object this\nfunction will return the two properties as separate arguments passed to the\ncallback.\n\n#### Parameters\n\n  * details\n\nTokenDetails optional\n\nToken options.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: GetAuthTokenResult) => void\n\n    * result\n\nGetAuthTokenResult\n\nChrome 105+\n\n#### Returns\n\n  * Promise<GetAuthTokenResult>\n\nChrome 105+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getProfileUserInfo()\n\nPromise\n\n    \n    \n    chrome.identity.getProfileUserInfo(  \n      details?: ProfileDetails,  \n      callback?: function,  \n    )\n\nRetrieves email address and obfuscated gaia id of the user signed into a\nprofile.\n\nRequires the `identity.email` manifest permission. Otherwise, returns an empty\nresult.\n\nThis API is different from identity.getAccounts in two ways. The information\nreturned is available offline, and it only applies to the primary account for\nthe profile.\n\n#### Parameters\n\n  * details\n\nProfileDetails optional\n\nChrome 84+\n\nProfile options.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (userInfo: ProfileUserInfo) => void\n\n    * userInfo\n\nProfileUserInfo\n\n#### Returns\n\n  * Promise<ProfileUserInfo>\n\nChrome 106+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getRedirectURL()\n\n    \n    \n    chrome.identity.getRedirectURL(  \n      path?: string,  \n    )\n\nGenerates a redirect URL to be used in `launchWebAuthFlow`.\n\nThe generated URLs match the pattern `https://<app-id>.chromiumapp.org/*`.\n\n#### Parameters\n\n  * path\n\nstring optional\n\nThe path appended to the end of the generated URL.\n\n#### Returns\n\n  * string\n\n### launchWebAuthFlow()\n\nPromise\n\n    \n    \n    chrome.identity.launchWebAuthFlow(  \n      details: WebAuthFlowDetails,  \n      callback?: function,  \n    )\n\nStarts an auth flow at the specified URL.\n\nThis method enables auth flows with non-Google identity providers by launching\na web view and navigating it to the first URL in the provider's auth flow.\nWhen the provider redirects to a URL matching the pattern `https://<app-\nid>.chromiumapp.org/*`, the window will close, and the final redirect URL will\nbe passed to the `callback` function.\n\nFor a good user experience it is important interactive auth flows are\ninitiated by UI in your app explaining what the authorization is for. Failing\nto do this will cause your users to get authorization requests with no\ncontext. In particular, do not launch an interactive auth flow when your app\nis first launched.\n\n#### Parameters\n\n  * details\n\nWebAuthFlowDetails\n\nWebAuth flow options.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (responseUrl?: string) => void\n\n    * responseUrl\n\nstring optional\n\n#### Returns\n\n  * Promise<string | undefined>\n\nChrome 106+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeCachedAuthToken()\n\nPromise\n\n    \n    \n    chrome.identity.removeCachedAuthToken(  \n      details: InvalidTokenDetails,  \n      callback?: function,  \n    )\n\nRemoves an OAuth2 access token from the Identity API's token cache.\n\nIf an access token is discovered to be invalid, it should be passed to\nremoveCachedAuthToken to remove it from the cache. The app may then retrieve a\nfresh token with `getAuthToken`.\n\n#### Parameters\n\n  * details\n\nInvalidTokenDetails\n\nToken information.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 106+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onSignInChanged\n\n    \n    \n    chrome.identity.onSignInChanged.addListener(  \n      callback: function,  \n    )\n\nFired when signin state changes for an account on the user's profile.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (account: AccountInfo, signedIn: boolean) => void\n\n    * account\n\nAccountInfo\n\n    * signedIn\n\nboolean\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/idle": "#  chrome.idle\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.idle` API to detect when the machine's idle state changes.\n\n## Permissions\n\n`idle`  \n\nYou must declare the `\"idle\"` permission in your extension's manifest to use\nthe idle API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"idle\"\n      ],\n      ...\n    }\n    \n\n## Types\n\n### IdleState\n\nChrome 44+\n\n#### Enum\n\n\"active\"  \n\n\"idle\"  \n\n\"locked\"  \n\n## Methods\n\n### getAutoLockDelay()\n\nPromise Chrome 73+  ChromeOS only\n\n    \n    \n    chrome.idle.getAutoLockDelay(  \n      callback?: function,  \n    )\n\nGets the time, in seconds, it takes until the screen is locked automatically\nwhile idle. Returns a zero duration if the screen is never locked\nautomatically. Currently supported on Chrome OS only.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (delay: number) => void\n\n    * delay\n\nnumber\n\nTime, in seconds, until the screen is locked automatically while idle. This is\nzero if the screen never locks automatically.\n\n#### Returns\n\n  * Promise<number>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### queryState()\n\nPromise\n\n    \n    \n    chrome.idle.queryState(  \n      detectionIntervalInSeconds: number,  \n      callback?: function,  \n    )\n\nReturns \"locked\" if the system is locked, \"idle\" if the user has not generated\nany input for a specified number of seconds, or \"active\" otherwise.\n\n#### Parameters\n\n  * detectionIntervalInSeconds\n\nnumber\n\nThe system is considered idle if detectionIntervalInSeconds seconds have\nelapsed since the last user input detected.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (newState: IdleState) => void\n\n    * newState\n\nIdleState\n\n#### Returns\n\n  * Promise<IdleState>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setDetectionInterval()\n\n    \n    \n    chrome.idle.setDetectionInterval(  \n      intervalInSeconds: number,  \n    )\n\nSets the interval, in seconds, used to determine when the system is in an idle\nstate for onStateChanged events. The default interval is 60 seconds.\n\n#### Parameters\n\n  * intervalInSeconds\n\nnumber\n\nThreshold, in seconds, used to determine when the system is in an idle state.\n\n## Events\n\n### onStateChanged\n\n    \n    \n    chrome.idle.onStateChanged.addListener(  \n      callback: function,  \n    )\n\nFired when the system changes to an active, idle or locked state. The event\nfires with \"locked\" if the screen is locked or the screensaver activates,\n\"idle\" if the system is unlocked and the user has not generated any input for\na specified number of seconds, and \"active\" when the user generates input on\nan idle system.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (newState: IdleState) => void\n\n    * newState\n\nIdleState\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/input/ime": "#  chrome.input.ime\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.input.ime` API to implement a custom IME for Chrome OS. This\nallows your extension to handle keystrokes, set the composition, and manage\nthe candidate window.\n\n## Permissions\n\n`input`  \n\nYou must declare the \"input\" permission in the extension manifest to use the\ninput.ime API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"input\"\n      ],\n      ...\n    }\n    \n\n## Availability\n\nChromeOS only\n\n## Examples\n\nThe following code creates an IME that converts typed letters to upper case.\n\n    \n    \n    var context_id = -1;\n    \n    chrome.input.ime.onFocus.addListener(function(context) {\n      context_id = context.contextID;\n    });\n    \n    chrome.input.ime.onKeyEvent.addListener(\n      function(engineID, keyData) {\n        if (keyData.type == \"keydown\" && keyData.key.match(/^[a-z]$/)) {\n          chrome.input.ime.commitText({\"contextID\": context_id,\n                                        \"text\": keyData.key.toUpperCase()});\n          return true;\n        } else {\n          return false;\n        }\n      }\n    );\n    \n\n## Types\n\n### AssistiveWindowButton\n\nChrome 85+\n\nID of buttons in assistive window.\n\n#### Enum\n\n\"undo\"  \n\n\"addToDictionary\"  \n\n### AssistiveWindowProperties\n\nChrome 85+\n\nProperties of the assistive window.\n\n#### Properties\n\n  * announceString\n\nstring optional\n\nStrings for ChromeVox to announce.\n\n  * type\n\n\"undo\"  \n\n  * visible\n\nboolean\n\nSets true to show AssistiveWindow, sets false to hide.\n\n### AssistiveWindowType\n\nChrome 85+\n\nType of assistive window.\n\n#### Value\n\n\"undo\"  \n\n### AutoCapitalizeType\n\nChrome 69+\n\nThe auto-capitalize type of the text field.\n\n#### Enum\n\n\"characters\"  \n\n\"words\"  \n\n\"sentences\"  \n\n### InputContext\n\nDescribes an input Context\n\n#### Properties\n\n  * autoCapitalize\n\nAutoCapitalizeType\n\nChrome 69+\n\nThe auto-capitalize type of the text field.\n\n  * autoComplete\n\nboolean\n\nWhether the text field wants auto-complete.\n\n  * autoCorrect\n\nboolean\n\nWhether the text field wants auto-correct.\n\n  * contextID\n\nnumber\n\nThis is used to specify targets of text field operations. This ID becomes\ninvalid as soon as onBlur is called.\n\n  * shouldDoLearning\n\nboolean\n\nChrome 68+\n\nWhether text entered into the text field should be used to improve typing\nsuggestions for the user.\n\n  * spellCheck\n\nboolean\n\nWhether the text field wants spell-check.\n\n  * type\n\nInputContextType\n\nType of value this text field edits, (Text, Number, URL, etc)\n\n### InputContextType\n\nChrome 44+\n\nType of value this text field edits, (Text, Number, URL, etc)\n\n#### Enum\n\n\"text\"  \n\n\"search\"  \n\n\"tel\"  \n\n\"url\"  \n\n\"email\"  \n\n\"number\"  \n\n\"password\"  \n\n\"null\"  \n\n### KeyboardEvent\n\nSee http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent\n\n#### Properties\n\n  * altKey\n\nboolean optional\n\nWhether or not the ALT key is pressed.\n\n  * altgrKey\n\nboolean optional\n\nChrome 79+\n\nWhether or not the ALTGR key is pressed.\n\n  * capsLock\n\nboolean optional\n\nWhether or not the CAPS_LOCK is enabled.\n\n  * code\n\nstring\n\nValue of the physical key being pressed. The value is not affected by current\nkeyboard layout or modifier state.\n\n  * ctrlKey\n\nboolean optional\n\nWhether or not the CTRL key is pressed.\n\n  * extensionId\n\nstring optional\n\nThe extension ID of the sender of this keyevent.\n\n  * key\n\nstring\n\nValue of the key being pressed\n\n  * keyCode\n\nnumber optional\n\nThe deprecated HTML keyCode, which is system- and implementation-dependent\nnumerical code signifying the unmodified identifier associated with the key\npressed.\n\n  * requestId\n\nstring optional\n\n(Deprecated) The ID of the request. Use the `requestId` param from the\n`onKeyEvent` event instead.\n\n  * shiftKey\n\nboolean optional\n\nWhether or not the SHIFT key is pressed.\n\n  * type\n\nKeyboardEventType\n\nOne of keyup or keydown.\n\n### KeyboardEventType\n\nChrome 44+\n\n#### Enum\n\n\"keyup\"  \n\n\"keydown\"  \n\n### MenuItem\n\nA menu item used by an input method to interact with the user from the\nlanguage menu.\n\n#### Properties\n\n  * checked\n\nboolean optional\n\nIndicates this item should be drawn with a check.\n\n  * enabled\n\nboolean optional\n\nIndicates this item is enabled.\n\n  * id\n\nstring\n\nString that will be passed to callbacks referencing this MenuItem.\n\n  * label\n\nstring optional\n\nText displayed in the menu for this item.\n\n  * style\n\nMenuItemStyle optional\n\nThe type of menu item.\n\n  * visible\n\nboolean optional\n\nIndicates this item is visible.\n\n### MenuItemStyle\n\nChrome 44+\n\nThe type of menu item. Radio buttons between separators are considered\ngrouped.\n\n#### Enum\n\n\"check\"  \n\n\"radio\"  \n\n\"separator\"  \n\n### MenuParameters\n\nChrome 88+\n\n#### Properties\n\n  * engineID\n\nstring\n\nID of the engine to use.\n\n  * items\n\nMenuItem[]\n\nMenuItems to add or update. They will be added in the order they exist in the\narray.\n\n### MouseButton\n\nChrome 44+\n\nWhich mouse buttons was clicked.\n\n#### Enum\n\n\"left\"  \n\n\"middle\"  \n\n\"right\"  \n\n### ScreenType\n\nChrome 44+\n\nThe screen type under which the IME is activated.\n\n#### Enum\n\n\"normal\"  \n\n\"login\"  \n\n\"lock\"  \n\n\"secondary-login\"  \n\n### UnderlineStyle\n\nChrome 44+\n\nThe type of the underline to modify this segment.\n\n#### Enum\n\n\"underline\"  \n\n\"doubleUnderline\"  \n\n\"noUnderline\"  \n\n### WindowPosition\n\nChrome 44+\n\nWhere to display the candidate window. If set to 'cursor', the window follows\nthe cursor. If set to 'composition', the window is locked to the beginning of\nthe composition.\n\n#### Enum\n\n\"cursor\"  \n\n\"composition\"  \n\n## Methods\n\n### clearComposition()\n\nPromise\n\n    \n    \n    chrome.input.ime.clearComposition(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nClear the current composition. If this extension does not own the active IME,\nthis fails.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * contextID\n\nnumber\n\nID of the context where the composition will be cleared\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### commitText()\n\nPromise\n\n    \n    \n    chrome.input.ime.commitText(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nCommits the provided text to the current input.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * contextID\n\nnumber\n\nID of the context where the text will be committed\n\n    * text\n\nstring\n\nThe text to commit\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### deleteSurroundingText()\n\nPromise\n\n    \n    \n    chrome.input.ime.deleteSurroundingText(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nDeletes the text around the caret.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * contextID\n\nnumber\n\nID of the context where the surrounding text will be deleted.\n\n    * engineID\n\nstring\n\nID of the engine receiving the event.\n\n    * length\n\nnumber\n\nThe number of characters to be deleted\n\n    * offset\n\nnumber\n\nThe offset from the caret position where deletion will start. This value can\nbe negative.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### hideInputView()\n\n    \n    \n    chrome.input.ime.hideInputView()\n\nHides the input view window, which is popped up automatically by system. If\nthe input view window is already hidden, this function will do nothing.\n\n### keyEventHandled()\n\n    \n    \n    chrome.input.ime.keyEventHandled(  \n      requestId: string,  \n      response: boolean,  \n    )\n\nIndicates that the key event received by onKeyEvent is handled. This should\nonly be called if the onKeyEvent listener is asynchronous.\n\n#### Parameters\n\n  * requestId\n\nstring\n\nRequest id of the event that was handled. This should come from\nkeyEvent.requestId\n\n  * response\n\nboolean\n\nTrue if the keystroke was handled, false if not\n\n### sendKeyEvents()\n\nPromise\n\n    \n    \n    chrome.input.ime.sendKeyEvents(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nSends the key events. This function is expected to be used by virtual\nkeyboards. When key(s) on a virtual keyboard is pressed by a user, this\nfunction is used to propagate that event to the system.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * contextID\n\nnumber\n\nID of the context where the key events will be sent, or zero to send key\nevents to non-input field.\n\n    * keyData\n\nKeyboardEvent[]\n\nData on the key event.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setAssistiveWindowButtonHighlighted()\n\nPromise Chrome 86+\n\n    \n    \n    chrome.input.ime.setAssistiveWindowButtonHighlighted(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nHighlights/Unhighlights a button in an assistive window.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * announceString\n\nstring optional\n\nThe text for the screenreader to announce.\n\n    * buttonID\n\nAssistiveWindowButton\n\nThe ID of the button\n\n    * contextID\n\nnumber\n\nID of the context owning the assistive window.\n\n    * highlighted\n\nboolean\n\nWhether the button should be highlighted.\n\n    * windowType\n\n\"undo\"  \n\nThe window type the button belongs to.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setAssistiveWindowProperties()\n\nPromise Chrome 85+\n\n    \n    \n    chrome.input.ime.setAssistiveWindowProperties(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nShows/Hides an assistive window with the given properties.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * contextID\n\nnumber\n\nID of the context owning the assistive window.\n\n    * properties\n\nAssistiveWindowProperties\n\nProperties of the assistive window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setCandidates()\n\nPromise\n\n    \n    \n    chrome.input.ime.setCandidates(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nSets the current candidate list. This fails if this extension doesn't own the\nactive IME\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * candidates\n\nobject[]\n\nList of candidates to show in the candidate window\n\n      * annotation\n\nstring optional\n\nAdditional text describing the candidate\n\n      * candidate\n\nstring\n\nThe candidate\n\n      * id\n\nnumber\n\nThe candidate's id\n\n      * label\n\nstring optional\n\nShort string displayed to next to the candidate, often the shortcut key or\nindex\n\n      * parentId\n\nnumber optional\n\nThe id to add these candidates under\n\n      * usage\n\nobject optional\n\nThe usage or detail description of word.\n\n        * body\n\nstring\n\nThe body string of detail description.\n\n        * title\n\nstring\n\nThe title string of details description.\n\n    * contextID\n\nnumber\n\nID of the context that owns the candidate window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setCandidateWindowProperties()\n\nPromise\n\n    \n    \n    chrome.input.ime.setCandidateWindowProperties(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nSets the properties of the candidate window. This fails if the extension\ndoesn't own the active IME\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * engineID\n\nstring\n\nID of the engine to set properties on.\n\n    * properties\n\nobject\n\n      * auxiliaryText\n\nstring optional\n\nText that is shown at the bottom of the candidate window.\n\n      * auxiliaryTextVisible\n\nboolean optional\n\nTrue to display the auxiliary text, false to hide it.\n\n      * currentCandidateIndex\n\nnumber optional\n\nChrome 84+\n\nThe index of the current chosen candidate out of total candidates.\n\n      * cursorVisible\n\nboolean optional\n\nTrue to show the cursor, false to hide it.\n\n      * pageSize\n\nnumber optional\n\nThe number of candidates to display per page.\n\n      * totalCandidates\n\nnumber optional\n\nChrome 84+\n\nThe total number of candidates for the candidate window.\n\n      * vertical\n\nboolean optional\n\nTrue if the candidate window should be rendered vertical, false to make it\nhorizontal.\n\n      * visible\n\nboolean optional\n\nTrue to show the Candidate window, false to hide it.\n\n      * windowPosition\n\nWindowPosition optional\n\nWhere to display the candidate window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setComposition()\n\nPromise\n\n    \n    \n    chrome.input.ime.setComposition(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nSet the current composition. If this extension does not own the active IME,\nthis fails.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * contextID\n\nnumber\n\nID of the context where the composition text will be set\n\n    * cursor\n\nnumber\n\nPosition in the text of the cursor.\n\n    * segments\n\nobject[] optional\n\nList of segments and their associated types.\n\n      * end\n\nnumber\n\nIndex of the character to end this segment after.\n\n      * start\n\nnumber\n\nIndex of the character to start this segment at\n\n      * style\n\nUnderlineStyle\n\nThe type of the underline to modify this segment.\n\n    * selectionEnd\n\nnumber optional\n\nPosition in the text that the selection ends at.\n\n    * selectionStart\n\nnumber optional\n\nPosition in the text that the selection starts at.\n\n    * text\n\nstring\n\nText to set\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setCursorPosition()\n\nPromise\n\n    \n    \n    chrome.input.ime.setCursorPosition(  \n      parameters: object,  \n      callback?: function,  \n    )\n\nSet the position of the cursor in the candidate window. This is a no-op if\nthis extension does not own the active IME.\n\n#### Parameters\n\n  * parameters\n\nobject\n\n    * candidateID\n\nnumber\n\nID of the candidate to select.\n\n    * contextID\n\nnumber\n\nID of the context that owns the candidate window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setMenuItems()\n\nPromise\n\n    \n    \n    chrome.input.ime.setMenuItems(  \n      parameters: MenuParameters,  \n      callback?: function,  \n    )\n\nAdds the provided menu items to the language menu when this IME is active.\n\n#### Parameters\n\n  * parameters\n\nMenuParameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### updateMenuItems()\n\nPromise\n\n    \n    \n    chrome.input.ime.updateMenuItems(  \n      parameters: MenuParameters,  \n      callback?: function,  \n    )\n\nUpdates the state of the MenuItems specified\n\n#### Parameters\n\n  * parameters\n\nMenuParameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 111+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onActivate\n\n    \n    \n    chrome.input.ime.onActivate.addListener(  \n      callback: function,  \n    )\n\nThis event is sent when an IME is activated. It signals that the IME will be\nreceiving onKeyPress events.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (engineID: string, screen: ScreenType) => void\n\n    * engineID\n\nstring\n\n    * screen\n\nScreenType\n\n### onAssistiveWindowButtonClicked\n\nChrome 85+\n\n    \n    \n    chrome.input.ime.onAssistiveWindowButtonClicked.addListener(  \n      callback: function,  \n    )\n\nThis event is sent when a button in an assistive window is clicked.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * buttonID\n\nAssistiveWindowButton\n\nThe ID of the button clicked.\n\n      * windowType\n\nAssistiveWindowType\n\nThe type of the assistive window.\n\n### onBlur\n\n    \n    \n    chrome.input.ime.onBlur.addListener(  \n      callback: function,  \n    )\n\nThis event is sent when focus leaves a text box. It is sent to all extensions\nthat are listening to this event, and enabled by the user.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (contextID: number) => void\n\n    * contextID\n\nnumber\n\n### onCandidateClicked\n\n    \n    \n    chrome.input.ime.onCandidateClicked.addListener(  \n      callback: function,  \n    )\n\nThis event is sent if this extension owns the active IME.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (engineID: string, candidateID: number, button: MouseButton) => void\n\n    * engineID\n\nstring\n\n    * candidateID\n\nnumber\n\n    * button\n\nMouseButton\n\n### onDeactivated\n\n    \n    \n    chrome.input.ime.onDeactivated.addListener(  \n      callback: function,  \n    )\n\nThis event is sent when an IME is deactivated. It signals that the IME will no\nlonger be receiving onKeyPress events.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (engineID: string) => void\n\n    * engineID\n\nstring\n\n### onFocus\n\n    \n    \n    chrome.input.ime.onFocus.addListener(  \n      callback: function,  \n    )\n\nThis event is sent when focus enters a text box. It is sent to all extensions\nthat are listening to this event, and enabled by the user.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (context: InputContext) => void\n\n    * context\n\nInputContext\n\n### onInputContextUpdate\n\n    \n    \n    chrome.input.ime.onInputContextUpdate.addListener(  \n      callback: function,  \n    )\n\nThis event is sent when the properties of the current InputContext change,\nsuch as the the type. It is sent to all extensions that are listening to this\nevent, and enabled by the user.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (context: InputContext) => void\n\n    * context\n\nInputContext\n\n### onKeyEvent\n\n    \n    \n    chrome.input.ime.onKeyEvent.addListener(  \n      callback: function,  \n    )\n\nFired when a key event is sent from the operating system. The event will be\nsent to the extension if this extension owns the active IME. The listener\nfunction should return true if the event was handled false if it was not. If\nthe event will be evaluated asynchronously, this function must return\nundefined and the IME must later call keyEventHandled() with the result.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (engineID: string, keyData: KeyboardEvent, requestId: string) => boolean | undefined\n\n    * engineID\n\nstring\n\n    * keyData\n\nKeyboardEvent\n\n    * requestId\n\nstring\n\n    * returns\n\nboolean | undefined\n\n### onMenuItemActivated\n\n    \n    \n    chrome.input.ime.onMenuItemActivated.addListener(  \n      callback: function,  \n    )\n\nCalled when the user selects a menu item\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (engineID: string, name: string) => void\n\n    * engineID\n\nstring\n\n    * name\n\nstring\n\n### onReset\n\n    \n    \n    chrome.input.ime.onReset.addListener(  \n      callback: function,  \n    )\n\nThis event is sent when chrome terminates ongoing text input session.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (engineID: string) => void\n\n    * engineID\n\nstring\n\n### onSurroundingTextChanged\n\n    \n    \n    chrome.input.ime.onSurroundingTextChanged.addListener(  \n      callback: function,  \n    )\n\nCalled when the editable string around caret is changed or when the caret\nposition is moved. The text length is limited to 100 characters for each back\nand forth direction.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (engineID: string, surroundingInfo: object) => void\n\n    * engineID\n\nstring\n\n    * surroundingInfo\n\nobject\n\n      * anchor\n\nnumber\n\nThe beginning position of the selection. This value indicates caret position\nif there is no selection.\n\n      * focus\n\nnumber\n\nThe ending position of the selection. This value indicates caret position if\nthere is no selection.\n\n      * offset\n\nnumber\n\nChrome 46+\n\nThe offset position of `text`. Since `text` only includes a subset of text\naround the cursor, offset indicates the absolute position of the first\ncharacter of `text`.\n\n      * text\n\nstring\n\nThe text around the cursor. This is only a subset of all text in the input\nfield.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/instanceID": "#  chrome.instanceID\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse `chrome.instanceID` to access the Instance ID service.\n\n## Permissions\n\n`gcm`  \n\n## Availability\n\nChrome 44+\n\n## Methods\n\n### deleteID()\n\nPromise\n\n    \n    \n    chrome.instanceID.deleteID(  \n      callback?: function,  \n    )\n\nResets the app instance identifier and revokes all tokens associated with it.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### deleteToken()\n\nPromise\n\n    \n    \n    chrome.instanceID.deleteToken(  \n      deleteTokenParams: object,  \n      callback?: function,  \n    )\n\nRevokes a granted token.\n\n#### Parameters\n\n  * deleteTokenParams\n\nobject\n\nParameters for deleteToken.\n\n    * authorizedEntity\n\nstring\n\nChrome 46+\n\nThe authorized entity that is used to obtain the token.\n\n    * scope\n\nstring\n\nChrome 46+\n\nThe scope that is used to obtain the token.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getCreationTime()\n\nPromise\n\n    \n    \n    chrome.instanceID.getCreationTime(  \n      callback?: function,  \n    )\n\nRetrieves the time when the InstanceID has been generated. The creation time\nwill be returned by the `callback`.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (creationTime: number) => void\n\n    * creationTime\n\nnumber\n\nThe time when the Instance ID has been generated, represented in milliseconds\nsince the epoch.\n\n#### Returns\n\n  * Promise<number>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getID()\n\nPromise\n\n    \n    \n    chrome.instanceID.getID(  \n      callback?: function,  \n    )\n\nRetrieves an identifier for the app instance. The instance ID will be returned\nby the `callback`. The same ID will be returned as long as the application\nidentity has not been revoked or expired.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (instanceID: string) => void\n\n    * instanceID\n\nstring\n\nAn Instance ID assigned to the app instance.\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getToken()\n\nPromise\n\n    \n    \n    chrome.instanceID.getToken(  \n      getTokenParams: object,  \n      callback?: function,  \n    )\n\nReturn a token that allows the authorized entity to access the service defined\nby scope.\n\n#### Parameters\n\n  * getTokenParams\n\nobject\n\nParameters for getToken.\n\n    * authorizedEntity\n\nstring\n\nChrome 46+\n\nIdentifies the entity that is authorized to access resources associated with\nthis Instance ID. It can be a project ID from Google developer console.\n\n    * options\n\nobject optional\n\nChrome 46+  Deprecated since Chrome 89\n\noptions are deprecated and will be ignored.\n\nAllows including a small number of string key/value pairs that will be\nassociated with the token and may be used in processing the request.\n\n    * scope\n\nstring\n\nChrome 46+\n\nIdentifies authorized actions that the authorized entity can take. E.g. for\nsending GCM messages, `GCM` scope should be used.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (token: string) => void\n\n    * token\n\nstring\n\nA token assigned by the requested service.\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onTokenRefresh\n\n    \n    \n    chrome.instanceID.onTokenRefresh.addListener(  \n      callback: function,  \n    )\n\nFired when all the granted tokens need to be refreshed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/loginState": "#  chrome.loginState\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.loginState` API to read and monitor the login state.\n\n## Permissions\n\n`loginState`  \n\n## Availability\n\nChrome 78+  ChromeOS only\n\n## Types\n\n### ProfileType\n\n#### Enum\n\n\"SIGNIN_PROFILE\"  \nSpecifies that the extension is in the signin profile.\n\n\"USER_PROFILE\"  \nSpecifies that the extension is in the user profile.\n\n### SessionState\n\n#### Enum\n\n\"UNKNOWN\"  \nSpecifies that the session state is unknown.\n\n\"IN_OOBE_SCREEN\"  \nSpecifies that the user is in the out-of-box-experience screen.\n\n\"IN_LOGIN_SCREEN\"  \nSpecifies that the user is in the login screen.\n\n\"IN_SESSION\"  \nSpecifies that the user is in the session.\n\n\"IN_LOCK_SCREEN\"  \nSpecifies that the user is in the lock screen.\n\n\"IN_RMA_SCREEN\"  \nSpecifies that the device is in RMA mode, finalizing repairs.\n\n## Methods\n\n### getProfileType()\n\nPromise\n\n    \n    \n    chrome.loginState.getProfileType(  \n      callback?: function,  \n    )\n\nGets the type of the profile the extension is in.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ProfileType) => void\n\n    * result\n\nProfileType\n\n#### Returns\n\n  * Promise<ProfileType>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getSessionState()\n\nPromise\n\n    \n    \n    chrome.loginState.getSessionState(  \n      callback?: function,  \n    )\n\nGets the current session state.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: SessionState) => void\n\n    * result\n\nSessionState\n\n#### Returns\n\n  * Promise<SessionState>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onSessionStateChanged\n\n    \n    \n    chrome.loginState.onSessionStateChanged.addListener(  \n      callback: function,  \n    )\n\nDispatched when the session state changes. `sessionState` is the new session\nstate.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (sessionState: SessionState) => void\n\n    * sessionState\n\nSessionState\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/management": "#  chrome.management\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.management` API provides ways to manage installed apps and\nextensions.\n\n## Permissions\n\n`management`  \n\nYou must declare the \"management\" permission in the extension manifest to use\nthe management API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"management\"\n      ],\n      ...\n    }\n    \n\n`management.getPermissionWarningsByManifest()`, `management.uninstallSelf()`,\nand `management.getSelf()` do not require the management permission.\n\n## Types\n\n### ExtensionDisabledReason\n\nChrome 44+\n\nA reason the item is disabled.\n\n#### Enum\n\n\"unknown\"  \n\n\"permissions_increase\"  \n\n### ExtensionInfo\n\nInformation about an installed extension, app, or theme.\n\n#### Properties\n\n  * appLaunchUrl\n\nstring optional\n\nThe launch url (only present for apps).\n\n  * availableLaunchTypes\n\nLaunchType[] optional\n\nThe currently available launch types (only present for apps).\n\n  * description\n\nstring\n\nThe description of this extension, app, or theme.\n\n  * disabledReason\n\nExtensionDisabledReason optional\n\nA reason the item is disabled.\n\n  * enabled\n\nboolean\n\nWhether it is currently enabled or disabled.\n\n  * homepageUrl\n\nstring optional\n\nThe URL of the homepage of this extension, app, or theme.\n\n  * hostPermissions\n\nstring[]\n\nReturns a list of host based permissions.\n\n  * icons\n\nIconInfo[] optional\n\nA list of icon information. Note that this just reflects what was declared in\nthe manifest, and the actual image at that url may be larger or smaller than\nwhat was declared, so you might consider using explicit width and height\nattributes on img tags referencing these images. See the manifest\ndocumentation on icons for more details.\n\n  * id\n\nstring\n\nThe extension's unique identifier.\n\n  * installType\n\nExtensionInstallType\n\nHow the extension was installed.\n\n  * isApp\n\nboolean\n\nDeprecated\n\nPlease use `management.ExtensionInfo.type`.\n\nTrue if this is an app.\n\n  * launchType\n\nLaunchType optional\n\nThe app launch type (only present for apps).\n\n  * mayDisable\n\nboolean\n\nWhether this extension can be disabled or uninstalled by the user.\n\n  * mayEnable\n\nboolean optional\n\nChrome 62+\n\nWhether this extension can be enabled by the user. This is only returned for\nextensions which are not enabled.\n\n  * name\n\nstring\n\nThe name of this extension, app, or theme.\n\n  * offlineEnabled\n\nboolean\n\nWhether the extension, app, or theme declares that it supports offline.\n\n  * optionsUrl\n\nstring\n\nThe url for the item's options page, if it has one.\n\n  * permissions\n\nstring[]\n\nReturns a list of API based permissions.\n\n  * shortName\n\nstring\n\nA short version of the name of this extension, app, or theme.\n\n  * type\n\nExtensionType\n\nThe type of this extension, app, or theme.\n\n  * updateUrl\n\nstring optional\n\nThe update URL of this extension, app, or theme.\n\n  * version\n\nstring\n\nThe version of this extension, app, or theme.\n\n  * versionName\n\nstring optional\n\nChrome 50+\n\nThe version name of this extension, app, or theme if the manifest specified\none.\n\n### ExtensionInstallType\n\nChrome 44+\n\nHow the extension was installed. One of `admin`: The extension was installed\nbecause of an administrative policy, `development`: The extension was loaded\nunpacked in developer mode, `normal`: The extension was installed normally via\na .crx file, `sideload`: The extension was installed by other software on the\nmachine, `other`: The extension was installed by other means.\n\n#### Enum\n\n\"admin\"  \n\n\"development\"  \n\n\"normal\"  \n\n\"sideload\"  \n\n\"other\"  \n\n### ExtensionType\n\nChrome 44+\n\nThe type of this extension, app, or theme.\n\n#### Enum\n\n\"extension\"  \n\n\"hosted_app\"  \n\n\"packaged_app\"  \n\n\"legacy_packaged_app\"  \n\n\"theme\"  \n\n\"login_screen_extension\"  \n\n### IconInfo\n\nInformation about an icon belonging to an extension, app, or theme.\n\n#### Properties\n\n  * size\n\nnumber\n\nA number representing the width and height of the icon. Likely values include\n(but are not limited to) 128, 48, 24, and 16.\n\n  * url\n\nstring\n\nThe URL for this icon image. To display a grayscale version of the icon (to\nindicate that an extension is disabled, for example), append `?grayscale=true`\nto the URL.\n\n### LaunchType\n\nThese are all possible app launch types.\n\n#### Enum\n\n\"OPEN_AS_REGULAR_TAB\"  \n\n\"OPEN_AS_PINNED_TAB\"  \n\n\"OPEN_AS_WINDOW\"  \n\n\"OPEN_FULL_SCREEN\"  \n\n### UninstallOptions\n\nChrome 88+\n\nOptions for how to handle the extension's uninstallation.\n\n#### Properties\n\n  * showConfirmDialog\n\nboolean optional\n\nWhether or not a confirm-uninstall dialog should prompt the user. Defaults to\nfalse for self uninstalls. If an extension uninstalls another extension, this\nparameter is ignored and the dialog is always shown.\n\n## Methods\n\n### createAppShortcut()\n\nPromise\n\n    \n    \n    chrome.management.createAppShortcut(  \n      id: string,  \n      callback?: function,  \n    )\n\nDisplay options to create shortcuts for an app. On Mac, only packaged app\nshortcuts can be created.\n\n#### Parameters\n\n  * id\n\nstring\n\nThis should be the id from an app item of `management.ExtensionInfo`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### generateAppForLink()\n\nPromise\n\n    \n    \n    chrome.management.generateAppForLink(  \n      url: string,  \n      title: string,  \n      callback?: function,  \n    )\n\nGenerate an app for a URL. Returns the generated bookmark app.\n\n#### Parameters\n\n  * url\n\nstring\n\nThe URL of a web page. The scheme of the URL can only be \"http\" or \"https\".\n\n  * title\n\nstring\n\nThe title of the generated app.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ExtensionInfo) => void\n\n    * result\n\nExtensionInfo\n\n#### Returns\n\n  * Promise<ExtensionInfo>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### get()\n\nPromise\n\n    \n    \n    chrome.management.get(  \n      id: string,  \n      callback?: function,  \n    )\n\nReturns information about the installed extension, app, or theme that has the\ngiven ID.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe ID from an item of `management.ExtensionInfo`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ExtensionInfo) => void\n\n    * result\n\nExtensionInfo\n\n#### Returns\n\n  * Promise<ExtensionInfo>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.management.getAll(  \n      callback?: function,  \n    )\n\nReturns a list of information about installed extensions and apps.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ExtensionInfo[]) => void\n\n    * result\n\nExtensionInfo[]\n\n#### Returns\n\n  * Promise<ExtensionInfo[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPermissionWarningsById()\n\nPromise\n\n    \n    \n    chrome.management.getPermissionWarningsById(  \n      id: string,  \n      callback?: function,  \n    )\n\nReturns a list of permission warnings for the given extension id.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe ID of an already installed extension.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (permissionWarnings: string[]) => void\n\n    * permissionWarnings\n\nstring[]\n\n#### Returns\n\n  * Promise<string[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPermissionWarningsByManifest()\n\nPromise\n\n    \n    \n    chrome.management.getPermissionWarningsByManifest(  \n      manifestStr: string,  \n      callback?: function,  \n    )\n\nReturns a list of permission warnings for the given extension manifest string.\nNote: This function can be used without requesting the 'management' permission\nin the manifest.\n\n#### Parameters\n\n  * manifestStr\n\nstring\n\nExtension manifest JSON string.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (permissionWarnings: string[]) => void\n\n    * permissionWarnings\n\nstring[]\n\n#### Returns\n\n  * Promise<string[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getSelf()\n\nPromise\n\n    \n    \n    chrome.management.getSelf(  \n      callback?: function,  \n    )\n\nReturns information about the calling extension, app, or theme. Note: This\nfunction can be used without requesting the 'management' permission in the\nmanifest.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: ExtensionInfo) => void\n\n    * result\n\nExtensionInfo\n\n#### Returns\n\n  * Promise<ExtensionInfo>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### installReplacementWebApp()\n\nPromise Chrome 77+\n\n    \n    \n    chrome.management.installReplacementWebApp(  \n      callback?: function,  \n    )\n\nLaunches the replacement_web_app specified in the manifest. Prompts the user\nto install if not already installed.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### launchApp()\n\nPromise\n\n    \n    \n    chrome.management.launchApp(  \n      id: string,  \n      callback?: function,  \n    )\n\nLaunches an application.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe extension id of the application.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setEnabled()\n\nPromise\n\n    \n    \n    chrome.management.setEnabled(  \n      id: string,  \n      enabled: boolean,  \n      callback?: function,  \n    )\n\nEnables or disables an app or extension. In most cases this function must be\ncalled in the context of a user gesture (e.g. an onclick handler for a\nbutton), and may present the user with a native confirmation UI as a way of\npreventing abuse.\n\n#### Parameters\n\n  * id\n\nstring\n\nThis should be the id from an item of `management.ExtensionInfo`.\n\n  * enabled\n\nboolean\n\nWhether this item should be enabled or disabled.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setLaunchType()\n\nPromise\n\n    \n    \n    chrome.management.setLaunchType(  \n      id: string,  \n      launchType: LaunchType,  \n      callback?: function,  \n    )\n\nSet the launch type of an app.\n\n#### Parameters\n\n  * id\n\nstring\n\nThis should be the id from an app item of `management.ExtensionInfo`.\n\n  * launchType\n\nLaunchType\n\nThe target launch type. Always check and make sure this launch type is in\n`ExtensionInfo.availableLaunchTypes`, because the available launch types vary\non different platforms and configurations.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### uninstall()\n\nPromise\n\n    \n    \n    chrome.management.uninstall(  \n      id: string,  \n      options?: UninstallOptions,  \n      callback?: function,  \n    )\n\nUninstalls a currently installed app or extension. Note: This function does\nnot work in managed environments when the user is not allowed to uninstall the\nspecified extension/app. If the uninstall fails (e.g. the user cancels the\ndialog) the promise will be rejected or the callback will be called with\n`runtime.lastError` set.\n\n#### Parameters\n\n  * id\n\nstring\n\nThis should be the id from an item of `management.ExtensionInfo`.\n\n  * options\n\nUninstallOptions optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### uninstallSelf()\n\nPromise\n\n    \n    \n    chrome.management.uninstallSelf(  \n      options?: UninstallOptions,  \n      callback?: function,  \n    )\n\nUninstalls the calling extension. Note: This function can be used without\nrequesting the 'management' permission in the manifest. This function does not\nwork in managed environments when the user is not allowed to uninstall the\nspecified extension/app.\n\n#### Parameters\n\n  * options\n\nUninstallOptions optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onDisabled\n\n    \n    \n    chrome.management.onDisabled.addListener(  \n      callback: function,  \n    )\n\nFired when an app or extension has been disabled.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (info: ExtensionInfo) => void\n\n    * info\n\nExtensionInfo\n\n### onEnabled\n\n    \n    \n    chrome.management.onEnabled.addListener(  \n      callback: function,  \n    )\n\nFired when an app or extension has been enabled.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (info: ExtensionInfo) => void\n\n    * info\n\nExtensionInfo\n\n### onInstalled\n\n    \n    \n    chrome.management.onInstalled.addListener(  \n      callback: function,  \n    )\n\nFired when an app or extension has been installed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (info: ExtensionInfo) => void\n\n    * info\n\nExtensionInfo\n\n### onUninstalled\n\n    \n    \n    chrome.management.onUninstalled.addListener(  \n      callback: function,  \n    )\n\nFired when an app or extension has been uninstalled.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string) => void\n\n    * id\n\nstring\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/notifications": "#  chrome.notifications\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.notifications` API to create rich notifications using\ntemplates and show these notifications to users in the system tray.\n\n## Permissions\n\n`notifications`  \n\n## Types\n\n### NotificationBitmap\n\n### NotificationButton\n\n#### Properties\n\n  * iconUrl\n\nstring optional\n\nDeprecated since Chrome 59\n\nButton icons not visible for Mac OS X users.\n\n  * title\n\nstring\n\n### NotificationItem\n\n#### Properties\n\n  * message\n\nstring\n\nAdditional details about this item.\n\n  * title\n\nstring\n\nTitle of one item of a list notification.\n\n### NotificationOptions\n\n#### Properties\n\n  * appIconMaskUrl\n\nstring optional\n\nDeprecated since Chrome 59\n\nThe app icon mask is not visible for Mac OS X users.\n\nA URL to the app icon mask. URLs have the same restrictions as iconUrl.\n\nThe app icon mask should be in alpha channel, as only the alpha channel of the\nimage will be considered.\n\n  * buttons\n\nNotificationButton[] optional\n\nText and icons for up to two notification action buttons.\n\n  * contextMessage\n\nstring optional\n\nAlternate notification content with a lower-weight font.\n\n  * eventTime\n\nnumber optional\n\nA timestamp associated with the notification, in milliseconds past the epoch\n(e.g. `Date.now() + n`).\n\n  * iconUrl\n\nstring optional\n\nA URL to the sender's avatar, app icon, or a thumbnail for image\nnotifications.\n\nURLs can be a data URL, a blob URL, or a URL relative to a resource within\nthis extension's .crx file\n\n**Note:**This value is required for the `notifications.create``()` method.\n\n  * imageUrl\n\nstring optional\n\nDeprecated since Chrome 59\n\nThe image is not visible for Mac OS X users.\n\nA URL to the image thumbnail for image-type notifications. URLs have the same\nrestrictions as iconUrl.\n\n  * isClickable\n\nboolean optional\n\nDeprecated since Chrome 67\n\nThis UI hint is ignored as of Chrome 67\n\n  * items\n\nNotificationItem[] optional\n\nItems for multi-item notifications. Users on Mac OS X only see the first item.\n\n  * message\n\nstring optional\n\nMain notification content.\n\n**Note:**This value is required for the `notifications.create``()` method.\n\n  * priority\n\nnumber optional\n\nPriority ranges from -2 to 2. -2 is lowest priority. 2 is highest. Zero is\ndefault. On platforms that don't support a notification center (Windows, Linux\n& Mac), -2 and -1 result in an error as notifications with those priorities\nwill not be shown at all.\n\n  * progress\n\nnumber optional\n\nCurrent progress ranges from 0 to 100.\n\n  * requireInteraction\n\nboolean optional\n\nChrome 50+\n\nIndicates that the notification should remain visible on screen until the user\nactivates or dismisses the notification. This defaults to false.\n\n  * silent\n\nboolean optional\n\nChrome 70+\n\nIndicates that no sounds or vibrations should be made when the notification is\nbeing shown. This defaults to false.\n\n  * title\n\nstring optional\n\nTitle of the notification (e.g. sender name for email).\n\n**Note:**This value is required for the `notifications.create``()` method.\n\n  * type\n\nTemplateType optional\n\nWhich type of notification to display. _Required for`notifications.create`_\nmethod.\n\n### PermissionLevel\n\n#### Enum\n\n\"granted\"  \nSpecifies that the user has elected to show notifications from the app or\nextension. This is the default at install time.\n\n\"denied\"  \nSpecifies that the user has elected not to show notifications from the app or\nextension.\n\n### TemplateType\n\n#### Enum\n\n\"basic\"  \nContains an icon, title, message, expandedMessage, and up to two buttons.\n\n\"image\"  \nContains an icon, title, message, expandedMessage, image, and up to two\nbuttons.\n\n\"list\"  \nContains an icon, title, message, items, and up to two buttons. Users on Mac\nOS X only see the first item.\n\n\"progress\"  \nContains an icon, title, message, progress, and up to two buttons.\n\n## Methods\n\n### clear()\n\nPromise\n\n    \n    \n    chrome.notifications.clear(  \n      notificationId: string,  \n      callback?: function,  \n    )\n\nClears the specified notification.\n\n#### Parameters\n\n  * notificationId\n\nstring\n\nThe id of the notification to be cleared. This is returned by\n`notifications.create` method.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (wasCleared: boolean) => void\n\n    * wasCleared\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### create()\n\nPromise\n\n    \n    \n    chrome.notifications.create(  \n      notificationId?: string,  \n      options: NotificationOptions,  \n      callback?: function,  \n    )\n\nCreates and displays a notification.\n\n#### Parameters\n\n  * notificationId\n\nstring optional\n\nIdentifier of the notification. If not set or empty, an ID will automatically\nbe generated. If it matches an existing notification, this method first clears\nthat notification before proceeding with the create operation. The identifier\nmay not be longer than 500 characters.\n\nThe `notificationId` parameter is required before Chrome 42.\n\n  * options\n\nNotificationOptions\n\nContents of the notification.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (notificationId: string) => void\n\n    * notificationId\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.notifications.getAll(  \n      callback?: function,  \n    )\n\nRetrieves all the notifications of this app or extension.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (notifications: object) => void\n\n    * notifications\n\nobject\n\n#### Returns\n\n  * Promise<object>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPermissionLevel()\n\nPromise\n\n    \n    \n    chrome.notifications.getPermissionLevel(  \n      callback?: function,  \n    )\n\nRetrieves whether the user has enabled notifications from this app or\nextension.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (level: PermissionLevel) => void\n\n    * level\n\nPermissionLevel\n\n#### Returns\n\n  * Promise<PermissionLevel>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### update()\n\nPromise\n\n    \n    \n    chrome.notifications.update(  \n      notificationId: string,  \n      options: NotificationOptions,  \n      callback?: function,  \n    )\n\nUpdates an existing notification.\n\n#### Parameters\n\n  * notificationId\n\nstring\n\nThe id of the notification to be updated. This is returned by\n`notifications.create` method.\n\n  * options\n\nNotificationOptions\n\nContents of the notification to update to.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (wasUpdated: boolean) => void\n\n    * wasUpdated\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onButtonClicked\n\n    \n    \n    chrome.notifications.onButtonClicked.addListener(  \n      callback: function,  \n    )\n\nThe user pressed a button in the notification.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (notificationId: string, buttonIndex: number) => void\n\n    * notificationId\n\nstring\n\n    * buttonIndex\n\nnumber\n\n### onClicked\n\n    \n    \n    chrome.notifications.onClicked.addListener(  \n      callback: function,  \n    )\n\nThe user clicked in a non-button area of the notification.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (notificationId: string) => void\n\n    * notificationId\n\nstring\n\n### onClosed\n\n    \n    \n    chrome.notifications.onClosed.addListener(  \n      callback: function,  \n    )\n\nThe notification closed, either by the system or by user action.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (notificationId: string, byUser: boolean) => void\n\n    * notificationId\n\nstring\n\n    * byUser\n\nboolean\n\n### onPermissionLevelChanged\n\n    \n    \n    chrome.notifications.onPermissionLevelChanged.addListener(  \n      callback: function,  \n    )\n\nThe user changes the permission level. As of Chrome 47, only ChromeOS has UI\nthat dispatches this event.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (level: PermissionLevel) => void\n\n    * level\n\nPermissionLevel\n\n### onShowSettings\n\nDeprecated since Chrome 65\n\n    \n    \n    chrome.notifications.onShowSettings.addListener(  \n      callback: function,  \n    )\n\nCustom notification settings button is no longer supported.\n\nThe user clicked on a link for the app's notification settings. As of Chrome\n47, only ChromeOS has UI that dispatches this event. As of Chrome 65, that UI\nhas been removed from ChromeOS, too.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/offscreen": "#  chrome.offscreen\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `offscreen` API to create and manage offscreen documents.\n\n## Permissions\n\n`offscreen`  \n\nTo use the Offscreen API, declare the `\"offscreen\"` permission in the\nextension manifest. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"offscreen\"\n      ],\n      ...\n    }\n    \n\n## Availability\n\nChrome 109+ MV3+\n\n## Concepts and usage\n\nService workers don't have DOM access, and many websites have content security\npolicies that limit the functionality of content scripts. The Offscreen API\nallows the extension to use DOM APIs in a hidden document without interrupting\nthe user experience by opening new windows or tabs. The `runtime` API is the\nonly extensions API supported by offscreen documents.\n\nPages loaded as offscreen documents are handled differently from other types\nof extension pages. The extension's permissions carry over to offscreen\ndocuments, but with limits on extension API access. For example, because the\n`chrome.runtime` API is the only extensions API supported by offscreen\ndocuments, messaging must be handled using members of that API.\n\nThe following are other ways offscreen documents behave differently from\nnormal pages:\n\n  * An offscreen document's URL must be a static HTML file bundled with the extension.\n  * Offscreen documents can't be focused.\n  * An offscreen document is an instance of `window`, but the value of its `opener` property is always `null`.\n  * Though an extension package can contain multiple offscreen documents, an installed extension can only have one open at a time. If the extension is running in split mode with an active incognito profile, the normal and incognito profiles can each have one offscreen document.\n\nUse `chrome.offscreen.createDocument()` and `chrome.offscreen.closeDocument()`\nto create and close an offscreen document. `createDocument()` requires the\ndocument's `url`, a reason, and a justification:\n\n    \n    \n    chrome.offscreen.createDocument({\n      url: 'off_screen.html',\n      reasons: ['CLIPBOARD'],\n      justification: 'reason for needing the document',\n    });\n    \n\n### Reasons\n\nFor a list of valid reasons, see the Reasons section. Reasons are set during\ndocument creation to determine the document's lifespan. The `AUDIO_PLAYBACK`\nreason sets the document to close after 30 seconds without audio playing. All\nother reasons don't set lifetime limits.\n\n## Examples\n\n### Maintain the lifecycle of an offscreen document\n\nThe following example shows how to ensure that an offscreen document exists.\nThe `setupOffscreenDocument()` function calls `runtime.getContexts()` to find\nan existing offscreen document, or creates the document if it doesn't already\nexist.\n\n    \n    \n    let creating; // A global promise to avoid concurrency issues\n    async function setupOffscreenDocument(path) {\n      // Check all windows controlled by the service worker to see if one\n      // of them is the offscreen document with the given path\n      const offscreenUrl = chrome.runtime.getURL(path);\n      const existingContexts = await chrome.runtime.getContexts({\n        contextTypes: ['OFFSCREEN_DOCUMENT'],\n        documentUrls: [offscreenUrl]\n      });\n    \n      if (existingContexts.length > 0) {\n        return;\n      }\n    \n      // create offscreen document\n      if (creating) {\n        await creating;\n      } else {\n        creating = chrome.offscreen.createDocument({\n          url: path,\n          reasons: ['CLIPBOARD'],\n          justification: 'reason for needing the document',\n        });\n        await creating;\n        creating = null;\n      }\n    }\n    \n\nBefore sending a message to an offscreen document, call\n`setupOffscreenDocument()` to make sure the document exists, as demonstrated\nin the following example.\n\n    \n    \n    chrome.action.onClicked.addListener(async () => {\n      await setupOffscreenDocument('off_screen.html');\n    \n      // Send message to offscreen document\n      chrome.runtime.sendMessage({\n        type: '...',\n        target: 'offscreen',\n        data: '...'\n      });\n    });\n    \n\nFor complete examples, see the offscreen-clipboard and offscreen-dom demos on\nGitHub.\n\n### Before Chrome 116: check if an offscreen document is open\n\n`runtime.getContexts()` was added in Chrome 116. In earlier versions of\nChrome, use `clients.matchAll()` to check for an existing offscreen document:\n\n    \n    \n    async function hasOffscreenDocument() {\n      if ('getContexts' in chrome.runtime) {\n        const contexts = await chrome.runtime.getContexts({\n          contextTypes: ['OFFSCREEN_DOCUMENT'],\n          documentUrls: [OFFSCREEN_DOCUMENT_PATH]\n        });\n        return Boolean(contexts.length);\n      } else {\n        const matchedClients = await clients.matchAll();\n        return matchedClients.some(client => {\n          return client.url.includes(chrome.runtime.id);\n        });\n      }\n    }\n    \n\n## Types\n\n### CreateParameters\n\n#### Properties\n\n  * justification\n\nstring\n\nA developer-provided string that explains, in more detail, the need for the\nbackground context. The user agent _may_ use this in display to the user.\n\n  * reasons\n\nReason[]\n\nThe reason(s) the extension is creating the offscreen document.\n\n  * url\n\nstring\n\nThe (relative) URL to load in the document.\n\n### Reason\n\n#### Enum\n\n\"TESTING\"  \nA reason used for testing purposes only.\n\n\"AUDIO_PLAYBACK\"  \nSpecifies that the offscreen document is responsible for playing audio.\n\n\"IFRAME_SCRIPTING\"  \nSpecifies that the offscreen document needs to embed and script an iframe in\norder to modify the iframe's content.\n\n\"DOM_SCRAPING\"  \nSpecifies that the offscreen document needs to embed an iframe and scrape its\nDOM to extract information.\n\n\"BLOBS\"  \nSpecifies that the offscreen document needs to interact with Blob objects\n(including `URL.createObjectURL()`).\n\n\"DOM_PARSER\"  \nSpecifies that the offscreen document needs to use the DOMParser API.\n\n\"USER_MEDIA\"  \nSpecifies that the offscreen document needs to interact with media streams\nfrom user media (e.g. `getUserMedia()`).\n\n\"DISPLAY_MEDIA\"  \nSpecifies that the offscreen document needs to interact with media streams\nfrom display media (e.g. `getDisplayMedia()`).\n\n\"WEB_RTC\"  \nSpecifies that the offscreen document needs to use WebRTC APIs.\n\n\"CLIPBOARD\"  \nSpecifies that the offscreen document needs to interact with the Clipboard\nAPI.\n\n\"LOCAL_STORAGE\"  \nSpecifies that the offscreen document needs access to localStorage.\n\n\"WORKERS\"  \nSpecifies that the offscreen document needs to spawn workers.\n\n\"BATTERY_STATUS\"  \nSpecifies that the offscreen document needs to use navigator.getBattery.\n\n\"MATCH_MEDIA\"  \nSpecifies that the offscreen document needs to use window.matchMedia.\n\n\"GEOLOCATION\"  \nSpecifies that the offscreen document needs to use navigator.geolocation.\n\n## Methods\n\n### closeDocument()\n\nPromise\n\n    \n    \n    chrome.offscreen.closeDocument(  \n      callback?: function,  \n    )\n\nCloses the currently-open offscreen document for the extension.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### createDocument()\n\nPromise\n\n    \n    \n    chrome.offscreen.createDocument(  \n      parameters: CreateParameters,  \n      callback?: function,  \n    )\n\nCreates a new offscreen document for the extension.\n\n#### Parameters\n\n  * parameters\n\nCreateParameters\n\nThe parameters describing the offscreen document to create.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/omnibox": "#  chrome.omnibox\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe omnibox API allows you to register a keyword with Google Chrome's address\nbar, which is also known as the omnibox.\n\n![A screenshot showing suggestions related to the keyword 'Chromium\nSearch'](/static/docs/extensions/mv2/reference/omnibox/images/omnibox.png)\n\nWhen the user enters your extension's keyword, the user starts interacting\nsolely with your extension. Each keystroke is sent to your extension, and you\ncan provide suggestions in response.\n\nThe suggestions can be richly formatted in a variety of ways. When the user\naccepts a suggestion, your extension is notified and can take action.\n\n## Manifest\n\nThe following keys must be declared in the manifest to use this API.\n\n`\"omnibox\"`  \n\nYou must include an `\"omnibox.keyword\"` field in the manifest to use the\nomnibox API. You should also specify a 16 by 16-pixel icon, which will be\ndisplayed in the address bar when suggesting that users enter keyword mode.\n\nFor example:\n\n    \n    \n    {\n      \"name\": \"Aaron's omnibox extension\",\n      \"version\": \"1.0\",\n      \"omnibox\": { \"keyword\" : \"aaron\" },\n      \"icons\": {\n        \"16\": \"16-full-color.png\"\n      },\n      \"background\": {\n        \"persistent\": false,\n        \"scripts\": [\"background.js\"]\n      }\n    }\n    \n\n**Note:** Chrome automatically creates a grayscale version of your 16x16-pixel\nicon. You should provide a full-color version so that it can also be used in\nother situations that require color. For example, the context menus API also\nuses a 16x16-pixel icon, but it is displayed in color.\n\n## Examples\n\nTo try this API, install the omnibox API example from the chrome-extension-\nsamples repository.\n\n## Types\n\n### DefaultSuggestResult\n\nA suggest result.\n\n#### Properties\n\n  * description\n\nstring\n\nThe text that is displayed in the URL dropdown. Can contain XML-style markup\nfor styling. The supported tags are 'url' (for a literal URL), 'match' (for\nhighlighting text that matched what the user's query), and 'dim' (for dim\nhelper text). The styles can be nested, eg. dimmed match.\n\n### DescriptionStyleType\n\nChrome 44+\n\nThe style type.\n\n#### Enum\n\n\"url\"  \n\n\"match\"  \n\n\"dim\"  \n\n### OnInputEnteredDisposition\n\nChrome 44+\n\nThe window disposition for the omnibox query. This is the recommended context\nto display results. For example, if the omnibox command is to navigate to a\ncertain URL, a disposition of 'newForegroundTab' means the navigation should\ntake place in a new selected tab.\n\n#### Enum\n\n\"currentTab\"  \n\n\"newForegroundTab\"  \n\n\"newBackgroundTab\"  \n\n### SuggestResult\n\nA suggest result.\n\n#### Properties\n\n  * content\n\nstring\n\nThe text that is put into the URL bar, and that is sent to the extension when\nthe user chooses this entry.\n\n  * deletable\n\nboolean optional\n\nChrome 63+\n\nWhether the suggest result can be deleted by the user.\n\n  * description\n\nstring\n\nThe text that is displayed in the URL dropdown. Can contain XML-style markup\nfor styling. The supported tags are 'url' (for a literal URL), 'match' (for\nhighlighting text that matched what the user's query), and 'dim' (for dim\nhelper text). The styles can be nested, eg. dimmed match. You must escape the\nfive predefined entities to display them as text:\nstackoverflow.com/a/1091953/89484\n\n## Methods\n\n### setDefaultSuggestion()\n\nPromise\n\n    \n    \n    chrome.omnibox.setDefaultSuggestion(  \n      suggestion: DefaultSuggestResult,  \n      callback?: function,  \n    )\n\nSets the description and styling for the default suggestion. The default\nsuggestion is the text that is displayed in the first suggestion row\nunderneath the URL bar.\n\n#### Parameters\n\n  * suggestion\n\nDefaultSuggestResult\n\nA partial SuggestResult object, without the 'content' parameter.\n\n  * callback\n\nfunction optional\n\nChrome 100+\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 100+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onDeleteSuggestion\n\nChrome 63+\n\n    \n    \n    chrome.omnibox.onDeleteSuggestion.addListener(  \n      callback: function,  \n    )\n\nUser has deleted a suggested result.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (text: string) => void\n\n    * text\n\nstring\n\n### onInputCancelled\n\n    \n    \n    chrome.omnibox.onInputCancelled.addListener(  \n      callback: function,  \n    )\n\nUser has ended the keyword input session without accepting the input.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onInputChanged\n\n    \n    \n    chrome.omnibox.onInputChanged.addListener(  \n      callback: function,  \n    )\n\nUser has changed what is typed into the omnibox.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (text: string, suggest: function) => void\n\n    * text\n\nstring\n\n    * suggest\n\nfunction\n\nThe `suggest` parameter looks like:\n\n          \n          (suggestResults: SuggestResult[]) => void\n\n      * suggestResults\n\nSuggestResult[]\n\nArray of suggest results\n\n### onInputEntered\n\n    \n    \n    chrome.omnibox.onInputEntered.addListener(  \n      callback: function,  \n    )\n\nUser has accepted what is typed into the omnibox.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (text: string, disposition: OnInputEnteredDisposition) => void\n\n    * text\n\nstring\n\n    * disposition\n\nOnInputEnteredDisposition\n\n### onInputStarted\n\n    \n    \n    chrome.omnibox.onInputStarted.addListener(  \n      callback: function,  \n    )\n\nUser has started a keyword input session by typing the extension's keyword.\nThis is guaranteed to be sent exactly once per input session, and before any\nonInputChanged events.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/pageCapture": "#  chrome.pageCapture\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.pageCapture` API to save a tab as MHTML.\n\nMHTML is a standard format supported by most browsers. It encapsulates in a\nsingle file a page and all its resources (CSS files, images..).\n\nNote that for security reasons a MHTML file can only be loaded from the file\nsystem and that it can only be loaded in the main frame.\n\n## Permissions\n\n`pageCapture`  \n\nYou must declare the \"pageCapture\" permission in the extension manifest to use\nthe pageCapture API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"pageCapture\"\n      ],\n      ...\n    }\n    \n\n## Methods\n\n### saveAsMHTML()\n\nPromise\n\n    \n    \n    chrome.pageCapture.saveAsMHTML(  \n      details: object,  \n      callback?: function,  \n    )\n\nSaves the content of the tab with given id as MHTML.\n\n#### Parameters\n\n  * details\n\nobject\n\n    * tabId\n\nnumber\n\nThe id of the tab to save as MHTML.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (mhtmlData?: Blob) => void\n\n    * mhtmlData\n\nBlob optional\n\nThe MHTML data as a Blob.\n\n#### Returns\n\n  * Promise<Blob | undefined>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/permissions": "#  chrome.permissions\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.permissions` API to request declared optional permissions at\nrun time rather than install time, so users understand why the permissions are\nneeded and grant only those that are necessary.\n\n## Concepts and usage\n\nPermission warnings exist to describe the capabilities granted by an API, but\nsome of these warnings may not be obvious. The Permissions API allows\ndevelopers to explain permission warnings and introduce new features gradually\nwhich gives users a risk-free introduction to the extension. This way, users\ncan specify how much access they are willing to grant and which features they\nwant to enable.\n\nFor example, the optional permissions extension's core functionality is\noverriding the new tab page. One feature is displaying the user's goal of the\nday. This feature only requires the storage permission, which does not include\na warning. The extension has an additional feature, that users can enable by\nclicking the following button:\n\n![An extension button that enables additional\nfeatures.](/static/docs/extensions/reference/api/permissions/images/extension-\nbutton-enables-c53fe17733b8f.png) An extension button that enables additional\nfeatures.\n\nDisplaying the user's top sites requires the topSites permission, which has\nthe following warning.\n\n![Axtension warning for topSites\nAPI.](/static/docs/extensions/reference/api/permissions/images/extension-\nwarning-topsit-8927d6b7cb863.png) An extension warning for `topSites` API\n\n### Implement optional permissions\n\n#### Step 1: Decide which permissions are required and which are optional\n\nAn extension can declare both required and optional permissions. In general,\nyou should:\n\n  * Use required permissions when they are needed for your extension's basic functionality.\n  * Use optional permissions when they are needed for optional features in your extension.\n\nAdvantages of _required_ permissions:\n\n  * **Fewer prompts:** An extension can prompt the user once to accept all permissions.\n  * **Simpler development:** Required permissions are guaranteed to be present.\n\nAdvantages of _optional_ permissions:\n\n  * **Better security:** Extensions run with fewer permissions since users only enable permissions that are needed.\n  * **Better information for users:** An extension can explain why it needs a particular permission when the user enables the relevant feature.\n  * **Easier upgrades:** When you upgrade your extension, Chrome won't disable it for your users if the upgrade adds optional rather than required permissions.\n\n#### Step 2: Declare optional permissions in the manifest\n\nDeclare optional permissions in your extension manifest with the\n`optional_permissions` key, using the same format as the permissions field:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"optional_permissions\": [\"tabs\"],\n      \"optional_host_permissions\": [\"https://www.google.com/\"],\n      ...\n    }\n    \n\nIf you want to request hosts that you only discover at runtime, include\n`\"https://*/*\"` in your extension's `optional_host_permissions` field. This\nlets you specify any origin in `\"Permissions.origins\"` as long as it has a\nmatching scheme.\n\n**Permissions that can _not_ be specified as optional**\n\nMost Chrome extension permissions can be specified as optional, with the\nfollowing exceptions.\n\nPermission | Description  \n---|---  \n`\"debugger\"` | The chrome.debugger API serves as an alternate transport for Chrome's remote debugging protocol.  \n`\"declarativeNetRequest\"` | Grants the extension access to the  chrome.declarativeNetRequest API.  \n`\"devtools\"` | Allows extension to expand Chrome DevTools functionality.  \n`\"geolocation\"` | Allows the extension to use the HTML5 geolocation API.  \n`\"mdns\"` | Grants the extension access to the chrome.mdns API.  \n`\"proxy\"` | Grants the extension access to the chrome.proxy API to manage Chrome's proxy settings.  \n`\"tts\"` | The chrome.tts API plays synthesized text-to-speech (TTS).  \n`\"ttsEngine\"` | The chrome.ttsEngine API implements a text-to-speech (TTS) engine using an extension.  \n`\"wallpaper\"` | **ChromeOS only**. Use the chrome.wallpaper API change the ChromeOS wallpaper.  \n  \nView Declare Permissions for further information on available permissions and\ntheir warnings.\n\n#### Step 3: Request optional permissions\n\nRequest the permissions from within a user gesture using\n`permissions.request()`:\n\n    \n    \n    document.querySelector('#my-button').addEventListener('click', (event) => {\n      // Permissions must be requested from inside a user gesture, like a button's\n      // click handler.\n      chrome.permissions.request({\n        permissions: ['tabs'],\n        origins: ['https://www.google.com/']\n      }, (granted) => {\n        // The callback argument will be true if the user granted the permissions.\n        if (granted) {\n          doSomething();\n        } else {\n          doSomethingElse();\n        }\n      });\n    });\n    \n\nChrome prompts the user if adding the permissions results in different warning\nmessages than the user has already seen and accepted. For example, the\nprevious code might result in a prompt like this:\n\n![An example permission confirmation\nprompt.](/static/docs/extensions/reference/api/permissions/images/perms-\noptional.png) An example permission confirmation prompt.\n\n#### Step 4: Check the extension's current permissions\n\nTo check whether your extension has a specific permission or set of\npermissions, use `permission.contains()`:\n\n    \n    \n    chrome.permissions.contains({\n      permissions: ['tabs'],\n      origins: ['https://www.google.com/']\n    }, (result) => {\n      if (result) {\n        // The extension has the permissions.\n      } else {\n        // The extension doesn't have the permissions.\n      }\n    });\n    \n\n#### Step 5: Remove the permissions\n\nYou should remove permissions when you no longer need them. After a permission\nhas been removed, calling `permissions.request()` usually adds the permission\nback without prompting the user.\n\n    \n    \n    chrome.permissions.remove({\n      permissions: ['tabs'],\n      origins: ['https://www.google.com/']\n    }, (removed) => {\n      if (removed) {\n        // The permissions have been removed.\n      } else {\n        // The permissions have not been removed (e.g., you tried to remove\n        // required permissions).\n      }\n    });\n    \n\n## Types\n\n### Permissions\n\n#### Properties\n\n  * origins\n\nstring[] optional\n\nThe list of host permissions, including those specified in the\n`optional_permissions` or `permissions` keys in the manifest, and those\nassociated with Content Scripts.\n\n  * permissions\n\nstring[] optional\n\nList of named permissions (does not include hosts or origins).\n\n## Methods\n\n### addHostAccessRequest()\n\nPromise Chrome 133+ MV3+\n\n    \n    \n    chrome.permissions.addHostAccessRequest(  \n      request: object,  \n      callback?: function,  \n    )\n\nAdds a host access request. Request will only be signaled to the user if\nextension can be granted access to the host in the request. Request will be\nreset on cross-origin navigation. When accepted, grants persistent access to\nthe sites top origin\n\n#### Parameters\n\n  * request\n\nobject\n\n    * documentId\n\nstring optional\n\nThe id of a document where host access requests can be shown. Must be the top-\nlevel document within a tab. If provided, the request is shown on the tab of\nthe specified document and is removed when the document navigates to a new\norigin. Adding a new request will override any existent request for `tabId`.\nThis or `tabId` must be specified.\n\n    * pattern\n\nstring optional\n\nThe URL pattern where host access requests can be shown. If provided, host\naccess requests will only be shown on URLs that match this pattern.\n\n    * tabId\n\nnumber optional\n\nThe id of the tab where host access requests can be shown. If provided, the\nrequest is shown on the specified tab and is removed when the tab navigates to\na new origin. Adding a new request will override an existent request for\n`documentId`. This or `documentId` must be specified.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### contains()\n\nPromise\n\n    \n    \n    chrome.permissions.contains(  \n      permissions: Permissions,  \n      callback?: function,  \n    )\n\nChecks if the extension has the specified permissions.\n\n#### Parameters\n\n  * permissions\n\nPermissions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: boolean) => void\n\n    * result\n\nboolean\n\nTrue if the extension has the specified permissions. If an origin is specified\nas both an optional permission and a content script match pattern, this will\nreturn `false` unless both permissions are granted.\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.permissions.getAll(  \n      callback?: function,  \n    )\n\nGets the extension's current set of permissions.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (permissions: Permissions) => void\n\n    * permissions\n\nPermissions\n\nThe extension's active permissions. Note that the `origins` property will\ncontain granted origins from those specified in the `permissions` and\n`optional_permissions` keys in the manifest and those associated with Content\nScripts.\n\n#### Returns\n\n  * Promise<Permissions>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### remove()\n\nPromise\n\n    \n    \n    chrome.permissions.remove(  \n      permissions: Permissions,  \n      callback?: function,  \n    )\n\nRemoves access to the specified permissions. If there are any problems\nremoving the permissions, `runtime.lastError` will be set.\n\n#### Parameters\n\n  * permissions\n\nPermissions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (removed: boolean) => void\n\n    * removed\n\nboolean\n\nTrue if the permissions were removed.\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeHostAccessRequest()\n\nPromise Chrome 133+ MV3+\n\n    \n    \n    chrome.permissions.removeHostAccessRequest(  \n      request: object,  \n      callback?: function,  \n    )\n\nRemoves a host access request, if existent.\n\n#### Parameters\n\n  * request\n\nobject\n\n    * documentId\n\nstring optional\n\nThe id of a document where host access request will be removed. Must be the\ntop-level document within a tab. This or `tabId` must be specified.\n\n    * pattern\n\nstring optional\n\nThe URL pattern where host access request will be removed. If provided, this\nmust exactly match the pattern of an existing host access request.\n\n    * tabId\n\nnumber optional\n\nThe id of the tab where host access request will be removed. This or\n`documentId` must be specified.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### request()\n\nPromise\n\n    \n    \n    chrome.permissions.request(  \n      permissions: Permissions,  \n      callback?: function,  \n    )\n\nRequests access to the specified permissions, displaying a prompt to the user\nif necessary. These permissions must either be defined in the\n`optional_permissions` field of the manifest or be required permissions that\nwere withheld by the user. Paths on origin patterns will be ignored. You can\nrequest subsets of optional origin permissions; for example, if you specify\n`*://*\\/*` in the `optional_permissions` section of the manifest, you can\nrequest `http://example.com/`. If there are any problems requesting the\npermissions, `runtime.lastError` will be set.\n\n#### Parameters\n\n  * permissions\n\nPermissions\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (granted: boolean) => void\n\n    * granted\n\nboolean\n\nTrue if the user granted the specified permissions.\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onAdded\n\n    \n    \n    chrome.permissions.onAdded.addListener(  \n      callback: function,  \n    )\n\nFired when the extension acquires new permissions.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (permissions: Permissions) => void\n\n    * permissions\n\nPermissions\n\n### onRemoved\n\n    \n    \n    chrome.permissions.onRemoved.addListener(  \n      callback: function,  \n    )\n\nFired when access to permissions has been removed from the extension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (permissions: Permissions) => void\n\n    * permissions\n\nPermissions\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/platformKeys": "#  chrome.platformKeys\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.platformKeys` API to access client certificates managed by the\nplatform. If the user or policy grants the permission, an extension can use\nsuch a certficate in its custom authentication protocol. E.g. this allows\nusage of platform managed certificates in third party VPNs (see\nchrome.vpnProvider).\n\n## Permissions\n\n`platformKeys`  \n\n## Availability\n\nChrome 45+  ChromeOS only\n\n## Types\n\n### ClientCertificateRequest\n\n#### Properties\n\n  * certificateAuthorities\n\nArrayBuffer[]\n\nList of distinguished names of certificate authorities allowed by the server.\nEach entry must be a DER-encoded X.509 DistinguishedName.\n\n  * certificateTypes\n\nClientCertificateType[]\n\nThis field is a list of the types of certificates requested, sorted in order\nof the server's preference. Only certificates of a type contained in this list\nwill be retrieved. If `certificateTypes` is the empty list, however,\ncertificates of any type will be returned.\n\n### ClientCertificateType\n\n#### Enum\n\n\"rsaSign\"  \n\n\"ecdsaSign\"  \n\n### Match\n\n#### Properties\n\n  * certificate\n\nArrayBuffer\n\nThe DER encoding of a X.509 certificate.\n\n  * keyAlgorithm\n\nobject\n\nThe KeyAlgorithm of the certified key. This contains algorithm parameters that\nare inherent to the key of the certificate (e.g. the key length). Other\nparameters like the hash function used by the sign function are not included.\n\n### SelectDetails\n\n#### Properties\n\n  * clientCerts\n\nArrayBuffer[] optional\n\nIf given, the `selectClientCertificates` operates on this list. Otherwise,\nobtains the list of all certificates from the platform's certificate stores\nthat are available to this extensions. Entries that the extension doesn't have\npermission for or which doesn't match the request, are removed.\n\n  * interactive\n\nboolean\n\nIf true, the filtered list is presented to the user to manually select a\ncertificate and thereby granting the extension access to the certificate(s)\nand key(s). Only the selected certificate(s) will be returned. If is false,\nthe list is reduced to all certificates that the extension has been granted\naccess to (automatically or manually).\n\n  * request\n\nClientCertificateRequest\n\nOnly certificates that match this request will be returned.\n\n### VerificationDetails\n\n#### Properties\n\n  * hostname\n\nstring\n\nThe hostname of the server to verify the certificate for, e.g. the server that\npresented the `serverCertificateChain`.\n\n  * serverCertificateChain\n\nArrayBuffer[]\n\nEach chain entry must be the DER encoding of a X.509 certificate, the first\nentry must be the server certificate and each entry must certify the entry\npreceding it.\n\n### VerificationResult\n\n#### Properties\n\n  * debug_errors\n\nstring[]\n\nIf the trust verification failed, this array contains the errors reported by\nthe underlying network layer. Otherwise, this array is empty.\n\n**Note:** This list is meant for debugging only and may not contain all\nrelevant errors. The errors returned may change in future revisions of this\nAPI, and are not guaranteed to be forwards or backwards compatible.\n\n  * trusted\n\nboolean\n\nThe result of the trust verification: true if trust for the given verification\ndetails could be established and false if trust is rejected for any reason.\n\n## Methods\n\n### getKeyPair()\n\n    \n    \n    chrome.platformKeys.getKeyPair(  \n      certificate: ArrayBuffer,  \n      parameters: object,  \n      callback: function,  \n    )\n\nPasses the key pair of `certificate` for usage with\n`platformKeys.subtleCrypto` to `callback`.\n\n#### Parameters\n\n  * certificate\n\nArrayBuffer\n\nThe certificate of a `Match` returned by `selectClientCertificates`.\n\n  * parameters\n\nobject\n\nDetermines signature/hash algorithm parameters additionally to the parameters\nfixed by the key itself. The same parameters are accepted as by WebCrypto's\nimportKey function, e.g. `RsaHashedImportParams` for a RSASSA-PKCS1-v1_5 key\nand `EcKeyImportParams` for EC key. Additionally for RSASSA-PKCS1-v1_5 keys,\nhashing algorithm name parameter can be specified with one of the following\nvalues: \"none\", \"SHA-1\", \"SHA-256\", \"SHA-384\", or \"SHA-512\", e.g. `{\"hash\": {\n\"name\": \"none\" } }`. The sign function will then apply PKCS#1 v1.5 padding but\nnot hash the given data.\n\nCurrently, this method only supports the \"RSASSA-PKCS1-v1_5\" and \"ECDSA\"\nalgorithms.\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (publicKey: object, privateKey?: object) => void\n\n    * publicKey\n\nobject\n\n    * privateKey\n\nobject optional\n\nMight be `null` if this extension does not have access to it.\n\n### getKeyPairBySpki()\n\nChrome 85+\n\n    \n    \n    chrome.platformKeys.getKeyPairBySpki(  \n      publicKeySpkiDer: ArrayBuffer,  \n      parameters: object,  \n      callback: function,  \n    )\n\nPasses the key pair identified by `publicKeySpkiDer` for usage with\n`platformKeys.subtleCrypto` to `callback`.\n\n#### Parameters\n\n  * publicKeySpkiDer\n\nArrayBuffer\n\nA DER-encoded X.509 SubjectPublicKeyInfo, obtained e.g. by calling WebCrypto's\nexportKey function with format=\"spki\".\n\n  * parameters\n\nobject\n\nProvides signature and hash algorithm parameters, in addition to those fixed\nby the key itself. The same parameters are accepted as by WebCrypto's\nimportKey function, e.g. `RsaHashedImportParams` for a RSASSA-PKCS1-v1_5 key.\nFor RSASSA-PKCS1-v1_5 keys, we need to also pass a \"hash\" parameter `{ \"hash\":\n{ \"name\": string } }`. The \"hash\" parameter represents the name of the hashing\nalgorithm to be used in the digest operation before a sign. It is possible to\npass \"none\" as the hash name, in which case the sign function will apply\nPKCS#1 v1.5 padding and but not hash the given data.\n\nCurrently, this method supports the \"ECDSA\" algorithm with named-curve P-256\nand \"RSASSA-PKCS1-v1_5\" algorithm with one of the hashing algorithms \"none\",\n\"SHA-1\", \"SHA-256\", \"SHA-384\", and \"SHA-512\".\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (publicKey: object, privateKey?: object) => void\n\n    * publicKey\n\nobject\n\n    * privateKey\n\nobject optional\n\nMight be `null` if this extension does not have access to it.\n\n### selectClientCertificates()\n\nPromise\n\n    \n    \n    chrome.platformKeys.selectClientCertificates(  \n      details: SelectDetails,  \n      callback?: function,  \n    )\n\nThis method filters from a list of client certificates the ones that are known\nto the platform, match `request` and for which the extension has permission to\naccess the certificate and its private key. If `interactive` is true, the user\nis presented a dialog where they can select from matching certificates and\ngrant the extension access to the certificate. The selected/filtered client\ncertificates will be passed to `callback`.\n\n#### Parameters\n\n  * details\n\nSelectDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (matches: Match[]) => void\n\n    * matches\n\nMatch[]\n\nThe list of certificates that match the request, that the extension has\npermission for and, if `interactive` is true, that were selected by the user.\n\n#### Returns\n\n  * Promise<Match[]>\n\nChrome 121+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### subtleCrypto()\n\n    \n    \n    chrome.platformKeys.subtleCrypto()\n\nAn implementation of WebCrypto's SubtleCrypto that allows crypto operations on\nkeys of client certificates that are available to this extension.\n\n#### Returns\n\n  * object | undefined\n\n### verifyTLSServerCertificate()\n\nPromise\n\n    \n    \n    chrome.platformKeys.verifyTLSServerCertificate(  \n      details: VerificationDetails,  \n      callback?: function,  \n    )\n\nChecks whether `details.serverCertificateChain` can be trusted for\n`details.hostname` according to the trust settings of the platform. Note: The\nactual behavior of the trust verification is not fully specified and might\nchange in the future. The API implementation verifies certificate expiration,\nvalidates the certification path and checks trust by a known CA. The\nimplementation is supposed to respect the EKU serverAuth and to support\nsubject alternative names.\n\n#### Parameters\n\n  * details\n\nVerificationDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: VerificationResult) => void\n\n    * result\n\nVerificationResult\n\n#### Returns\n\n  * Promise<VerificationResult>\n\nChrome 121+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/vpnProvider": "#  chrome.vpnProvider\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.vpnProvider` API to implement a VPN client.\n\n## Permissions\n\n`vpnProvider`  \n\n## Availability\n\nChrome 43+  ChromeOS only\n\n## Concepts and usage\n\nTypical usage of `chrome.vpnProvider` is as follows:\n\n  * Create VPN configurations by calling `createConfig()`. A VPN configuration is a persistent entry shown to the user in a ChromeOS UI. The user can select a VPN configuration from a list and connect to it or disconnect from it.\n\n  * Add listeners to the `onPlatformMessage`, `onPacketReceived`, and `onConfigRemoved` events.\n\n  * When the user connects to the VPN configuration, `onPlatformMessage` will be received with the message `\"connected\"`. The period between the `\"connected\"` and `\"disconnected\"` messages is called a \"VPN session\". In this time period, the extension that receives the message is said to own the VPN session.\n\n  * Initiate connection to the VPN server and start the VPN client.\n\n  * Set the Parameters of the connection by calling `setParameters()`.\n\n  * Notify the connection state as `\"connected\"` by calling `notifyConnectionStateChanged()`.\n\n  * When the steps previous are completed without errors, a virtual tunnel is created to the network stack of ChromeOS. IP packets can be sent through the tunnel by calling `sendPacket()` and any packets originating on the ChromeOS device will be received using the `onPacketReceived` event handler.\n\n  * When the user disconnects from the VPN configuration, `onPlatformMessage` will be fired with the message `\"disconnected\"`.\n\n  * If the VPN configuration is no longer necessary, it can be destroyed by calling `destroyConfig()`.\n\n## Types\n\n### Parameters\n\n#### Properties\n\n  * address\n\nstring\n\nIP address for the VPN interface in CIDR notation. IPv4 is currently the only\nsupported mode.\n\n  * broadcastAddress\n\nstring optional\n\nBroadcast address for the VPN interface. (default: deduced from IP address and\nmask)\n\n  * dnsServers\n\nstring[]\n\nA list of IPs for the DNS servers.\n\n  * domainSearch\n\nstring[] optional\n\nA list of search domains. (default: no search domain)\n\n  * exclusionList\n\nstring[]\n\nExclude network traffic to the list of IP blocks in CIDR notation from the\ntunnel. This can be used to bypass traffic to and from the VPN server. When\nmany rules match a destination, the rule with the longest matching prefix\nwins. Entries that correspond to the same CIDR block are treated as\nduplicates. Such duplicates in the collated (exclusionList + inclusionList)\nlist are eliminated and the exact duplicate entry that will be eliminated is\nundefined.\n\n  * inclusionList\n\nstring[]\n\nInclude network traffic to the list of IP blocks in CIDR notation to the\ntunnel. This parameter can be used to set up a split tunnel. By default no\ntraffic is directed to the tunnel. Adding the entry \"0.0.0.0/0\" to this list\ngets all the user traffic redirected to the tunnel. When many rules match a\ndestination, the rule with the longest matching prefix wins. Entries that\ncorrespond to the same CIDR block are treated as duplicates. Such duplicates\nin the collated (exclusionList + inclusionList) list are eliminated and the\nexact duplicate entry that will be eliminated is undefined.\n\n  * mtu\n\nstring optional\n\nMTU setting for the VPN interface. (default: 1500 bytes)\n\n  * reconnect\n\nstring optional\n\nChrome 51+\n\nWhether or not the VPN extension implements auto-reconnection.\n\nIf true, the `linkDown`, `linkUp`, `linkChanged`, `suspend`, and `resume`\nplatform messages will be used to signal the respective events. If false, the\nsystem will forcibly disconnect the VPN if the network topology changes, and\nthe user will need to reconnect manually. (default: false)\n\nThis property is new in Chrome 51; it will generate an exception in earlier\nversions. try/catch can be used to conditionally enable the feature based on\nbrowser support.\n\n### PlatformMessage\n\nThe enum is used by the platform to notify the client of the VPN session\nstatus.\n\n#### Enum\n\n\"connected\"  \nIndicates that the VPN configuration connected.\n\n\"disconnected\"  \nIndicates that the VPN configuration disconnected.\n\n\"error\"  \nIndicates that an error occurred in VPN connection, for example a timeout. A\ndescription of the error is given as the error argument to onPlatformMessage.\n\n\"linkDown\"  \nIndicates that the default physical network connection is down.\n\n\"linkUp\"  \nIndicates that the default physical network connection is back up.\n\n\"linkChanged\"  \nIndicates that the default physical network connection changed, e.g.\nwifi->mobile.\n\n\"suspend\"  \nIndicates that the OS is preparing to suspend, so the VPN should drop its\nconnection. The extension is not guaranteed to receive this event prior to\nsuspending.\n\n\"resume\"  \nIndicates that the OS has resumed and the user has logged back in, so the VPN\nshould try to reconnect.\n\n### UIEvent\n\nThe enum is used by the platform to indicate the event that triggered\n`onUIEvent`.\n\n#### Enum\n\n\"showAddDialog\"  \nRequests that the VPN client show the add configuration dialog box to the\nuser.\n\n\"showConfigureDialog\"  \nRequests that the VPN client show the configuration settings dialog box to the\nuser.\n\n### VpnConnectionState\n\nThe enum is used by the VPN client to inform the platform of its current\nstate. This helps provide meaningful messages to the user.\n\n#### Enum\n\n\"connected\"  \nSpecifies that VPN connection was successful.\n\n\"failure\"  \nSpecifies that VPN connection has failed.\n\n## Methods\n\n### createConfig()\n\nPromise\n\n    \n    \n    chrome.vpnProvider.createConfig(  \n      name: string,  \n      callback?: function,  \n    )\n\nCreates a new VPN configuration that persists across multiple login sessions\nof the user.\n\n#### Parameters\n\n  * name\n\nstring\n\nThe name of the VPN configuration.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (id: string) => void\n\n    * id\n\nstring\n\nA unique ID for the created configuration, or `undefined` on failure.\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### destroyConfig()\n\nPromise\n\n    \n    \n    chrome.vpnProvider.destroyConfig(  \n      id: string,  \n      callback?: function,  \n    )\n\nDestroys a VPN configuration created by the extension.\n\n#### Parameters\n\n  * id\n\nstring\n\nID of the VPN configuration to destroy.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### notifyConnectionStateChanged()\n\nPromise\n\n    \n    \n    chrome.vpnProvider.notifyConnectionStateChanged(  \n      state: VpnConnectionState,  \n      callback?: function,  \n    )\n\nNotifies the VPN session state to the platform. This will succeed only when\nthe VPN session is owned by the extension.\n\n#### Parameters\n\n  * state\n\nVpnConnectionState\n\nThe VPN session state of the VPN client.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### sendPacket()\n\nPromise\n\n    \n    \n    chrome.vpnProvider.sendPacket(  \n      data: ArrayBuffer,  \n      callback?: function,  \n    )\n\nSends an IP packet through the tunnel created for the VPN session. This will\nsucceed only when the VPN session is owned by the extension.\n\n#### Parameters\n\n  * data\n\nArrayBuffer\n\nThe IP packet to be sent to the platform.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setParameters()\n\nPromise\n\n    \n    \n    chrome.vpnProvider.setParameters(  \n      parameters: Parameters,  \n      callback?: function,  \n    )\n\nSets the parameters for the VPN session. This should be called immediately\nafter `\"connected\"` is received from the platform. This will succeed only when\nthe VPN session is owned by the extension.\n\n#### Parameters\n\n  * parameters\n\nParameters\n\nThe parameters for the VPN session.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onConfigCreated\n\n    \n    \n    chrome.vpnProvider.onConfigCreated.addListener(  \n      callback: function,  \n    )\n\nTriggered when a configuration is created by the platform for the extension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, name: string, data: object) => void\n\n    * id\n\nstring\n\n    * name\n\nstring\n\n    * data\n\nobject\n\n### onConfigRemoved\n\n    \n    \n    chrome.vpnProvider.onConfigRemoved.addListener(  \n      callback: function,  \n    )\n\nTriggered when a configuration created by the extension is removed by the\nplatform.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string) => void\n\n    * id\n\nstring\n\n### onPacketReceived\n\n    \n    \n    chrome.vpnProvider.onPacketReceived.addListener(  \n      callback: function,  \n    )\n\nTriggered when an IP packet is received via the tunnel for the VPN session\nowned by the extension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (data: ArrayBuffer) => void\n\n    * data\n\nArrayBuffer\n\n### onPlatformMessage\n\n    \n    \n    chrome.vpnProvider.onPlatformMessage.addListener(  \n      callback: function,  \n    )\n\nTriggered when a message is received from the platform for a VPN configuration\nowned by the extension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, message: PlatformMessage, error: string) => void\n\n    * id\n\nstring\n\n    * message\n\nPlatformMessage\n\n    * error\n\nstring\n\n### onUIEvent\n\n    \n    \n    chrome.vpnProvider.onUIEvent.addListener(  \n      callback: function,  \n    )\n\nTriggered when there is a UI event for the extension. UI events are signals\nfrom the platform that indicate to the app that a UI dialog needs to be shown\nto the user.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (event: UIEvent, id?: string) => void\n\n    * event\n\nUIEvent\n\n    * id\n\nstring optional\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/power": "#  chrome.power\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.power` API to override the system's power management features.\n\n## Permissions\n\n`power`  \n\n## Concepts and usage\n\nBy default, operating systems dim the screen when users are inactive and\neventually suspend the system. With the power API, an app or extension can\nkeep the system awake.\n\nUsing this API, you can specify the Level to which power management is\ndisabled. The `\"system\"` level keeps the system active, but allows the screen\nto be dimmed or turned off. For example, a communication app can continue to\nreceive messages while the screen is off. The `\"display\"` level keeps the\nscreen and system active. E-book and presentation apps, for example, can keep\nthe screen and system active while users read.\n\nWhen a user has more than one app or extension active, each with its own power\nlevel, the highest-precedence level takes effect; `\"display\"` always takes\nprecedence over `\"system\"`. For example, if app A asks for `\"system\"` power\nmanagement, and app B asks for `\"display\"`, `\"display\"` is used until app B is\nunloaded or releases its request. If app A is still active, `\"system\"` is then\nused.\n\n## Types\n\n### Level\n\n#### Enum\n\n\"system\"  \nPrevents the system from sleeping in response to user inactivity.\n\n\"display\"  \nPrevents the display from being turned off or dimmed, or the system from\nsleeping in response to user inactivity.\n\n## Methods\n\n### releaseKeepAwake()\n\n    \n    \n    chrome.power.releaseKeepAwake()\n\nReleases a request previously made via requestKeepAwake().\n\n### reportActivity()\n\nPromise Chrome 113+  ChromeOS only\n\n    \n    \n    chrome.power.reportActivity(  \n      callback?: function,  \n    )\n\nReports a user activity in order to awake the screen from a dimmed or turned\noff state or from a screensaver. Exits the screensaver if it is currently\nactive.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### requestKeepAwake()\n\n    \n    \n    chrome.power.requestKeepAwake(  \n      level: Level,  \n    )\n\nRequests that power management be temporarily disabled. `level` describes the\ndegree to which power management should be disabled. If a request previously\nmade by the same app is still active, it will be replaced by the new request.\n\n#### Parameters\n\n  * level\n\nLevel\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/printerProvider": "#  chrome.printerProvider\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.printerProvider` API exposes events used by print manager to query\nprinters controlled by extensions, to query their capabilities and to submit\nprint jobs to these printers.\n\n## Permissions\n\n`printerProvider`  \n\n## Availability\n\nChrome 44+\n\n## Types\n\n### PrinterInfo\n\n#### Properties\n\n  * description\n\nstring optional\n\nPrinter's human readable description.\n\n  * id\n\nstring\n\nUnique printer ID.\n\n  * name\n\nstring\n\nPrinter's human readable name.\n\n### PrintError\n\nError codes returned in response to `onPrintRequested` event.\n\n#### Enum\n\n\"OK\"  \nSpecifies that the operation was completed successfully.\n\n\"FAILED\"  \nSpecifies that a general failure occured.\n\n\"INVALID_TICKET\"  \nSpecifies that the print ticket is invalid. For example, the ticket is\ninconsistent with some capabilities, or the extension is not able to handle\nall settings from the ticket.\n\n\"INVALID_DATA\"  \nSpecifies that the document is invalid. For example, data may be corrupted or\nthe format is incompatible with the extension.\n\n### PrintJob\n\n#### Properties\n\n  * contentType\n\nstring\n\nThe document content type. Supported formats are `\"application/pdf\"` and\n`\"image/pwg-raster\"`.\n\n  * document\n\nBlob\n\nBlob containing the document data to print. Format must match `contentType`.\n\n  * printerId\n\nstring\n\nID of the printer which should handle the job.\n\n  * ticket\n\nobject\n\nPrint ticket in CJT format.\n\nThe CJT reference is marked as deprecated. It is deprecated for Google Cloud\nPrint only. is not deprecated for ChromeOS printing.\n\n  * title\n\nstring\n\nThe print job title.\n\n## Events\n\n### onGetCapabilityRequested\n\n    \n    \n    chrome.printerProvider.onGetCapabilityRequested.addListener(  \n      callback: function,  \n    )\n\nEvent fired when print manager requests printer capabilities.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (printerId: string, resultCallback: function) => void\n\n    * printerId\n\nstring\n\n    * resultCallback\n\nfunction\n\nThe `resultCallback` parameter looks like:\n\n          \n          (capabilities: object) => void\n\n      * capabilities\n\nobject\n\nDevice capabilities in CDD format.\n\n### onGetPrintersRequested\n\n    \n    \n    chrome.printerProvider.onGetPrintersRequested.addListener(  \n      callback: function,  \n    )\n\nEvent fired when print manager requests printers provided by extensions.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (resultCallback: function) => void\n\n    * resultCallback\n\nfunction\n\nThe `resultCallback` parameter looks like:\n\n          \n          (printerInfo: PrinterInfo[]) => void\n\n      * printerInfo\n\nPrinterInfo[]\n\n### onGetUsbPrinterInfoRequested\n\nChrome 45+\n\n    \n    \n    chrome.printerProvider.onGetUsbPrinterInfoRequested.addListener(  \n      callback: function,  \n    )\n\nEvent fired when print manager requests information about a USB device that\nmay be a printer.\n\n_Note:_ An application should not rely on this event being fired more than\nonce per device. If a connected device is supported it should be returned in\nthe `onGetPrintersRequested` event.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (device: usb.Device, resultCallback: function) => void\n\n    * device\n\nusb.Device\n\n    * resultCallback\n\nfunction\n\nThe `resultCallback` parameter looks like:\n\n          \n          (printerInfo?: PrinterInfo) => void\n\n      * printerInfo\n\nPrinterInfo optional\n\n### onPrintRequested\n\n    \n    \n    chrome.printerProvider.onPrintRequested.addListener(  \n      callback: function,  \n    )\n\nEvent fired when print manager requests printing.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (printJob: PrintJob, resultCallback: function) => void\n\n    * printJob\n\nPrintJob\n\n    * resultCallback\n\nfunction\n\nThe `resultCallback` parameter looks like:\n\n          \n          (result: PrintError) => void\n\n      * result\n\nPrintError\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/printing": "#  chrome.printing\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.printing` API to send print jobs to printers installed on\nChromebook.\n\n## Permissions\n\n`printing`  \n\n## Availability\n\nChrome 81+  ChromeOS only\n\nAll `chrome.printing` methods and events require you to declare the\n`\"printing\"` permission in the extension manifest. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"printing\"\n      ],\n      ...\n    }\n    \n\n## Examples\n\nThe examples below demonstrate using each of the methods in the printing\nnamespace. This code is copied from or based on the api-samples/printing in\nthe extensions-samples Github repo.\n\n### cancelJob()\n\nThis example uses the `onJobStatusChanged` handler to hide a 'cancel' button\nwhen the `jobStatus` is neither `PENDING` or `IN_PROGRESS`. Note that on some\nnetworks or when a Chromebook is connected directly to the printer, these\nstates may pass too quickly for the cancel button to be visible long enough to\nbe called. This is greatly simplified printing example.\n\n    \n    \n    chrome.printing.onJobStatusChanged.addListener((jobId, status) => {\n      const cancelButton = document.getElementById(\"cancelButton\");\n      cancelButton.addEventListener('click', () => {\n        chrome.printing.cancelJob(jobId).then((response) => {\n          if (response !== undefined) {\n            console.log(response.status);\n          }\n          if (chrome.runtime.lastError !== undefined) {\n            console.log(chrome.runtime.lastError.message);\n          }\n        });\n      });\n      if (status !== \"PENDING\" && status !== \"IN_PROGRESS\") {\n        cancelButton.style.visibility = 'hidden';\n      } else {\n        cancelButton.style.visibility = 'visible';\n      }\n    }\n    \n\n### getPrinters() and getPrinterInfo()\n\nA single example is used for these functions because getting printer\ninformation requires a printer ID, which is retrieved by calling\n`getPrinters()`. This example logs the name and description of the default\nprinter to the console. This is a simplified version of the printing example.\n\n    \n    \n    const printers = await chrome.printing.getPrinters();\n    const defaultPrinter = printers.find((printer) => {\n      const printerInfo = await chrome.printing.getPrinterInfo(printer.id);\n      return printerInfo.isDefault;\n    }\n    console.log(`Default printer: ${defaultPrinter.name}.\\n\\t${defaultPrinter.description}`);\n    \n\n### submitJob()\n\nThe `submitJob()` method requires three things.\n\n  * A `ticket` structure specifying which capabilities of the printer are to be used. If the user needs to select from available capabilities, you can retrieve them for a specific printer using `getPrinterInfo()`.\n  * A `SubmitJobRequest` structure, which specifies the printer to use, and the file or date to print. This structure contains a reference to the `ticket` structure.\n  * A blob of the file or data to print.\n\nCalling `submitJob()` triggers a dialog box asking the user to confirm\nprinting. Use the `PrintingAPIExtensionsAllowlist` to bypass confirmation.\n\nThis is a simplified version of the printing example. Notice that the `ticket`\nis attached to the `SubmitJobRequest` structure (line 8) and that the data to\nprint is converted to a blob (line 10). Getting the ID of the printer (line 1)\nis more complicated in the sample than is shown here.\n\n    \n    \n    const defaultPrinter = getDefaultPrinter();\n    const ticket = getPrinterTicket(defaultPrinter);\n    const arrayBuffer = getPrintData();\n    const submitJobRequest = {\n      job: {\n        printerId: defaultPrinter,\n        title: 'test job',\n        ticket: ticket,\n        contentType: 'application/pdf',\n        document: new Blob([new Uint8Array(arrayBuffer)], {\n          type: 'application/pdf'\n        });\n      }\n    };\n    \n    chrome.printing.submitJob(submitJobRequest, (response) => {\n      if (response !== undefined) {\n        console.log(response.status);\n      }\n      if (chrome.runtime.lastError !== undefined) {\n        console.log(chrome.runtime.lastError.message);\n      }\n    });\n    \n\n### Roll printing\n\nThis example shows how to build a printer ticket for continuous (or roll)\nprinting, which is often used with receipt printing. The `submitJobRequest`\nobject for roll printing is the same as that shown for the `submitJob()`\nexample.\n\nIf you need to change the default value for paper cutting, use the\n`vendor_ticket_item` key. (The default varies from printer to printer.) To\nchange the value, provide an array with one member: an object whose `id` is\n`'finishings'`. The value can either be `'trim'` for printers that cut the\nroll at the end of printing or `'none'` for printers that require the print\njob to be torn off.\n\n    \n    \n    const ticket = {\n      version: '1.0',\n      print: {\n        vendor_ticket_item: [{id: 'finishings', value: 'trim'}],\n        color: {type: 'STANDARD_MONOCHROME'},\n        duplex: {type: 'NO_DUPLEX'},\n        page_orientation: {type: 'PORTRAIT'},\n        copies: {copies: 1},\n        dpi: {horizontal_dpi: 300, vertical_dpi: 300},\n        media_size: {\n          width_microns: 72320,\n          height_microns: 100000\n        },\n        collate: {collate: false}\n      }\n    };\n    \n\nSome printers do not support the `\"finishings\"` option. To determine if your\nprinter does, call `getPrinterInfo()` and look for a `\"display_name\"` of\n`\"finishings/11\"`.\n\n    \n    \n    \"vendor_capability\": [\n      {\n        \"display_name\": \"finishings/11\",\n        \"id\": \"finishings/11\",\n        \"type\": \"TYPED_VALUE\",\n        \"typed_value_cap\": {\n          \"value_type\": \"BOOLEAN\"\n        }\n      },\n      ...\n    ]\n    \n\n**Note:** starting with Chrome 124, the `vendor_ticket_item` allows all items\nfrom the printer's `vendor_capabilities`. For example, any value return by\n`getPrinterInfo()` is valid. Before, only the `finishings` key was supported.\n\nThe values in a ticket's `media_size` key are specific to each printer. To\nselect an appropriate size call `getPrinterInfo()`. The returned\n`GetPrinterResponse` contains an array of supported media sizes at\n`\"media_size\".\"option\"`. Choose an option whose `\"is_continuous_feed\"` value\nis true. Use its height and width values for the ticket.\n\n    \n    \n    \"media_size\": {\n      \"option\": [\n      {\n        \"custom_display_name\": \"\",\n        \"is_continuous_feed\": true,\n        \"max_height_microns\": 2000000,\n        \"min_height_microns\": 25400,\n        \"width_microns\": 50800\n      },\n      ...\n      ]\n    }\n    \n\n## Types\n\n### GetPrinterInfoResponse\n\n#### Properties\n\n  * capabilities\n\nobject optional\n\nPrinter capabilities in CDD format. The property may be missing.\n\n  * status\n\nPrinterStatus\n\nThe status of the printer.\n\n### JobStatus\n\nStatus of the print job.\n\n#### Enum\n\n\"PENDING\"  \nPrint job is received on Chrome side but was not processed yet.\n\n\"IN_PROGRESS\"  \nPrint job is sent for printing.\n\n\"FAILED\"  \nPrint job was interrupted due to some error.\n\n\"CANCELED\"  \nPrint job was canceled by the user or via API.\n\n\"PRINTED\"  \nPrint job was printed without any errors.\n\n### Printer\n\n#### Properties\n\n  * description\n\nstring\n\nThe human-readable description of the printer.\n\n  * id\n\nstring\n\nThe printer's identifier; guaranteed to be unique among printers on the\ndevice.\n\n  * isDefault\n\nboolean\n\nThe flag which shows whether the printer fits DefaultPrinterSelection rules.\nNote that several printers could be flagged.\n\n  * name\n\nstring\n\nThe name of the printer.\n\n  * recentlyUsedRank\n\nnumber optional\n\nThe value showing how recent the printer was used for printing from Chrome.\nThe lower the value is the more recent the printer was used. The minimum value\nis 0. Missing value indicates that the printer wasn't used recently. This\nvalue is guaranteed to be unique amongst printers.\n\n  * source\n\nPrinterSource\n\nThe source of the printer (user or policy configured).\n\n  * uri\n\nstring\n\nThe printer URI. This can be used by extensions to choose the printer for the\nuser.\n\n### PrinterSource\n\nThe source of the printer.\n\n#### Enum\n\n\"USER\"  \nPrinter was added by user.\n\n\"POLICY\"  \nPrinter was added via policy.\n\n### PrinterStatus\n\nThe status of the printer.\n\n#### Enum\n\n\"DOOR_OPEN\"  \nThe door of the printer is open. Printer still accepts print jobs.\n\n\"TRAY_MISSING\"  \nThe tray of the printer is missing. Printer still accepts print jobs.\n\n\"OUT_OF_INK\"  \nThe printer is out of ink. Printer still accepts print jobs.\n\n\"OUT_OF_PAPER\"  \nThe printer is out of paper. Printer still accepts print jobs.\n\n\"OUTPUT_FULL\"  \nThe output area of the printer (e.g. tray) is full. Printer still accepts\nprint jobs.\n\n\"PAPER_JAM\"  \nThe printer has a paper jam. Printer still accepts print jobs.\n\n\"GENERIC_ISSUE\"  \nSome generic issue. Printer still accepts print jobs.\n\n\"STOPPED\"  \nThe printer is stopped and doesn't print but still accepts print jobs.\n\n\"UNREACHABLE\"  \nThe printer is unreachable and doesn't accept print jobs.\n\n\"EXPIRED_CERTIFICATE\"  \nThe SSL certificate is expired. Printer accepts jobs but they fail.\n\n\"AVAILABLE\"  \nThe printer is available.\n\n### SubmitJobRequest\n\n#### Properties\n\n  * job\n\nPrintJob\n\nThe print job to be submitted. Supported content types are \"application/pdf\"\nand \"image/png\". The Cloud Job Ticket shouldn't include `FitToPageTicketItem`,\n`PageRangeTicketItem` and `ReverseOrderTicketItem` fields since they are\nirrelevant for native printing. `VendorTicketItem` is optional. All other\nfields must be present.\n\n### SubmitJobResponse\n\n#### Properties\n\n  * jobId\n\nstring optional\n\nThe id of created print job. This is a unique identifier among all print jobs\non the device. If status is not OK, jobId will be null.\n\n  * status\n\nSubmitJobStatus\n\nThe status of the request.\n\n### SubmitJobStatus\n\nThe status of `submitJob` request.\n\n#### Enum\n\n\"OK\"  \nSent print job request is accepted.\n\n\"USER_REJECTED\"  \nSent print job request is rejected by the user.\n\n## Properties\n\n### MAX_GET_PRINTER_INFO_CALLS_PER_MINUTE\n\nThe maximum number of times that `getPrinterInfo` can be called per minute.\n\n#### Value\n\n20  \n\n### MAX_SUBMIT_JOB_CALLS_PER_MINUTE\n\nThe maximum number of times that `submitJob` can be called per minute.\n\n#### Value\n\n40  \n\n## Methods\n\n### cancelJob()\n\nPromise\n\n    \n    \n    chrome.printing.cancelJob(  \n      jobId: string,  \n      callback?: function,  \n    )\n\nCancels previously submitted job.\n\n#### Parameters\n\n  * jobId\n\nstring\n\nThe id of the print job to cancel. This should be the same id received in a\n`SubmitJobResponse`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 100+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getJobStatus()\n\nPromise Chrome 135+\n\n    \n    \n    chrome.printing.getJobStatus(  \n      jobId: string,  \n      callback?: function,  \n    )\n\nReturns the status of the print job. This call will fail with a runtime error\nif the print job with the given `jobId` doesn't exist. `jobId`: The id of the\nprint job to return the status of. This should be the same id received in a\n`SubmitJobResponse`.\n\n#### Parameters\n\n  * jobId\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (status: JobStatus) => void\n\n    * status\n\nJobStatus\n\n#### Returns\n\n  * Promise<JobStatus>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPrinterInfo()\n\nPromise\n\n    \n    \n    chrome.printing.getPrinterInfo(  \n      printerId: string,  \n      callback?: function,  \n    )\n\nReturns the status and capabilities of the printer in CDD format. This call\nwill fail with a runtime error if no printers with given id are installed.\n\n#### Parameters\n\n  * printerId\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: GetPrinterInfoResponse) => void\n\n    * response\n\nGetPrinterInfoResponse\n\n#### Returns\n\n  * Promise<GetPrinterInfoResponse>\n\nChrome 100+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPrinters()\n\nPromise\n\n    \n    \n    chrome.printing.getPrinters(  \n      callback?: function,  \n    )\n\nReturns the list of available printers on the device. This includes manually\nadded, enterprise and discovered printers.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (printers: Printer[]) => void\n\n    * printers\n\nPrinter[]\n\n#### Returns\n\n  * Promise<Printer[]>\n\nChrome 100+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### submitJob()\n\nPromise\n\n    \n    \n    chrome.printing.submitJob(  \n      request: SubmitJobRequest,  \n      callback?: function,  \n    )\n\nSubmits the job for printing. If the extension is not listed in the\n`PrintingAPIExtensionsAllowlist` policy, the user is prompted to accept the\nprint job. Before Chrome 120, this function did not return a promise.\n\n#### Parameters\n\n  * request\n\nSubmitJobRequest\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (response: SubmitJobResponse) => void\n\n    * response\n\nSubmitJobResponse\n\n#### Returns\n\n  * Promise<SubmitJobResponse>\n\nChrome 100+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onJobStatusChanged\n\n    \n    \n    chrome.printing.onJobStatusChanged.addListener(  \n      callback: function,  \n    )\n\nEvent fired when the status of the job is changed. This is only fired for the\njobs created by this extension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (jobId: string, status: JobStatus) => void\n\n    * jobId\n\nstring\n\n    * status\n\nJobStatus\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/printingMetrics": "#  chrome.printingMetrics\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.printingMetrics` API to fetch data about printing usage.\n\n## Permissions\n\n`printingMetrics`  \n\n## Availability\n\nChrome 79+  ChromeOS only  Requires policy\n\n## Types\n\n### ColorMode\n\n#### Enum\n\n\"BLACK_AND_WHITE\"  \nSpecifies that black and white mode was used.\n\n\"COLOR\"  \nSpecifies that color mode was used.\n\n### DuplexMode\n\n#### Enum\n\n\"ONE_SIDED\"  \nSpecifies that one-sided printing was used.\n\n\"TWO_SIDED_LONG_EDGE\"  \nSpecifies that two-sided printing was used, flipping on long edge.\n\n\"TWO_SIDED_SHORT_EDGE\"  \nSpecifies that two-sided printing was used, flipping on short edge.\n\n### MediaSize\n\n#### Properties\n\n  * height\n\nnumber\n\nHeight (in micrometers) of the media used for printing.\n\n  * vendorId\n\nstring\n\nVendor-provided ID, e.g. \"iso_a3_297x420mm\" or \"na_index-3x5_3x5in\". Possible\nvalues are values of \"media\" IPP attribute and can be found on IANA page .\n\n  * width\n\nnumber\n\nWidth (in micrometers) of the media used for printing.\n\n### Printer\n\n#### Properties\n\n  * name\n\nstring\n\nDisplayed name of the printer.\n\n  * source\n\nPrinterSource\n\nThe source of the printer.\n\n  * uri\n\nstring\n\nThe full path for the printer. Contains protocol, hostname, port, and queue.\n\n### PrinterSource\n\nThe source of the printer.\n\n#### Enum\n\n\"USER\"  \nSpecifies that the printer was added by user.\n\n\"POLICY\"  \nSpecifies that the printer was added via policy.\n\n### PrintJobInfo\n\n#### Properties\n\n  * completionTime\n\nnumber\n\nThe job completion time (in milliseconds past the Unix epoch).\n\n  * creationTime\n\nnumber\n\nThe job creation time (in milliseconds past the Unix epoch).\n\n  * id\n\nstring\n\nThe ID of the job.\n\n  * numberOfPages\n\nnumber\n\nThe number of pages in the document.\n\n  * printer\n\nPrinter\n\nThe info about the printer which printed the document.\n\n  * printer_status\n\nPrinterStatus\n\nChrome 85+\n\nThe status of the printer.\n\n  * settings\n\nPrintSettings\n\nThe settings of the print job.\n\n  * source\n\nPrintJobSource\n\nSource showing who initiated the print job.\n\n  * sourceId\n\nstring optional\n\nID of source. Null if source is PRINT_PREVIEW or ANDROID_APP.\n\n  * status\n\nPrintJobStatus\n\nThe final status of the job.\n\n  * title\n\nstring\n\nThe title of the document which was printed.\n\n### PrintJobSource\n\nThe source of the print job.\n\n#### Enum\n\n\"PRINT_PREVIEW\"  \nSpecifies that the job was created from the Print Preview page initiated by\nthe user.\n\n\"ANDROID_APP\"  \nSpecifies that the job was created from an Android App.\n\n\"EXTENSION\"  \nSpecifies that the job was created by extension via Chrome API.\n\n\"ISOLATED_WEB_APP\"  \nSpecifies that the job was created by an Isolated Web App via API.\n\n### PrintJobStatus\n\nSpecifies the final status of the print job.\n\n#### Enum\n\n\"FAILED\"  \nSpecifies that the print job was interrupted due to some error.\n\n\"CANCELED\"  \nSpecifies that the print job was canceled by the user or via API.\n\n\"PRINTED\"  \nSpecifies that the print job was printed without any errors.\n\n### PrintSettings\n\n#### Properties\n\n  * color\n\nColorMode\n\nThe requested color mode.\n\n  * copies\n\nnumber\n\nThe requested number of copies.\n\n  * duplex\n\nDuplexMode\n\nThe requested duplex mode.\n\n  * mediaSize\n\nMediaSize\n\nThe requested media size.\n\n## Methods\n\n### getPrintJobs()\n\nPromise\n\n    \n    \n    chrome.printingMetrics.getPrintJobs(  \n      callback?: function,  \n    )\n\nReturns the list of the finished print jobs.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (jobs: PrintJobInfo[]) => void\n\n    * jobs\n\nPrintJobInfo[]\n\n#### Returns\n\n  * Promise<PrintJobInfo[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onPrintJobFinished\n\n    \n    \n    chrome.printingMetrics.onPrintJobFinished.addListener(  \n      callback: function,  \n    )\n\nEvent fired when the print job is finished. This includes any of termination\nstatuses: FAILED, CANCELED and PRINTED.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (jobInfo: PrintJobInfo) => void\n\n    * jobInfo\n\nPrintJobInfo\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/privacy": "#  chrome.privacy\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Note:** The Chrome Privacy Whitepaper gives background detail regarding the\nfeatures which this API can control.\n\n## Description\n\nUse the `chrome.privacy` API to control usage of the features in Chrome that\ncan affect a user's privacy. This API relies on the ChromeSetting prototype of\nthe type API for getting and setting Chrome's configuration.\n\n## Permissions\n\n`privacy`  \n\nYou must declare the \"privacy\" permission in your extension's manifest to use\nthe API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"privacy\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nReading the current value of a Chrome setting is straightforward. You'll first\nneed to find the property you're interested in, then you'll call `get()` on\nthat object in order to retrieve its current value and your extension's level\nof control. For example, to determine if Chrome's credit card autofill feature\nis enabled, you'd write:\n\n    \n    \n    chrome.privacy.services.autofillCreditCardEnabled.get({}, function(details) {\n      if (details.value) {\n        console.log('Autofill is on!');\n      } else {\n        console.log('Autofill is off!');\n      }\n    });\n    \n\nChanging the value of a setting is a little bit more complex, because you\nfirst must verify that your extension can control the setting. The user won't\nsee any change to their settings if your extension toggles a setting that is\neither locked to a specific value by enterprise policies (`levelOfControl`\nwill be set to \"not_controllable\"), or if another extension is controlling the\nvalue (`levelOfControl` will be set to \"controlled_by_other_extensions\"). The\n`set()` call will succeed, but the setting will be immediately overridden. As\nthis might be confusing, it is advisable to warn the user when the settings\nthey've chosen aren't practically applied.\n\n**Note:** Full details about extensions' ability to control `ChromeSetting`s\ncan be found under `chrome.types.ChromeSetting`.\n\nThis means that you ought to use the `get()` method to determine your level of\naccess, and then only call `set()` if your extension can grab control over the\nsetting (in fact if your extension can't control the setting it's probably a\ngood idea to visually disable the feature to reduce user confusion):\n\n    \n    \n    chrome.privacy.services.autofillCreditCardEnabled.get({}, function(details) {\n      if (details.levelOfControl === 'controllable_by_this_extension') {\n        chrome.privacy.services.autofillCreditCardEnabled.set({ value: true }, function() {\n          if (chrome.runtime.lastError === undefined) {\n            console.log(\"Hooray, it worked!\");\n          } else {\n            console.log(\"Sadness!\", chrome.runtime.lastError);\n          }\n        });\n      }\n    });\n    \n\nIf you're interested in changes to a setting's value, add a listener to its\n`onChange` event. Among other uses, this will allow you to warn the user if a\nmore recently installed extension grabs control of a setting, or if enterprise\npolicy overrides your control. To listen for changes to credit card autofill\nstatus, for example, the following code would suffice:\n\n    \n    \n    chrome.privacy.services.autofillCreditCardEnabled.onChange.addListener(\n      function (details) {\n        // The new value is stored in `details.value`, the new level of control\n        // in `details.levelOfControl`, and `details.incognitoSpecific` will be\n        // `true` if the value is specific to Incognito mode.\n      }\n    );\n    \n\n## Examples\n\nTo try this API, install the privacy API example from the chrome-extension-\nsamples repository.\n\n## Types\n\n### IPHandlingPolicy\n\nChrome 48+\n\nThe IP handling policy of WebRTC.\n\n#### Enum\n\n\"default\"  \n\n\"default_public_and_private_interfaces\"  \n\n\"default_public_interface_only\"  \n\n\"disable_non_proxied_udp\"  \n\n## Properties\n\n### network\n\nSettings that influence Chrome's handling of network connections in general.\n\n#### Type\n\nobject\n\n#### Properties\n\n  * networkPredictionEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome attempts to speed up your web browsing experience by pre-\nresolving DNS entries and preemptively opening TCP and SSL connections to\nservers. This preference only affects actions taken by Chrome's internal\nprediction service. It does not affect webpage-initiated prefectches or\npreconnects. This preference's value is a boolean, defaulting to `true`.\n\n  * webRTCIPHandlingPolicy\n\ntypes.ChromeSetting<IPHandlingPolicy>\n\nChrome 48+\n\nAllow users to specify the media performance/privacy tradeoffs which impacts\nhow WebRTC traffic will be routed and how much local address information is\nexposed. This preference's value is of type IPHandlingPolicy, defaulting to\n`default`.\n\n### services\n\nSettings that enable or disable features that require third-party network\nservices provided by Google and your default search provider.\n\n#### Type\n\nobject\n\n#### Properties\n\n  * alternateErrorPagesEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome uses a web service to help resolve navigation errors. This\npreference's value is a boolean, defaulting to `true`.\n\n  * autofillAddressEnabled\n\ntypes.ChromeSetting<boolean>\n\nChrome 70+\n\nIf enabled, Chrome offers to automatically fill in addresses and other form\ndata. This preference's value is a boolean, defaulting to `true`.\n\n  * autofillCreditCardEnabled\n\ntypes.ChromeSetting<boolean>\n\nChrome 70+\n\nIf enabled, Chrome offers to automatically fill in credit card forms. This\npreference's value is a boolean, defaulting to `true`.\n\n  * autofillEnabled\n\ntypes.ChromeSetting<boolean>\n\nDeprecated since Chrome 70\n\nPlease use privacy.services.autofillAddressEnabled and\nprivacy.services.autofillCreditCardEnabled. This remains for backward\ncompatibility in this release and will be removed in the future.\n\nIf enabled, Chrome offers to automatically fill in forms. This preference's\nvalue is a boolean, defaulting to `true`.\n\n  * passwordSavingEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, the password manager will ask if you want to save passwords. This\npreference's value is a boolean, defaulting to `true`.\n\n  * safeBrowsingEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome does its best to protect you from phishing and malware.\nThis preference's value is a boolean, defaulting to `true`.\n\n  * safeBrowsingExtendedReportingEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome will send additional information to Google when\nSafeBrowsing blocks a page, such as the content of the blocked page. This\npreference's value is a boolean, defaulting to `false`.\n\n  * searchSuggestEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome sends the text you type into the Omnibox to your default\nsearch engine, which provides predictions of websites and searches that are\nlikely completions of what you've typed so far. This preference's value is a\nboolean, defaulting to `true`.\n\n  * spellingServiceEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome uses a web service to help correct spelling errors. This\npreference's value is a boolean, defaulting to `false`.\n\n  * translationServiceEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome offers to translate pages that aren't in a language you\nread. This preference's value is a boolean, defaulting to `true`.\n\n### websites\n\nSettings that determine what information Chrome makes available to websites.\n\n#### Type\n\nobject\n\n#### Properties\n\n  * adMeasurementEnabled\n\ntypes.ChromeSetting<boolean>\n\nChrome 111+\n\nIf disabled, the Attribution Reporting API and Private Aggregation API are\ndeactivated. The value of this preference is of type boolean, and the default\nvalue is `true`. Extensions may only disable these APIs by setting the value\nto `false`. If you try setting these APIs to `true`, it will throw an error.\n\n  * doNotTrackEnabled\n\ntypes.ChromeSetting<boolean>\n\nChrome 65+\n\nIf enabled, Chrome sends 'Do Not Track' (`DNT: 1`) header with your requests.\nThe value of this preference is of type boolean, and the default value is\n`false`.\n\n  * fledgeEnabled\n\ntypes.ChromeSetting<boolean>\n\nChrome 111+\n\nIf disabled, the Fledge API is deactivated. The value of this preference is of\ntype boolean, and the default value is `true`. Extensions may only disable\nthis API by setting the value to `false`. If you try setting this API to\n`true`, it will throw an error.\n\n  * hyperlinkAuditingEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome sends auditing pings when requested by a website (`<a\nping>`). The value of this preference is of type boolean, and the default\nvalue is `true`.\n\n  * protectedContentEnabled\n\ntypes.ChromeSetting<boolean>\n\n**Available on Windows and ChromeOS only** : If enabled, Chrome provides a\nunique ID to plugins in order to run protected content. The value of this\npreference is of type boolean, and the default value is `true`.\n\n  * referrersEnabled\n\ntypes.ChromeSetting<boolean>\n\nIf enabled, Chrome sends `referer` headers with your requests. Yes, the name\nof this preference doesn't match the misspelled header. No, we're not going to\nchange it. The value of this preference is of type boolean, and the default\nvalue is `true`.\n\n  * relatedWebsiteSetsEnabled\n\ntypes.ChromeSetting<boolean>\n\nChrome 121+\n\nIf disabled, Related Website Sets is deactivated. The value of this preference\nis of type boolean, and the default value is `true`. Extensions may only\ndisable this API by setting the value to `false`. If you try setting this API\nto `true`, it will throw an error.\n\n  * thirdPartyCookiesAllowed\n\ntypes.ChromeSetting<boolean>\n\nIf disabled, Chrome blocks third-party sites from setting cookies. The value\nof this preference is of type boolean, and the default value is `true`.\n\n**Note:**Individual sites may still be able to access third-party cookies when\nthis API returns `false`, if they have a valid exemption or they use the\nStorage Access API instead.\n\n  * topicsEnabled\n\ntypes.ChromeSetting<boolean>\n\nChrome 111+\n\nIf disabled, the Topics API is deactivated. The value of this preference is of\ntype boolean, and the default value is `true`. Extensions may only disable\nthis API by setting the value to `false`. If you try setting this API to\n`true`, it will throw an error.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/processes": "#  chrome.processes\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.processes` API to interact with the browser's processes.\n\n## Permissions\n\n`processes`  \n\n## Availability\n\nDev channel\n\n## Types\n\n### Cache\n\n#### Properties\n\n  * liveSize\n\nnumber\n\nThe part of the cache that is utilized, in bytes.\n\n  * size\n\nnumber\n\nThe size of the cache, in bytes.\n\n### Process\n\n#### Properties\n\n  * cpu\n\nnumber optional\n\nThe most recent measurement of the process's CPU usage, expressed as the\npercentage of a single CPU core used in total, by all of the process's\nthreads. This gives a value from zero to CpuInfo.numOfProcessors*100, which\ncan exceed 100% in multi-threaded processes. Only available when receiving the\nobject as part of a callback from onUpdated or onUpdatedWithMemory.\n\n  * cssCache\n\nCache optional\n\nThe most recent information about the CSS cache for the process. Only\navailable when receiving the object as part of a callback from onUpdated or\nonUpdatedWithMemory.\n\n  * id\n\nnumber\n\nUnique ID of the process provided by the browser.\n\n  * imageCache\n\nCache optional\n\nThe most recent information about the image cache for the process. Only\navailable when receiving the object as part of a callback from onUpdated or\nonUpdatedWithMemory.\n\n  * jsMemoryAllocated\n\nnumber optional\n\nThe most recent measurement of the process JavaScript allocated memory, in\nbytes. Only available when receiving the object as part of a callback from\nonUpdated or onUpdatedWithMemory.\n\n  * jsMemoryUsed\n\nnumber optional\n\nThe most recent measurement of the process JavaScript memory used, in bytes.\nOnly available when receiving the object as part of a callback from onUpdated\nor onUpdatedWithMemory.\n\n  * naclDebugPort\n\nnumber\n\nThe debugging port for Native Client processes. Zero for other process types\nand for NaCl processes that do not have debugging enabled.\n\n  * network\n\nnumber optional\n\nThe most recent measurement of the process network usage, in bytes per second.\nOnly available when receiving the object as part of a callback from onUpdated\nor onUpdatedWithMemory.\n\n  * osProcessId\n\nnumber\n\nThe ID of the process, as provided by the OS.\n\n  * privateMemory\n\nnumber optional\n\nThe most recent measurement of the process private memory usage, in bytes.\nOnly available when receiving the object as part of a callback from\nonUpdatedWithMemory or getProcessInfo with the includeMemory flag.\n\n  * profile\n\nstring\n\nThe profile which the process is associated with.\n\n  * scriptCache\n\nCache optional\n\nThe most recent information about the script cache for the process. Only\navailable when receiving the object as part of a callback from onUpdated or\nonUpdatedWithMemory.\n\n  * sqliteMemory\n\nnumber optional\n\nThe most recent measurement of the process's SQLite memory usage, in bytes.\nOnly available when receiving the object as part of a callback from onUpdated\nor onUpdatedWithMemory.\n\n  * tasks\n\nTaskInfo[]\n\nArray of TaskInfos representing the tasks running on this process.\n\n  * type\n\nProcessType\n\nThe type of process.\n\n### ProcessType\n\nThe types of the browser processes.\n\n#### Enum\n\n\"browser\"  \n\n\"renderer\"  \n\n\"extension\"  \n\n\"notification\"  \n\n\"plugin\"  \n\n\"worker\"  \n\n\"nacl\"  \n\n\"service_worker\"  \n\n\"utility\"  \n\n\"gpu\"  \n\n\"other\"  \n\n### TaskInfo\n\n#### Properties\n\n  * tabId\n\nnumber optional\n\nOptional tab ID, if this task represents a tab running on a renderer process.\n\n  * title\n\nstring\n\nThe title of the task.\n\n## Methods\n\n### getProcessIdForTab()\n\nPromise\n\n    \n    \n    chrome.processes.getProcessIdForTab(  \n      tabId: number,  \n      callback?: function,  \n    )\n\nReturns the ID of the renderer process for the specified tab.\n\n#### Parameters\n\n  * tabId\n\nnumber\n\nThe ID of the tab for which the renderer process ID is to be returned.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (processId: number) => void\n\n    * processId\n\nnumber\n\nProcess ID of the tab's renderer process.\n\n#### Returns\n\n  * Promise<number>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getProcessInfo()\n\nPromise\n\n    \n    \n    chrome.processes.getProcessInfo(  \n      processIds: number | number[],  \n      includeMemory: boolean,  \n      callback?: function,  \n    )\n\nRetrieves the process information for each process ID specified.\n\n#### Parameters\n\n  * processIds\n\nnumber | number[]\n\nThe list of process IDs or single process ID for which to return the process\ninformation. An empty list indicates all processes are requested.\n\n  * includeMemory\n\nboolean\n\nTrue if detailed memory usage is required. Note, collecting memory usage\ninformation incurs extra CPU usage and should only be queried for when needed.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (processes: object) => void\n\n    * processes\n\nobject\n\nA dictionary of `Process` objects for each requested process that is a live\nchild process of the current browser process, indexed by process ID. Metrics\nrequiring aggregation over time will not be populated in each Process object.\n\n#### Returns\n\n  * Promise<object>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### terminate()\n\nPromise\n\n    \n    \n    chrome.processes.terminate(  \n      processId: number,  \n      callback?: function,  \n    )\n\nTerminates the specified renderer process. Equivalent to visiting about:crash,\nbut without changing the tab's URL.\n\n#### Parameters\n\n  * processId\n\nnumber\n\nThe ID of the process to be terminated.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (didTerminate: boolean) => void\n\n    * didTerminate\n\nboolean\n\nTrue if terminating the process was successful, and false otherwise.\n\n#### Returns\n\n  * Promise<boolean>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onCreated\n\n    \n    \n    chrome.processes.onCreated.addListener(  \n      callback: function,  \n    )\n\nFired each time a process is created, providing the corrseponding Process\nobject.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (process: Process) => void\n\n    * process\n\nProcess\n\n### onExited\n\n    \n    \n    chrome.processes.onExited.addListener(  \n      callback: function,  \n    )\n\nFired each time a process is terminated, providing the type of exit.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (processId: number, exitType: number, exitCode: number) => void\n\n    * processId\n\nnumber\n\n    * exitType\n\nnumber\n\n    * exitCode\n\nnumber\n\n### onUnresponsive\n\n    \n    \n    chrome.processes.onUnresponsive.addListener(  \n      callback: function,  \n    )\n\nFired each time a process becomes unresponsive, providing the corrseponding\nProcess object.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (process: Process) => void\n\n    * process\n\nProcess\n\n### onUpdated\n\n    \n    \n    chrome.processes.onUpdated.addListener(  \n      callback: function,  \n    )\n\nFired each time the Task Manager updates its process statistics, providing the\ndictionary of updated Process objects, indexed by process ID.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (processes: object) => void\n\n    * processes\n\nobject\n\n### onUpdatedWithMemory\n\n    \n    \n    chrome.processes.onUpdatedWithMemory.addListener(  \n      callback: function,  \n    )\n\nFired each time the Task Manager updates its process statistics, providing the\ndictionary of updated Process objects, indexed by process ID. Identical to\nonUpdate, with the addition of memory usage details included in each Process\nobject. Note, collecting memory usage information incurs extra CPU usage and\nshould only be listened for when needed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (processes: object) => void\n\n    * processes\n\nobject\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/proxy": "#  chrome.proxy\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.proxy` API to manage Chrome's proxy settings. This API relies\non the ChromeSetting prototype of the type API for getting and setting the\nproxy configuration.\n\n## Permissions\n\n`proxy`  \n\nYou must declare the \"proxy\" permission in the extension manifest to use the\nproxy settings API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"proxy\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nProxy settings are defined in a `proxy.ProxyConfig` object. Depending on\nChrome's proxy settings, the settings may contain `proxy.ProxyRules` or a\n`proxy.PacScript`.\n\n### Proxy modes\n\nA ProxyConfig object's `mode` attribute determines the overall behavior of\nChrome with regards to proxy usage. It can take the following values:\n\n`direct`\n\n    In `direct` mode all connections are created directly, without any proxy involved. This mode allows no further parameters in the `ProxyConfig` object.\n`auto_detect`\n\n    In `auto_detect` mode the proxy configuration is determined by a PAC script that can be downloaded at http://wpad/wpad.dat. This mode allows no further parameters in the `ProxyConfig` object.\n`pac_script`\n\n    In `pac_script` mode the proxy configuration is determined by a PAC script that is either retrieved from the URL specified in the `proxy.PacScript` object or taken literally from the `data` element specified in the `proxy.PacScript` object. Besides this, this mode allows no further parameters in the `ProxyConfig` object.\n`fixed_servers`\n\n    In `fixed_servers` mode the proxy configuration is codified in a `proxy.ProxyRules` object. Its structure is described in Proxy rules. Besides this, the `fixed_servers` mode allows no further parameters in the `ProxyConfig` object.\n`system`\n\n    In `system` mode the proxy configuration is taken from the operating system. This mode allows no further parameters in the `ProxyConfig` object. Note that the `system` mode is different from setting no proxy configuration. In the latter case, Chrome falls back to the system settings only if no command-line options influence the proxy configuration.\n\n### Proxy rules\n\nThe `proxy.ProxyRules` object can contain either a `singleProxy` attribute or\na subset of `proxyForHttp`, `proxyForHttps`, `proxyForFtp`, and\n`fallbackProxy`.\n\nIn the first case, HTTP, HTTPS and FTP traffic is proxied through the\nspecified proxy server. Other traffic is sent directly. In the latter case the\nbehavior is slightly more subtle: If a proxy server is configured for the\nHTTP, HTTPS or FTP protocol, the respective traffic is proxied through the\nspecified server. If no such proxy server is specified or traffic uses a\ndifferent protocol than HTTP, HTTPS or FTP, the `fallbackProxy` is used. If no\n`fallbackProxy` is specified, traffic is sent directly without a proxy server.\n\n### Proxy server objects\n\nA proxy server is configured in a `proxy.ProxyServer` object. The connection\nto the proxy server (defined by the `host` attribute) uses the protocol\ndefined in the `scheme` attribute. If no `scheme` is specified, the proxy\nconnection defaults to `http`.\n\nIf no `port` is defined in a `proxy.ProxyServer` object, the port is derived\nfrom the scheme. The default ports are:\n\nScheme| Port  \n---|---  \nhttp| 80  \nhttps| 443  \nsocks4| 1080  \nsocks5| 1080  \n  \n### Bypass list\n\nIndividual servers may be excluded from being proxied with the `bypassList`.\nThis list may contain the following entries:\n\n`[SCHEME://]HOST_PATTERN[:PORT]`\n\n    \n\nMatch all hostnames that match the pattern `HOST_PATTERN`. A leading `\".\"` is\ninterpreted as a `\"*.\"`.\n\nExamples: `\"foobar.com\", \"*foobar.com\", \"*.foobar.com\", \"*foobar.com:99\",\n\"https://x.*.y.com:99\"`.\n\nPattern| Matches| Does not match  \n---|---|---  \n`\".foobar.com\"`| `\"www.foobar.com\"`| `\"foobar.com\"`  \n`\"*.foobar.com\"`| `\"www.foobar.com\"`| `\"foobar.com\"`  \n`\"foobar.com\"`| `\"foobar.com\"`| `\"www.foobar.com\"`  \n`\"*foobar.com\"`| `\"foobar.com\"`, `\"www.foobar.com\"`, `\"foofoobar.com\"`|  \n`[SCHEME://]IP_LITERAL[:PORT]`\n\n    \n\nMatch URLs that are IP address literals. Conceptually this is the similar to\nthe first case, but with special cases to handle IP literal canonicalization.\nFor example, matching on \"[0:0:0::1]\" is the same as matching on \"[::1]\"\nbecause the IPv6 canonicalization is done internally.\n\nExamples: `127.0.1`, `[0:0::1]`, `[::1]:80`, `https://[::1]:443`\n\n`IP_LITERAL/PREFIX_LENGTH_IN_BITS`\n\n    \n\nMatch any URL containing an IP literal (`IP_LITERAL`) within the given range.\nThe IP range (`PREFIX_LENGTH_IN_BITS`) is specified using CIDR notation.\n\n    \n\nMatch any URL containing an IP literal within the given range. The IP range is\nspecified using CIDR notation. Examples: `\"192.168.1.1/16\", \"fefe:13::abc/33\"`\n\n`<local>`\n\n    \n\nThe literal string `<local>` matches simple hostnames. A simple hostname is\none that contains no dots and is not an IP literal. For instance `example` and\n`localhost` are simple hostnames, whereas `example.com`, `example.`, and\n`[::1]` are not.\n\nExample: `\"<local>\"`\n\n## Examples\n\nThe following code sets a SOCKS 5 proxy for HTTP connections to all servers\nbut foobar.com and uses direct connections for all other protocols. The\nsettings apply to regular and incognito windows, as incognito windows inherit\nsettings from regular windows. See also the Types API documentation.\n\n    \n    \n    var config = {\n      mode: \"fixed_servers\",\n      rules: {\n        proxyForHttp: {\n          scheme: \"socks5\",\n          host: \"1.2.3.4\"\n        },\n        bypassList: [\"foobar.com\"]\n      }\n    };\n    chrome.proxy.settings.set(\n      {value: config, scope: 'regular'},\n      function() {}\n    );\n    \n\nThe following code sets a custom PAC script.\n\n    \n    \n    var config = {\n      mode: \"pac_script\",\n      pacScript: {\n        data: \"function FindProxyForURL(url, host) {\\n\" +\n              \"  if (host == 'foobar.com')\\n\" +\n              \"    return 'PROXY blackhole:80';\\n\" +\n              \"  return 'DIRECT';\\n\" +\n              \"}\"\n      }\n    };\n    chrome.proxy.settings.set(\n      {value: config, scope: 'regular'},\n      function() {}\n    );\n    \n\nThe next snippet queries the current effective proxy settings. The effective\nproxy settings can be determined by another extension or by a policy. See the\nTypes API documentation for details.\n\n    \n    \n    chrome.proxy.settings.get(\n      {'incognito': false},\n      function(config) {\n        console.log(JSON.stringify(config));\n      }\n    );\n    \n\nNote that the `value` object passed to `set()` is not identical to the `value`\nobject passed to callback function of `get()`. The latter will contain a\n`rules.proxyForHttp.port` element.\n\n## Types\n\n### Mode\n\nChrome 54+\n\n#### Enum\n\n\"direct\"  \n\n\"auto_detect\"  \n\n\"pac_script\"  \n\n\"fixed_servers\"  \n\n\"system\"  \n\n### PacScript\n\nAn object holding proxy auto-config information. Exactly one of the fields\nshould be non-empty.\n\n#### Properties\n\n  * data\n\nstring optional\n\nA PAC script.\n\n  * mandatory\n\nboolean optional\n\nIf true, an invalid PAC script will prevent the network stack from falling\nback to direct connections. Defaults to false.\n\n  * url\n\nstring optional\n\nURL of the PAC file to be used.\n\n### ProxyConfig\n\nAn object encapsulating a complete proxy configuration.\n\n#### Properties\n\n  * mode\n\nMode\n\n'direct' = Never use a proxy 'auto_detect' = Auto detect proxy settings\n'pac_script' = Use specified PAC script 'fixed_servers' = Manually specify\nproxy servers 'system' = Use system proxy settings\n\n  * pacScript\n\nPacScript optional\n\nThe proxy auto-config (PAC) script for this configuration. Use this for\n'pac_script' mode.\n\n  * rules\n\nProxyRules optional\n\nThe proxy rules describing this configuration. Use this for 'fixed_servers'\nmode.\n\n### ProxyRules\n\nAn object encapsulating the set of proxy rules for all protocols. Use either\n'singleProxy' or (a subset of) 'proxyForHttp', 'proxyForHttps', 'proxyForFtp'\nand 'fallbackProxy'.\n\n#### Properties\n\n  * bypassList\n\nstring[] optional\n\nList of servers to connect to without a proxy server.\n\n  * fallbackProxy\n\nProxyServer optional\n\nThe proxy server to be used for everthing else or if any of the specific\nproxyFor... is not specified.\n\n  * proxyForFtp\n\nProxyServer optional\n\nThe proxy server to be used for FTP requests.\n\n  * proxyForHttp\n\nProxyServer optional\n\nThe proxy server to be used for HTTP requests.\n\n  * proxyForHttps\n\nProxyServer optional\n\nThe proxy server to be used for HTTPS requests.\n\n  * singleProxy\n\nProxyServer optional\n\nThe proxy server to be used for all per-URL requests (that is http, https, and\nftp).\n\n### ProxyServer\n\nAn object encapsulating a single proxy server's specification.\n\n#### Properties\n\n  * host\n\nstring\n\nThe hostname or IP address of the proxy server. Hostnames must be in ASCII (in\nPunycode format). IDNA is not supported, yet.\n\n  * port\n\nnumber optional\n\nThe port of the proxy server. Defaults to a port that depends on the scheme.\n\n  * scheme\n\nScheme optional\n\nThe scheme (protocol) of the proxy server itself. Defaults to 'http'.\n\n### Scheme\n\nChrome 54+\n\n#### Enum\n\n\"http\"  \n\n\"https\"  \n\n\"quic\"  \n\n\"socks4\"  \n\n\"socks5\"  \n\n## Properties\n\n### settings\n\nProxy settings to be used. The value of this setting is a ProxyConfig object.\n\n#### Type\n\ntypes.ChromeSetting<ProxyConfig>\n\n## Events\n\n### onProxyError\n\n    \n    \n    chrome.proxy.onProxyError.addListener(  \n      callback: function,  \n    )\n\nNotifies about proxy errors.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * details\n\nstring\n\nAdditional details about the error such as a JavaScript runtime error.\n\n      * error\n\nstring\n\nThe error description.\n\n      * fatal\n\nboolean\n\nIf true, the error was fatal and the network transaction was aborted.\nOtherwise, a direct connection is used instead.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/readingList": "#  chrome.readingList\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.readingList` API to read from and modify the items in the\nReading List.\n\n## Permissions\n\n`readingList`  \n\nTo use the Reading List API, add the `\"readingList\"` permission in the\nextension manifest file:\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"My reading list extension\",\n      ...\n      \"permissions\": [\n        \"readingList\"\n      ]\n    }\n    \n\n## Availability\n\nChrome 120+ MV3+\n\nChrome features a reading list located on the side panel. It lets users save\nweb pages to read later or when offline. Use the Reading List API to retrieve\nexisting items and add or remove items from the list.\n\n![Reading list showing a number of\narticles](/static/docs/extensions/reference/api/readingList/image/reading-\nlist-showing-num-a0718c5ab1fe5.png) Reading list showing a number of articles\n\n## Concepts and usage\n\n### Item ordering\n\nItems in the reading list are not in any guaranteed order.\n\n### Item uniqueness\n\nItems are keyed by URL. This includes the hash and query string.\n\n## Use cases\n\nThe following sections demonstrate some common use cases for the Reading List\nAPI. See Extension samples for complete extension examples.\n\n### Add an item\n\nTo add an item to the reading list, use `chrome.readingList.addEntry()`:\n\n    \n    \n    chrome.readingList.addEntry({\n      title: \"New to the web platform in September | web.dev\",\n      url: \"https://developer.chrome.com/\",\n      hasBeenRead: false\n    });\n    \n\n### Display items\n\nTo display items from the reading list, use the `chrome.readingList.query()`\nmethod to retrieve them. method.\n\n    \n    \n    const items = await chrome.readingList.query({});\n    \n    for (const item of items) {\n      // Do something do display the item\n    }\n    \n\n### Mark an item as read\n\nYou can use `chrome.readingList.updateEntry()` to update the title, URL, and\nread status. The following code marks an item as read:\n\n    \n    \n    chrome.readingList.updateEntry({\n      url: \"https://developer.chrome.com/\",\n      hasBeenRead: true\n    });\n    \n\n### Remove an item\n\nTo remove an item, use `chrome.readingList.removeEntry()`:\n\n    \n    \n    chrome.readingList.removeEntry({\n      url: \"https://developer.chrome.com/\"\n    });\n    \n\n## Extension samples\n\nFor more Reading List API extensions demos, see the Reading List API sample.\n\n## Types\n\n### AddEntryOptions\n\n#### Properties\n\n  * hasBeenRead\n\nboolean\n\nWill be `true` if the entry has been read.\n\n  * title\n\nstring\n\nThe title of the entry.\n\n  * url\n\nstring\n\nThe url of the entry.\n\n### QueryInfo\n\n#### Properties\n\n  * hasBeenRead\n\nboolean optional\n\nIndicates whether to search for read (`true`) or unread (`false`) items.\n\n  * title\n\nstring optional\n\nA title to search for.\n\n  * url\n\nstring optional\n\nA url to search for.\n\n### ReadingListEntry\n\n#### Properties\n\n  * creationTime\n\nnumber\n\nThe time the entry was created. Recorded in milliseconds since Jan 1, 1970.\n\n  * hasBeenRead\n\nboolean\n\nWill be `true` if the entry has been read.\n\n  * lastUpdateTime\n\nnumber\n\nThe last time the entry was updated. This value is in milliseconds since Jan\n1, 1970.\n\n  * title\n\nstring\n\nThe title of the entry.\n\n  * url\n\nstring\n\nThe url of the entry.\n\n### RemoveOptions\n\n#### Properties\n\n  * url\n\nstring\n\nThe url to remove.\n\n### UpdateEntryOptions\n\n#### Properties\n\n  * hasBeenRead\n\nboolean optional\n\nThe updated read status. The existing status remains if a value isn't\nprovided.\n\n  * title\n\nstring optional\n\nThe new title. The existing tile remains if a value isn't provided.\n\n  * url\n\nstring\n\nThe url that will be updated.\n\n## Methods\n\n### addEntry()\n\nPromise\n\n    \n    \n    chrome.readingList.addEntry(  \n      entry: AddEntryOptions,  \n      callback?: function,  \n    )\n\nAdds an entry to the reading list if it does not exist.\n\n#### Parameters\n\n  * entry\n\nAddEntryOptions\n\nThe entry to add to the reading list.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### query()\n\nPromise\n\n    \n    \n    chrome.readingList.query(  \n      info: QueryInfo,  \n      callback?: function,  \n    )\n\nRetrieves all entries that match the `QueryInfo` properties. Properties that\nare not provided will not be matched.\n\n#### Parameters\n\n  * info\n\nQueryInfo\n\nThe properties to search for.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (entries: ReadingListEntry[]) => void\n\n    * entries\n\nReadingListEntry[]\n\n#### Returns\n\n  * Promise<ReadingListEntry[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeEntry()\n\nPromise\n\n    \n    \n    chrome.readingList.removeEntry(  \n      info: RemoveOptions,  \n      callback?: function,  \n    )\n\nRemoves an entry from the reading list if it exists.\n\n#### Parameters\n\n  * info\n\nRemoveOptions\n\nThe entry to remove from the reading list.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### updateEntry()\n\nPromise\n\n    \n    \n    chrome.readingList.updateEntry(  \n      info: UpdateEntryOptions,  \n      callback?: function,  \n    )\n\nUpdates a reading list entry if it exists.\n\n#### Parameters\n\n  * info\n\nUpdateEntryOptions\n\nThe entry to update.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onEntryAdded\n\n    \n    \n    chrome.readingList.onEntryAdded.addListener(  \n      callback: function,  \n    )\n\nTriggered when a `ReadingListEntry` is added to the reading list.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (entry: ReadingListEntry) => void\n\n    * entry\n\nReadingListEntry\n\n### onEntryRemoved\n\n    \n    \n    chrome.readingList.onEntryRemoved.addListener(  \n      callback: function,  \n    )\n\nTriggered when a `ReadingListEntry` is removed from the reading list.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (entry: ReadingListEntry) => void\n\n    * entry\n\nReadingListEntry\n\n### onEntryUpdated\n\n    \n    \n    chrome.readingList.onEntryUpdated.addListener(  \n      callback: function,  \n    )\n\nTriggered when a `ReadingListEntry` is updated in the reading list.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (entry: ReadingListEntry) => void\n\n    * entry\n\nReadingListEntry\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/runtime": "#  chrome.runtime\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.runtime` API to retrieve the service worker, return details\nabout the manifest, and listen for and respond to events in the extension\nlifecycle. You can also use this API to convert the relative path of URLs to\nfully-qualified URLs.\n\nMost members of this API do **not** require any permissions. This permission\nis needed for `connectNative()`, `sendNativeMessage()` and `onNativeConnect`.\n\nThe following example shows how to declare the `\"nativeMessaging\"` permission\nin the manifest:\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"nativeMessaging\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nThe Runtime API provides methods to support a number of areas that your\nextensions can use:\n\nMessage passing\n\n    Your extension can communicate with different contexts within your extension and also with other extensions using these methods and events: `connect()`, `onConnect`, `onConnectExternal`, `sendMessage()`, `onMessage` and `onMessageExternal`. In addition, your extension can pass messages to native applications on the user's device using `connectNative()` and `sendNativeMessage()`.\n**Note:** See Message Passing for an overview of the subject.\n\nAccessing extension and platform metadata\n\n    These methods let you retrieve several specific pieces of metadata about the extension and the platform. Methods in this category include `getManifest()`, and `getPlatformInfo()`.\nManaging extension lifecycle and options\n\n    These properties let you perform some meta-operations on the extension, and display the options page. Methods and events in this category include `onInstalled`, `onStartup`, `openOptionsPage()`, `reload()`, `requestUpdateCheck()`, and `setUninstallURL()`.\nHelper utilities\n\n    These methods provide utility such as the conversion of internal resource representations to external formats. Methods in this category include `getURL()`.\nKiosk mode utilities\n\n    These methods are available only on ChromeOS, and exist mainly to support kiosk implementations. Methods in this category include `restart()` and `restartAfterDelay()``.\n\n### Unpacked extension behavior\n\nWhen an unpacked extension is reloaded, this is treated as an update. This\nmeans that the `chrome.runtime.onInstalled` event will fire with the\n`\"update\"` reason. This includes when the extension is reloaded with\n`chrome.runtime.reload()`.\n\n## Use cases\n\n### Add an image to a web page\n\nFor a web page to access an asset hosted on another domain, it must specify\nthe resource's full URL (e.g. `<img src=\"https://example.com/logo.png\">`). The\nsame is true to include an extension asset on a web page. The two differences\nare that the extension's assets must be exposed as web accessible resources\nand that typically content scripts are responsible for injecting extension\nassets.\n\nIn this example, the extension will add `logo.png` to the page that the\ncontent script is being injected into by using `runtime.getURL()` to create a\nfully-qualified URL. But first, the asset must be declared as a web accessible\nresource in the manifest.\n\nmanifest.json:\n\n    \n    \n    {\n      ...\n      \"web_accessible_resources\": [\n        {\n          \"resources\": [ \"logo.png\" ],\n          \"matches\": [ \"https://*/*\" ]\n        }\n      ],\n      ...\n    }\n    \n\ncontent.js:\n\n    \n    \n    { // Block used to avoid setting global variables\n      const img = document.createElement('img');\n      img.src = chrome.runtime.getURL('logo.png');\n      document.body.append(img);\n    }\n    \n\n### Send data from a content script to the service worker\n\nIts common for an extension's content scripts to need data managed by another\npart of the extension, like the service worker. Much like two browser windows\nopened to the same web page, these two contexts cannot directly access each\nother's values. Instead, the extension can use message passing to coordinate\nacross these different contexts.\n\nIn this example, the content script needs some data from the extension's\nservice worker to initialize its UI. To get this data, it passes the\ndeveloper-defined `get-user-data` message to the service worker, and it\nresponds with a copy of the user's information.\n\ncontent.js:\n\n    \n    \n    // 1. Send a message to the service worker requesting the user's data\n    chrome.runtime.sendMessage('get-user-data', (response) => {\n      // 3. Got an asynchronous response with the data from the service worker\n      console.log('received user data', response);\n      initializeUI(response);\n    });\n    \n\nservice-worker.js:\n\n    \n    \n    // Example of a simple user data object\n    const user = {\n      username: 'demo-user'\n    };\n    \n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n      // 2. A page requested user data, respond with a copy of `user`\n      if (message === 'get-user-data') {\n        sendResponse(user);\n      }\n    });\n    \n\n### Gather feedback on uninstall\n\nMany extensions use post-uninstall surveys to understand how the extension\ncould better serve its users and improve retention. The following example\nshows how to add this functionality.\n\nbackground.js:\n\n    \n    \n    chrome.runtime.onInstalled.addListener(details => {\n      if (details.reason === chrome.runtime.OnInstalledReason.INSTALL) {\n        chrome.runtime.setUninstallURL('https://example.com/extension-survey');\n      }\n    });\n    \n\n## Examples\n\nSee the Manifest V3 - Web Accessible Resources demo for more Runtime API\nexamples.\n\n## Types\n\n### ContextFilter\n\nChrome 114+\n\nA filter to match against certain extension contexts. Matching contexts must\nmatch all specified filters; any filter that is not specified matches all\navailable contexts. Thus, a filter of `{}` will match all available contexts.\n\n#### Properties\n\n  * contextIds\n\nstring[] optional\n\n  * contextTypes\n\nContextType[] optional\n\n  * documentIds\n\nstring[] optional\n\n  * documentOrigins\n\nstring[] optional\n\n  * documentUrls\n\nstring[] optional\n\n  * frameIds\n\nnumber[] optional\n\n  * incognito\n\nboolean optional\n\n  * tabIds\n\nnumber[] optional\n\n  * windowIds\n\nnumber[] optional\n\n### ContextType\n\nChrome 114+\n\n#### Enum\n\n\"TAB\"  \nSpecifies the context type as a tab\n\n\"POPUP\"  \nSpecifies the context type as an extension popup window\n\n\"BACKGROUND\"  \nSpecifies the context type as a service worker.\n\n\"OFFSCREEN_DOCUMENT\"  \nSpecifies the context type as an offscreen document.\n\n\"SIDE_PANEL\"  \nSpecifies the context type as a side panel.\n\n\"DEVELOPER_TOOLS\"  \nSpecifies the context type as developer tools.\n\n### ExtensionContext\n\nChrome 114+\n\nA context hosting extension content.\n\n#### Properties\n\n  * contextId\n\nstring\n\nA unique identifier for this context\n\n  * contextType\n\nContextType\n\nThe type of context this corresponds to.\n\n  * documentId\n\nstring optional\n\nA UUID for the document associated with this context, or undefined if this\ncontext is hosted not in a document.\n\n  * documentOrigin\n\nstring optional\n\nThe origin of the document associated with this context, or undefined if the\ncontext is not hosted in a document.\n\n  * documentUrl\n\nstring optional\n\nThe URL of the document associated with this context, or undefined if the\ncontext is not hosted in a document.\n\n  * frameId\n\nnumber\n\nThe ID of the frame for this context, or -1 if this context is not hosted in a\nframe.\n\n  * incognito\n\nboolean\n\nWhether the context is associated with an incognito profile.\n\n  * tabId\n\nnumber\n\nThe ID of the tab for this context, or -1 if this context is not hosted in a\ntab.\n\n  * windowId\n\nnumber\n\nThe ID of the window for this context, or -1 if this context is not hosted in\na window.\n\n### MessageSender\n\nAn object containing information about the script context that sent a message\nor request.\n\n#### Properties\n\n  * documentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the document that opened the connection.\n\n  * documentLifecycle\n\nstring optional\n\nChrome 106+\n\nThe lifecycle the document that opened the connection is in at the time the\nport was created. Note that the lifecycle state of the document may have\nchanged since port creation.\n\n  * frameId\n\nnumber optional\n\nThe frame that opened the connection. 0 for top-level frames, positive for\nchild frames. This will only be set when `tab` is set.\n\n  * id\n\nstring optional\n\nThe ID of the extension that opened the connection, if any.\n\n  * nativeApplication\n\nstring optional\n\nChrome 74+\n\nThe name of the native application that opened the connection, if any.\n\n  * origin\n\nstring optional\n\nChrome 80+\n\nThe origin of the page or frame that opened the connection. It can vary from\nthe url property (e.g., about:blank) or can be opaque (e.g., sandboxed\niframes). This is useful for identifying if the origin can be trusted if we\ncan't immediately tell from the URL.\n\n  * tab\n\nTab optional\n\nThe `tabs.Tab` which opened the connection, if any. This property will\n**only** be present when the connection was opened from a tab (including\ncontent scripts), and **only** if the receiver is an extension, not an app.\n\n  * tlsChannelId\n\nstring optional\n\nThe TLS channel ID of the page or frame that opened the connection, if\nrequested by the extension, and if available.\n\n  * url\n\nstring optional\n\nThe URL of the page or frame that opened the connection. If the sender is in\nan iframe, it will be iframe's URL not the URL of the page which hosts it.\n\n### OnInstalledReason\n\nChrome 44+\n\nThe reason that this event is being dispatched.\n\n#### Enum\n\n\"install\"  \nSpecifies the event reason as an installation.\n\n\"update\"  \nSpecifies the event reason as an extension update.\n\n\"chrome_update\"  \nSpecifies the event reason as a Chrome update.\n\n\"shared_module_update\"  \nSpecifies the event reason as an update to a shared module.\n\n### OnRestartRequiredReason\n\nChrome 44+\n\nThe reason that the event is being dispatched. 'app_update' is used when the\nrestart is needed because the application is updated to a newer version.\n'os_update' is used when the restart is needed because the browser/OS is\nupdated to a newer version. 'periodic' is used when the system runs for more\nthan the permitted uptime set in the enterprise policy.\n\n#### Enum\n\n\"app_update\"  \nSpecifies the event reason as an update to the app.\n\n\"os_update\"  \nSpecifies the event reason as an update to the operating system.\n\n\"periodic\"  \nSpecifies the event reason as a periodic restart of the app.\n\n### PlatformArch\n\nChrome 44+\n\nThe machine's processor architecture.\n\n#### Enum\n\n\"arm\"  \nSpecifies the processer architecture as arm.\n\n\"arm64\"  \nSpecifies the processer architecture as arm64.\n\n\"x86-32\"  \nSpecifies the processer architecture as x86-32.\n\n\"x86-64\"  \nSpecifies the processer architecture as x86-64.\n\n\"mips\"  \nSpecifies the processer architecture as mips.\n\n\"mips64\"  \nSpecifies the processer architecture as mips64.\n\n### PlatformInfo\n\nAn object containing information about the current platform.\n\n#### Properties\n\n  * arch\n\nPlatformArch\n\nThe machine's processor architecture.\n\n  * nacl_arch\n\nPlatformNaclArch\n\nThe native client architecture. This may be different from arch on some\nplatforms.\n\n  * os\n\nPlatformOs\n\nThe operating system Chrome is running on.\n\n### PlatformNaclArch\n\nChrome 44+\n\nThe native client architecture. This may be different from arch on some\nplatforms.\n\n#### Enum\n\n\"arm\"  \nSpecifies the native client architecture as arm.\n\n\"x86-32\"  \nSpecifies the native client architecture as x86-32.\n\n\"x86-64\"  \nSpecifies the native client architecture as x86-64.\n\n\"mips\"  \nSpecifies the native client architecture as mips.\n\n\"mips64\"  \nSpecifies the native client architecture as mips64.\n\n### PlatformOs\n\nChrome 44+\n\nThe operating system Chrome is running on.\n\n#### Enum\n\n\"mac\"  \nSpecifies the MacOS operating system.\n\n\"win\"  \nSpecifies the Windows operating system.\n\n\"android\"  \nSpecifies the Android operating system.\n\n\"cros\"  \nSpecifies the Chrome operating system.\n\n\"linux\"  \nSpecifies the Linux operating system.\n\n\"openbsd\"  \nSpecifies the OpenBSD operating system.\n\n\"fuchsia\"  \nSpecifies the Fuchsia operating system.\n\n### Port\n\nAn object which allows two way communication with other pages. See Long-lived\nconnections for more information.\n\n#### Properties\n\n  * name\n\nstring\n\nThe name of the port, as specified in the call to `runtime.connect`.\n\n  * onDisconnect\n\nEvent<functionvoidvoid>\n\nFired when the port is disconnected from the other end(s). `runtime.lastError`\nmay be set if the port was disconnected by an error. If the port is closed via\ndisconnect, then this event is _only_ fired on the other end. This event is\nfired at most once (see also Port lifetime).\n\nThe `onDisconnect.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (port: Port) => void\n\n      * port\n\nPort\n\n  * onMessage\n\nEvent<functionvoidvoid>\n\nThis event is fired when postMessage is called by the other end of the port.\n\nThe `onMessage.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (message: any, port: Port) => void\n\n      * message\n\nany\n\n      * port\n\nPort\n\n  * sender\n\nMessageSender optional\n\nThis property will **only** be present on ports passed to onConnect /\nonConnectExternal / onConnectNative listeners.\n\n  * disconnect\n\nvoid\n\nImmediately disconnect the port. Calling `disconnect()` on an already-\ndisconnected port has no effect. When a port is disconnected, no new events\nwill be dispatched to this port.\n\nThe `disconnect` function looks like:\n\n        \n        () => {...}\n\n  * postMessage\n\nvoid\n\nSend a message to the other end of the port. If the port is disconnected, an\nerror is thrown.\n\nThe `postMessage` function looks like:\n\n        \n        (message: any) => {...}\n\n    * message\n\nany\n\nChrome 52+\n\nThe message to send. This object should be JSON-ifiable.\n\n### RequestUpdateCheckStatus\n\nChrome 44+\n\nResult of the update check.\n\n#### Enum\n\n\"throttled\"  \nSpecifies that the status check has been throttled. This can occur after\nrepeated checks within a short amount of time.\n\n\"no_update\"  \nSpecifies that there are no available updates to install.\n\n\"update_available\"  \nSpecifies that there is an available update to install.\n\n## Properties\n\n### id\n\nThe ID of the extension/app.\n\n#### Type\n\nstring\n\n### lastError\n\nPopulated with an error message if calling an API function fails; otherwise\nundefined. This is only defined within the scope of that function's callback.\nIf an error is produced, but `runtime.lastError` is not accessed within the\ncallback, a message is logged to the console listing the API function that\nproduced the error. API functions that return promises do not set this\nproperty.\n\n#### Type\n\nobject\n\n#### Properties\n\n  * message\n\nstring optional\n\nDetails about the error which occurred.\n\n## Methods\n\n### connect()\n\n    \n    \n    chrome.runtime.connect(  \n      extensionId?: string,  \n      connectInfo?: object,  \n    )\n\nAttempts to connect listeners within an extension (such as the background\npage), or other extensions/apps. This is useful for content scripts connecting\nto their extension processes, inter-app/extension communication, and web\nmessaging. Note that this does not connect to any listeners in a content\nscript. Extensions may connect to content scripts embedded in tabs via\n`tabs.connect`.\n\n#### Parameters\n\n  * extensionId\n\nstring optional\n\nThe ID of the extension to connect to. If omitted, a connection will be\nattempted with your own extension. Required if sending messages from a web\npage for web messaging.\n\n  * connectInfo\n\nobject optional\n\n    * includeTlsChannelId\n\nboolean optional\n\nWhether the TLS channel ID will be passed into onConnectExternal for processes\nthat are listening for the connection event.\n\n    * name\n\nstring optional\n\nWill be passed into onConnect for processes that are listening for the\nconnection event.\n\n#### Returns\n\n  * Port\n\nPort through which messages can be sent and received. The port's onDisconnect\nevent is fired if the extension does not exist.\n\n### connectNative()\n\n    \n    \n    chrome.runtime.connectNative(  \n      application: string,  \n    )\n\nConnects to a native application in the host machine. This method requires the\n`\"nativeMessaging\"` permission. See Native Messaging for more information.\n\n#### Parameters\n\n  * application\n\nstring\n\nThe name of the registered application to connect to.\n\n#### Returns\n\n  * Port\n\nPort through which messages can be sent and received with the application\n\n### getBackgroundPage()\n\nPromise  Foreground only  Deprecated since Chrome 133\n\n    \n    \n    chrome.runtime.getBackgroundPage(  \n      callback?: function,  \n    )\n\nBackground pages do not exist in MV3 extensions.\n\nRetrieves the JavaScript 'window' object for the background page running\ninside the current extension/app. If the background page is an event page, the\nsystem will ensure it is loaded before calling the callback. If there is no\nbackground page, an error is set.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (backgroundPage?: Window) => void\n\n    * backgroundPage\n\nWindow optional\n\nThe JavaScript 'window' object for the background page.\n\n#### Returns\n\n  * Promise<Window | undefined>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getContexts()\n\nPromise Chrome 116+ MV3+\n\n    \n    \n    chrome.runtime.getContexts(  \n      filter: ContextFilter,  \n      callback?: function,  \n    )\n\nFetches information about active contexts associated with this extension\n\n#### Parameters\n\n  * filter\n\nContextFilter\n\nA filter to find matching contexts. A context matches if it matches all\nspecified fields in the filter. Any unspecified field in the filter matches\nall contexts.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (contexts: ExtensionContext[]) => void\n\n    * contexts\n\nExtensionContext[]\n\nThe matching contexts, if any.\n\n#### Returns\n\n  * Promise<ExtensionContext[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getManifest()\n\n    \n    \n    chrome.runtime.getManifest()\n\nReturns details about the app or extension from the manifest. The object\nreturned is a serialization of the full manifest file.\n\n#### Returns\n\n  * object\n\nThe manifest details.\n\n### getPackageDirectoryEntry()\n\nPromise  Foreground only\n\n    \n    \n    chrome.runtime.getPackageDirectoryEntry(  \n      callback?: function,  \n    )\n\nReturns a DirectoryEntry for the package directory.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (directoryEntry: DirectoryEntry) => void\n\n    * directoryEntry\n\nDirectoryEntry\n\n#### Returns\n\n  * Promise<DirectoryEntry>\n\nChrome 122+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPlatformInfo()\n\nPromise\n\n    \n    \n    chrome.runtime.getPlatformInfo(  \n      callback?: function,  \n    )\n\nReturns information about the current platform.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (platformInfo: PlatformInfo) => void\n\n    * platformInfo\n\nPlatformInfo\n\n#### Returns\n\n  * Promise<PlatformInfo>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getURL()\n\n    \n    \n    chrome.runtime.getURL(  \n      path: string,  \n    )\n\nConverts a relative path within an app/extension install directory to a fully-\nqualified URL.\n\n#### Parameters\n\n  * path\n\nstring\n\nA path to a resource within an app/extension expressed relative to its install\ndirectory.\n\n#### Returns\n\n  * string\n\nThe fully-qualified URL to the resource.\n\n### openOptionsPage()\n\nPromise\n\n    \n    \n    chrome.runtime.openOptionsPage(  \n      callback?: function,  \n    )\n\nOpen your Extension's options page, if possible.\n\nThe precise behavior may depend on your manifest's `options_ui` or\n`options_page` key, or what Chrome happens to support at the time. For\nexample, the page may be opened in a new tab, within chrome://extensions,\nwithin an App, or it may just focus an open options page. It will never cause\nthe caller page to reload.\n\nIf your Extension does not declare an options page, or Chrome failed to create\none for some other reason, the callback will set `lastError`.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### reload()\n\n    \n    \n    chrome.runtime.reload()\n\nReloads the app or extension. This method is not supported in kiosk mode. For\nkiosk mode, use chrome.runtime.restart() method.\n\n### requestUpdateCheck()\n\nPromise\n\n    \n    \n    chrome.runtime.requestUpdateCheck(  \n      callback?: function,  \n    )\n\nRequests an immediate update check be done for this app/extension.\n\n**Important** : Most extensions/apps should **not** use this method, since\nChrome already does automatic checks every few hours, and you can listen for\nthe `runtime.onUpdateAvailable` event without needing to call\nrequestUpdateCheck.\n\nThis method is only appropriate to call in very limited circumstances, such as\nif your extension talks to a backend service, and the backend service has\ndetermined that the client extension version is very far out of date and you'd\nlike to prompt a user to update. Most other uses of requestUpdateCheck, such\nas calling it unconditionally based on a repeating timer, probably only serve\nto waste client, network, and server resources.\n\nNote: When called with a callback, instead of returning an object this\nfunction will return the two properties as separate arguments passed to the\ncallback.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: object) => void\n\n    * result\n\nobject\n\nChrome 109+\n\nRequestUpdateCheckResult object that holds the status of the update check and\nany details of the result if there is an update available\n\n      * status\n\nRequestUpdateCheckStatus\n\nResult of the update check.\n\n      * version\n\nstring optional\n\nIf an update is available, this contains the version of the available update.\n\n#### Returns\n\n  * Promise<object>\n\nChrome 109+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### restart()\n\n    \n    \n    chrome.runtime.restart()\n\nRestart the ChromeOS device when the app runs in kiosk mode. Otherwise, it's\nno-op.\n\n### restartAfterDelay()\n\nPromise Chrome 53+\n\n    \n    \n    chrome.runtime.restartAfterDelay(  \n      seconds: number,  \n      callback?: function,  \n    )\n\nRestart the ChromeOS device when the app runs in kiosk mode after the given\nseconds. If called again before the time ends, the reboot will be delayed. If\ncalled with a value of -1, the reboot will be cancelled. It's a no-op in non-\nkiosk mode. It's only allowed to be called repeatedly by the first extension\nto invoke this API.\n\n#### Parameters\n\n  * seconds\n\nnumber\n\nTime to wait in seconds before rebooting the device, or -1 to cancel a\nscheduled reboot.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### sendMessage()\n\nPromise\n\n    \n    \n    chrome.runtime.sendMessage(  \n      extensionId?: string,  \n      message: any,  \n      options?: object,  \n      callback?: function,  \n    )\n\nSends a single message to event listeners within your extension or a different\nextension/app. Similar to `runtime.connect` but only sends a single message,\nwith an optional response. If sending to your extension, the\n`runtime.onMessage` event will be fired in every frame of your extension\n(except for the sender's frame), or `runtime.onMessageExternal`, if a\ndifferent extension. Note that extensions cannot send messages to content\nscripts using this method. To send messages to content scripts, use\n`tabs.sendMessage`.\n\n#### Parameters\n\n  * extensionId\n\nstring optional\n\nThe ID of the extension to send the message to. If omitted, the message will\nbe sent to your own extension/app. Required if sending messages from a web\npage for web messaging.\n\n  * message\n\nany\n\nThe message to send. This message should be a JSON-ifiable object.\n\n  * options\n\nobject optional\n\n    * includeTlsChannelId\n\nboolean optional\n\nWhether the TLS channel ID will be passed into onMessageExternal for processes\nthat are listening for the connection event.\n\n  * callback\n\nfunction optional\n\nChrome 99+\n\nThe `callback` parameter looks like:\n\n        \n        (response: any) => void\n\n    * response\n\nany\n\nThe JSON response object sent by the handler of the message. If an error\noccurs while connecting to the extension, the callback will be called with no\narguments and `runtime.lastError` will be set to the error message.\n\n#### Returns\n\n  * Promise<any>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### sendNativeMessage()\n\nPromise\n\n    \n    \n    chrome.runtime.sendNativeMessage(  \n      application: string,  \n      message: object,  \n      callback?: function,  \n    )\n\nSend a single message to a native application. This method requires the\n`\"nativeMessaging\"` permission.\n\n#### Parameters\n\n  * application\n\nstring\n\nThe name of the native messaging host.\n\n  * message\n\nobject\n\nThe message that will be passed to the native messaging host.\n\n  * callback\n\nfunction optional\n\nChrome 99+\n\nThe `callback` parameter looks like:\n\n        \n        (response: any) => void\n\n    * response\n\nany\n\nThe response message sent by the native messaging host. If an error occurs\nwhile connecting to the native messaging host, the callback will be called\nwith no arguments and `runtime.lastError` will be set to the error message.\n\n#### Returns\n\n  * Promise<any>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setUninstallURL()\n\nPromise\n\n    \n    \n    chrome.runtime.setUninstallURL(  \n      url: string,  \n      callback?: function,  \n    )\n\nSets the URL to be visited upon uninstallation. This may be used to clean up\nserver-side data, do analytics, and implement surveys. Maximum 1023\ncharacters.\n\n#### Parameters\n\n  * url\n\nstring\n\nURL to be opened after the extension is uninstalled. This URL must have an\nhttp: or https: scheme. Set an empty string to not open a new tab upon\nuninstallation.\n\n  * callback\n\nfunction optional\n\nChrome 45+\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onBrowserUpdateAvailable\n\nDeprecated\n\n    \n    \n    chrome.runtime.onBrowserUpdateAvailable.addListener(  \n      callback: function,  \n    )\n\nPlease use `runtime.onRestartRequired`.\n\nFired when a Chrome update is available, but isn't installed immediately\nbecause a browser restart is required.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onConnect\n\n    \n    \n    chrome.runtime.onConnect.addListener(  \n      callback: function,  \n    )\n\nFired when a connection is made from either an extension process or a content\nscript (by `runtime.connect`).\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (port: Port) => void\n\n    * port\n\nPort\n\n### onConnectExternal\n\n    \n    \n    chrome.runtime.onConnectExternal.addListener(  \n      callback: function,  \n    )\n\nFired when a connection is made from another extension (by `runtime.connect`),\nor from an externally connectable web site.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (port: Port) => void\n\n    * port\n\nPort\n\n### onConnectNative\n\nChrome 76+\n\n    \n    \n    chrome.runtime.onConnectNative.addListener(  \n      callback: function,  \n    )\n\nFired when a connection is made from a native application. This event requires\nthe `\"nativeMessaging\"` permission. It is only supported on Chrome OS.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (port: Port) => void\n\n    * port\n\nPort\n\n### onInstalled\n\n    \n    \n    chrome.runtime.onInstalled.addListener(  \n      callback: function,  \n    )\n\nFired when the extension is first installed, when the extension is updated to\na new version, and when Chrome is updated to a new version.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * id\n\nstring optional\n\nIndicates the ID of the imported shared module extension which updated. This\nis present only if 'reason' is 'shared_module_update'.\n\n      * previousVersion\n\nstring optional\n\nIndicates the previous version of the extension, which has just been updated.\nThis is present only if 'reason' is 'update'.\n\n      * reason\n\nOnInstalledReason\n\nThe reason that this event is being dispatched.\n\n### onMessage\n\n    \n    \n    chrome.runtime.onMessage.addListener(  \n      callback: function,  \n    )\n\nFired when a message is sent from either an extension process (by\n`runtime.sendMessage`) or a content script (by `tabs.sendMessage`).\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n\n    * message\n\nany\n\n    * sender\n\nMessageSender\n\n    * sendResponse\n\nfunction\n\nThe `sendResponse` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nboolean | undefined\n\n### onMessageExternal\n\n    \n    \n    chrome.runtime.onMessageExternal.addListener(  \n      callback: function,  \n    )\n\nFired when a message is sent from another extension (by\n`runtime.sendMessage`). Cannot be used in a content script.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n\n    * message\n\nany\n\n    * sender\n\nMessageSender\n\n    * sendResponse\n\nfunction\n\nThe `sendResponse` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nboolean | undefined\n\n### onRestartRequired\n\n    \n    \n    chrome.runtime.onRestartRequired.addListener(  \n      callback: function,  \n    )\n\nFired when an app or the device that it runs on needs to be restarted. The app\nshould close all its windows at its earliest convenient time to let the\nrestart to happen. If the app does nothing, a restart will be enforced after a\n24-hour grace period has passed. Currently, this event is only fired for\nChrome OS kiosk apps.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (reason: OnRestartRequiredReason) => void\n\n    * reason\n\nOnRestartRequiredReason\n\n### onStartup\n\n    \n    \n    chrome.runtime.onStartup.addListener(  \n      callback: function,  \n    )\n\nFired when a profile that has this extension installed first starts up. This\nevent is not fired when an incognito profile is started, even if this\nextension is operating in 'split' incognito mode.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onSuspend\n\n    \n    \n    chrome.runtime.onSuspend.addListener(  \n      callback: function,  \n    )\n\nSent to the event page just before it is unloaded. This gives the extension\nopportunity to do some clean up. Note that since the page is unloading, any\nasynchronous operations started while handling this event are not guaranteed\nto complete. If more activity for the event page occurs before it gets\nunloaded the onSuspendCanceled event will be sent and the page won't be\nunloaded.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onSuspendCanceled\n\n    \n    \n    chrome.runtime.onSuspendCanceled.addListener(  \n      callback: function,  \n    )\n\nSent after onSuspend to indicate that the app won't be unloaded after all.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onUpdateAvailable\n\n    \n    \n    chrome.runtime.onUpdateAvailable.addListener(  \n      callback: function,  \n    )\n\nFired when an update is available, but isn't installed immediately because the\napp is currently running. If you do nothing, the update will be installed the\nnext time the background page gets unloaded, if you want it to be installed\nsooner you can explicitly call chrome.runtime.reload(). If your extension is\nusing a persistent background page, the background page of course never gets\nunloaded, so unless you call chrome.runtime.reload() manually in response to\nthis event the update will not get installed until the next time Chrome itself\nrestarts. If no handlers are listening for this event, and your extension has\na persistent background page, it behaves as if chrome.runtime.reload() is\ncalled in response to this event.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * version\n\nstring\n\nThe version number of the available update.\n\n### onUserScriptConnect\n\nChrome 115+ MV3+\n\n    \n    \n    chrome.runtime.onUserScriptConnect.addListener(  \n      callback: function,  \n    )\n\nFired when a connection is made from a user script from this extension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (port: Port) => void\n\n    * port\n\nPort\n\n### onUserScriptMessage\n\nChrome 115+ MV3+\n\n    \n    \n    chrome.runtime.onUserScriptMessage.addListener(  \n      callback: function,  \n    )\n\nFired when a message is sent from a user script associated with the same\nextension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n\n    * message\n\nany\n\n    * sender\n\nMessageSender\n\n    * sendResponse\n\nfunction\n\nThe `sendResponse` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nboolean | undefined\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/scripting": "#  chrome.scripting\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.scripting` API to execute script in different contexts.\n\n## Permissions\n\n`scripting`  \n\n## Availability\n\nChrome 88+ MV3+\n\n## Manifest\n\nTo use the `chrome.scripting` API, declare the `\"scripting\"` permission in the\nmanifest plus the host permissions for the pages to inject scripts into. Use\nthe `\"host_permissions\"` key or the `\"activeTab\"` permission, which grants\ntemporary host permissions. The following example uses the activeTab\npermission.\n\n    \n    \n    {\n     \"name\": \"Scripting Extension\",\n     \"manifest_version\": 3,\n     \"permissions\": [\"scripting\", \"activeTab\"],\n     ...\n    }\n    \n\n## Concepts and usage\n\nYou can use the `chrome.scripting` API to inject JavaScript and CSS into\nwebsites. This is similar to what you can do with content scripts. But by\nusing the `chrome.scripting` namespace, extensions can make decisions at\nruntime.\n\n### Injection targets\n\nYou can use the `target` parameter to specify a target to inject JavaScript or\nCSS into.\n\nThe only required field is `tabId`. By default, an injection will run in the\nmain frame of the specified tab.\n\n    \n    \n    function getTabId() { ... }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId()},\n          files : [ \"script.js\" ],\n        })\n        .then(() => console.log(\"script injected\"));\n    \n\nTo run in all frames of the specified tab, you can set the `allFrames` boolean\nto `true`.\n\n    \n    \n    function getTabId() { ... }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId(), allFrames : true},\n          files : [ \"script.js\" ],\n        })\n        .then(() => console.log(\"script injected in all frames\"));\n    \n\nYou can also inject into specific frames of a tab by specifying individual\nframe IDs. For more information on frame IDs, see the `chrome.webNavigation`\nAPI.\n\n    \n    \n    function getTabId() { ... }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId(), frameIds : [ frameId1, frameId2 ]},\n          files : [ \"script.js\" ],\n        })\n        .then(() => console.log(\"script injected on target frames\"));\n    \n\n**Note:** You cannot specify both the `\"frameIds\"` and `\"allFrames\"`\nproperties.\n\n### Injected code\n\nExtensions can specify the code to be injected either via an external file or\na runtime variable.\n\n#### Files\n\nFiles are specified as strings that are paths relative to the extension's root\ndirectory. The following code will inject the file `script.js` into the main\nframe of the tab.\n\n    \n    \n    function getTabId() { ... }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId()},\n          files : [ \"script.js\" ],\n        })\n        .then(() => console.log(\"injected script file\"));\n    \n\n#### Runtime functions\n\nWhen injecting JavaScript with `scripting.executeScript()`, you can specify a\nfunction to be executed instead of a file. This function should be a function\nvariable available to the current extension context.\n\n    \n    \n    function getTabId() { ... }\n    function getTitle() { return document.title; }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId()},\n          func : getTitle,\n        })\n        .then(() => console.log(\"injected a function\"));\n    \n    \n    \n    function getTabId() { ... }\n    function getUserColor() { ... }\n    \n    function changeBackgroundColor() {\n      document.body.style.backgroundColor = getUserColor();\n    }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId()},\n          func : changeBackgroundColor,\n        })\n        .then(() => console.log(\"injected a function\"));\n    \n\nYou can work around this by using the `args` property:\n\n    \n    \n    function getTabId() { ... }\n    function getUserColor() { ... }\n    function changeBackgroundColor(backgroundColor) {\n      document.body.style.backgroundColor = backgroundColor;\n    }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId()},\n          func : changeBackgroundColor,\n          args : [ getUserColor() ],\n        })\n        .then(() => console.log(\"injected a function\"));\n    \n\n#### Runtime strings\n\nIf injecting CSS within a page, you can also specify a string to be used in\nthe `css` property. This option is only available for `scripting.insertCSS()`;\nyou can't execute a string using `scripting.executeScript()`.\n\n    \n    \n    function getTabId() { ... }\n    const css = \"body { background-color: red; }\";\n    \n    chrome.scripting\n        .insertCSS({\n          target : {tabId : getTabId()},\n          css : css,\n        })\n        .then(() => console.log(\"CSS injected\"));\n    \n\n### Handle the results\n\nThe results of executing JavaScript are passed to the extension. A single\nresult is included per-frame. The main frame is guaranteed to be the first\nindex in the resulting array; all other frames are in a non-deterministic\norder.\n\n    \n    \n    function getTabId() { ... }\n    function getTitle() { return document.title; }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId(), allFrames : true},\n          func : getTitle,\n        })\n        .then(injectionResults => {\n          for (const {frameId, result} of injectionResults) {\n            console.log(`Frame ${frameId} result:`, result);\n          }\n        });\n    \n\n`scripting.insertCSS()` does not return any results.\n\n#### Promises\n\nIf the resulting value of the script execution is a promise, Chrome will wait\nfor the promise to settle and return the resulting value.\n\n    \n    \n    function getTabId() { ... }\n    async function addIframe() {\n      const iframe = document.createElement(\"iframe\");\n      const loadComplete =\n          new Promise(resolve => iframe.addEventListener(\"load\", resolve));\n      iframe.src = \"https://example.com\";\n      document.body.appendChild(iframe);\n      await loadComplete;\n      return iframe.contentWindow.document.title;\n    }\n    \n    chrome.scripting\n        .executeScript({\n          target : {tabId : getTabId(), allFrames : true},\n          func : addIframe,\n        })\n        .then(injectionResults => {\n          for (const frameResult of injectionResults) {\n            const {frameId, result} = frameResult;\n            console.log(`Frame ${frameId} result:`, result);\n          }\n        });\n    \n\n## Examples\n\n### Unregister all dynamic content scripts\n\nThe following snippet contains a function that unregisters all dynamic content\nscripts the extension has previously registered.\n\n    \n    \n    async function unregisterAllDynamicContentScripts() {\n      try {\n        const scripts = await chrome.scripting.getRegisteredContentScripts();\n        const scriptIds = scripts.map(script => script.id);\n        return chrome.scripting.unregisterContentScripts({ ids: scriptIds });\n      } catch (error) {\n        const message = [\n          \"An unexpected error occurred while\",\n          \"unregistering dynamic content scripts.\",\n        ].join(\" \");\n        throw new Error(message, {cause : error});\n      }\n    }\n    \n\n**Key point:** Unregistering content scripts will not remove scripts or styles\nthat have already been injected.\n\nTo try the `chrome.scripting` API, install the scripting sample from the\nChrome extension samples repository.\n\n## Types\n\n### ContentScriptFilter\n\nChrome 96+\n\n#### Properties\n\n  * ids\n\nstring[] optional\n\nIf specified, `getRegisteredContentScripts` will only return scripts with an\nid specified in this list.\n\n### CSSInjection\n\n#### Properties\n\n  * css\n\nstring optional\n\nA string containing the CSS to inject. Exactly one of `files` and `css` must\nbe specified.\n\n  * files\n\nstring[] optional\n\nThe path of the CSS files to inject, relative to the extension's root\ndirectory. Exactly one of `files` and `css` must be specified.\n\n  * origin\n\nStyleOrigin optional\n\nThe style origin for the injection. Defaults to `'AUTHOR'`.\n\n  * target\n\nInjectionTarget\n\nDetails specifying the target into which to insert the CSS.\n\n### ExecutionWorld\n\nChrome 95+\n\nThe JavaScript world for a script to execute within.\n\n#### Enum\n\n\"ISOLATED\"  \nSpecifies the isolated world, which is the execution environment unique to\nthis extension.\n\n\"MAIN\"  \nSpecifies the main world of the DOM, which is the execution environment shared\nwith the host page's JavaScript.\n\n### InjectionResult\n\n#### Properties\n\n  * documentId\n\nstring\n\nChrome 106+\n\nThe document associated with the injection.\n\n  * frameId\n\nnumber\n\nChrome 90+\n\nThe frame associated with the injection.\n\n  * result\n\nany optional\n\nThe result of the script execution.\n\n### InjectionTarget\n\n#### Properties\n\n  * allFrames\n\nboolean optional\n\nWhether the script should inject into all frames within the tab. Defaults to\nfalse. This must not be true if `frameIds` is specified.\n\n  * documentIds\n\nstring[] optional\n\nChrome 106+\n\nThe IDs of specific documentIds to inject into. This must not be set if\n`frameIds` is set.\n\n  * frameIds\n\nnumber[] optional\n\nThe IDs of specific frames to inject into.\n\n  * tabId\n\nnumber\n\nThe ID of the tab into which to inject.\n\n### RegisteredContentScript\n\nChrome 96+\n\n#### Properties\n\n  * allFrames\n\nboolean optional\n\nIf specified true, it will inject into all frames, even if the frame is not\nthe top-most frame in the tab. Each frame is checked independently for URL\nrequirements; it will not inject into child frames if the URL requirements are\nnot met. Defaults to false, meaning that only the top frame is matched.\n\n  * css\n\nstring[] optional\n\nThe list of CSS files to be injected into matching pages. These are injected\nin the order they appear in this array, before any DOM is constructed or\ndisplayed for the page.\n\n  * excludeMatches\n\nstring[] optional\n\nExcludes pages that this content script would otherwise be injected into. See\nMatch Patterns for more details on the syntax of these strings.\n\n  * id\n\nstring\n\nThe id of the content script, specified in the API call. Must not start with a\n'_' as it's reserved as a prefix for generated script IDs.\n\n  * js\n\nstring[] optional\n\nThe list of JavaScript files to be injected into matching pages. These are\ninjected in the order they appear in this array.\n\n  * matchOriginAsFallback\n\nboolean optional\n\nChrome 119+\n\nIndicates whether the script can be injected into frames where the URL\ncontains an unsupported scheme; specifically: about:, data:, blob:, or\nfilesystem:. In these cases, the URL's origin is checked to determine if the\nscript should be injected. If the origin is `null` (as is the case for data:\nURLs) then the used origin is either the frame that created the current frame\nor the frame that initiated the navigation to this frame. Note that this may\nnot be the parent frame.\n\n  * matches\n\nstring[] optional\n\nSpecifies which pages this content script will be injected into. See Match\nPatterns for more details on the syntax of these strings. Must be specified\nfor `registerContentScripts`.\n\n  * persistAcrossSessions\n\nboolean optional\n\nSpecifies if this content script will persist into future sessions. The\ndefault is true.\n\n  * runAt\n\nRunAt optional\n\nSpecifies when JavaScript files are injected into the web page. The preferred\nand default value is `document_idle`.\n\n  * world\n\nExecutionWorld optional\n\nChrome 102+\n\nThe JavaScript \"world\" to run the script in. Defaults to `ISOLATED`.\n\n### ScriptInjection\n\n#### Properties\n\n  * args\n\nany[] optional\n\nChrome 92+\n\nThe arguments to pass to the provided function. This is only valid if the\n`func` parameter is specified. These arguments must be JSON-serializable.\n\n  * files\n\nstring[] optional\n\nThe path of the JS or CSS files to inject, relative to the extension's root\ndirectory. Exactly one of `files` or `func` must be specified.\n\n  * injectImmediately\n\nboolean optional\n\nChrome 102+\n\nWhether the injection should be triggered in the target as soon as possible.\nNote that this is not a guarantee that injection will occur prior to page\nload, as the page may have already loaded by the time the script reaches the\ntarget.\n\n  * target\n\nInjectionTarget\n\nDetails specifying the target into which to inject the script.\n\n  * world\n\nExecutionWorld optional\n\nChrome 95+\n\nThe JavaScript \"world\" to run the script in. Defaults to `ISOLATED`.\n\n  * func\n\nvoid optional\n\nChrome 92+\n\nA JavaScript function to inject. This function will be serialized, and then\ndeserialized for injection. This means that any bound parameters and execution\ncontext will be lost. Exactly one of `files` or `func` must be specified.\n\nThe `func` function looks like:\n\n        \n        () => {...}\n\n### StyleOrigin\n\nThe origin for a style change. See style origins for more info.\n\n#### Enum\n\n\"AUTHOR\"  \n\n\"USER\"  \n\n## Methods\n\n### executeScript()\n\nPromise\n\n    \n    \n    chrome.scripting.executeScript(  \n      injection: ScriptInjection,  \n      callback?: function,  \n    )\n\nInjects a script into a target context. By default, the script will be run at\n`document_idle`, or immediately if the page has already loaded. If the\n`injectImmediately` property is set, the script will inject without waiting,\neven if the page has not finished loading. If the script evaluates to a\npromise, the browser will wait for the promise to settle and return the\nresulting value.\n\n#### Parameters\n\n  * injection\n\nScriptInjection\n\nThe details of the script which to inject.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (results: InjectionResult[]) => void\n\n    * results\n\nInjectionResult[]\n\n#### Returns\n\n  * Promise<InjectionResult[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getRegisteredContentScripts()\n\nPromise Chrome 96+\n\n    \n    \n    chrome.scripting.getRegisteredContentScripts(  \n      filter?: ContentScriptFilter,  \n      callback?: function,  \n    )\n\nReturns all dynamically registered content scripts for this extension that\nmatch the given filter.\n\n#### Parameters\n\n  * filter\n\nContentScriptFilter optional\n\nAn object to filter the extension's dynamically registered scripts.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (scripts: RegisteredContentScript[]) => void\n\n    * scripts\n\nRegisteredContentScript[]\n\n#### Returns\n\n  * Promise<RegisteredContentScript[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### insertCSS()\n\nPromise\n\n    \n    \n    chrome.scripting.insertCSS(  \n      injection: CSSInjection,  \n      callback?: function,  \n    )\n\nInserts a CSS stylesheet into a target context. If multiple frames are\nspecified, unsuccessful injections are ignored.\n\n#### Parameters\n\n  * injection\n\nCSSInjection\n\nThe details of the styles to insert.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### registerContentScripts()\n\nPromise Chrome 96+\n\n    \n    \n    chrome.scripting.registerContentScripts(  \n      scripts: RegisteredContentScript[],  \n      callback?: function,  \n    )\n\nRegisters one or more content scripts for this extension.\n\n#### Parameters\n\n  * scripts\n\nRegisteredContentScript[]\n\nContains a list of scripts to be registered. If there are errors during script\nparsing/file validation, or if the IDs specified already exist, then no\nscripts are registered.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### removeCSS()\n\nPromise Chrome 90+\n\n    \n    \n    chrome.scripting.removeCSS(  \n      injection: CSSInjection,  \n      callback?: function,  \n    )\n\nRemoves a CSS stylesheet that was previously inserted by this extension from a\ntarget context.\n\n#### Parameters\n\n  * injection\n\nCSSInjection\n\nThe details of the styles to remove. Note that the `css`, `files`, and\n`origin` properties must exactly match the stylesheet inserted through\n`insertCSS`. Attempting to remove a non-existent stylesheet is a no-op.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### unregisterContentScripts()\n\nPromise Chrome 96+\n\n    \n    \n    chrome.scripting.unregisterContentScripts(  \n      filter?: ContentScriptFilter,  \n      callback?: function,  \n    )\n\nUnregisters content scripts for this extension.\n\n#### Parameters\n\n  * filter\n\nContentScriptFilter optional\n\nIf specified, only unregisters dynamic content scripts which match the filter.\nOtherwise, all of the extension's dynamic content scripts are unregistered.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### updateContentScripts()\n\nPromise Chrome 96+\n\n    \n    \n    chrome.scripting.updateContentScripts(  \n      scripts: RegisteredContentScript[],  \n      callback?: function,  \n    )\n\nUpdates one or more content scripts for this extension.\n\n#### Parameters\n\n  * scripts\n\nRegisteredContentScript[]\n\nContains a list of scripts to be updated. A property is only updated for the\nexisting script if it is specified in this object. If there are errors during\nscript parsing/file validation, or if the IDs specified do not correspond to a\nfully registered script, then no scripts are updated.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/search": "#  chrome.search\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.search` API to search via the default provider.\n\n## Permissions\n\n`search`  \n\n## Availability\n\nChrome 87+\n\n## Types\n\n### Disposition\n\n#### Enum\n\n\"CURRENT_TAB\"  \nSpecifies that the search results display in the calling tab or the tab from\nthe active browser.\n\n\"NEW_TAB\"  \nSpecifies that the search results display in a new tab.\n\n\"NEW_WINDOW\"  \nSpecifies that the search results display in a new window.\n\n### QueryInfo\n\n#### Properties\n\n  * disposition\n\nDisposition optional\n\nLocation where search results should be displayed. `CURRENT_TAB` is the\ndefault.\n\n  * tabId\n\nnumber optional\n\nLocation where search results should be displayed. `tabId` cannot be used with\n`disposition`.\n\n  * text\n\nstring\n\nString to query with the default search provider.\n\n## Methods\n\n### query()\n\nPromise\n\n    \n    \n    chrome.search.query(  \n      queryInfo: QueryInfo,  \n      callback?: function,  \n    )\n\nUsed to query the default search provider. In case of an error,\n`runtime.lastError` will be set.\n\n#### Parameters\n\n  * queryInfo\n\nQueryInfo\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/sessions": "#  chrome.sessions\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.sessions` API to query and restore tabs and windows from a\nbrowsing session.\n\n## Permissions\n\n`sessions`  \n\n## Types\n\n### Device\n\n#### Properties\n\n  * deviceName\n\nstring\n\nThe name of the foreign device.\n\n  * sessions\n\nSession[]\n\nA list of open window sessions for the foreign device, sorted from most\nrecently to least recently modified session.\n\n### Filter\n\n#### Properties\n\n  * maxResults\n\nnumber optional\n\nThe maximum number of entries to be fetched in the requested list. Omit this\nparameter to fetch the maximum number of entries\n(`sessions.MAX_SESSION_RESULTS`).\n\n### Session\n\n#### Properties\n\n  * lastModified\n\nnumber\n\nThe time when the window or tab was closed or modified, represented in seconds\nsince the epoch.\n\n  * tab\n\nTab optional\n\nThe `tabs.Tab`, if this entry describes a tab. Either this or\n`sessions.Session.window` will be set.\n\n  * window\n\nWindow optional\n\nThe `windows.Window`, if this entry describes a window. Either this or\n`sessions.Session.tab` will be set.\n\n## Properties\n\n### MAX_SESSION_RESULTS\n\nThe maximum number of `sessions.Session` that will be included in a requested\nlist.\n\n#### Value\n\n25  \n\n## Methods\n\n### getDevices()\n\nPromise\n\n    \n    \n    chrome.sessions.getDevices(  \n      filter?: Filter,  \n      callback?: function,  \n    )\n\nRetrieves all devices with synced sessions.\n\n#### Parameters\n\n  * filter\n\nFilter optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (devices: Device[]) => void\n\n    * devices\n\nDevice[]\n\nThe list of `sessions.Device` objects for each synced session, sorted in order\nfrom device with most recently modified session to device with least recently\nmodified session. `tabs.Tab` objects are sorted by recency in the\n`windows.Window` of the `sessions.Session` objects.\n\n#### Returns\n\n  * Promise<Device[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getRecentlyClosed()\n\nPromise\n\n    \n    \n    chrome.sessions.getRecentlyClosed(  \n      filter?: Filter,  \n      callback?: function,  \n    )\n\nGets the list of recently closed tabs and/or windows.\n\n#### Parameters\n\n  * filter\n\nFilter optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (sessions: Session[]) => void\n\n    * sessions\n\nSession[]\n\nThe list of closed entries in reverse order that they were closed (the most\nrecently closed tab or window will be at index `0`). The entries may contain\neither tabs or windows.\n\n#### Returns\n\n  * Promise<Session[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### restore()\n\nPromise\n\n    \n    \n    chrome.sessions.restore(  \n      sessionId?: string,  \n      callback?: function,  \n    )\n\nReopens a `windows.Window` or `tabs.Tab`, with an optional callback to run\nwhen the entry has been restored.\n\n#### Parameters\n\n  * sessionId\n\nstring optional\n\nThe `windows.Window.sessionId`, or `tabs.Tab.sessionId` to restore. If this\nparameter is not specified, the most recently closed session is restored.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (restoredSession: Session) => void\n\n    * restoredSession\n\nSession\n\nA `sessions.Session` containing the restored `windows.Window` or `tabs.Tab`\nobject.\n\n#### Returns\n\n  * Promise<Session>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onChanged\n\n    \n    \n    chrome.sessions.onChanged.addListener(  \n      callback: function,  \n    )\n\nFired when recently closed tabs and/or windows are changed. This event does\nnot monitor synced sessions changes.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/sidePanel": "#  chrome.sidePanel\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.sidePanel` API to host content in the browser's side panel\nalongside the main content of a webpage.\n\n## Permissions\n\n`sidePanel`  \n\nTo use the Side Panel API, add the `\"sidePanel\"` permission in the extension\nmanifest file:\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"My side panel extension\",\n      ...\n      \"permissions\": [\n        \"sidePanel\"\n      ]\n    }\n    \n\n## Availability\n\nChrome 114+ MV3+\n\n## Concepts and usage\n\nThe Side Panel API allows extensions to display their own UI in the side\npanel, enabling persistent experiences that complement the user's browsing\njourney.\n\n![Side panel drop-down\nmenu](/static/docs/extensions/reference/api/sidePanel/images/example-side-\npanel.png) Chrome browser side panel UI.\n\nSome features include:\n\n  * The side panel remains open when navigating between tabs (if set to do so).\n  * It can be available only on specific websites.\n  * As an extension page, side panels have access to all Chrome APIs.\n  * Within Chrome's settings, users can specify which side the panel should be displayed on.\n\n### Use cases\n\nThe following sections demonstrate some common use cases for the Side Panel\nAPI. See Extension samples for complete extension examples.\n\n#### Display the same side panel on every site\n\nThe side panel can be set initially from the `\"default_path\"` property in the\n`\"side_panel\"` key of the manifest to display the same side panel on every\nsite. This should point to a relative path within the extension directory.\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"My side panel extension\",\n      ...\n      \"side_panel\": {\n        \"default_path\": \"sidepanel.html\"\n      }\n      ...\n    }\n    \n\nsidepanel.html:\n\n    \n    \n    <!DOCTYPE html>\n    <html>\n      <head>\n        <title>My Sidepanel</title>\n      </head>\n      <body>\n        <h1>All sites sidepanel extension</h1>\n        <p>This side panel is enabled on all sites</p>\n      </body>\n    </html>\n    \n\n#### Enable a side panel on a specific site\n\nAn extension can use `sidepanel.setOptions()` to enable a side panel on a\nspecific tab. This example uses `chrome.tabs.onUpdated()` to listen for any\nupdates made to the tab. It checks if the URL is www.google.com and enables\nthe side panel. Otherwise, it disables it.\n\nservice-worker.js:\n\n    \n    \n    const GOOGLE_ORIGIN = 'https://www.google.com';\n    \n    chrome.tabs.onUpdated.addListener(async (tabId, info, tab) => {\n      if (!tab.url) return;\n      const url = new URL(tab.url);\n      // Enables the side panel on google.com\n      if (url.origin === GOOGLE_ORIGIN) {\n        await chrome.sidePanel.setOptions({\n          tabId,\n          path: 'sidepanel.html',\n          enabled: true\n        });\n      } else {\n        // Disables the side panel on all other sites\n        await chrome.sidePanel.setOptions({\n          tabId,\n          enabled: false\n        });\n      }\n    });\n    \n\nWhen a user temporarily switches to a tab where the side panel is not enabled,\nthe side panel will be hidden. It will automatically show again when the user\nswitches to a tab where it was previously open.\n\nWhen the user navigates to a site where the side panel is not enabled, the\nside panel will close, and the extension won't show in the side panel drop-\ndown menu.\n\nFor a complete example, see the Tab-specific side panel sample.\n\n#### Open the side panel by clicking the toolbar icon\n\nDevelopers can allow users to open the side panel when they click the action\ntoolbar icon with `sidePanel.setPanelBehavior()`. First, declare the\n`\"action\"` key in the manifest:\n\nmanifest.json:\n\n    \n    \n    {\n      \"name\": \"My side panel extension\",\n      ...\n      \"action\": {\n        \"default_title\": \"Click to open panel\"\n      },\n      ...\n    }\n    \n\nNow, add this code to the previous example:\n\nservice-worker.js:\n\n    \n    \n    const GOOGLE_ORIGIN = 'https://www.google.com';\n    \n    // Allows users to open the side panel by clicking on the action toolbar icon\n    chrome.sidePanel\n      .setPanelBehavior({ openPanelOnActionClick: true })\n      .catch((error) => console.error(error));\n    ...\n    \n\n#### Programmatically open the side panel on user interaction\n\nChrome 116 introduces `sidePanel.open()`. It allows extensions to open the\nside panel through an extension user gesture, such as clicking on the action\nicon. Or a user interaction on an extension page or content script, such as\nclicking a button. For a complete demo, see the Open Side Panel sample\nextension.\n\nThe following code shows how to open a global side panel on the current window\nwhen the user clicks on a context menu. When using `sidePanel.open()`, you\nmust choose the context in which it should open. Use `windowId` to open a\nglobal side panel. Alternatively, set the `tabId` to open the side panel only\non a specific tab.\n\nservice-worker.js:\n\n    \n    \n    chrome.runtime.onInstalled.addListener(() => {\n      chrome.contextMenus.create({\n        id: 'openSidePanel',\n        title: 'Open side panel',\n        contexts: ['all']\n      });\n    });\n    \n    chrome.contextMenus.onClicked.addListener((info, tab) => {\n      if (info.menuItemId === 'openSidePanel') {\n        // This will open the panel in all the pages on the current window.\n        chrome.sidePanel.open({ windowId: tab.windowId });\n      }\n    });\n    \n\n**Key point:** Remember to design your side panel as a useful companion tool\nfor users, improving their browsing experience without unnecessary\ndistractions. Check the Quality Guidelines in the Program Policies for more\ninfo.\n\n#### Switch to a different panel\n\nExtensions can use `sidepanel.getOptions()` to retrieve the current side\npanel. The following example sets a welcome side panel on\n`runtime.onInstalled()`. Then when the user navigates to a different tab, it\nreplaces it with the main side panel.\n\nservice-worker.js:\n\n    \n    \n    const welcomePage = 'sidepanels/welcome-sp.html';\n    const mainPage = 'sidepanels/main-sp.html';\n    \n    chrome.runtime.onInstalled.addListener(() => {\n      chrome.sidePanel.setOptions({ path: welcomePage });\n      chrome.sidePanel.setPanelBehavior({ openPanelOnActionClick: true });\n    });\n    \n    chrome.tabs.onActivated.addListener(async ({ tabId }) => {\n      const { path } = await chrome.sidePanel.getOptions({ tabId });\n      if (path === welcomePage) {\n        chrome.sidePanel.setOptions({ path: mainPage });\n      }\n    });\n    \n\nSee the Multiple side panels sample for the full code.\n\n### Side panel user experience\n\nUsers will see Chrome's built-in side panels first. Each side panel displays\nthe extension's icon in the side panel menu. If no icons are included, it will\nshow a placeholder icon with the first letter of the extension's name.\n\n#### Open the side panel\n\nTo allow users to open the side panel, use an action icon in combination with\n`sidePanel.setPanelBehavior()`. Alternatively, make a call to\n`sidePanel.open()` following a user interaction, such as:\n\n  * An action click\n  * A keyboard shortcut\n  * A context menu\n  * A user gesture on an extension page or content script.\n\n#### Pin the side panel\n\n![Pin icon in side panel\nUI.](/static/docs/extensions/reference/api/sidePanel/images/side-panel-\npin.png) Pin icon in side panel UI.\n\nThe side panel toolbar displays a pin icon when your side panel is open.\nClicking the icon pins your extension's action icon. Clicking the action icon\nonce pinned will perform the default action for your action icon and will only\nopen the side panel if this has been explicitly configured.\n\n## Examples\n\nFor more Side Panel API extensions demos, explore any of the following\nextensions:\n\n  * Dictionary side panel.\n  * Global side panel.\n  * Multiple side panels.\n  * Open Side panel.\n  * Site-specific side panel.\n\n## Types\n\n### GetPanelOptions\n\n#### Properties\n\n  * tabId\n\nnumber optional\n\nIf specified, the side panel options for the given tab will be returned.\nOtherwise, returns the default side panel options (used for any tab that\ndoesn't have specific settings).\n\n### OpenOptions\n\nChrome 116+\n\n#### Properties\n\n  * tabId\n\nnumber optional\n\nThe tab in which to open the side panel. If the corresponding tab has a tab-\nspecific side panel, the panel will only be open for that tab. If there is not\na tab-specific panel, the global panel will be open in the specified tab and\nany other tabs without a currently-open tab- specific panel. This will\noverride any currently-active side panel (global or tab-specific) in the\ncorresponding tab. At least one of this or `windowId` must be provided.\n\n  * windowId\n\nnumber optional\n\nThe window in which to open the side panel. This is only applicable if the\nextension has a global (non-tab-specific) side panel or `tabId` is also\nspecified. This will override any currently-active global side panel the user\nhas open in the given window. At least one of this or `tabId` must be\nprovided.\n\n### PanelBehavior\n\n#### Properties\n\n  * openPanelOnActionClick\n\nboolean optional\n\nWhether clicking the extension's icon will toggle showing the extension's\nentry in the side panel. Defaults to false.\n\n### PanelOptions\n\n#### Properties\n\n  * enabled\n\nboolean optional\n\nWhether the side panel should be enabled. This is optional. The default value\nis true.\n\n  * path\n\nstring optional\n\nThe path to the side panel HTML file to use. This must be a local resource\nwithin the extension package.\n\n  * tabId\n\nnumber optional\n\nIf specified, the side panel options will only apply to the tab with this id.\nIf omitted, these options set the default behavior (used for any tab that\ndoesn't have specific settings). Note: if the same path is set for this tabId\nand the default tabId, then the panel for this tabId will be a different\ninstance than the panel for the default tabId.\n\n### SidePanel\n\n#### Properties\n\n  * default_path\n\nstring\n\nDeveloper specified path for side panel display.\n\n## Methods\n\n### getOptions()\n\nPromise\n\n    \n    \n    chrome.sidePanel.getOptions(  \n      options: GetPanelOptions,  \n      callback?: function,  \n    )\n\nReturns the active panel configuration.\n\n#### Parameters\n\n  * options\n\nGetPanelOptions\n\nSpecifies the context to return the configuration for.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (options: PanelOptions) => void\n\n    * options\n\nPanelOptions\n\n#### Returns\n\n  * Promise<PanelOptions>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getPanelBehavior()\n\nPromise\n\n    \n    \n    chrome.sidePanel.getPanelBehavior(  \n      callback?: function,  \n    )\n\nReturns the extension's current side panel behavior.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (behavior: PanelBehavior) => void\n\n    * behavior\n\nPanelBehavior\n\n#### Returns\n\n  * Promise<PanelBehavior>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### open()\n\nPromise Chrome 116+\n\n    \n    \n    chrome.sidePanel.open(  \n      options: OpenOptions,  \n      callback?: function,  \n    )\n\nOpens the side panel for the extension. This may only be called in response to\na user action.\n\n#### Parameters\n\n  * options\n\nOpenOptions\n\nSpecifies the context in which to open the side panel.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setOptions()\n\nPromise\n\n    \n    \n    chrome.sidePanel.setOptions(  \n      options: PanelOptions,  \n      callback?: function,  \n    )\n\nConfigures the side panel.\n\n#### Parameters\n\n  * options\n\nPanelOptions\n\nThe configuration options to apply to the panel.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setPanelBehavior()\n\nPromise\n\n    \n    \n    chrome.sidePanel.setPanelBehavior(  \n      behavior: PanelBehavior,  \n      callback?: function,  \n    )\n\nConfigures the extension's side panel behavior. This is an upsert operation.\n\n#### Parameters\n\n  * behavior\n\nPanelBehavior\n\nThe new behavior to be set.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/storage": "#  chrome.storage\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.storage` API to store, retrieve, and track changes to user\ndata.\n\n## Permissions\n\n`storage`  \n\nTo use the storage API, declare the `\"storage\"` permission in the extension\nmanifest. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"storage\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\nThe Storage API provides an extension-specific way to persist user data and\nstate. It's similar to the web platform's storage APIs (IndexedDB, and\nStorage), but was designed to meet the storage needs of extensions. The\nfollowing are a few key features:\n\n  * All extension contexts, including the extension service worker and content scripts have access to the Storage API.\n  * The JSON serializable values are stored as object properties.\n  * The Storage API is asynchronous with bulk read and write operations.\n  * Even if the user clears the cache and browsing history, the data persists.\n  * Stored settings persist even when using split incognito.\n  * Includes an exclusive read-only managed storage area for enterprise policies.\n\n### Can extensions use web storage APIs?\n\nWhile extensions can use the `Storage` interface (accessible from\n`window.localStorage`) in some contexts (popup and other HTML pages), we don't\nrecommend it for the following reasons:\n\n  * Extension service workers can't use the Web Storage API.\n  * Content scripts share storage with the host page.\n  * Data saved using the Web Storage API is lost when the user clears their browsing history.\n\nTo move data from web storage APIs to extension storage APIs from a service\nworker:\n\n  1. Prepare an offscreen document html page and script file. The script file should contain a conversion routine and an `onMessage` handler.\n  2. In the extension service worker, check `chrome.storage` for your data.\n  3. If your data isn't found, call `createDocument()`.\n  4. After the returned Promise resolves, call `sendMessage()` to start the conversion routine.\n  5. Inside the offscreen document's `onMessage` handler, call the conversion routine.\n\nThere are also some nuances to how web storage APIs work in extensions. Learn\nmore in the Storage and Cookies article.\n\n### Storage areas\n\nThe Storage API is divided into the following storage areas:\n\n`storage.local`\n\n    Data is stored locally and cleared when the extension is removed. The storage limit is 10 MB (5 MB in Chrome 113 and earlier), but can be increased by requesting the `\"unlimitedStorage\"` permission. We recommend using `storage.local` to store larger amounts of data.\n`storage.managed`\n\n    Managed storage is read-only storage for policy installed extensions and managed by system administrators using a developer-defined schema and enterprise policies. Policies are analogous to options but are configured by a system administrator instead of the user, allowing the extension to be preconfigured for all users of an organization. For information on policies, see Documentation for Administrators. To learn more about the `managed` storage area, see Manifest for storage areas.\n`storage.session`\n\n    Holds data in memory while an extension is loaded. The storage is cleared if the extension is disabled, reloaded or updated and when the browser restarts. By default, it's not exposed to content scripts, but this behavior can be changed by setting `chrome.storage.session.setAccessLevel()`. The storage limit is 10 MB (1 MB in Chrome 111 and earlier). The`storage.session` interface is one of several we recommend for service workers.\n`storage.sync`\n\n    If syncing is enabled, the data is synced to any Chrome browser that the user is logged into. If disabled, it behaves like `storage.local`. Chrome stores the data locally when the browser is offline and resumes syncing when it's back online. The quota limitation is approximately 100 KB, 8 KB per item. We recommend using `storage.sync` to preserve user settings across synced browsers. If you're working with sensitive user data, instead use `storage.session`.\n\n### Storage and throttling limits\n\nThe Storage API has the following usage limitations:\n\n  * Storing data often comes with performance costs, and the API includes storage quotas. We recommend being careful about what data you store so that you don't lose the ability to store data.\n  * Storage can take time to complete. Make sure to structure your code to account for that time.\n\nFor details on storage area limitations and what happens when they're\nexceeded, see the quota information for `sync`, `local`, and `session`.\n\n## Use cases\n\nThe following sections demonstrate common use cases for the Storage API.\n\n### Synchronous response to storage updates\n\nTo track changes made to storage, add a listener to its `onChanged` event.\nWhen anything changes in storage, that event fires. The sample code listens\nfor these changes:\n\nbackground.js:\n\n    \n    \n    chrome.storage.onChanged.addListener((changes, namespace) => {\n      for (let [key, { oldValue, newValue }] of Object.entries(changes)) {\n        console.log(\n          `Storage key \"${key}\" in namespace \"${namespace}\" changed.`,\n          `Old value was \"${oldValue}\", new value is \"${newValue}\".`\n        );\n      }\n    });\n    \n\nWe can take this idea even further. In this example, we have an options page\nthat allows the user to toggle a \"debug mode\" (implementation not shown here).\nThe options page immediately saves the new settings to `storage.sync`, and the\nservice worker uses `storage.onChanged` to apply the setting as soon as\npossible.\n\noptions.html:\n\n    \n    \n    <!-- type=\"module\" allows you to use top level await -->\n    <script defer src=\"options.js\" type=\"module\"></script>\n    <form id=\"optionsForm\">\n      <label for=\"debug\">\n        <input type=\"checkbox\" name=\"debug\" id=\"debug\">\n        Enable debug mode\n      </label>\n    </form>\n    \n\noptions.js:\n\n    \n    \n    // In-page cache of the user's options\n    const options = {};\n    const optionsForm = document.getElementById(\"optionsForm\");\n    \n    // Immediately persist options changes\n    optionsForm.debug.addEventListener(\"change\", (event) => {\n      options.debug = event.target.checked;\n      chrome.storage.sync.set({ options });\n    });\n    \n    // Initialize the form with the user's option settings\n    const data = await chrome.storage.sync.get(\"options\");\n    Object.assign(options, data.options);\n    optionsForm.debug.checked = Boolean(options.debug);\n    \n\nbackground.js:\n\n    \n    \n    function setDebugMode() { /* ... */ }\n    \n    // Watch for changes to the user's options & apply them\n    chrome.storage.onChanged.addListener((changes, area) => {\n      if (area === 'sync' && changes.options?.newValue) {\n        const debugMode = Boolean(changes.options.newValue.debug);\n        console.log('enable debug mode?', debugMode);\n        setDebugMode(debugMode);\n      }\n    });\n    \n\n### Asynchronous preload from storage\n\nBecause service workers don't run all the time, Manifest V3 extensions\nsometimes need to asynchronously load data from storage before they execute\ntheir event handlers. To do this, the following snippet uses an async\n`action.onClicked` event handler that waits for the `storageCache` global to\nbe populated before executing its logic.\n\nbackground.js:\n\n    \n    \n    // Where we will expose all the data we retrieve from storage.sync.\n    const storageCache = { count: 0 };\n    // Asynchronously retrieve data from storage.sync, then cache it.\n    const initStorageCache = chrome.storage.sync.get().then((items) => {\n      // Copy the data retrieved from storage into storageCache.\n      Object.assign(storageCache, items);\n    });\n    \n    chrome.action.onClicked.addListener(async (tab) => {\n      try {\n        await initStorageCache;\n      } catch (e) {\n        // Handle error that occurred during storage initialization.\n      }\n    \n      // Normal action handler logic.\n      storageCache.count++;\n      storageCache.lastTabId = tab.id;\n      chrome.storage.sync.set(storageCache);\n    });\n    \n\n## DevTools\n\nYou can view and edit data stored using the API in DevTools. To learn more,\nsee the View and edit extension storage page in the DevTools documentation.\n\n## Examples\n\nThe following samples demonstrate the `local`, `sync`, and `session` storage\nareas:\n\n### Local\n\n    \n    \n    chrome.storage.local.set({ key: value }).then(() => {\n      console.log(\"Value is set\");\n    });\n    \n    chrome.storage.local.get([\"key\"]).then((result) => {\n      console.log(\"Value is \" + result.key);\n    });\n    \n\n### Sync\n\n    \n    \n    chrome.storage.sync.set({ key: value }).then(() => {\n      console.log(\"Value is set\");\n    });\n    \n    chrome.storage.sync.get([\"key\"]).then((result) => {\n      console.log(\"Value is \" + result.key);\n    });\n    \n\n### Session\n\n    \n    \n    chrome.storage.session.set({ key: value }).then(() => {\n      console.log(\"Value was set\");\n    });\n    \n    chrome.storage.session.get([\"key\"]).then((result) => {\n      console.log(\"Value is \" + result.key);\n    });\n    \n\nTo see other demos of the Storage API, explore any of the following samples:\n\n  * Global search extension.\n  * Water alarm extension.\n\n## Types\n\n### AccessLevel\n\nChrome 102+\n\nThe storage area's access level.\n\n#### Enum\n\n\"TRUSTED_CONTEXTS\"  \nSpecifies contexts originating from the extension itself.\n\n\"TRUSTED_AND_UNTRUSTED_CONTEXTS\"  \nSpecifies contexts originating from outside the extension.\n\n### StorageArea\n\n#### Properties\n\n  * onChanged\n\nEvent<functionvoidvoid>\n\nChrome 73+\n\nFired when one or more items change.\n\nThe `onChanged.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (changes: object) => void\n\n      * changes\n\nobject\n\n  * clear\n\nvoid\n\nPromise\n\nRemoves all items from storage.\n\nThe `clear` function looks like:\n\n        \n        (callback?: function) => {...}\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nChrome 95+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * get\n\nvoid\n\nPromise\n\nGets one or more items from storage.\n\nThe `get` function looks like:\n\n        \n        (keys?: string | string[] | object, callback?: function) => {...}\n\n    * keys\n\nstring | string[] | object optional\n\nA single key to get, list of keys to get, or a dictionary specifying default\nvalues (see description of the object). An empty list or object will return an\nempty result object. Pass in `null` to get the entire contents of storage.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (items: object) => void\n\n      * items\n\nobject\n\nObject with items in their key-value mappings.\n\n    * returns\n\nPromise<object>\n\nChrome 95+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * getBytesInUse\n\nvoid\n\nPromise\n\nGets the amount of space (in bytes) being used by one or more items.\n\nThe `getBytesInUse` function looks like:\n\n        \n        (keys?: string | string[], callback?: function) => {...}\n\n    * keys\n\nstring | string[] optional\n\nA single key or list of keys to get the total usage for. An empty list will\nreturn 0. Pass in `null` to get the total usage of all of storage.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (bytesInUse: number) => void\n\n      * bytesInUse\n\nnumber\n\nAmount of space being used in storage, in bytes.\n\n    * returns\n\nPromise<number>\n\nChrome 95+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * getKeys\n\nvoid\n\nPromise Chrome 130+\n\nGets all keys from storage.\n\nThe `getKeys` function looks like:\n\n        \n        (callback?: function) => {...}\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (keys: string[]) => void\n\n      * keys\n\nstring[]\n\nArray with keys read from storage.\n\n    * returns\n\nPromise<string[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * remove\n\nvoid\n\nPromise\n\nRemoves one or more items from storage.\n\nThe `remove` function looks like:\n\n        \n        (keys: string | string[], callback?: function) => {...}\n\n    * keys\n\nstring | string[]\n\nA single key or a list of keys for items to remove.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nChrome 95+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * set\n\nvoid\n\nPromise\n\nSets multiple items.\n\nThe `set` function looks like:\n\n        \n        (items: object, callback?: function) => {...}\n\n    * items\n\nobject\n\nAn object which gives each key/value pair to update storage with. Any other\nkey/value pairs in storage will not be affected.\n\nPrimitive values such as numbers will serialize as expected. Values with a\n`typeof` `\"object\"` and `\"function\"` will typically serialize to `{}`, with\nthe exception of `Array` (serializes as expected), `Date`, and `Regex`\n(serialize using their `String` representation).\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nChrome 95+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * setAccessLevel\n\nvoid\n\nPromise Chrome 102+\n\nSets the desired access level for the storage area. The default will be only\ntrusted contexts.\n\nThe `setAccessLevel` function looks like:\n\n        \n        (accessOptions: object, callback?: function) => {...}\n\n    * accessOptions\n\nobject\n\n      * accessLevel\n\nAccessLevel\n\nThe access level of the storage area.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### StorageChange\n\n#### Properties\n\n  * newValue\n\nany optional\n\nThe new value of the item, if there is a new value.\n\n  * oldValue\n\nany optional\n\nThe old value of the item, if there was an old value.\n\n## Properties\n\n### local\n\nItems in the `local` storage area are local to each machine.\n\n#### Type\n\nStorageArea & object\n\n#### Properties\n\n  * QUOTA_BYTES\n\n10485760  \n\nThe maximum amount (in bytes) of data that can be stored in local storage, as\nmeasured by the JSON stringification of every value plus every key's length.\nThis value will be ignored if the extension has the `unlimitedStorage`\npermission. Updates that would cause this limit to be exceeded fail\nimmediately and set `runtime.lastError` when using a callback, or a rejected\nPromise if using async/await.\n\n### managed\n\nItems in the `managed` storage area are set by an enterprise policy configured\nby the domain administrator, and are read-only for the extension; trying to\nmodify this namespace results in an error. For information on configuring a\npolicy, see Manifest for storage areas.\n\n#### Type\n\nStorageArea\n\n### session\n\nChrome 102+ MV3+\n\nItems in the `session` storage area are stored in-memory and will not be\npersisted to disk.\n\n#### Type\n\nStorageArea & object\n\n#### Properties\n\n  * QUOTA_BYTES\n\n10485760  \n\nThe maximum amount (in bytes) of data that can be stored in memory, as\nmeasured by estimating the dynamically allocated memory usage of every value\nand key. Updates that would cause this limit to be exceeded fail immediately\nand set `runtime.lastError` when using a callback, or when a Promise is\nrejected.\n\n### sync\n\nItems in the `sync` storage area are synced using Chrome Sync.\n\n#### Type\n\nStorageArea & object\n\n#### Properties\n\n  * MAX_ITEMS\n\n512  \n\nThe maximum number of items that can be stored in sync storage. Updates that\nwould cause this limit to be exceeded will fail immediately and set\n`runtime.lastError` when using a callback, or when a Promise is rejected.\n\n  * MAX_SUSTAINED_WRITE_OPERATIONS_PER_MINUTE\n\n1000000  \n\nDeprecated\n\nThe storage.sync API no longer has a sustained write operation quota.\n\n  * MAX_WRITE_OPERATIONS_PER_HOUR\n\n1800  \n\nThe maximum number of `set`, `remove`, or `clear` operations that can be\nperformed each hour. This is 1 every 2 seconds, a lower ceiling than the short\nterm higher writes-per-minute limit.\n\nUpdates that would cause this limit to be exceeded fail immediately and set\n`runtime.lastError` when using a callback, or when a Promise is rejected.\n\n  * MAX_WRITE_OPERATIONS_PER_MINUTE\n\n120  \n\nThe maximum number of `set`, `remove`, or `clear` operations that can be\nperformed each minute. This is 2 per second, providing higher throughput than\nwrites-per-hour over a shorter period of time.\n\nUpdates that would cause this limit to be exceeded fail immediately and set\n`runtime.lastError` when using a callback, or when a Promise is rejected.\n\n  * QUOTA_BYTES\n\n102400  \n\nThe maximum total amount (in bytes) of data that can be stored in sync\nstorage, as measured by the JSON stringification of every value plus every\nkey's length. Updates that would cause this limit to be exceeded fail\nimmediately and set `runtime.lastError` when using a callback, or when a\nPromise is rejected.\n\n  * QUOTA_BYTES_PER_ITEM\n\n8192  \n\nThe maximum size (in bytes) of each individual item in sync storage, as\nmeasured by the JSON stringification of its value plus its key length. Updates\ncontaining items larger than this limit will fail immediately and set\n`runtime.lastError` when using a callback, or when a Promise is rejected.\n\n## Events\n\n### onChanged\n\n    \n    \n    chrome.storage.onChanged.addListener(  \n      callback: function,  \n    )\n\nFired when one or more items change.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (changes: object, areaName: string) => void\n\n    * changes\n\nobject\n\n    * areaName\n\nstring\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/system/cpu": "#  chrome.system.cpu\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `system.cpu` API to query CPU metadata.\n\n## Permissions\n\n`system.cpu`  \n\n## Types\n\n### CpuInfo\n\n#### Properties\n\n  * archName\n\nstring\n\nThe architecture name of the processors.\n\n  * features\n\nstring[]\n\nA set of feature codes indicating some of the processor's capabilities. The\ncurrently supported codes are \"mmx\", \"sse\", \"sse2\", \"sse3\", \"ssse3\", \"sse4_1\",\n\"sse4_2\", and \"avx\".\n\n  * modelName\n\nstring\n\nThe model name of the processors.\n\n  * numOfProcessors\n\nnumber\n\nThe number of logical processors.\n\n  * processors\n\nProcessorInfo[]\n\nInformation about each logical processor.\n\n  * temperatures\n\nnumber[]\n\nChrome 60+\n\nList of CPU temperature readings from each thermal zone of the CPU.\nTemperatures are in degrees Celsius.\n\n**Currently supported on Chrome OS only.**\n\n### CpuTime\n\n#### Properties\n\n  * idle\n\nnumber\n\nThe cumulative time spent idle by this processor.\n\n  * kernel\n\nnumber\n\nThe cumulative time used by kernel programs on this processor.\n\n  * total\n\nnumber\n\nThe total cumulative time for this processor. This value is equal to user +\nkernel + idle.\n\n  * user\n\nnumber\n\nThe cumulative time used by userspace programs on this processor.\n\n### ProcessorInfo\n\n#### Properties\n\n  * usage\n\nCpuTime\n\nCumulative usage info for this logical processor.\n\n## Methods\n\n### getInfo()\n\nPromise\n\n    \n    \n    chrome.system.cpu.getInfo(  \n      callback?: function,  \n    )\n\nQueries basic CPU information of the system.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (info: CpuInfo) => void\n\n    * info\n\nCpuInfo\n\n#### Returns\n\n  * Promise<CpuInfo>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/system/display": "#  chrome.system.display\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `system.display` API to query display metadata.\n\n## Permissions\n\n`system.display`  \n\n## Types\n\n### ActiveState\n\nChrome 117+\n\nAn enum to tell if the display is detected and used by the system. The display\nis considered 'inactive', if it is not detected by the system (maybe\ndisconnected, or considered disconnected due to sleep mode, etc). This state\nis used to keep existing display when the all displays are disconnected, for\nexample.\n\n#### Enum\n\n\"active\"  \n\n\"inactive\"  \n\n### Bounds\n\n#### Properties\n\n  * height\n\nnumber\n\nThe height of the display in pixels.\n\n  * left\n\nnumber\n\nThe x-coordinate of the upper-left corner.\n\n  * top\n\nnumber\n\nThe y-coordinate of the upper-left corner.\n\n  * width\n\nnumber\n\nThe width of the display in pixels.\n\n### DisplayLayout\n\nChrome 53+\n\n#### Properties\n\n  * id\n\nstring\n\nThe unique identifier of the display.\n\n  * offset\n\nnumber\n\nThe offset of the display along the connected edge. 0 indicates that the\ntopmost or leftmost corners are aligned.\n\n  * parentId\n\nstring\n\nThe unique identifier of the parent display. Empty if this is the root.\n\n  * position\n\nLayoutPosition\n\nThe layout position of this display relative to the parent. This will be\nignored for the root.\n\n### DisplayMode\n\nChrome 52+\n\n#### Properties\n\n  * deviceScaleFactor\n\nnumber\n\nThe display mode device scale factor.\n\n  * height\n\nnumber\n\nThe display mode height in device independent (user visible) pixels.\n\n  * heightInNativePixels\n\nnumber\n\nThe display mode height in native pixels.\n\n  * isInterlaced\n\nboolean optional\n\nChrome 74+\n\nTrue if this mode is interlaced, false if not provided.\n\n  * isNative\n\nboolean\n\nTrue if the mode is the display's native mode.\n\n  * isSelected\n\nboolean\n\nTrue if the display mode is currently selected.\n\n  * refreshRate\n\nnumber\n\nChrome 67+\n\nThe display mode refresh rate in hertz.\n\n  * uiScale\n\nnumber optional\n\nDeprecated since Chrome 70\n\nUse `displayZoomFactor`\n\nThe display mode UI scale factor.\n\n  * width\n\nnumber\n\nThe display mode width in device independent (user visible) pixels.\n\n  * widthInNativePixels\n\nnumber\n\nThe display mode width in native pixels.\n\n### DisplayProperties\n\n#### Properties\n\n  * boundsOriginX\n\nnumber optional\n\nIf set, updates the display's logical bounds origin along the x-axis. Applied\ntogether with `boundsOriginY`. Defaults to the current value if not set and\n`boundsOriginY` is set. Note that when updating the display origin, some\nconstraints will be applied, so the final bounds origin may be different than\nthe one set. The final bounds can be retrieved using `getInfo`. The bounds\norigin cannot be changed on the primary display.\n\n  * boundsOriginY\n\nnumber optional\n\nIf set, updates the display's logical bounds origin along the y-axis. See\ndocumentation for `boundsOriginX` parameter.\n\n  * displayMode\n\nDisplayMode optional\n\nChrome 52+\n\nIf set, updates the display mode to the mode matching this value. If other\nparameters are invalid, this will not be applied. If the display mode is\ninvalid, it will not be applied and an error will be set, but other properties\nwill still be applied.\n\n  * displayZoomFactor\n\nnumber optional\n\nChrome 65+\n\nIf set, updates the zoom associated with the display. This zoom performs re-\nlayout and repaint thus resulting in a better quality zoom than just\nperforming a pixel by pixel stretch enlargement.\n\n  * isPrimary\n\nboolean optional\n\nIf set to true, makes the display primary. No-op if set to false. Note: If\nset, the display is considered primary for all other properties (i.e.\n`isUnified` may be set and bounds origin may not).\n\n  * isUnified\n\nboolean optional\n\nChrome 59+\n\nChromeOS only. If set to true, changes the display mode to unified desktop\n(see `enableUnifiedDesktop` for details). If set to false, unified desktop\nmode will be disabled. This is only valid for the primary display. If\nprovided, mirroringSourceId must not be provided and other properties will be\nignored. This is has no effect if not provided.\n\n  * mirroringSourceId\n\nstring optional\n\nDeprecated since Chrome 68\n\nUse `setMirrorMode`.\n\nChromeOS only. If set and not empty, enables mirroring for this display only.\nOtherwise disables mirroring for all displays. This value should indicate the\nid of the source display to mirror, which must not be the same as the id\npassed to setDisplayProperties. If set, no other property may be set.\n\n  * overscan\n\nInsets optional\n\nIf set, sets the display's overscan insets to the provided values. Note that\noverscan values may not be negative or larger than a half of the screen's\nsize. Overscan cannot be changed on the internal monitor.\n\n  * rotation\n\nnumber optional\n\nIf set, updates the display's rotation. Legal values are [0, 90, 180, 270].\nThe rotation is set clockwise, relative to the display's vertical position.\n\n### DisplayUnitInfo\n\n#### Properties\n\n  * activeState\n\nActiveState\n\nChrome 117+\n\nActive if the display is detected and used by the system.\n\n  * availableDisplayZoomFactors\n\nnumber[]\n\nChrome 67+\n\nA list of zoom factor values that can be set for the display.\n\n  * bounds\n\nBounds\n\nThe display's logical bounds.\n\n  * displayZoomFactor\n\nnumber\n\nChrome 65+\n\nThe ratio between the display's current and default zoom. For example, value 1\nis equivalent to 100% zoom, and value 1.5 is equivalent to 150% zoom.\n\n  * dpiX\n\nnumber\n\nThe number of pixels per inch along the x-axis.\n\n  * dpiY\n\nnumber\n\nThe number of pixels per inch along the y-axis.\n\n  * edid\n\nEdid optional\n\nChrome 67+\n\nNOTE: This is only available to ChromeOS Kiosk apps and Web UI.\n\n  * hasTouchSupport\n\nboolean\n\nChrome 57+\n\nTrue if this display has a touch input device associated with it.\n\n  * id\n\nstring\n\nThe unique identifier of the display.\n\n  * isEnabled\n\nboolean\n\nTrue if this display is enabled.\n\n  * isPrimary\n\nboolean\n\nTrue if this is the primary display.\n\n  * isUnified\n\nboolean\n\nChrome 59+\n\nTrue for all displays when in unified desktop mode. See documentation for\n`enableUnifiedDesktop`.\n\n  * mirroringDestinationIds\n\nstring[]\n\nChrome 64+\n\nChromeOS only. Identifiers of the displays to which the source display is\nbeing mirrored. Empty if no displays are being mirrored. This will be set to\nthe same value for all displays. This must not include `mirroringSourceId`.\n\n  * mirroringSourceId\n\nstring\n\nChromeOS only. Identifier of the display that is being mirrored if mirroring\nis enabled, otherwise empty. This will be set for all displays (including the\ndisplay being mirrored).\n\n  * modes\n\nDisplayMode[]\n\nChrome 52+\n\nThe list of available display modes. The current mode will have\nisSelected=true. Only available on ChromeOS. Will be set to an empty array on\nother platforms.\n\n  * name\n\nstring\n\nThe user-friendly name (e.g. \"HP LCD monitor\").\n\n  * overscan\n\nInsets\n\nThe display's insets within its screen's bounds. Currently exposed only on\nChromeOS. Will be set to empty insets on other platforms.\n\n  * rotation\n\nnumber\n\nThe display's clockwise rotation in degrees relative to the vertical position.\nCurrently exposed only on ChromeOS. Will be set to 0 on other platforms. A\nvalue of -1 will be interpreted as auto-rotate when the device is in a\nphysical tablet state.\n\n  * workArea\n\nBounds\n\nThe usable work area of the display within the display bounds. The work area\nexcludes areas of the display reserved for OS, for example taskbar and\nlauncher.\n\n### Edid\n\nChrome 67+\n\n#### Properties\n\n  * manufacturerId\n\nstring\n\n3 character manufacturer code. See Sec. 3.4.1 page 21. Required in v1.4.\n\n  * productId\n\nstring\n\n2 byte manufacturer-assigned code, Sec. 3.4.2 page 21. Required in v1.4.\n\n  * yearOfManufacture\n\nnumber\n\nYear of manufacturer, Sec. 3.4.4 page 22. Required in v1.4.\n\n### GetInfoFlags\n\nChrome 59+\n\n#### Properties\n\n  * singleUnified\n\nboolean optional\n\nIf set to true, only a single `DisplayUnitInfo` will be returned by `getInfo`\nwhen in unified desktop mode (see `enableUnifiedDesktop`). Defaults to false.\n\n### Insets\n\n#### Properties\n\n  * bottom\n\nnumber\n\nThe y-axis distance from the bottom bound.\n\n  * left\n\nnumber\n\nThe x-axis distance from the left bound.\n\n  * right\n\nnumber\n\nThe x-axis distance from the right bound.\n\n  * top\n\nnumber\n\nThe y-axis distance from the top bound.\n\n### LayoutPosition\n\nChrome 53+\n\nLayout position, i.e. edge of parent that the display is attached to.\n\n#### Enum\n\n\"top\"  \n\n\"right\"  \n\n\"bottom\"  \n\n\"left\"  \n\n### MirrorMode\n\nChrome 65+\n\nMirror mode, i.e. different ways of how a display is mirrored to other\ndisplays.\n\n#### Enum\n\n\"off\"  \nSpecifies the default mode (extended or unified desktop).\n\n\"normal\"  \nSpecifies that the default source display will be mirrored to all other\ndisplays.\n\n\"mixed\"  \nSpecifies that the specified source display will be mirrored to the provided\ndestination displays. All other connected displays will be extended.\n\n### MirrorModeInfo\n\nChrome 65+\n\n#### Properties\n\n  * mirroringDestinationIds\n\nstring[] optional\n\nThe ids of the mirroring destination displays. This is only valid for 'mixed'.\n\n  * mirroringSourceId\n\nstring optional\n\nThe id of the mirroring source display. This is only valid for 'mixed'.\n\n  * mode\n\nMirrorMode\n\nThe mirror mode that should be set.\n\n### Point\n\nChrome 57+\n\n#### Properties\n\n  * x\n\nnumber\n\nThe x-coordinate of the point.\n\n  * y\n\nnumber\n\nThe y-coordinate of the point.\n\n### TouchCalibrationPair\n\nChrome 57+\n\n#### Properties\n\n  * displayPoint\n\nPoint\n\nThe coordinates of the display point.\n\n  * touchPoint\n\nPoint\n\nThe coordinates of the touch point corresponding to the display point.\n\n### TouchCalibrationPairQuad\n\nChrome 57+\n\n#### Properties\n\n  * pair1\n\nTouchCalibrationPair\n\nFirst pair of touch and display point required for touch calibration.\n\n  * pair2\n\nTouchCalibrationPair\n\nSecond pair of touch and display point required for touch calibration.\n\n  * pair3\n\nTouchCalibrationPair\n\nThird pair of touch and display point required for touch calibration.\n\n  * pair4\n\nTouchCalibrationPair\n\nFourth pair of touch and display point required for touch calibration.\n\n## Methods\n\n### clearTouchCalibration()\n\nChrome 57+\n\n    \n    \n    chrome.system.display.clearTouchCalibration(  \n      id: string,  \n    )\n\nResets the touch calibration for the display and brings it back to its default\nstate by clearing any touch calibration data associated with the display.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n### completeCustomTouchCalibration()\n\nChrome 57+\n\n    \n    \n    chrome.system.display.completeCustomTouchCalibration(  \n      pairs: TouchCalibrationPairQuad,  \n      bounds: Bounds,  \n    )\n\nSets the touch calibration pairs for a display. These `pairs` would be used to\ncalibrate the touch screen for display with `id` called in\nstartCustomTouchCalibration(). Always call `startCustomTouchCalibration`\nbefore calling this method. If another touch calibration is already in\nprogress this will throw an error.\n\n#### Parameters\n\n  * pairs\n\nTouchCalibrationPairQuad\n\nThe pairs of point used to calibrate the display.\n\n  * bounds\n\nBounds\n\nBounds of the display when the touch calibration was performed. `bounds.left`\nand `bounds.top` values are ignored.\n\n### enableUnifiedDesktop()\n\nChrome 46+\n\n    \n    \n    chrome.system.display.enableUnifiedDesktop(  \n      enabled: boolean,  \n    )\n\nEnables/disables the unified desktop feature. If enabled while mirroring is\nactive, the desktop mode will not change until mirroring is turned off.\nOtherwise, the desktop mode will switch to unified immediately. NOTE: This is\nonly available to ChromeOS Kiosk apps and Web UI.\n\n#### Parameters\n\n  * enabled\n\nboolean\n\nTrue if unified desktop should be enabled.\n\n### getDisplayLayout()\n\nPromise Chrome 53+\n\n    \n    \n    chrome.system.display.getDisplayLayout(  \n      callback?: function,  \n    )\n\nRequests the layout info for all displays. NOTE: This is only available to\nChromeOS Kiosk apps and Web UI.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (layouts: DisplayLayout[]) => void\n\n    * layouts\n\nDisplayLayout[]\n\n#### Returns\n\n  * Promise<DisplayLayout[]>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getInfo()\n\nPromise\n\n    \n    \n    chrome.system.display.getInfo(  \n      flags?: GetInfoFlags,  \n      callback?: function,  \n    )\n\nRequests the information for all attached display devices.\n\n#### Parameters\n\n  * flags\n\nGetInfoFlags optional\n\nChrome 59+\n\nOptions affecting how the information is returned.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (displayInfo: DisplayUnitInfo[]) => void\n\n    * displayInfo\n\nDisplayUnitInfo[]\n\n#### Returns\n\n  * Promise<DisplayUnitInfo[]>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### overscanCalibrationAdjust()\n\nChrome 53+\n\n    \n    \n    chrome.system.display.overscanCalibrationAdjust(  \n      id: string,  \n      delta: Insets,  \n    )\n\nAdjusts the current overscan insets for a display. Typically this should\neither move the display along an axis (e.g. left+right have the same value) or\nscale it along an axis (e.g. top+bottom have opposite values). Each Adjust\ncall is cumulative with previous calls since Start.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n  * delta\n\nInsets\n\nThe amount to change the overscan insets.\n\n### overscanCalibrationComplete()\n\nChrome 53+\n\n    \n    \n    chrome.system.display.overscanCalibrationComplete(  \n      id: string,  \n    )\n\nComplete overscan adjustments for a display by saving the current values and\nhiding the overlay.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n### overscanCalibrationReset()\n\nChrome 53+\n\n    \n    \n    chrome.system.display.overscanCalibrationReset(  \n      id: string,  \n    )\n\nResets the overscan insets for a display to the last saved value (i.e before\nStart was called).\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n### overscanCalibrationStart()\n\nChrome 53+\n\n    \n    \n    chrome.system.display.overscanCalibrationStart(  \n      id: string,  \n    )\n\nStarts overscan calibration for a display. This will show an overlay on the\nscreen indicating the current overscan insets. If overscan calibration for\ndisplay `id` is in progress this will reset calibration.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n### setDisplayLayout()\n\nPromise Chrome 53+\n\n    \n    \n    chrome.system.display.setDisplayLayout(  \n      layouts: DisplayLayout[],  \n      callback?: function,  \n    )\n\nSet the layout for all displays. Any display not included will use the default\nlayout. If a layout would overlap or be otherwise invalid it will be adjusted\nto a valid layout. After layout is resolved, an onDisplayChanged event will be\ntriggered. NOTE: This is only available to ChromeOS Kiosk apps and Web UI.\n\n#### Parameters\n\n  * layouts\n\nDisplayLayout[]\n\nThe layout information, required for all displays except the primary display.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setDisplayProperties()\n\nPromise\n\n    \n    \n    chrome.system.display.setDisplayProperties(  \n      id: string,  \n      info: DisplayProperties,  \n      callback?: function,  \n    )\n\nUpdates the properties for the display specified by `id`, according to the\ninformation provided in `info`. On failure, `runtime.lastError` will be set.\nNOTE: This is only available to ChromeOS Kiosk apps and Web UI.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n  * info\n\nDisplayProperties\n\nThe information about display properties that should be changed. A property\nwill be changed only if a new value for it is specified in `info`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setMirrorMode()\n\nPromise Chrome 65+\n\n    \n    \n    chrome.system.display.setMirrorMode(  \n      info: MirrorModeInfo,  \n      callback?: function,  \n    )\n\nSets the display mode to the specified mirror mode. Each call resets the state\nfrom previous calls. Calling setDisplayProperties() will fail for the\nmirroring destination displays. NOTE: This is only available to ChromeOS Kiosk\napps and Web UI.\n\n#### Parameters\n\n  * info\n\nMirrorModeInfo\n\nThe information of the mirror mode that should be applied to the display mode.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### showNativeTouchCalibration()\n\nPromise Chrome 57+\n\n    \n    \n    chrome.system.display.showNativeTouchCalibration(  \n      id: string,  \n      callback?: function,  \n    )\n\nDisplays the native touch calibration UX for the display with `id` as display\nid. This will show an overlay on the screen with required instructions on how\nto proceed. The callback will be invoked in case of successful calibration\nonly. If the calibration fails, this will throw an error.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (success: boolean) => void\n\n    * success\n\nboolean\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### startCustomTouchCalibration()\n\nChrome 57+\n\n    \n    \n    chrome.system.display.startCustomTouchCalibration(  \n      id: string,  \n    )\n\nStarts custom touch calibration for a display. This should be called when\nusing a custom UX for collecting calibration data. If another touch\ncalibration is already in progress this will throw an error.\n\n#### Parameters\n\n  * id\n\nstring\n\nThe display's unique identifier.\n\n## Events\n\n### onDisplayChanged\n\n    \n    \n    chrome.system.display.onDisplayChanged.addListener(  \n      callback: function,  \n    )\n\nFired when anything changes to the display configuration.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/system/memory": "#  chrome.system.memory\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.system.memory` API.\n\n## Permissions\n\n`system.memory`  \n\n## Types\n\n### MemoryInfo\n\n#### Properties\n\n  * availableCapacity\n\nnumber\n\nThe amount of available capacity, in bytes.\n\n  * capacity\n\nnumber\n\nThe total amount of physical memory capacity, in bytes.\n\n## Methods\n\n### getInfo()\n\nPromise\n\n    \n    \n    chrome.system.memory.getInfo(  \n      callback?: function,  \n    )\n\nGet physical memory information.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (info: MemoryInfo) => void\n\n    * info\n\nMemoryInfo\n\n#### Returns\n\n  * Promise<MemoryInfo>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/system/storage": "#  chrome.system.storage\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.system.storage` API to query storage device information and be\nnotified when a removable storage device is attached and detached.\n\n## Permissions\n\n`system.storage`  \n\n## Types\n\n### EjectDeviceResultCode\n\n#### Enum\n\n\"success\"  \nThe ejection command is successful -- the application can prompt the user to\nremove the device.\n\n\"in_use\"  \nThe device is in use by another application. The ejection did not succeed; the\nuser should not remove the device until the other application is done with the\ndevice.\n\n\"no_such_device\"  \nThere is no such device known.\n\n\"failure\"  \nThe ejection command failed.\n\n### StorageAvailableCapacityInfo\n\n#### Properties\n\n  * availableCapacity\n\nnumber\n\nThe available capacity of the storage device, in bytes.\n\n  * id\n\nstring\n\nA copied `id` of getAvailableCapacity function parameter `id`.\n\n### StorageUnitInfo\n\n#### Properties\n\n  * capacity\n\nnumber\n\nThe total amount of the storage space, in bytes.\n\n  * id\n\nstring\n\nThe transient ID that uniquely identifies the storage device. This ID will be\npersistent within the same run of a single application. It will not be a\npersistent identifier between different runs of an application, or between\ndifferent applications.\n\n  * name\n\nstring\n\nThe name of the storage unit.\n\n  * type\n\nStorageUnitType\n\nThe media type of the storage unit.\n\n### StorageUnitType\n\n#### Enum\n\n\"fixed\"  \nThe storage has fixed media, e.g. hard disk or SSD.\n\n\"removable\"  \nThe storage is removable, e.g. USB flash drive.\n\n\"unknown\"  \nThe storage type is unknown.\n\n## Methods\n\n### ejectDevice()\n\nPromise\n\n    \n    \n    chrome.system.storage.ejectDevice(  \n      id: string,  \n      callback?: function,  \n    )\n\nEjects a removable storage device.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: EjectDeviceResultCode) => void\n\n    * result\n\nEjectDeviceResultCode\n\n#### Returns\n\n  * Promise<EjectDeviceResultCode>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAvailableCapacity()\n\nPromise  Dev channel\n\n    \n    \n    chrome.system.storage.getAvailableCapacity(  \n      id: string,  \n      callback?: function,  \n    )\n\nGet the available capacity of a specified `id` storage device. The `id` is the\ntransient device ID from StorageUnitInfo.\n\n#### Parameters\n\n  * id\n\nstring\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (info: StorageAvailableCapacityInfo) => void\n\n    * info\n\nStorageAvailableCapacityInfo\n\n#### Returns\n\n  * Promise<StorageAvailableCapacityInfo>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getInfo()\n\nPromise\n\n    \n    \n    chrome.system.storage.getInfo(  \n      callback?: function,  \n    )\n\nGet the storage information from the system. The argument passed to the\ncallback is an array of StorageUnitInfo objects.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (info: StorageUnitInfo[]) => void\n\n    * info\n\nStorageUnitInfo[]\n\n#### Returns\n\n  * Promise<StorageUnitInfo[]>\n\nChrome 91+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onAttached\n\n    \n    \n    chrome.system.storage.onAttached.addListener(  \n      callback: function,  \n    )\n\nFired when a new removable storage is attached to the system.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (info: StorageUnitInfo) => void\n\n    * info\n\nStorageUnitInfo\n\n### onDetached\n\n    \n    \n    chrome.system.storage.onDetached.addListener(  \n      callback: function,  \n    )\n\nFired when a removable storage is detached from the system.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string) => void\n\n    * id\n\nstring\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/systemLog": "#  chrome.systemLog\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.systemLog` API to record Chrome system logs from extensions.\n\n## Permissions\n\n`systemLog`  \n\n## Availability\n\nChrome 125+  ChromeOS only  Requires policy\n\n## Types\n\n### MessageOptions\n\n#### Properties\n\n  * message\n\nstring\n\n## Methods\n\n### add()\n\nPromise\n\n    \n    \n    chrome.systemLog.add(  \n      options: MessageOptions,  \n      callback?: function,  \n    )\n\nAdds a new log record.\n\n#### Parameters\n\n  * options\n\nMessageOptions\n\nThe logging options.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/tabCapture": "#  chrome.tabCapture\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.tabCapture` API to interact with tab media streams.\n\n## Permissions\n\n`tabCapture`  \n\n## Concepts and usage\n\nThe chrome.tabCapture API lets you access a `MediaStream` containing video and\naudio of the current tab. It can only be called after the user invokes an\nextension, such as by clicking the extension's action button. This is similar\nto the behavior of the `\"activeTab\"` permission.\n\n### Preserve system audio\n\nWhen a `MediaStream` is obtained for a tab, audio in that tab will no longer\nbe played to the user. This is similar to the behavior of the\n`getDisplayMedia()` function when the `suppressLocalAudioPlayback` flag is set\nto true.\n\nTo continue playing audio to the user, use the following:\n\n    \n    \n    const output = new AudioContext();\n    const source = output.createMediaStreamSource(stream);\n    source.connect(output.destination);\n    \n\nThis creates a new `AudioContext` and connects the audio of the tab's\n`MediaStream` to the default destination.\n\n### Stream IDs\n\nCalling `chrome.tabCapture.getMediaStreamId()` will return a stream ID. To\nlater access a `MediaStream` from the ID, use the following:\n\n    \n    \n    navigator.mediaDevices.getUserMedia({\n      audio: {\n        mandatory: {\n          chromeMediaSource: \"tab\",\n          chromeMediaSourceId: id,\n        },\n      },\n      video: {\n        mandatory: {\n          chromeMediaSource: \"tab\",\n          chromeMediaSourceId: id,\n        },\n      },\n    });\n    \n\n### Usage restrictions\n\nAfter calling `getMediaStreamId()`, there are restrictions on where the\nreturned stream ID can be used:\n\n  * If `consumerTabId` is specified, the ID can be used by a `getUserMedia()` call in any frame in the given tab which has the same security origin.\n  * When this is not specified, beginning in Chrome 116, the ID can be used in any frame with the same security origin in the same render process as the caller. This means that a stream ID obtained in a service worker can be used in an offscreen document.\n\nPrior to Chrome 116, when a `consumerTabId` was not specified, the stream ID\nwas restricted to both the security origin, render process and render frame of\nthe caller.\n\n### Learn more\n\nTo learn more about how to use the `chrome.tabCapture` API, see Audio\nrecording and screen capture. This demonstrates how to use `tabCapture` and\nrelated APIs to solve a number of common use cases.\n\n## Types\n\n### CaptureInfo\n\n#### Properties\n\n  * fullscreen\n\nboolean\n\nWhether an element in the tab being captured is in fullscreen mode.\n\n  * status\n\nTabCaptureState\n\nThe new capture status of the tab.\n\n  * tabId\n\nnumber\n\nThe id of the tab whose status changed.\n\n### CaptureOptions\n\n#### Properties\n\n  * audio\n\nboolean optional\n\n  * audioConstraints\n\nMediaStreamConstraint optional\n\n  * video\n\nboolean optional\n\n  * videoConstraints\n\nMediaStreamConstraint optional\n\n### GetMediaStreamOptions\n\nChrome 71+\n\n#### Properties\n\n  * consumerTabId\n\nnumber optional\n\nOptional tab id of the tab which will later invoke `getUserMedia()` to consume\nthe stream. If not specified then the resulting stream can be used only by the\ncalling extension. The stream can only be used by frames in the given tab\nwhose security origin matches the consumber tab's origin. The tab's origin\nmust be a secure origin, e.g. HTTPS.\n\n  * targetTabId\n\nnumber optional\n\nOptional tab id of the tab which will be captured. If not specified then the\ncurrent active tab will be selected. Only tabs for which the extension has\nbeen granted the `activeTab` permission can be used as the target tab.\n\n### MediaStreamConstraint\n\n#### Properties\n\n  * mandatory\n\nobject\n\n  * optional\n\nobject optional\n\n### TabCaptureState\n\n#### Enum\n\n\"pending\"  \n\n\"active\"  \n\n\"stopped\"  \n\n\"error\"  \n\n## Methods\n\n### capture()\n\nForeground only\n\n    \n    \n    chrome.tabCapture.capture(  \n      options: CaptureOptions,  \n      callback: function,  \n    )\n\nCaptures the visible area of the currently active tab. Capture can only be\nstarted on the currently active tab after the extension has been _invoked_ ,\nsimilar to the way that activeTab works. Capture is maintained across page\nnavigations within the tab, and stops when the tab is closed, or the media\nstream is closed by the extension.\n\n#### Parameters\n\n  * options\n\nCaptureOptions\n\nConfigures the returned media stream.\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (stream: LocalMediaStream) => void\n\n    * stream\n\nLocalMediaStream\n\n### getCapturedTabs()\n\nPromise\n\n    \n    \n    chrome.tabCapture.getCapturedTabs(  \n      callback?: function,  \n    )\n\nReturns a list of tabs that have requested capture or are being captured, i.e.\nstatus != stopped and status != error. This allows extensions to inform the\nuser that there is an existing tab capture that would prevent a new tab\ncapture from succeeding (or to prevent redundant requests for the same tab).\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: CaptureInfo[]) => void\n\n    * result\n\nCaptureInfo[]\n\n#### Returns\n\n  * Promise<CaptureInfo[]>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getMediaStreamId()\n\nPromise Chrome 71+\n\n    \n    \n    chrome.tabCapture.getMediaStreamId(  \n      options?: GetMediaStreamOptions,  \n      callback?: function,  \n    )\n\nCreates a stream ID to capture the target tab. Similar to\nchrome.tabCapture.capture() method, but returns a media stream ID, instead of\na media stream, to the consumer tab.\n\n#### Parameters\n\n  * options\n\nGetMediaStreamOptions optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (streamId: string) => void\n\n    * streamId\n\nstring\n\n#### Returns\n\n  * Promise<string>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onStatusChanged\n\n    \n    \n    chrome.tabCapture.onStatusChanged.addListener(  \n      callback: function,  \n    )\n\nEvent fired when the capture status of a tab changes. This allows extension\nauthors to keep track of the capture status of tabs to keep UI elements like\npage actions in sync.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (info: CaptureInfo) => void\n\n    * info\n\nCaptureInfo\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/tabGroups": "#  chrome.tabGroups\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.tabGroups` API to interact with the browser's tab grouping\nsystem. You can use this API to modify and rearrange tab groups in the\nbrowser. To group and ungroup tabs, or to query what tabs are in groups, use\nthe `chrome.tabs` API.\n\n## Permissions\n\n`tabGroups`  \n\n## Availability\n\nChrome 89+ MV3+\n\n## Types\n\n### Color\n\nThe group's color.\n\n#### Enum\n\n\"grey\"  \n\n\"blue\"  \n\n\"red\"  \n\n\"yellow\"  \n\n\"green\"  \n\n\"pink\"  \n\n\"purple\"  \n\n\"cyan\"  \n\n\"orange\"  \n\n### TabGroup\n\n#### Properties\n\n  * collapsed\n\nboolean\n\nWhether the group is collapsed. A collapsed group is one whose tabs are\nhidden.\n\n  * color\n\nColor\n\nThe group's color.\n\n  * id\n\nnumber\n\nThe ID of the group. Group IDs are unique within a browser session.\n\n  * title\n\nstring optional\n\nThe title of the group.\n\n  * windowId\n\nnumber\n\nThe ID of the window that contains the group.\n\n## Properties\n\n### TAB_GROUP_ID_NONE\n\nAn ID that represents the absence of a group.\n\n#### Value\n\n-1   \n\n## Methods\n\n### get()\n\nPromise\n\n    \n    \n    chrome.tabGroups.get(  \n      groupId: number,  \n      callback?: function,  \n    )\n\nRetrieves details about the specified group.\n\n#### Parameters\n\n  * groupId\n\nnumber\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (group: TabGroup) => void\n\n    * group\n\nTabGroup\n\n#### Returns\n\n  * Promise<TabGroup>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### move()\n\nPromise\n\n    \n    \n    chrome.tabGroups.move(  \n      groupId: number,  \n      moveProperties: object,  \n      callback?: function,  \n    )\n\nMoves the group and all its tabs within its window, or to a new window.\n\n#### Parameters\n\n  * groupId\n\nnumber\n\nThe ID of the group to move.\n\n  * moveProperties\n\nobject\n\n    * index\n\nnumber\n\nThe position to move the group to. Use `-1` to place the group at the end of\nthe window.\n\n    * windowId\n\nnumber optional\n\nThe window to move the group to. Defaults to the window the group is currently\nin. Note that groups can only be moved to and from windows with\n`windows.WindowType` type `\"normal\"`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (group?: TabGroup) => void\n\n    * group\n\nTabGroup optional\n\nDetails about the moved group.\n\n#### Returns\n\n  * Promise<TabGroup | undefined>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### query()\n\nPromise\n\n    \n    \n    chrome.tabGroups.query(  \n      queryInfo: object,  \n      callback?: function,  \n    )\n\nGets all groups that have the specified properties, or all groups if no\nproperties are specified.\n\n#### Parameters\n\n  * queryInfo\n\nobject\n\n    * collapsed\n\nboolean optional\n\nWhether the groups are collapsed.\n\n    * color\n\nColor optional\n\nThe color of the groups.\n\n    * title\n\nstring optional\n\nMatch group titles against a pattern.\n\n    * windowId\n\nnumber optional\n\nThe ID of the parent window, or `windows.WINDOW_ID_CURRENT` for the current\nwindow.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: TabGroup[]) => void\n\n    * result\n\nTabGroup[]\n\n#### Returns\n\n  * Promise<TabGroup[]>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### update()\n\nPromise\n\n    \n    \n    chrome.tabGroups.update(  \n      groupId: number,  \n      updateProperties: object,  \n      callback?: function,  \n    )\n\nModifies the properties of a group. Properties that are not specified in\n`updateProperties` are not modified.\n\n#### Parameters\n\n  * groupId\n\nnumber\n\nThe ID of the group to modify.\n\n  * updateProperties\n\nobject\n\n    * collapsed\n\nboolean optional\n\nWhether the group should be collapsed.\n\n    * color\n\nColor optional\n\nThe color of the group.\n\n    * title\n\nstring optional\n\nThe title of the group.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (group?: TabGroup) => void\n\n    * group\n\nTabGroup optional\n\nDetails about the updated group.\n\n#### Returns\n\n  * Promise<TabGroup | undefined>\n\nChrome 90+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onCreated\n\n    \n    \n    chrome.tabGroups.onCreated.addListener(  \n      callback: function,  \n    )\n\nFired when a group is created.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (group: TabGroup) => void\n\n    * group\n\nTabGroup\n\n### onMoved\n\n    \n    \n    chrome.tabGroups.onMoved.addListener(  \n      callback: function,  \n    )\n\nFired when a group is moved within a window. Move events are still fired for\nthe individual tabs within the group, as well as for the group itself. This\nevent is not fired when a group is moved between windows; instead, it will be\nremoved from one window and created in another.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (group: TabGroup) => void\n\n    * group\n\nTabGroup\n\n### onRemoved\n\n    \n    \n    chrome.tabGroups.onRemoved.addListener(  \n      callback: function,  \n    )\n\nFired when a group is closed, either directly by the user or automatically\nbecause it contained zero tabs.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (group: TabGroup) => void\n\n    * group\n\nTabGroup\n\n### onUpdated\n\n    \n    \n    chrome.tabGroups.onUpdated.addListener(  \n      callback: function,  \n    )\n\nFired when a group is updated.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (group: TabGroup) => void\n\n    * group\n\nTabGroup\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/tabs": "#  chrome.tabs\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Note:** The Tabs API can be used by the service worker and extension pages,\nbut not content scripts.\n\n## Description\n\nUse the `chrome.tabs` API to interact with the browser's tab system. You can\nuse this API to create, modify, and rearrange tabs in the browser.\n\nThe Tabs API not only offers features for manipulating and managing tabs, but\ncan also detect the language of the tab, take a screenshot, and communicate\nwith a tab's content scripts.\n\n## Permissions\n\nMost features don't require any permissions to use. For example: creating a\nnew tab, reloading a tab, navigating to another URL, etc.\n\nThere are three permissions developers should be aware of when working with\nthe Tabs API.\n\nThe \"tabs\" permission\n\n    \n\nThis permission does not give access to the `chrome.tabs` namespace. Instead,\nit grants an extension the ability to call `tabs.query()` against four\nsensitive properties on `tabs.Tab` instances: `url`, `pendingUrl`, `title`,\nand `favIconUrl`.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"tabs\"\n      ],\n      ...\n    }\n    \n\nHost permissions\n\n    \n\nHost permissions allow an extension to read and query a matching tab's four\nsensitive `tabs.Tab` properties. They can also interact directly with the\nmatching tabs using methods such as `tabs.captureVisibleTab()`,\n`scripting.executeScript()`, `scripting.insertCSS()`, and\n`scripting.removeCSS()`.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"host_permissions\": [\n        \"http://*/*\",\n        \"https://*/*\"\n      ],\n      ...\n    }\n    \n\nThe \"activeTab\" permission\n\n    \n\n`activeTab` grants an extension temporary host permission for the current tab\nin response to a user invocation. Unlike host permissions, `activeTab` does\nnot trigger any warnings.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"activeTab\"\n      ],\n      ...\n    }\n    \n\n## Use cases\n\nThe following sections demonstrate some common use cases.\n\n### Open an extension page in a new tab\n\nA common pattern for extensions is to open an onboarding page in a new tab\nwhen the extension is installed. The following example shows how to do this.\n\nbackground.js:\n\n    \n    \n    chrome.runtime.onInstalled.addListener(({reason}) => {\n      if (reason === 'install') {\n        chrome.tabs.create({\n          url: \"onboarding.html\"\n        });\n      }\n    });\n    \n\n**Note:** This example doesn't require any permissions.\n\n### Get the current tab\n\nThis example demonstrates how an extension's service worker can retrieve the\nactive tab from the currently-focused window (or most recently-focused window,\nif no Chrome windows are focused). This can usually be thought of as the\nuser's current tab.\n\n    \n    \n      async function getCurrentTab() {\n        let queryOptions = { active: true, lastFocusedWindow: true };\n        // `tab` will either be a `tabs.Tab` instance or `undefined`.\n        let [tab] = await chrome.tabs.query(queryOptions);\n        return tab;\n      }\n    \n    \n    \n      function getCurrentTab(callback) {\n        let queryOptions = { active: true, lastFocusedWindow: true };\n        chrome.tabs.query(queryOptions, ([tab]) => {\n          if (chrome.runtime.lastError)\n          console.error(chrome.runtime.lastError);\n          // `tab` will either be a `tabs.Tab` instance or `undefined`.\n          callback(tab);\n        });\n      }\n    \n\n### Mute the specified tab\n\nThis example shows how an extension can toggle the muted state for a given\ntab.\n\n    \n    \n      async function toggleMuteState(tabId) {\n        const tab = await chrome.tabs.get(tabId);\n        const muted = !tab.mutedInfo.muted;\n        await chrome.tabs.update(tabId, {muted});\n        console.log(`Tab ${tab.id} is ${muted ? \"muted\" : \"unmuted\"}`);\n      }\n    \n    \n    \n      function toggleMuteState(tabId) {\n        chrome.tabs.get(tabId, async (tab) => {\n          let muted = !tab.mutedInfo.muted;\n          await chrome.tabs.update(tabId, { muted });\n          console.log(`Tab ${tab.id} is ${ muted ? \"muted\" : \"unmuted\" }`);\n        });\n      }\n    \n\n### Move the current tab to the first position when clicked\n\nThis example shows how to move a tab while a drag may or may not be in\nprogress. While this example uses `chrome.tabs.move`, you can use the same\nwaiting pattern for other calls that modify tabs while a drag is in progress.\n\n    \n    \n      chrome.tabs.onActivated.addListener(moveToFirstPosition);\n    \n      async function moveToFirstPosition(activeInfo) {\n        try {\n          await chrome.tabs.move(activeInfo.tabId, {index: 0});\n          console.log(\"Success.\");\n        } catch (error) {\n          if (error == \"Error: Tabs cannot be edited right now (user may be dragging a tab).\") {\n            setTimeout(() => moveToFirstPosition(activeInfo), 50);\n          } else {\n            console.error(error);\n          }\n        }\n      }\n    \n\n**Important:** Using catch(error) in a Promise is a way to ensure that an\nerror that otherwise populates `chrome.runtime.lastError` is not unchecked.\n\n    \n    \n      chrome.tabs.onActivated.addListener(moveToFirstPositionMV2);\n    \n      function moveToFirstPositionMV2(activeInfo) {\n        chrome.tabs.move(activeInfo.tabId, { index: 0 }, () => {\n          if (chrome.runtime.lastError) {\n            const error = chrome.runtime.lastError;\n            if (error == \"Error: Tabs cannot be edited right now (user may be dragging a tab).\") {\n              setTimeout(() => moveToFirstPositionMV2(activeInfo), 50);\n            } else {\n              console.error(error);\n            }\n          } else {\n            console.log(\"Success.\");\n          }\n        });\n      }\n    \n\n### Pass a message to a selected tab's content script\n\nThis example demonstrates how an extension's service worker can communicate\nwith content scripts in specific browser tabs using `tabs.sendMessage()`.\n\n    \n    \n    function sendMessageToActiveTab(message) {\n      const [tab] = await chrome.tabs.query({ active: true, lastFocusedWindow: true });\n      const response = await chrome.tabs.sendMessage(tab.id, message);\n      // TODO: Do something with the response.\n    }\n    \n\n## Extension examples\n\nFor more Tabs API extensions demos, explore any of the following:\n\n  * Manifest V2 - Tabs API extensions.\n  * Manifest V3 - Tabs Manager.\n\n## Types\n\n### MutedInfo\n\nChrome 46+\n\nThe tab's muted state and the reason for the last state change.\n\n#### Properties\n\n  * extensionId\n\nstring optional\n\nThe ID of the extension that changed the muted state. Not set if an extension\nwas not the reason the muted state last changed.\n\n  * muted\n\nboolean\n\nWhether the tab is muted (prevented from playing sound). The tab may be muted\neven if it has not played or is not currently playing sound. Equivalent to\nwhether the 'muted' audio indicator is showing.\n\n  * reason\n\nMutedInfoReason optional\n\nThe reason the tab was muted or unmuted. Not set if the tab's mute state has\nnever been changed.\n\n### MutedInfoReason\n\nChrome 46+\n\nAn event that caused a muted state change.\n\n#### Enum\n\n\"user\"  \nA user input action set the muted state.\n\n\"capture\"  \nTab capture was started, forcing a muted state change.\n\n\"extension\"  \nAn extension, identified by the extensionId field, set the muted state.\n\n### Tab\n\n#### Properties\n\n  * active\n\nboolean\n\nWhether the tab is active in its window. Does not necessarily mean the window\nis focused.\n\n  * audible\n\nboolean optional\n\nChrome 45+\n\nWhether the tab has produced sound over the past couple of seconds (but it\nmight not be heard if also muted). Equivalent to whether the 'speaker audio'\nindicator is showing.\n\n  * autoDiscardable\n\nboolean\n\nChrome 54+\n\nWhether the tab can be discarded automatically by the browser when resources\nare low.\n\n  * discarded\n\nboolean\n\nChrome 54+\n\nWhether the tab is discarded. A discarded tab is one whose content has been\nunloaded from memory, but is still visible in the tab strip. Its content is\nreloaded the next time it is activated.\n\n  * favIconUrl\n\nstring optional\n\nThe URL of the tab's favicon. This property is only present if the extension\nhas the `\"tabs\"` permission or has host permissions for the page. It may also\nbe an empty string if the tab is loading.\n\n  * frozen\n\nboolean\n\nChrome 132+\n\nWhether the tab is frozen. A frozen tab cannot execute tasks, including event\nhandlers or timers. It is visible in the tab strip and its content is loaded\nin memory. It is unfrozen on activation.\n\n  * groupId\n\nnumber\n\nChrome 88+\n\nThe ID of the group that the tab belongs to.\n\n  * height\n\nnumber optional\n\nThe height of the tab in pixels.\n\n  * highlighted\n\nboolean\n\nWhether the tab is highlighted.\n\n  * id\n\nnumber optional\n\nThe ID of the tab. Tab IDs are unique within a browser session. Under some\ncircumstances a tab may not be assigned an ID; for example, when querying\nforeign tabs using the `sessions` API, in which case a session ID may be\npresent. Tab ID can also be set to `chrome.tabs.TAB_ID_NONE` for apps and\ndevtools windows.\n\n  * incognito\n\nboolean\n\nWhether the tab is in an incognito window.\n\n  * index\n\nnumber\n\nThe zero-based index of the tab within its window.\n\n  * lastAccessed\n\nnumber\n\nChrome 121+\n\nThe last time the tab became active in its window as the number of\nmilliseconds since epoch.\n\n  * mutedInfo\n\nMutedInfo optional\n\nChrome 46+\n\nThe tab's muted state and the reason for the last state change.\n\n  * openerTabId\n\nnumber optional\n\nThe ID of the tab that opened this tab, if any. This property is only present\nif the opener tab still exists.\n\n  * pendingUrl\n\nstring optional\n\nChrome 79+\n\nThe URL the tab is navigating to, before it has committed. This property is\nonly present if the extension has the `\"tabs\"` permission or has host\npermissions for the page and there is a pending navigation.\n\n  * pinned\n\nboolean\n\nWhether the tab is pinned.\n\n  * selected\n\nboolean\n\nDeprecated\n\nPlease use `tabs.Tab.highlighted`.\n\nWhether the tab is selected.\n\n  * sessionId\n\nstring optional\n\nThe session ID used to uniquely identify a tab obtained from the `sessions`\nAPI.\n\n  * status\n\nTabStatus optional\n\nThe tab's loading status.\n\n  * title\n\nstring optional\n\nThe title of the tab. This property is only present if the extension has the\n`\"tabs\"` permission or has host permissions for the page.\n\n  * url\n\nstring optional\n\nThe last committed URL of the main frame of the tab. This property is only\npresent if the extension has the `\"tabs\"` permission or has host permissions\nfor the page. May be an empty string if the tab has not yet committed. See\nalso `Tab.pendingUrl`.\n\n  * width\n\nnumber optional\n\nThe width of the tab in pixels.\n\n  * windowId\n\nnumber\n\nThe ID of the window that contains the tab.\n\n### TabStatus\n\nChrome 44+\n\nThe tab's loading status.\n\n#### Enum\n\n\"unloaded\"  \n\n\"loading\"  \n\n\"complete\"  \n\n### WindowType\n\nChrome 44+\n\nThe type of window.\n\n#### Enum\n\n\"normal\"  \n\n\"popup\"  \n\n\"panel\"  \n\n\"app\"  \n\n\"devtools\"  \n\n### ZoomSettings\n\nDefines how zoom changes in a tab are handled and at what scope.\n\n#### Properties\n\n  * defaultZoomFactor\n\nnumber optional\n\nChrome 43+\n\nUsed to return the default zoom level for the current tab in calls to\ntabs.getZoomSettings.\n\n  * mode\n\nZoomSettingsMode optional\n\nDefines how zoom changes are handled, i.e., which entity is responsible for\nthe actual scaling of the page; defaults to `automatic`.\n\n  * scope\n\nZoomSettingsScope optional\n\nDefines whether zoom changes persist for the page's origin, or only take\neffect in this tab; defaults to `per-origin` when in `automatic` mode, and\n`per-tab` otherwise.\n\n### ZoomSettingsMode\n\nChrome 44+\n\nDefines how zoom changes are handled, i.e., which entity is responsible for\nthe actual scaling of the page; defaults to `automatic`.\n\n#### Enum\n\n\"automatic\"  \nZoom changes are handled automatically by the browser.\n\n\"manual\"  \nOverrides the automatic handling of zoom changes. The `onZoomChange` event\nwill still be dispatched, and it is the extension's responsibility to listen\nfor this event and manually scale the page. This mode does not support `per-\norigin` zooming, and thus ignores the `scope` zoom setting and assumes `per-\ntab`.\n\n\"disabled\"  \nDisables all zooming in the tab. The tab reverts to the default zoom level,\nand all attempted zoom changes are ignored.\n\n### ZoomSettingsScope\n\nChrome 44+\n\nDefines whether zoom changes persist for the page's origin, or only take\neffect in this tab; defaults to `per-origin` when in `automatic` mode, and\n`per-tab` otherwise.\n\n#### Enum\n\n\"per-origin\"  \nZoom changes persist in the zoomed page's origin, i.e., all other tabs\nnavigated to that same origin are zoomed as well. Moreover, `per-origin` zoom\nchanges are saved with the origin, meaning that when navigating to other pages\nin the same origin, they are all zoomed to the same zoom factor. The `per-\norigin` scope is only available in the `automatic` mode.\n\n\"per-tab\"  \nZoom changes only take effect in this tab, and zoom changes in other tabs do\nnot affect the zooming of this tab. Also, `per-tab` zoom changes are reset on\nnavigation; navigating a tab always loads pages with their `per-origin` zoom\nfactors.\n\n## Properties\n\n### MAX_CAPTURE_VISIBLE_TAB_CALLS_PER_SECOND\n\nChrome 92+\n\nThe maximum number of times that `captureVisibleTab` can be called per second.\n`captureVisibleTab` is expensive and should not be called too often.\n\n#### Value\n\n2  \n\n### TAB_ID_NONE\n\nChrome 46+\n\nAn ID that represents the absence of a browser tab.\n\n#### Value\n\n-1   \n\n### TAB_INDEX_NONE\n\nChrome 123+\n\nAn index that represents the absence of a tab index in a tab_strip.\n\n#### Value\n\n-1   \n\n## Methods\n\n### captureVisibleTab()\n\nPromise\n\n    \n    \n    chrome.tabs.captureVisibleTab(  \n      windowId?: number,  \n      options?: ImageDetails,  \n      callback?: function,  \n    )\n\nCaptures the visible area of the currently active tab in the specified window.\nIn order to call this method, the extension must have either the <all_urls>\npermission or the activeTab permission. In addition to sites that extensions\ncan normally access, this method allows extensions to capture sensitive sites\nthat are otherwise restricted, including chrome:-scheme pages, other\nextensions' pages, and data: URLs. These sensitive sites can only be captured\nwith the activeTab permission. File URLs may be captured only if the extension\nhas been granted file access.\n\n#### Parameters\n\n  * windowId\n\nnumber optional\n\nThe target window. Defaults to the current window.\n\n  * options\n\nImageDetails optional\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (dataUrl: string) => void\n\n    * dataUrl\n\nstring\n\nA data URL that encodes an image of the visible area of the captured tab. May\nbe assigned to the 'src' property of an HTML `img` element for display.\n\n#### Returns\n\n  * Promise<string>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### connect()\n\n    \n    \n    chrome.tabs.connect(  \n      tabId: number,  \n      connectInfo?: object,  \n    )\n\nConnects to the content script(s) in the specified tab. The\n`runtime.onConnect` event is fired in each content script running in the\nspecified tab for the current extension. For more details, see Content Script\nMessaging.\n\n#### Parameters\n\n  * tabId\n\nnumber\n\n  * connectInfo\n\nobject optional\n\n    * documentId\n\nstring optional\n\nChrome 106+\n\nOpen a port to a specific document identified by `documentId` instead of all\nframes in the tab.\n\n    * frameId\n\nnumber optional\n\nOpen a port to a specific frame identified by `frameId` instead of all frames\nin the tab.\n\n    * name\n\nstring optional\n\nIs passed into onConnect for content scripts that are listening for the\nconnection event.\n\n#### Returns\n\n  * runtime.Port\n\nA port that can be used to communicate with the content scripts running in the\nspecified tab. The port's `runtime.Port` event is fired if the tab closes or\ndoes not exist.\n\n### create()\n\nPromise\n\n    \n    \n    chrome.tabs.create(  \n      createProperties: object,  \n      callback?: function,  \n    )\n\nCreates a new tab.\n\n#### Parameters\n\n  * createProperties\n\nobject\n\n    * active\n\nboolean optional\n\nWhether the tab should become the active tab in the window. Does not affect\nwhether the window is focused (see `windows.update`). Defaults to `true`.\n\n    * index\n\nnumber optional\n\nThe position the tab should take in the window. The provided value is clamped\nto between zero and the number of tabs in the window.\n\n    * openerTabId\n\nnumber optional\n\nThe ID of the tab that opened this tab. If specified, the opener tab must be\nin the same window as the newly created tab.\n\n    * pinned\n\nboolean optional\n\nWhether the tab should be pinned. Defaults to `false`\n\n    * selected\n\nboolean optional\n\nDeprecated\n\nPlease use _active_.\n\nWhether the tab should become the selected tab in the window. Defaults to\n`true`\n\n    * url\n\nstring optional\n\nThe URL to initially navigate the tab to. Fully-qualified URLs must include a\nscheme (i.e., 'http://www.google.com', not 'www.google.com'). Relative URLs\nare relative to the current page within the extension. Defaults to the New Tab\nPage.\n\n    * windowId\n\nnumber optional\n\nThe window in which to create the new tab. Defaults to the current window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tab: Tab) => void\n\n    * tab\n\nTab\n\nThe created tab.\n\n#### Returns\n\n  * Promise<Tab>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### detectLanguage()\n\nPromise\n\n    \n    \n    chrome.tabs.detectLanguage(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nDetects the primary language of the content in a tab.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nDefaults to the active tab of the current window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (language: string) => void\n\n    * language\n\nstring\n\nAn ISO language code such as `en` or `fr`. For a complete list of languages\nsupported by this method, see kLanguageInfoTable. The second to fourth columns\nare checked and the first non-NULL value is returned, except for Simplified\nChinese for which `zh-CN` is returned. For an unknown/undefined language,\n`und` is returned.\n\n#### Returns\n\n  * Promise<string>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### discard()\n\nPromise Chrome 54+\n\n    \n    \n    chrome.tabs.discard(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nDiscards a tab from memory. Discarded tabs are still visible on the tab strip\nand are reloaded when activated.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to be discarded. If specified, the tab is discarded unless\nit is active or already discarded. If omitted, the browser discards the least\nimportant tab. This can fail if no discardable tabs exist.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tab?: Tab) => void\n\n    * tab\n\nTab optional\n\nThe discarded tab, if it was successfully discarded; undefined otherwise.\n\n#### Returns\n\n  * Promise<Tab | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### duplicate()\n\nPromise\n\n    \n    \n    chrome.tabs.duplicate(  \n      tabId: number,  \n      callback?: function,  \n    )\n\nDuplicates a tab.\n\n#### Parameters\n\n  * tabId\n\nnumber\n\nThe ID of the tab to duplicate.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tab?: Tab) => void\n\n    * tab\n\nTab optional\n\nDetails about the duplicated tab. The `url`, `pendingUrl`, `title` and\n`favIconUrl` properties are only included on the `tabs.Tab` object if the\nextension has the `\"tabs\"` permission or has host permissions for the page.\n\n#### Returns\n\n  * Promise<Tab | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### get()\n\nPromise\n\n    \n    \n    chrome.tabs.get(  \n      tabId: number,  \n      callback?: function,  \n    )\n\nRetrieves details about the specified tab.\n\n#### Parameters\n\n  * tabId\n\nnumber\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tab: Tab) => void\n\n    * tab\n\nTab\n\n#### Returns\n\n  * Promise<Tab>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getCurrent()\n\nPromise\n\n    \n    \n    chrome.tabs.getCurrent(  \n      callback?: function,  \n    )\n\nGets the tab that this script call is being made from. Returns `undefined` if\ncalled from a non-tab context (for example, a background page or popup view).\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tab?: Tab) => void\n\n    * tab\n\nTab optional\n\n#### Returns\n\n  * Promise<Tab | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getZoom()\n\nPromise\n\n    \n    \n    chrome.tabs.getZoom(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nGets the current zoom factor of a specified tab.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to get the current zoom factor from; defaults to the active\ntab of the current window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (zoomFactor: number) => void\n\n    * zoomFactor\n\nnumber\n\nThe tab's current zoom factor.\n\n#### Returns\n\n  * Promise<number>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getZoomSettings()\n\nPromise\n\n    \n    \n    chrome.tabs.getZoomSettings(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nGets the current zoom settings of a specified tab.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to get the current zoom settings from; defaults to the\nactive tab of the current window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (zoomSettings: ZoomSettings) => void\n\n    * zoomSettings\n\nZoomSettings\n\nThe tab's current zoom settings.\n\n#### Returns\n\n  * Promise<ZoomSettings>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### goBack()\n\nPromise Chrome 72+\n\n    \n    \n    chrome.tabs.goBack(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nGo back to the previous page, if one is available.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to navigate back; defaults to the selected tab of the\ncurrent window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### goForward()\n\nPromise Chrome 72+\n\n    \n    \n    chrome.tabs.goForward(  \n      tabId?: number,  \n      callback?: function,  \n    )\n\nGo foward to the next page, if one is available.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to navigate forward; defaults to the selected tab of the\ncurrent window.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### group()\n\nPromise Chrome 88+\n\n    \n    \n    chrome.tabs.group(  \n      options: object,  \n      callback?: function,  \n    )\n\nAdds one or more tabs to a specified group, or if no group is specified, adds\nthe given tabs to a newly created group.\n\n#### Parameters\n\n  * options\n\nobject\n\n    * createProperties\n\nobject optional\n\nConfigurations for creating a group. Cannot be used if groupId is already\nspecified.\n\n      * windowId\n\nnumber optional\n\nThe window of the new group. Defaults to the current window.\n\n    * groupId\n\nnumber optional\n\nThe ID of the group to add the tabs to. If not specified, a new group will be\ncreated.\n\n    * tabIds\n\nnumber | [number, ...number[]]\n\nThe tab ID or list of tab IDs to add to the specified group.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (groupId: number) => void\n\n    * groupId\n\nnumber\n\nThe ID of the group that the tabs were added to.\n\n#### Returns\n\n  * Promise<number>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### highlight()\n\nPromise\n\n    \n    \n    chrome.tabs.highlight(  \n      highlightInfo: object,  \n      callback?: function,  \n    )\n\nHighlights the given tabs and focuses on the first of group. Will appear to do\nnothing if the specified tab is currently active.\n\n#### Parameters\n\n  * highlightInfo\n\nobject\n\n    * tabs\n\nnumber | number[]\n\nOne or more tab indices to highlight.\n\n    * windowId\n\nnumber optional\n\nThe window that contains the tabs.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (window: Window) => void\n\n    * window\n\nWindow\n\nContains details about the window whose tabs were highlighted.\n\n#### Returns\n\n  * Promise<windows.Window>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### move()\n\nPromise\n\n    \n    \n    chrome.tabs.move(  \n      tabIds: number | number[],  \n      moveProperties: object,  \n      callback?: function,  \n    )\n\nMoves one or more tabs to a new position within its window, or to a new\nwindow. Note that tabs can only be moved to and from normal (window.type ===\n\"normal\") windows.\n\n#### Parameters\n\n  * tabIds\n\nnumber | number[]\n\nThe tab ID or list of tab IDs to move.\n\n  * moveProperties\n\nobject\n\n    * index\n\nnumber\n\nThe position to move the window to. Use `-1` to place the tab at the end of\nthe window.\n\n    * windowId\n\nnumber optional\n\nDefaults to the window the tab is currently in.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tabs: Tab | Tab[]) => void\n\n    * tabs\n\nTab | Tab[]\n\nDetails about the moved tabs.\n\n#### Returns\n\n  * Promise<Tab | Tab[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### query()\n\nPromise\n\n    \n    \n    chrome.tabs.query(  \n      queryInfo: object,  \n      callback?: function,  \n    )\n\nGets all tabs that have the specified properties, or all tabs if no properties\nare specified.\n\n#### Parameters\n\n  * queryInfo\n\nobject\n\n    * active\n\nboolean optional\n\nWhether the tabs are active in their windows.\n\n    * audible\n\nboolean optional\n\nChrome 45+\n\nWhether the tabs are audible.\n\n    * autoDiscardable\n\nboolean optional\n\nChrome 54+\n\nWhether the tabs can be discarded automatically by the browser when resources\nare low.\n\n    * currentWindow\n\nboolean optional\n\nWhether the tabs are in the current window.\n\n    * discarded\n\nboolean optional\n\nChrome 54+\n\nWhether the tabs are discarded. A discarded tab is one whose content has been\nunloaded from memory, but is still visible in the tab strip. Its content is\nreloaded the next time it is activated.\n\n    * frozen\n\nboolean optional\n\nChrome 132+\n\nWhether the tabs are frozen. A frozen tab cannot execute tasks, including\nevent handlers or timers. It is visible in the tab strip and its content is\nloaded in memory. It is unfrozen on activation.\n\n    * groupId\n\nnumber optional\n\nChrome 88+\n\nThe ID of the group that the tabs are in, or `tabGroups.TAB_GROUP_ID_NONE` for\nungrouped tabs.\n\n    * highlighted\n\nboolean optional\n\nWhether the tabs are highlighted.\n\n    * index\n\nnumber optional\n\nThe position of the tabs within their windows.\n\n    * lastFocusedWindow\n\nboolean optional\n\nWhether the tabs are in the last focused window.\n\n    * muted\n\nboolean optional\n\nChrome 45+\n\nWhether the tabs are muted.\n\n    * pinned\n\nboolean optional\n\nWhether the tabs are pinned.\n\n    * status\n\nTabStatus optional\n\nThe tab loading status.\n\n    * title\n\nstring optional\n\nMatch page titles against a pattern. This property is ignored if the extension\ndoes not have the `\"tabs\"` permission or host permissions for the page.\n\n    * url\n\nstring | string[] optional\n\nMatch tabs against one or more URL patterns. Fragment identifiers are not\nmatched. This property is ignored if the extension does not have the `\"tabs\"`\npermission or host permissions for the page.\n\n    * windowId\n\nnumber optional\n\nThe ID of the parent window, or `windows.WINDOW_ID_CURRENT` for the current\nwindow.\n\n    * windowType\n\nWindowType optional\n\nThe type of window the tabs are in.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: Tab[]) => void\n\n    * result\n\nTab[]\n\n#### Returns\n\n  * Promise<Tab[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### reload()\n\nPromise\n\n    \n    \n    chrome.tabs.reload(  \n      tabId?: number,  \n      reloadProperties?: object,  \n      callback?: function,  \n    )\n\nReload a tab.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to reload; defaults to the selected tab of the current\nwindow.\n\n  * reloadProperties\n\nobject optional\n\n    * bypassCache\n\nboolean optional\n\nWhether to bypass local caching. Defaults to `false`.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### remove()\n\nPromise\n\n    \n    \n    chrome.tabs.remove(  \n      tabIds: number | number[],  \n      callback?: function,  \n    )\n\nCloses one or more tabs.\n\n#### Parameters\n\n  * tabIds\n\nnumber | number[]\n\nThe tab ID or list of tab IDs to close.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### sendMessage()\n\nPromise\n\n    \n    \n    chrome.tabs.sendMessage(  \n      tabId: number,  \n      message: any,  \n      options?: object,  \n      callback?: function,  \n    )\n\nSends a single message to the content script(s) in the specified tab, with an\noptional callback to run when a response is sent back. The `runtime.onMessage`\nevent is fired in each content script running in the specified tab for the\ncurrent extension.\n\n#### Parameters\n\n  * tabId\n\nnumber\n\n  * message\n\nany\n\nThe message to send. This message should be a JSON-ifiable object.\n\n  * options\n\nobject optional\n\n    * documentId\n\nstring optional\n\nChrome 106+\n\nSend a message to a specific document identified by `documentId` instead of\nall frames in the tab.\n\n    * frameId\n\nnumber optional\n\nSend a message to a specific frame identified by `frameId` instead of all\nframes in the tab.\n\n  * callback\n\nfunction optional\n\nChrome 99+\n\nThe `callback` parameter looks like:\n\n        \n        (response: any) => void\n\n    * response\n\nany\n\nThe JSON response object sent by the handler of the message. If an error\noccurs while connecting to the specified tab, the callback is called with no\narguments and `runtime.lastError` is set to the error message.\n\n#### Returns\n\n  * Promise<any>\n\nChrome 99+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setZoom()\n\nPromise\n\n    \n    \n    chrome.tabs.setZoom(  \n      tabId?: number,  \n      zoomFactor: number,  \n      callback?: function,  \n    )\n\nZooms a specified tab.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to zoom; defaults to the active tab of the current window.\n\n  * zoomFactor\n\nnumber\n\nThe new zoom factor. A value of `0` sets the tab to its current default zoom\nfactor. Values greater than `0` specify a (possibly non-default) zoom factor\nfor the tab.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setZoomSettings()\n\nPromise\n\n    \n    \n    chrome.tabs.setZoomSettings(  \n      tabId?: number,  \n      zoomSettings: ZoomSettings,  \n      callback?: function,  \n    )\n\nSets the zoom settings for a specified tab, which define how zoom changes are\nhandled. These settings are reset to defaults upon navigating the tab.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nThe ID of the tab to change the zoom settings for; defaults to the active tab\nof the current window.\n\n  * zoomSettings\n\nZoomSettings\n\nDefines how zoom changes are handled and at what scope.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### ungroup()\n\nPromise Chrome 88+\n\n    \n    \n    chrome.tabs.ungroup(  \n      tabIds: number | [number, ...number[]],  \n      callback?: function,  \n    )\n\nRemoves one or more tabs from their respective groups. If any groups become\nempty, they are deleted.\n\n#### Parameters\n\n  * tabIds\n\nnumber | [number, ...number[]]\n\nThe tab ID or list of tab IDs to remove from their respective groups.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### update()\n\nPromise\n\n    \n    \n    chrome.tabs.update(  \n      tabId?: number,  \n      updateProperties: object,  \n      callback?: function,  \n    )\n\nModifies the properties of a tab. Properties that are not specified in\n`updateProperties` are not modified.\n\n#### Parameters\n\n  * tabId\n\nnumber optional\n\nDefaults to the selected tab of the current window.\n\n  * updateProperties\n\nobject\n\n    * active\n\nboolean optional\n\nWhether the tab should be active. Does not affect whether the window is\nfocused (see `windows.update`).\n\n    * autoDiscardable\n\nboolean optional\n\nChrome 54+\n\nWhether the tab should be discarded automatically by the browser when\nresources are low.\n\n    * highlighted\n\nboolean optional\n\nAdds or removes the tab from the current selection.\n\n    * muted\n\nboolean optional\n\nChrome 45+\n\nWhether the tab should be muted.\n\n    * openerTabId\n\nnumber optional\n\nThe ID of the tab that opened this tab. If specified, the opener tab must be\nin the same window as this tab.\n\n    * pinned\n\nboolean optional\n\nWhether the tab should be pinned.\n\n    * selected\n\nboolean optional\n\nDeprecated\n\nPlease use _highlighted_.\n\nWhether the tab should be selected.\n\n    * url\n\nstring optional\n\nA URL to navigate the tab to. JavaScript URLs are not supported; use\n`scripting.executeScript` instead.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (tab?: Tab) => void\n\n    * tab\n\nTab optional\n\nDetails about the updated tab. The `url`, `pendingUrl`, `title` and\n`favIconUrl` properties are only included on the `tabs.Tab` object if the\nextension has the `\"tabs\"` permission or has host permissions for the page.\n\n#### Returns\n\n  * Promise<Tab | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onActivated\n\n    \n    \n    chrome.tabs.onActivated.addListener(  \n      callback: function,  \n    )\n\nFires when the active tab in a window changes. Note that the tab's URL may not\nbe set at the time this event fired, but you can listen to onUpdated events so\nas to be notified when a URL is set.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (activeInfo: object) => void\n\n    * activeInfo\n\nobject\n\n      * tabId\n\nnumber\n\nThe ID of the tab that has become active.\n\n      * windowId\n\nnumber\n\nThe ID of the window the active tab changed inside of.\n\n### onAttached\n\n    \n    \n    chrome.tabs.onAttached.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is attached to a window; for example, because it was moved\nbetween windows.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (tabId: number, attachInfo: object) => void\n\n    * tabId\n\nnumber\n\n    * attachInfo\n\nobject\n\n      * newPosition\n\nnumber\n\n      * newWindowId\n\nnumber\n\n### onCreated\n\n    \n    \n    chrome.tabs.onCreated.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is created. Note that the tab's URL and tab group membership\nmay not be set at the time this event is fired, but you can listen to\nonUpdated events so as to be notified when a URL is set or the tab is added to\na tab group.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (tab: Tab) => void\n\n    * tab\n\nTab\n\n### onDetached\n\n    \n    \n    chrome.tabs.onDetached.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is detached from a window; for example, because it was moved\nbetween windows.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (tabId: number, detachInfo: object) => void\n\n    * tabId\n\nnumber\n\n    * detachInfo\n\nobject\n\n      * oldPosition\n\nnumber\n\n      * oldWindowId\n\nnumber\n\n### onHighlighted\n\n    \n    \n    chrome.tabs.onHighlighted.addListener(  \n      callback: function,  \n    )\n\nFired when the highlighted or selected tabs in a window changes.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (highlightInfo: object) => void\n\n    * highlightInfo\n\nobject\n\n      * tabIds\n\nnumber[]\n\nAll highlighted tabs in the window.\n\n      * windowId\n\nnumber\n\nThe window whose tabs changed.\n\n### onMoved\n\n    \n    \n    chrome.tabs.onMoved.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is moved within a window. Only one move event is fired,\nrepresenting the tab the user directly moved. Move events are not fired for\nthe other tabs that must move in response to the manually-moved tab. This\nevent is not fired when a tab is moved between windows; for details, see\n`tabs.onDetached`.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (tabId: number, moveInfo: object) => void\n\n    * tabId\n\nnumber\n\n    * moveInfo\n\nobject\n\n      * fromIndex\n\nnumber\n\n      * toIndex\n\nnumber\n\n      * windowId\n\nnumber\n\n### onRemoved\n\n    \n    \n    chrome.tabs.onRemoved.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is closed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (tabId: number, removeInfo: object) => void\n\n    * tabId\n\nnumber\n\n    * removeInfo\n\nobject\n\n      * isWindowClosing\n\nboolean\n\nTrue when the tab was closed because its parent window was closed.\n\n      * windowId\n\nnumber\n\nThe window whose tab is closed.\n\n### onReplaced\n\n    \n    \n    chrome.tabs.onReplaced.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is replaced with another tab due to prerendering or instant.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (addedTabId: number, removedTabId: number) => void\n\n    * addedTabId\n\nnumber\n\n    * removedTabId\n\nnumber\n\n### onUpdated\n\n    \n    \n    chrome.tabs.onUpdated.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is updated.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (tabId: number, changeInfo: object, tab: Tab) => void\n\n    * tabId\n\nnumber\n\n    * changeInfo\n\nobject\n\n      * audible\n\nboolean optional\n\nChrome 45+\n\nThe tab's new audible state.\n\n      * autoDiscardable\n\nboolean optional\n\nChrome 54+\n\nThe tab's new auto-discardable state.\n\n      * discarded\n\nboolean optional\n\nChrome 54+\n\nThe tab's new discarded state.\n\n      * favIconUrl\n\nstring optional\n\nThe tab's new favicon URL.\n\n      * frozen\n\nboolean optional\n\nChrome 132+\n\nThe tab's new frozen state.\n\n      * groupId\n\nnumber optional\n\nChrome 88+\n\nThe tab's new group.\n\n      * mutedInfo\n\nMutedInfo optional\n\nChrome 46+\n\nThe tab's new muted state and the reason for the change.\n\n      * pinned\n\nboolean optional\n\nThe tab's new pinned state.\n\n      * status\n\nTabStatus optional\n\nThe tab's loading status.\n\n      * title\n\nstring optional\n\nChrome 48+\n\nThe tab's new title.\n\n      * url\n\nstring optional\n\nThe tab's URL if it has changed.\n\n    * tab\n\nTab\n\n### onZoomChange\n\n    \n    \n    chrome.tabs.onZoomChange.addListener(  \n      callback: function,  \n    )\n\nFired when a tab is zoomed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (ZoomChangeInfo: object) => void\n\n    * ZoomChangeInfo\n\nobject\n\n      * newZoomFactor\n\nnumber\n\n      * oldZoomFactor\n\nnumber\n\n      * tabId\n\nnumber\n\n      * zoomSettings\n\nZoomSettings\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/topSites": "#  chrome.topSites\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.topSites` API to access the top sites (i.e. most visited\nsites) that are displayed on the new tab page. These do not include shortcuts\ncustomized by the user.\n\n## Permissions\n\n`topSites`  \n\nYou must declare the \"topSites\" permission in your extension's manifest to use\nthis API.\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"topSites\",\n      ],\n      ...\n    }\n    \n\n## Examples\n\nTo try this API, install the topSites API example from the chrome-extension-\nsamples repository.\n\n## Types\n\n### MostVisitedURL\n\nAn object encapsulating a most visited URL, such as the default shortcuts on\nthe new tab page.\n\n#### Properties\n\n  * title\n\nstring\n\nThe title of the page\n\n  * url\n\nstring\n\nThe most visited URL.\n\n## Methods\n\n### get()\n\nPromise\n\n    \n    \n    chrome.topSites.get(  \n      callback?: function,  \n    )\n\nGets a list of top sites.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (data: MostVisitedURL[]) => void\n\n    * data\n\nMostVisitedURL[]\n\n#### Returns\n\n  * Promise<MostVisitedURL[]>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/tts": "#  chrome.tts\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.tts` API to play synthesized text-to-speech (TTS). See also\nthe related `ttsEngine` API, which allows an extension to implement a speech\nengine.\n\nChrome provides this capability on Windows (using SAPI 5), Mac OS X, and\nChromeOS, using speech synthesis capabilities provided by the operating\nsystem. On all platforms, the user can install extensions that register\nthemselves as alternative speech engines.\n\n## Permissions\n\n`tts`  \n\n## Concepts and usage\n\n### Generate speech\n\nCall `speak()` from your extension to speak. For example:\n\n    \n    \n    chrome.tts.speak('Hello, world.');\n    \n\nTo stop speaking immediately, just call `stop()`:\n\n    \n    \n    chrome.tts.stop();\n    \n\nYou can provide options that control various properties of the speech, such as\nits rate, pitch, and more. For example:\n\n    \n    \n    chrome.tts.speak('Hello, world.', {'rate': 2.0});\n    \n\nIt's also a good idea to specify the language so that a synthesizer supporting\nthat language (and regional dialect, if applicable) is chosen.\n\n    \n    \n    chrome.tts.speak('Hello, world.', {'lang': 'en-US', 'rate': 2.0});\n    \n\nBy default, each call to `speak()` interrupts any ongoing speech and speaks\nimmediately. To determine if a call would be interrupting anything, you can\ncall `isSpeaking()`. In addition, you can use the `enqueue` option to cause\nthis utterance to be added to a queue of utterances that will be spoken when\nthe current utterance has finished.\n\n    \n    \n    chrome.tts.speak('Speak this first.');\n    chrome.tts.speak(\n        'Speak this next, when the first sentence is done.', {'enqueue': true});\n    \n\nA complete description of all options can be found under `tts.speak()`. Not\nall speech engines will support all options.\n\nTo catch errors and make sure you're calling `speak()` correctly, pass a\ncallback function that takes no arguments. Inside the callback, check\n`runtime.lastError` to see if there were any errors.\n\n    \n    \n    chrome.tts.speak(\n      utterance,\n      options,\n      function() {\n        if (chrome.runtime.lastError) {\n          console.log('Error: ' + chrome.runtime.lastError.message);\n        }\n      }\n    );\n    \n\nThe callback returns right away, before the engine has started generating\nspeech. The purpose of the callback is to alert you to syntax errors in your\nuse of the TTS API, not to catch all possible errors that might occur in the\nprocess of synthesizing and outputting speech. To catch these errors too, you\nneed to use an event listener, described in the next section.\n\n### Listen to events\n\nTo get more real-time information about the status of synthesized speech, pass\nan event listener in the options to `speak()`, like this:\n\n    \n    \n    chrome.tts.speak(\n      utterance,\n      {\n        onEvent: function(event) {\n          console.log('Event ' + event.type + ' at position ' + event.charIndex);\n          if (event.type == 'error') {\n            console.log('Error: ' + event.errorMessage);\n          }\n        }\n      },\n      callback\n    );\n    \n\nEach event includes an event type, the character index of the current speech\nrelative to the utterance, and for error events, an optional error message.\nThe event types are:\n\n  * `'start'`: The engine has started speaking the utterance.\n  * `'word'`: A word boundary was reached. Use `event.charIndex` to determine the current speech position.\n  * `'sentence'`: A sentence boundary was reached. Use `event.charIndex` to determine the current speech position.\n  * `'marker'`: An SSML marker was reached. Use `event.charIndex` to determine the current speech position.\n  * `'end'`: The engine has finished speaking the utterance.\n  * `'interrupted'`: This utterance was interrupted by another call to `speak()` or `stop()` and did not finish.\n  * `'cancelled'`: This utterance was queued, but then cancelled by another call to `speak()` or `stop()` and never began to speak at all.\n  * `'error'`: An engine-specific error occurred and this utterance cannot be spoken. Check `event.errorMessage` for details.\n\nFour of the event types`'end'`, `'interrupted'`, `'cancelled'`, and\n`'error'`are _final_. After one of those events is received, this utterance\nwill no longer speak and no new events from this utterance will be received.\n\nSome voices may not support all event types, and some voices may not send any\nevents at all. If you don't want to use a voice unless it sends certain\nevents, pass the events you require in the `requiredEventTypes` member of the\noptions object, or use `getVoices()` to choose a voice that meets your\nrequirements. Both are described in what follows.\n\n### SSML markup\n\nUtterances used in this API may include markup using the Speech Synthesis\nMarkup Language (SSML). If you use SSML, the first argument to `speak()`\nshould be a complete SSML document with an XML header and a top-level\n`<speak>` tag, not a document fragment.\n\nFor example:\n\n    \n    \n    chrome.tts.speak(\n      '<?xml version=\"1.0\"?>' +\n      '<speak>' +\n      '  The <emphasis>second</emphasis> ' +\n      '  word of this sentence was emphasized.' +\n      '</speak>'\n    );\n    \n\nNot all speech engines will support all SSML tags, and some may not support\nSSML at all, but all engines are required to ignore any SSML they don't\nsupport and to still speak the underlying text.\n\n### Choose a voice\n\nBy default, Chrome chooses the most appropriate voice for each utterance you\nwant to speak, based on the language. On most Windows, Mac OS X, and ChromeOS\nsystems, speech synthesis provided by the operating system should be able to\nspeak any text in at least one language. Some users may have a variety of\nvoices available, though, from their operating system and from speech engines\nimplemented by other Chrome extensions. In those cases, you can implement\ncustom code to choose the appropriate voice, or to present the user with a\nlist of choices.\n\nTo get a list of all voices, call `getVoices()` and pass it a function that\nreceives an array of `TtsVoice` objects as its argument:\n\n    \n    \n    chrome.tts.getVoices(\n      function(voices) {\n        for (var i = 0; i < voices.length; i++) {\n          console.log('Voice ' + i + ':');\n          console.log('  name: ' + voices[i].voiceName);\n          console.log('  lang: ' + voices[i].lang);\n          console.log('  extension id: ' + voices[i].extensionId);\n          console.log('  event types: ' + voices[i].eventTypes);\n        }\n      }\n    );\n    \n\n## Types\n\n### EventType\n\nChrome 54+\n\n#### Enum\n\n\"start\"  \n\n\"end\"  \n\n\"word\"  \n\n\"sentence\"  \n\n\"marker\"  \n\n\"interrupted\"  \n\n\"cancelled\"  \n\n\"error\"  \n\n\"pause\"  \n\n\"resume\"  \n\n### TtsEvent\n\nAn event from the TTS engine to communicate the status of an utterance.\n\n#### Properties\n\n  * charIndex\n\nnumber optional\n\nThe index of the current character in the utterance. For word events, the\nevent fires at the end of one word and before the beginning of the next. The\n`charIndex` represents a point in the text at the beginning of the next word\nto be spoken.\n\n  * errorMessage\n\nstring optional\n\nThe error description, if the event type is `error`.\n\n  * length\n\nnumber optional\n\nChrome 74+\n\nThe length of the next part of the utterance. For example, in a `word` event,\nthis is the length of the word which will be spoken next. It will be set to -1\nif not set by the speech engine.\n\n  * type\n\nEventType\n\nThe type can be `start` as soon as speech has started, `word` when a word\nboundary is reached, `sentence` when a sentence boundary is reached, `marker`\nwhen an SSML mark element is reached, `end` when the end of the utterance is\nreached, `interrupted` when the utterance is stopped or interrupted before\nreaching the end, `cancelled` when it's removed from the queue before ever\nbeing synthesized, or `error` when any other error occurs. When pausing\nspeech, a `pause` event is fired if a particular utterance is paused in the\nmiddle, and `resume` if an utterance resumes speech. Note that pause and\nresume events may not fire if speech is paused in-between utterances.\n\n### TtsOptions\n\nChrome 77+\n\nThe speech options for the TTS engine.\n\n#### Properties\n\n  * desiredEventTypes\n\nstring[] optional\n\nThe TTS event types that you are interested in listening to. If missing, all\nevent types may be sent.\n\n  * enqueue\n\nboolean optional\n\nIf true, enqueues this utterance if TTS is already in progress. If false (the\ndefault), interrupts any current speech and flushes the speech queue before\nspeaking this new utterance.\n\n  * extensionId\n\nstring optional\n\nThe extension ID of the speech engine to use, if known.\n\n  * gender\n\nVoiceGender optional\n\nDeprecated since Chrome 77\n\nGender is deprecated and will be ignored.\n\nGender of voice for synthesized speech.\n\n  * lang\n\nstring optional\n\nThe language to be used for synthesis, in the form _language_ -_region_.\nExamples: 'en', 'en-US', 'en-GB', 'zh-CN'.\n\n  * pitch\n\nnumber optional\n\nSpeaking pitch between 0 and 2 inclusive, with 0 being lowest and 2 being\nhighest. 1.0 corresponds to a voice's default pitch.\n\n  * rate\n\nnumber optional\n\nSpeaking rate relative to the default rate for this voice. 1.0 is the default\nrate, normally around 180 to 220 words per minute. 2.0 is twice as fast, and\n0.5 is half as fast. Values below 0.1 or above 10.0 are strictly disallowed,\nbut many voices will constrain the minimum and maximum rates furtherfor\nexample a particular voice may not actually speak faster than 3 times normal\neven if you specify a value larger than 3.0.\n\n  * requiredEventTypes\n\nstring[] optional\n\nThe TTS event types the voice must support.\n\n  * voiceName\n\nstring optional\n\nThe name of the voice to use for synthesis. If empty, uses any available\nvoice.\n\n  * volume\n\nnumber optional\n\nSpeaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being\nhighest, with a default of 1.0.\n\n  * onEvent\n\nvoid optional\n\nThis function is called with events that occur in the process of speaking the\nutterance.\n\nThe `onEvent` function looks like:\n\n        \n        (event: TtsEvent) => {...}\n\n    * event\n\nTtsEvent\n\nThe update event from the text-to-speech engine indicating the status of this\nutterance.\n\n### TtsVoice\n\nA description of a voice available for speech synthesis.\n\n#### Properties\n\n  * eventTypes\n\nEventType[] optional\n\nAll of the callback event types that this voice is capable of sending.\n\n  * extensionId\n\nstring optional\n\nThe ID of the extension providing this voice.\n\n  * gender\n\nVoiceGender optional\n\nDeprecated since Chrome 70\n\nGender is deprecated and will be ignored.\n\nThis voice's gender.\n\n  * lang\n\nstring optional\n\nThe language that this voice supports, in the form _language_ -_region_.\nExamples: 'en', 'en-US', 'en-GB', 'zh-CN'.\n\n  * remote\n\nboolean optional\n\nIf true, the synthesis engine is a remote network resource. It may be higher\nlatency and may incur bandwidth costs.\n\n  * voiceName\n\nstring optional\n\nThe name of the voice.\n\n### VoiceGender\n\nChrome 54+  Deprecated since Chrome 70\n\nGender is deprecated and is ignored.\n\n#### Enum\n\n\"male\"  \n\n\"female\"  \n\n## Methods\n\n### getVoices()\n\nPromise\n\n    \n    \n    chrome.tts.getVoices(  \n      callback?: function,  \n    )\n\nGets an array of all available voices.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (voices: TtsVoice[]) => void\n\n    * voices\n\nTtsVoice[]\n\nArray of `tts.TtsVoice` objects representing the available voices for speech\nsynthesis.\n\n#### Returns\n\n  * Promise<TtsVoice[]>\n\nChrome 101+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### isSpeaking()\n\nPromise\n\n    \n    \n    chrome.tts.isSpeaking(  \n      callback?: function,  \n    )\n\nChecks whether the engine is currently speaking. On Mac OS X, the result is\ntrue whenever the system speech engine is speaking, even if the speech wasn't\ninitiated by Chrome.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (speaking: boolean) => void\n\n    * speaking\n\nboolean\n\nTrue if speaking, false otherwise.\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 101+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### pause()\n\n    \n    \n    chrome.tts.pause()\n\nPauses speech synthesis, potentially in the middle of an utterance. A call to\nresume or stop will un-pause speech.\n\n### resume()\n\n    \n    \n    chrome.tts.resume()\n\nIf speech was paused, resumes speaking where it left off.\n\n### speak()\n\nPromise\n\n    \n    \n    chrome.tts.speak(  \n      utterance: string,  \n      options?: TtsOptions,  \n      callback?: function,  \n    )\n\nSpeaks text using a text-to-speech engine.\n\n#### Parameters\n\n  * utterance\n\nstring\n\nThe text to speak, either plain text or a complete, well-formed SSML document.\nSpeech engines that do not support SSML will strip away the tags and speak the\ntext. The maximum length of the text is 32,768 characters.\n\n  * options\n\nTtsOptions optional\n\nThe speech options.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 101+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### stop()\n\n    \n    \n    chrome.tts.stop()\n\nStops any current speech and flushes the queue of any pending utterances. In\naddition, if speech was paused, it will now be un-paused for the next call to\nspeak.\n\n## Events\n\n### onVoicesChanged\n\nChrome 124+\n\n    \n    \n    chrome.tts.onVoicesChanged.addListener(  \n      callback: function,  \n    )\n\nCalled when the list of `tts.TtsVoice` that would be returned by getVoices has\nchanged.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/ttsEngine": "#  chrome.ttsEngine\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.ttsEngine` API to implement a text-to-speech(TTS) engine using\nan extension. If your extension registers using this API, it will receive\nevents containing an utterance to be spoken and other parameters when any\nextension or Chrome App uses the `tts` API to generate speech. Your extension\ncan then use any available web technology to synthesize and output the speech,\nand send events back to the calling function to report the status.\n\n## Permissions\n\n`ttsEngine`  \n\n## Concepts and usage\n\nAn extension can register itself as a speech engine. By doing so, it can\nintercept some or all calls to functions such as `tts.speak()` and\n`tts.stop()` and provide an alternate implementation. Extensions are free to\nuse any available web technology to provide speech, including streaming audio\nfrom a server, HTML5 audio. An extension could even do something different\nwith the utterances, like display closed captions in a popup or send them as\nlog messages to a remote server.\n\nTo implement a TTS engine, an extension must declare the \"ttsEngine\"\npermission and then declare all voices it provides in the extension manifest,\nlike this:\n\n    \n    \n    {\n      \"name\": \"My TTS Engine\",\n      \"version\": \"1.0\",\n      \"permissions\": [\"ttsEngine\"],\n      \"tts_engine\": {\n        \"voices\": [\n          {\n            \"voice_name\": \"Alice\",\n            \"lang\": \"en-US\",\n            \"event_types\": [\"start\", \"marker\", \"end\"]\n          },\n          {\n            \"voice_name\": \"Pat\",\n            \"lang\": \"en-US\",\n            \"event_types\": [\"end\"]\n          }\n        ]\n      },\n      \"background\": {\n        \"page\": \"background.html\",\n        \"persistent\": false\n      }\n    }\n    \n\nAn extension can specify any number of voices.\n\nThe `voice_name` parameter is required. The name should be descriptive enough\nthat it identifies the name of the voice and the engine used. In the unlikely\nevent that two extensions register voices with the same name, a client can\nspecify the ID of the extension that should do the synthesis.\n\nThe `lang` parameter is optional, but highly recommended. Almost always, a\nvoice can synthesize speech in just a single language. When an engine supports\nmore than one language, it can easily register a separate voice for each\nlanguage. Under rare circumstances where a single voice can handle more than\none language, it's easiest to just list two separate voices and handle them\nusing the same logic internally. However, if you want to create a voice that\nwill handle utterances in any language, leave out the `lang` parameter from\nyour extension's manifest.\n\nFinally, the `event_types` parameter is required if the engine can send events\nto update the client on the progress of speech synthesis. At a minimum,\nsupporting the `'end'` event type to indicate when speech is finished is\nhighly recommended, otherwise Chrome cannot schedule queued utterances.\n\nOnce loaded, an extension can replace the list of declared voices by calling\n`chrome.ttsEngine.updateVoices`. (Note that the parameters used in the\nprogramatic call to `updateVoices` are in camel case: e.g., `voiceName`,\nunlike the manifest file which uses `voice_name`.)\n\n**Note:** If your TTS engine does not support the `'end'` event type, Chrome\ncannot queue utterances because it has no way of knowing when your utterance\nhas finished. To help mitigate this, Chrome passes an additional boolean\n`enqueue` option to your engine's onSpeak handler, giving you the option of\nimplementing your own queueing. This is discouraged because then clients are\nunable to queue utterances that should get spoken by different speech engines.\n\nThe possible event types that you can send correspond to the event types that\nthe `speak()` method receives:\n\n  * `'start'`: The engine has started speaking the utterance.\n  * `'word'`: A word boundary was reached. Use `event.charIndex` to determine the current speech position.\n  * `'sentence'`: A sentence boundary was reached. Use `event.charIndex` to determine the current speech position.\n  * `'marker'`: An SSML marker was reached. Use `event.charIndex` to determine the current speech position.\n  * `'end'`: The engine has finished speaking the utterance.\n  * `'error'`: An engine-specific error occurred and this utterance cannot be spoken. Pass more information in `event.errorMessage`.\n\nThe `'interrupted'` and `'cancelled'` events are not sent by the speech\nengine; they are generated automatically by Chrome.\n\nText-to-speech clients can get the voice information from your extension's\nmanifest by calling `tts.getVoices`, assuming you've registered speech event\nlisteners as described below.\n\n### Handle speech events\n\nTo generate speech at the request of clients, your extension must register\nlisteners for both `onSpeak` and `onStop`, like this:\n\n    \n    \n    const speakListener = (utterance, options, sendTtsEvent) => {\n      sendTtsEvent({type: 'start', charIndex: 0})\n    \n      // (start speaking)\n    \n      sendTtsEvent({type: 'end', charIndex: utterance.length})\n    };\n    \n    const stopListener = () => {\n      // (stop all speech)\n    };\n    \n    chrome.ttsEngine.onSpeak.addListener(speakListener);\n    chrome.ttsEngine.onStop.addListener(stopListener);\n    \n\n**Caution:** If your extension does not register listeners for both `onSpeak`\nand `onStop`, it will not intercept any speech calls, regardless of what is in\nthe manifest.\n\nThe decision of whether or not to send a given speech request to an extension\nis based solely on whether the extension supports the given voice parameters\nin its manifest and has registered listeners for `onSpeak` and `onStop`. In\nother words, there's no way for an extension to receive a speech request and\ndynamically decide whether to handle it.\n\n## Types\n\n### AudioBuffer\n\nChrome 92+\n\nParameters containing an audio buffer and associated data.\n\n#### Properties\n\n  * audioBuffer\n\nArrayBuffer\n\nThe audio buffer from the text-to-speech engine. It should have length exactly\naudioStreamOptions.bufferSize and encoded as mono, at\naudioStreamOptions.sampleRate, and as linear pcm, 32-bit signed float i.e. the\nFloat32Array type in javascript.\n\n  * charIndex\n\nnumber optional\n\nThe character index associated with this audio buffer.\n\n  * isLastBuffer\n\nboolean optional\n\nTrue if this audio buffer is the last for the text being spoken.\n\n### AudioStreamOptions\n\nChrome 92+\n\nContains the audio stream format expected to be produced by an engine.\n\n#### Properties\n\n  * bufferSize\n\nnumber\n\nThe number of samples within an audio buffer.\n\n  * sampleRate\n\nnumber\n\nThe sample rate expected in an audio buffer.\n\n### LanguageInstallStatus\n\nChrome 132+\n\nThe install status of a voice.\n\n#### Enum\n\n\"notInstalled\"  \n\n\"installing\"  \n\n\"installed\"  \n\n\"failed\"  \n\n### LanguageStatus\n\nChrome 132+\n\nInstall status of a language.\n\n#### Properties\n\n  * error\n\nstring optional\n\nDetail about installation failures. Optionally populated if the language\nfailed to install.\n\n  * installStatus\n\nLanguageInstallStatus\n\nInstallation status.\n\n  * lang\n\nstring\n\nLanguage string in the form of language code-region code, where the region may\nbe omitted. Examples are en, en-AU, zh-CH.\n\n### LanguageUninstallOptions\n\nChrome 132+\n\nOptions for uninstalling a given language.\n\n#### Properties\n\n  * uninstallImmediately\n\nboolean\n\nTrue if the TTS client wants the language to be immediately uninstalled. The\nengine may choose whether or when to uninstall the language, based on this\nparameter and the requestor information. If false, it may use other criteria,\nsuch as recent usage, to determine when to uninstall.\n\n### SpeakOptions\n\nChrome 92+\n\nOptions specified to the tts.speak() method.\n\n#### Properties\n\n  * gender\n\nVoiceGender optional\n\nDeprecated since Chrome 92\n\nGender is deprecated and will be ignored.\n\nGender of voice for synthesized speech.\n\n  * lang\n\nstring optional\n\nThe language to be used for synthesis, in the form _language_ -_region_.\nExamples: 'en', 'en-US', 'en-GB', 'zh-CN'.\n\n  * pitch\n\nnumber optional\n\nSpeaking pitch between 0 and 2 inclusive, with 0 being lowest and 2 being\nhighest. 1.0 corresponds to this voice's default pitch.\n\n  * rate\n\nnumber optional\n\nSpeaking rate relative to the default rate for this voice. 1.0 is the default\nrate, normally around 180 to 220 words per minute. 2.0 is twice as fast, and\n0.5 is half as fast. This value is guaranteed to be between 0.1 and 10.0,\ninclusive. When a voice does not support this full range of rates, don't\nreturn an error. Instead, clip the rate to the range the voice supports.\n\n  * voiceName\n\nstring optional\n\nThe name of the voice to use for synthesis.\n\n  * volume\n\nnumber optional\n\nSpeaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being\nhighest, with a default of 1.0.\n\n### TtsClient\n\nChrome 131+\n\nIdentifier for the client requesting status.\n\n#### Properties\n\n  * id\n\nstring\n\nClient making a language management request. For an extension, this is the\nunique extension ID. For Chrome features, this is the human-readable name of\nthe feature.\n\n  * source\n\nTtsClientSource\n\nType of requestor.\n\n### TtsClientSource\n\nChrome 131+\n\nType of requestor.\n\n#### Enum\n\n\"chromefeature\"  \n\n\"extension\"  \n\n### VoiceGender\n\nChrome 54+  Deprecated since Chrome 70\n\nGender is deprecated and will be ignored.\n\n#### Enum\n\n\"male\"  \n\n\"female\"  \n\n## Methods\n\n### updateLanguage()\n\nChrome 132+\n\n    \n    \n    chrome.ttsEngine.updateLanguage(  \n      status: LanguageStatus,  \n    )\n\nCalled by an engine when a language install is attempted, and when a language\nis uninstalled. Also called in response to a status request from a client.\nWhen a voice is installed or uninstalled, the engine should also call\nttsEngine.updateVoices to register the voice.\n\n#### Parameters\n\n  * status\n\nLanguageStatus\n\nThe install status of the language.\n\n### updateVoices()\n\nChrome 66+\n\n    \n    \n    chrome.ttsEngine.updateVoices(  \n      voices: TtsVoice[],  \n    )\n\nCalled by an engine to update its list of voices. This list overrides any\nvoices declared in this extension's manifest.\n\n#### Parameters\n\n  * voices\n\nTtsVoice[]\n\nArray of `tts.TtsVoice` objects representing the available voices for speech\nsynthesis.\n\n## Events\n\n### onInstallLanguageRequest\n\nChrome 131+\n\n    \n    \n    chrome.ttsEngine.onInstallLanguageRequest.addListener(  \n      callback: function,  \n    )\n\nFired when a TTS client requests to install a new language. The engine should\nattempt to download and install the language, and call\nttsEngine.updateLanguage with the result. On success, the engine should also\ncall ttsEngine.updateVoices to register the newly available voices.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestor: TtsClient, lang: string) => void\n\n    * requestor\n\nTtsClient\n\n    * lang\n\nstring\n\n### onLanguageStatusRequest\n\nChrome 132+\n\n    \n    \n    chrome.ttsEngine.onLanguageStatusRequest.addListener(  \n      callback: function,  \n    )\n\nFired when a TTS client requests the install status of a language.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestor: TtsClient, lang: string) => void\n\n    * requestor\n\nTtsClient\n\n    * lang\n\nstring\n\n### onPause\n\n    \n    \n    chrome.ttsEngine.onPause.addListener(  \n      callback: function,  \n    )\n\nOptional: if an engine supports the pause event, it should pause the current\nutterance being spoken, if any, until it receives a resume event or stop\nevent. Note that a stop event should also clear the paused state.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onResume\n\n    \n    \n    chrome.ttsEngine.onResume.addListener(  \n      callback: function,  \n    )\n\nOptional: if an engine supports the pause event, it should also support the\nresume event, to continue speaking the current utterance, if any. Note that a\nstop event should also clear the paused state.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onSpeak\n\n    \n    \n    chrome.ttsEngine.onSpeak.addListener(  \n      callback: function,  \n    )\n\nCalled when the user makes a call to tts.speak() and one of the voices from\nthis extension's manifest is the first to match the options object.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (utterance: string, options: SpeakOptions, sendTtsEvent: function) => void\n\n    * utterance\n\nstring\n\n    * options\n\nSpeakOptions\n\n    * sendTtsEvent\n\nfunction\n\nThe `sendTtsEvent` parameter looks like:\n\n          \n          (event: tts.TtsEvent) => void\n\n      * event\n\ntts.TtsEvent\n\nThe event from the text-to-speech engine indicating the status of this\nutterance.\n\n### onSpeakWithAudioStream\n\nChrome 92+\n\n    \n    \n    chrome.ttsEngine.onSpeakWithAudioStream.addListener(  \n      callback: function,  \n    )\n\nCalled when the user makes a call to tts.speak() and one of the voices from\nthis extension's manifest is the first to match the options object. Differs\nfrom ttsEngine.onSpeak in that Chrome provides audio playback services and\nhandles dispatching tts events.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (utterance: string, options: SpeakOptions, audioStreamOptions: AudioStreamOptions, sendTtsAudio: function, sendError: function) => void\n\n    * utterance\n\nstring\n\n    * options\n\nSpeakOptions\n\n    * audioStreamOptions\n\nAudioStreamOptions\n\n    * sendTtsAudio\n\nfunction\n\nThe `sendTtsAudio` parameter looks like:\n\n          \n          (audioBufferParams: AudioBuffer) => void\n\n      * audioBufferParams\n\nAudioBuffer\n\nParameters containing an audio buffer and associated data.\n\n    * sendError\n\nfunction\n\nChrome 94+\n\nThe `sendError` parameter looks like:\n\n          \n          (errorMessage?: string) => void\n\n      * errorMessage\n\nstring optional\n\nA string describing the error.\n\n### onStop\n\n    \n    \n    chrome.ttsEngine.onStop.addListener(  \n      callback: function,  \n    )\n\nFired when a call is made to tts.stop and this extension may be in the middle\nof speaking. If an extension receives a call to onStop and speech is already\nstopped, it should do nothing (not raise an error). If speech is in the paused\nstate, this should cancel the paused state.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onUninstallLanguageRequest\n\nChrome 132+\n\n    \n    \n    chrome.ttsEngine.onUninstallLanguageRequest.addListener(  \n      callback: function,  \n    )\n\nFired when a TTS client indicates a language is no longer needed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestor: TtsClient, lang: string, uninstallOptions: LanguageUninstallOptions) => void\n\n    * requestor\n\nTtsClient\n\n    * lang\n\nstring\n\n    * uninstallOptions\n\nLanguageUninstallOptions\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/ttsEngine": "#  chrome.ttsEngine\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.ttsEngine` API to implement a text-to-speech(TTS) engine using\nan extension. If your extension registers using this API, it will receive\nevents containing an utterance to be spoken and other parameters when any\nextension or Chrome App uses the `tts` API to generate speech. Your extension\ncan then use any available web technology to synthesize and output the speech,\nand send events back to the calling function to report the status.\n\n## Permissions\n\n`ttsEngine`  \n\n## Concepts and usage\n\nAn extension can register itself as a speech engine. By doing so, it can\nintercept some or all calls to functions such as `tts.speak()` and\n`tts.stop()` and provide an alternate implementation. Extensions are free to\nuse any available web technology to provide speech, including streaming audio\nfrom a server, HTML5 audio. An extension could even do something different\nwith the utterances, like display closed captions in a popup or send them as\nlog messages to a remote server.\n\nTo implement a TTS engine, an extension must declare the \"ttsEngine\"\npermission and then declare all voices it provides in the extension manifest,\nlike this:\n\n    \n    \n    {\n      \"name\": \"My TTS Engine\",\n      \"version\": \"1.0\",\n      \"permissions\": [\"ttsEngine\"],\n      \"tts_engine\": {\n        \"voices\": [\n          {\n            \"voice_name\": \"Alice\",\n            \"lang\": \"en-US\",\n            \"event_types\": [\"start\", \"marker\", \"end\"]\n          },\n          {\n            \"voice_name\": \"Pat\",\n            \"lang\": \"en-US\",\n            \"event_types\": [\"end\"]\n          }\n        ]\n      },\n      \"background\": {\n        \"page\": \"background.html\",\n        \"persistent\": false\n      }\n    }\n    \n\nAn extension can specify any number of voices.\n\nThe `voice_name` parameter is required. The name should be descriptive enough\nthat it identifies the name of the voice and the engine used. In the unlikely\nevent that two extensions register voices with the same name, a client can\nspecify the ID of the extension that should do the synthesis.\n\nThe `lang` parameter is optional, but highly recommended. Almost always, a\nvoice can synthesize speech in just a single language. When an engine supports\nmore than one language, it can easily register a separate voice for each\nlanguage. Under rare circumstances where a single voice can handle more than\none language, it's easiest to just list two separate voices and handle them\nusing the same logic internally. However, if you want to create a voice that\nwill handle utterances in any language, leave out the `lang` parameter from\nyour extension's manifest.\n\nFinally, the `event_types` parameter is required if the engine can send events\nto update the client on the progress of speech synthesis. At a minimum,\nsupporting the `'end'` event type to indicate when speech is finished is\nhighly recommended, otherwise Chrome cannot schedule queued utterances.\n\nOnce loaded, an extension can replace the list of declared voices by calling\n`chrome.ttsEngine.updateVoices`. (Note that the parameters used in the\nprogramatic call to `updateVoices` are in camel case: e.g., `voiceName`,\nunlike the manifest file which uses `voice_name`.)\n\n**Note:** If your TTS engine does not support the `'end'` event type, Chrome\ncannot queue utterances because it has no way of knowing when your utterance\nhas finished. To help mitigate this, Chrome passes an additional boolean\n`enqueue` option to your engine's onSpeak handler, giving you the option of\nimplementing your own queueing. This is discouraged because then clients are\nunable to queue utterances that should get spoken by different speech engines.\n\nThe possible event types that you can send correspond to the event types that\nthe `speak()` method receives:\n\n  * `'start'`: The engine has started speaking the utterance.\n  * `'word'`: A word boundary was reached. Use `event.charIndex` to determine the current speech position.\n  * `'sentence'`: A sentence boundary was reached. Use `event.charIndex` to determine the current speech position.\n  * `'marker'`: An SSML marker was reached. Use `event.charIndex` to determine the current speech position.\n  * `'end'`: The engine has finished speaking the utterance.\n  * `'error'`: An engine-specific error occurred and this utterance cannot be spoken. Pass more information in `event.errorMessage`.\n\nThe `'interrupted'` and `'cancelled'` events are not sent by the speech\nengine; they are generated automatically by Chrome.\n\nText-to-speech clients can get the voice information from your extension's\nmanifest by calling `tts.getVoices`, assuming you've registered speech event\nlisteners as described below.\n\n### Handle speech events\n\nTo generate speech at the request of clients, your extension must register\nlisteners for both `onSpeak` and `onStop`, like this:\n\n    \n    \n    const speakListener = (utterance, options, sendTtsEvent) => {\n      sendTtsEvent({type: 'start', charIndex: 0})\n    \n      // (start speaking)\n    \n      sendTtsEvent({type: 'end', charIndex: utterance.length})\n    };\n    \n    const stopListener = () => {\n      // (stop all speech)\n    };\n    \n    chrome.ttsEngine.onSpeak.addListener(speakListener);\n    chrome.ttsEngine.onStop.addListener(stopListener);\n    \n\n**Caution:** If your extension does not register listeners for both `onSpeak`\nand `onStop`, it will not intercept any speech calls, regardless of what is in\nthe manifest.\n\nThe decision of whether or not to send a given speech request to an extension\nis based solely on whether the extension supports the given voice parameters\nin its manifest and has registered listeners for `onSpeak` and `onStop`. In\nother words, there's no way for an extension to receive a speech request and\ndynamically decide whether to handle it.\n\n## Types\n\n### AudioBuffer\n\nChrome 92+\n\nParameters containing an audio buffer and associated data.\n\n#### Properties\n\n  * audioBuffer\n\nArrayBuffer\n\nThe audio buffer from the text-to-speech engine. It should have length exactly\naudioStreamOptions.bufferSize and encoded as mono, at\naudioStreamOptions.sampleRate, and as linear pcm, 32-bit signed float i.e. the\nFloat32Array type in javascript.\n\n  * charIndex\n\nnumber optional\n\nThe character index associated with this audio buffer.\n\n  * isLastBuffer\n\nboolean optional\n\nTrue if this audio buffer is the last for the text being spoken.\n\n### AudioStreamOptions\n\nChrome 92+\n\nContains the audio stream format expected to be produced by an engine.\n\n#### Properties\n\n  * bufferSize\n\nnumber\n\nThe number of samples within an audio buffer.\n\n  * sampleRate\n\nnumber\n\nThe sample rate expected in an audio buffer.\n\n### LanguageInstallStatus\n\nChrome 132+\n\nThe install status of a voice.\n\n#### Enum\n\n\"notInstalled\"  \n\n\"installing\"  \n\n\"installed\"  \n\n\"failed\"  \n\n### LanguageStatus\n\nChrome 132+\n\nInstall status of a language.\n\n#### Properties\n\n  * error\n\nstring optional\n\nDetail about installation failures. Optionally populated if the language\nfailed to install.\n\n  * installStatus\n\nLanguageInstallStatus\n\nInstallation status.\n\n  * lang\n\nstring\n\nLanguage string in the form of language code-region code, where the region may\nbe omitted. Examples are en, en-AU, zh-CH.\n\n### LanguageUninstallOptions\n\nChrome 132+\n\nOptions for uninstalling a given language.\n\n#### Properties\n\n  * uninstallImmediately\n\nboolean\n\nTrue if the TTS client wants the language to be immediately uninstalled. The\nengine may choose whether or when to uninstall the language, based on this\nparameter and the requestor information. If false, it may use other criteria,\nsuch as recent usage, to determine when to uninstall.\n\n### SpeakOptions\n\nChrome 92+\n\nOptions specified to the tts.speak() method.\n\n#### Properties\n\n  * gender\n\nVoiceGender optional\n\nDeprecated since Chrome 92\n\nGender is deprecated and will be ignored.\n\nGender of voice for synthesized speech.\n\n  * lang\n\nstring optional\n\nThe language to be used for synthesis, in the form _language_ -_region_.\nExamples: 'en', 'en-US', 'en-GB', 'zh-CN'.\n\n  * pitch\n\nnumber optional\n\nSpeaking pitch between 0 and 2 inclusive, with 0 being lowest and 2 being\nhighest. 1.0 corresponds to this voice's default pitch.\n\n  * rate\n\nnumber optional\n\nSpeaking rate relative to the default rate for this voice. 1.0 is the default\nrate, normally around 180 to 220 words per minute. 2.0 is twice as fast, and\n0.5 is half as fast. This value is guaranteed to be between 0.1 and 10.0,\ninclusive. When a voice does not support this full range of rates, don't\nreturn an error. Instead, clip the rate to the range the voice supports.\n\n  * voiceName\n\nstring optional\n\nThe name of the voice to use for synthesis.\n\n  * volume\n\nnumber optional\n\nSpeaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being\nhighest, with a default of 1.0.\n\n### TtsClient\n\nChrome 131+\n\nIdentifier for the client requesting status.\n\n#### Properties\n\n  * id\n\nstring\n\nClient making a language management request. For an extension, this is the\nunique extension ID. For Chrome features, this is the human-readable name of\nthe feature.\n\n  * source\n\nTtsClientSource\n\nType of requestor.\n\n### TtsClientSource\n\nChrome 131+\n\nType of requestor.\n\n#### Enum\n\n\"chromefeature\"  \n\n\"extension\"  \n\n### VoiceGender\n\nChrome 54+  Deprecated since Chrome 70\n\nGender is deprecated and will be ignored.\n\n#### Enum\n\n\"male\"  \n\n\"female\"  \n\n## Methods\n\n### updateLanguage()\n\nChrome 132+\n\n    \n    \n    chrome.ttsEngine.updateLanguage(  \n      status: LanguageStatus,  \n    )\n\nCalled by an engine when a language install is attempted, and when a language\nis uninstalled. Also called in response to a status request from a client.\nWhen a voice is installed or uninstalled, the engine should also call\nttsEngine.updateVoices to register the voice.\n\n#### Parameters\n\n  * status\n\nLanguageStatus\n\nThe install status of the language.\n\n### updateVoices()\n\nChrome 66+\n\n    \n    \n    chrome.ttsEngine.updateVoices(  \n      voices: TtsVoice[],  \n    )\n\nCalled by an engine to update its list of voices. This list overrides any\nvoices declared in this extension's manifest.\n\n#### Parameters\n\n  * voices\n\nTtsVoice[]\n\nArray of `tts.TtsVoice` objects representing the available voices for speech\nsynthesis.\n\n## Events\n\n### onInstallLanguageRequest\n\nChrome 131+\n\n    \n    \n    chrome.ttsEngine.onInstallLanguageRequest.addListener(  \n      callback: function,  \n    )\n\nFired when a TTS client requests to install a new language. The engine should\nattempt to download and install the language, and call\nttsEngine.updateLanguage with the result. On success, the engine should also\ncall ttsEngine.updateVoices to register the newly available voices.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestor: TtsClient, lang: string) => void\n\n    * requestor\n\nTtsClient\n\n    * lang\n\nstring\n\n### onLanguageStatusRequest\n\nChrome 132+\n\n    \n    \n    chrome.ttsEngine.onLanguageStatusRequest.addListener(  \n      callback: function,  \n    )\n\nFired when a TTS client requests the install status of a language.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestor: TtsClient, lang: string) => void\n\n    * requestor\n\nTtsClient\n\n    * lang\n\nstring\n\n### onPause\n\n    \n    \n    chrome.ttsEngine.onPause.addListener(  \n      callback: function,  \n    )\n\nOptional: if an engine supports the pause event, it should pause the current\nutterance being spoken, if any, until it receives a resume event or stop\nevent. Note that a stop event should also clear the paused state.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onResume\n\n    \n    \n    chrome.ttsEngine.onResume.addListener(  \n      callback: function,  \n    )\n\nOptional: if an engine supports the pause event, it should also support the\nresume event, to continue speaking the current utterance, if any. Note that a\nstop event should also clear the paused state.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onSpeak\n\n    \n    \n    chrome.ttsEngine.onSpeak.addListener(  \n      callback: function,  \n    )\n\nCalled when the user makes a call to tts.speak() and one of the voices from\nthis extension's manifest is the first to match the options object.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (utterance: string, options: SpeakOptions, sendTtsEvent: function) => void\n\n    * utterance\n\nstring\n\n    * options\n\nSpeakOptions\n\n    * sendTtsEvent\n\nfunction\n\nThe `sendTtsEvent` parameter looks like:\n\n          \n          (event: tts.TtsEvent) => void\n\n      * event\n\ntts.TtsEvent\n\nThe event from the text-to-speech engine indicating the status of this\nutterance.\n\n### onSpeakWithAudioStream\n\nChrome 92+\n\n    \n    \n    chrome.ttsEngine.onSpeakWithAudioStream.addListener(  \n      callback: function,  \n    )\n\nCalled when the user makes a call to tts.speak() and one of the voices from\nthis extension's manifest is the first to match the options object. Differs\nfrom ttsEngine.onSpeak in that Chrome provides audio playback services and\nhandles dispatching tts events.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (utterance: string, options: SpeakOptions, audioStreamOptions: AudioStreamOptions, sendTtsAudio: function, sendError: function) => void\n\n    * utterance\n\nstring\n\n    * options\n\nSpeakOptions\n\n    * audioStreamOptions\n\nAudioStreamOptions\n\n    * sendTtsAudio\n\nfunction\n\nThe `sendTtsAudio` parameter looks like:\n\n          \n          (audioBufferParams: AudioBuffer) => void\n\n      * audioBufferParams\n\nAudioBuffer\n\nParameters containing an audio buffer and associated data.\n\n    * sendError\n\nfunction\n\nChrome 94+\n\nThe `sendError` parameter looks like:\n\n          \n          (errorMessage?: string) => void\n\n      * errorMessage\n\nstring optional\n\nA string describing the error.\n\n### onStop\n\n    \n    \n    chrome.ttsEngine.onStop.addListener(  \n      callback: function,  \n    )\n\nFired when a call is made to tts.stop and this extension may be in the middle\nof speaking. If an extension receives a call to onStop and speech is already\nstopped, it should do nothing (not raise an error). If speech is in the paused\nstate, this should cancel the paused state.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onUninstallLanguageRequest\n\nChrome 132+\n\n    \n    \n    chrome.ttsEngine.onUninstallLanguageRequest.addListener(  \n      callback: function,  \n    )\n\nFired when a TTS client indicates a language is no longer needed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestor: TtsClient, lang: string, uninstallOptions: LanguageUninstallOptions) => void\n\n    * requestor\n\nTtsClient\n\n    * lang\n\nstring\n\n    * uninstallOptions\n\nLanguageUninstallOptions\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/tts": "#  chrome.tts\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.tts` API to play synthesized text-to-speech (TTS). See also\nthe related `ttsEngine` API, which allows an extension to implement a speech\nengine.\n\nChrome provides this capability on Windows (using SAPI 5), Mac OS X, and\nChromeOS, using speech synthesis capabilities provided by the operating\nsystem. On all platforms, the user can install extensions that register\nthemselves as alternative speech engines.\n\n## Permissions\n\n`tts`  \n\n## Concepts and usage\n\n### Generate speech\n\nCall `speak()` from your extension to speak. For example:\n\n    \n    \n    chrome.tts.speak('Hello, world.');\n    \n\nTo stop speaking immediately, just call `stop()`:\n\n    \n    \n    chrome.tts.stop();\n    \n\nYou can provide options that control various properties of the speech, such as\nits rate, pitch, and more. For example:\n\n    \n    \n    chrome.tts.speak('Hello, world.', {'rate': 2.0});\n    \n\nIt's also a good idea to specify the language so that a synthesizer supporting\nthat language (and regional dialect, if applicable) is chosen.\n\n    \n    \n    chrome.tts.speak('Hello, world.', {'lang': 'en-US', 'rate': 2.0});\n    \n\nBy default, each call to `speak()` interrupts any ongoing speech and speaks\nimmediately. To determine if a call would be interrupting anything, you can\ncall `isSpeaking()`. In addition, you can use the `enqueue` option to cause\nthis utterance to be added to a queue of utterances that will be spoken when\nthe current utterance has finished.\n\n    \n    \n    chrome.tts.speak('Speak this first.');\n    chrome.tts.speak(\n        'Speak this next, when the first sentence is done.', {'enqueue': true});\n    \n\nA complete description of all options can be found under `tts.speak()`. Not\nall speech engines will support all options.\n\nTo catch errors and make sure you're calling `speak()` correctly, pass a\ncallback function that takes no arguments. Inside the callback, check\n`runtime.lastError` to see if there were any errors.\n\n    \n    \n    chrome.tts.speak(\n      utterance,\n      options,\n      function() {\n        if (chrome.runtime.lastError) {\n          console.log('Error: ' + chrome.runtime.lastError.message);\n        }\n      }\n    );\n    \n\nThe callback returns right away, before the engine has started generating\nspeech. The purpose of the callback is to alert you to syntax errors in your\nuse of the TTS API, not to catch all possible errors that might occur in the\nprocess of synthesizing and outputting speech. To catch these errors too, you\nneed to use an event listener, described in the next section.\n\n### Listen to events\n\nTo get more real-time information about the status of synthesized speech, pass\nan event listener in the options to `speak()`, like this:\n\n    \n    \n    chrome.tts.speak(\n      utterance,\n      {\n        onEvent: function(event) {\n          console.log('Event ' + event.type + ' at position ' + event.charIndex);\n          if (event.type == 'error') {\n            console.log('Error: ' + event.errorMessage);\n          }\n        }\n      },\n      callback\n    );\n    \n\nEach event includes an event type, the character index of the current speech\nrelative to the utterance, and for error events, an optional error message.\nThe event types are:\n\n  * `'start'`: The engine has started speaking the utterance.\n  * `'word'`: A word boundary was reached. Use `event.charIndex` to determine the current speech position.\n  * `'sentence'`: A sentence boundary was reached. Use `event.charIndex` to determine the current speech position.\n  * `'marker'`: An SSML marker was reached. Use `event.charIndex` to determine the current speech position.\n  * `'end'`: The engine has finished speaking the utterance.\n  * `'interrupted'`: This utterance was interrupted by another call to `speak()` or `stop()` and did not finish.\n  * `'cancelled'`: This utterance was queued, but then cancelled by another call to `speak()` or `stop()` and never began to speak at all.\n  * `'error'`: An engine-specific error occurred and this utterance cannot be spoken. Check `event.errorMessage` for details.\n\nFour of the event types`'end'`, `'interrupted'`, `'cancelled'`, and\n`'error'`are _final_. After one of those events is received, this utterance\nwill no longer speak and no new events from this utterance will be received.\n\nSome voices may not support all event types, and some voices may not send any\nevents at all. If you don't want to use a voice unless it sends certain\nevents, pass the events you require in the `requiredEventTypes` member of the\noptions object, or use `getVoices()` to choose a voice that meets your\nrequirements. Both are described in what follows.\n\n### SSML markup\n\nUtterances used in this API may include markup using the Speech Synthesis\nMarkup Language (SSML). If you use SSML, the first argument to `speak()`\nshould be a complete SSML document with an XML header and a top-level\n`<speak>` tag, not a document fragment.\n\nFor example:\n\n    \n    \n    chrome.tts.speak(\n      '<?xml version=\"1.0\"?>' +\n      '<speak>' +\n      '  The <emphasis>second</emphasis> ' +\n      '  word of this sentence was emphasized.' +\n      '</speak>'\n    );\n    \n\nNot all speech engines will support all SSML tags, and some may not support\nSSML at all, but all engines are required to ignore any SSML they don't\nsupport and to still speak the underlying text.\n\n### Choose a voice\n\nBy default, Chrome chooses the most appropriate voice for each utterance you\nwant to speak, based on the language. On most Windows, Mac OS X, and ChromeOS\nsystems, speech synthesis provided by the operating system should be able to\nspeak any text in at least one language. Some users may have a variety of\nvoices available, though, from their operating system and from speech engines\nimplemented by other Chrome extensions. In those cases, you can implement\ncustom code to choose the appropriate voice, or to present the user with a\nlist of choices.\n\nTo get a list of all voices, call `getVoices()` and pass it a function that\nreceives an array of `TtsVoice` objects as its argument:\n\n    \n    \n    chrome.tts.getVoices(\n      function(voices) {\n        for (var i = 0; i < voices.length; i++) {\n          console.log('Voice ' + i + ':');\n          console.log('  name: ' + voices[i].voiceName);\n          console.log('  lang: ' + voices[i].lang);\n          console.log('  extension id: ' + voices[i].extensionId);\n          console.log('  event types: ' + voices[i].eventTypes);\n        }\n      }\n    );\n    \n\n## Types\n\n### EventType\n\nChrome 54+\n\n#### Enum\n\n\"start\"  \n\n\"end\"  \n\n\"word\"  \n\n\"sentence\"  \n\n\"marker\"  \n\n\"interrupted\"  \n\n\"cancelled\"  \n\n\"error\"  \n\n\"pause\"  \n\n\"resume\"  \n\n### TtsEvent\n\nAn event from the TTS engine to communicate the status of an utterance.\n\n#### Properties\n\n  * charIndex\n\nnumber optional\n\nThe index of the current character in the utterance. For word events, the\nevent fires at the end of one word and before the beginning of the next. The\n`charIndex` represents a point in the text at the beginning of the next word\nto be spoken.\n\n  * errorMessage\n\nstring optional\n\nThe error description, if the event type is `error`.\n\n  * length\n\nnumber optional\n\nChrome 74+\n\nThe length of the next part of the utterance. For example, in a `word` event,\nthis is the length of the word which will be spoken next. It will be set to -1\nif not set by the speech engine.\n\n  * type\n\nEventType\n\nThe type can be `start` as soon as speech has started, `word` when a word\nboundary is reached, `sentence` when a sentence boundary is reached, `marker`\nwhen an SSML mark element is reached, `end` when the end of the utterance is\nreached, `interrupted` when the utterance is stopped or interrupted before\nreaching the end, `cancelled` when it's removed from the queue before ever\nbeing synthesized, or `error` when any other error occurs. When pausing\nspeech, a `pause` event is fired if a particular utterance is paused in the\nmiddle, and `resume` if an utterance resumes speech. Note that pause and\nresume events may not fire if speech is paused in-between utterances.\n\n### TtsOptions\n\nChrome 77+\n\nThe speech options for the TTS engine.\n\n#### Properties\n\n  * desiredEventTypes\n\nstring[] optional\n\nThe TTS event types that you are interested in listening to. If missing, all\nevent types may be sent.\n\n  * enqueue\n\nboolean optional\n\nIf true, enqueues this utterance if TTS is already in progress. If false (the\ndefault), interrupts any current speech and flushes the speech queue before\nspeaking this new utterance.\n\n  * extensionId\n\nstring optional\n\nThe extension ID of the speech engine to use, if known.\n\n  * gender\n\nVoiceGender optional\n\nDeprecated since Chrome 77\n\nGender is deprecated and will be ignored.\n\nGender of voice for synthesized speech.\n\n  * lang\n\nstring optional\n\nThe language to be used for synthesis, in the form _language_ -_region_.\nExamples: 'en', 'en-US', 'en-GB', 'zh-CN'.\n\n  * pitch\n\nnumber optional\n\nSpeaking pitch between 0 and 2 inclusive, with 0 being lowest and 2 being\nhighest. 1.0 corresponds to a voice's default pitch.\n\n  * rate\n\nnumber optional\n\nSpeaking rate relative to the default rate for this voice. 1.0 is the default\nrate, normally around 180 to 220 words per minute. 2.0 is twice as fast, and\n0.5 is half as fast. Values below 0.1 or above 10.0 are strictly disallowed,\nbut many voices will constrain the minimum and maximum rates furtherfor\nexample a particular voice may not actually speak faster than 3 times normal\neven if you specify a value larger than 3.0.\n\n  * requiredEventTypes\n\nstring[] optional\n\nThe TTS event types the voice must support.\n\n  * voiceName\n\nstring optional\n\nThe name of the voice to use for synthesis. If empty, uses any available\nvoice.\n\n  * volume\n\nnumber optional\n\nSpeaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being\nhighest, with a default of 1.0.\n\n  * onEvent\n\nvoid optional\n\nThis function is called with events that occur in the process of speaking the\nutterance.\n\nThe `onEvent` function looks like:\n\n        \n        (event: TtsEvent) => {...}\n\n    * event\n\nTtsEvent\n\nThe update event from the text-to-speech engine indicating the status of this\nutterance.\n\n### TtsVoice\n\nA description of a voice available for speech synthesis.\n\n#### Properties\n\n  * eventTypes\n\nEventType[] optional\n\nAll of the callback event types that this voice is capable of sending.\n\n  * extensionId\n\nstring optional\n\nThe ID of the extension providing this voice.\n\n  * gender\n\nVoiceGender optional\n\nDeprecated since Chrome 70\n\nGender is deprecated and will be ignored.\n\nThis voice's gender.\n\n  * lang\n\nstring optional\n\nThe language that this voice supports, in the form _language_ -_region_.\nExamples: 'en', 'en-US', 'en-GB', 'zh-CN'.\n\n  * remote\n\nboolean optional\n\nIf true, the synthesis engine is a remote network resource. It may be higher\nlatency and may incur bandwidth costs.\n\n  * voiceName\n\nstring optional\n\nThe name of the voice.\n\n### VoiceGender\n\nChrome 54+  Deprecated since Chrome 70\n\nGender is deprecated and is ignored.\n\n#### Enum\n\n\"male\"  \n\n\"female\"  \n\n## Methods\n\n### getVoices()\n\nPromise\n\n    \n    \n    chrome.tts.getVoices(  \n      callback?: function,  \n    )\n\nGets an array of all available voices.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (voices: TtsVoice[]) => void\n\n    * voices\n\nTtsVoice[]\n\nArray of `tts.TtsVoice` objects representing the available voices for speech\nsynthesis.\n\n#### Returns\n\n  * Promise<TtsVoice[]>\n\nChrome 101+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### isSpeaking()\n\nPromise\n\n    \n    \n    chrome.tts.isSpeaking(  \n      callback?: function,  \n    )\n\nChecks whether the engine is currently speaking. On Mac OS X, the result is\ntrue whenever the system speech engine is speaking, even if the speech wasn't\ninitiated by Chrome.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (speaking: boolean) => void\n\n    * speaking\n\nboolean\n\nTrue if speaking, false otherwise.\n\n#### Returns\n\n  * Promise<boolean>\n\nChrome 101+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### pause()\n\n    \n    \n    chrome.tts.pause()\n\nPauses speech synthesis, potentially in the middle of an utterance. A call to\nresume or stop will un-pause speech.\n\n### resume()\n\n    \n    \n    chrome.tts.resume()\n\nIf speech was paused, resumes speaking where it left off.\n\n### speak()\n\nPromise\n\n    \n    \n    chrome.tts.speak(  \n      utterance: string,  \n      options?: TtsOptions,  \n      callback?: function,  \n    )\n\nSpeaks text using a text-to-speech engine.\n\n#### Parameters\n\n  * utterance\n\nstring\n\nThe text to speak, either plain text or a complete, well-formed SSML document.\nSpeech engines that do not support SSML will strip away the tags and speak the\ntext. The maximum length of the text is 32,768 characters.\n\n  * options\n\nTtsOptions optional\n\nThe speech options.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 101+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### stop()\n\n    \n    \n    chrome.tts.stop()\n\nStops any current speech and flushes the queue of any pending utterances. In\naddition, if speech was paused, it will now be un-paused for the next call to\nspeak.\n\n## Events\n\n### onVoicesChanged\n\nChrome 124+\n\n    \n    \n    chrome.tts.onVoicesChanged.addListener(  \n      callback: function,  \n    )\n\nCalled when the list of `tts.TtsVoice` that would be returned by getVoices has\nchanged.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/types": "#  chrome.types\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.types` API contains type declarations for Chrome.\n\n## Chrome settings\n\nThe `ChromeSetting` type provides a common set of functions (`get()`, `set()`,\nand `clear()`) as well as an event publisher (`onChange`) for settings of the\nChrome browser. The proxy settings examples demonstrate how these functions\nare intended to be used.\n\n### Scope and lifecycle\n\nChrome distinguishes between three different scopes of browser settings:\n\n`regular`\n\n    Settings set in the `regular` scope apply to regular browser windows and are inherited by incognito windows if they are not overwritten. These settings are stored to disk and remain in place until they are cleared by the governing extension, or the governing extension is disabled or uninstalled.\n`incognito_persistent`\n\n    Settings set in the `incognito_persistent` scope apply only to incognito windows. For these, they override `regular` settings. These settings are stored to disk and remain in place until they are cleared by the governing extension, or the governing extension is disabled or uninstalled.\n`incognito_session_only`\n\n    Settings set in the `incognito_session_only` scope apply only to incognito windows. For these, they override `regular` and `incognito_persistent` settings. These settings are not stored to disk and are cleared when the last incognito window is closed. They can only be set when at least one incognito window is open.\n\n### Precedence\n\nChrome manages settings on different layers. The following list describes the\nlayers that may influence the effective settings, in increasing order of\nprecedence.\n\n  1. System settings provided by the operating system\n  2. Command-line parameters\n  3. Settings provided by extensions\n  4. Policies\n\nAs the list implies, policies might overrule any changes that you specify with\nyour extension. You can use the `get()` function to determine whether your\nextension is capable of providing a setting or whether this setting would be\noverridden.\n\nAs discussed previously, Chrome allows using different settings for regular\nwindows and incognito windows. The following example illustrates the behavior.\nAssume that no policy overrides the settings and that an extension can set\nsettings for regular windows **(R)** and settings for incognito windows\n**(I)**.\n\n  * If only **(R)** is set, these settings are effective for both regular and incognito windows.\n  * If only **(I)** is set, these settings are effective for only incognito windows. Regular windows use the settings determined by the lower layers (command-line options and system settings).\n  * If both **(R)** and **(I)** are set, the respective settings are used for regular and incognito windows.\n\nIf two or more extensions want to set the same setting to different values,\nthe extension installed most recently takes precedence over the other\nextensions. If the most recently installed extension sets only **(I)** , the\nsettings of regular windows can be defined by previously installed extensions.\n\nThe _effective_ value of a setting is the one that results from considering\nthe precedence rules. It is used by Chrome.\n\n## Types\n\n### ChromeSetting\n\nAn interface that allows access to a Chrome browser setting. See\n`accessibilityFeatures` for an example.\n\n#### Properties\n\n  * onChange\n\nEvent<functionvoidvoid>\n\nFired after the setting changes.\n\nThe `onChange.addListener` function looks like:\n\n        \n        (callback: function) => {...}\n\n    * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n          \n          (details: object) => void\n\n      * details\n\nobject\n\n        * incognitoSpecific\n\nboolean optional\n\nWhether the value that has changed is specific to the incognito session. This\nproperty will _only_ be present if the user has enabled the extension in\nincognito mode.\n\n        * levelOfControl\n\nLevelOfControl\n\nThe level of control of the setting.\n\n        * value\n\nT\n\nThe value of the setting after the change.\n\n  * clear\n\nvoid\n\nPromise\n\nClears the setting, restoring any default value.\n\nThe `clear` function looks like:\n\n        \n        (details: object, callback?: function) => {...}\n\n    * details\n\nobject\n\nWhich setting to clear.\n\n      * scope\n\nChromeSettingScope optional\n\nWhere to clear the setting (default: regular).\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * get\n\nvoid\n\nPromise\n\nGets the value of a setting.\n\nThe `get` function looks like:\n\n        \n        (details: object, callback?: function) => {...}\n\n    * details\n\nobject\n\nWhich setting to consider.\n\n      * incognito\n\nboolean optional\n\nWhether to return the value that applies to the incognito session (default\nfalse).\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          (details: object) => void\n\n      * details\n\nobject\n\nDetails of the currently effective value.\n\n        * incognitoSpecific\n\nboolean optional\n\nWhether the effective value is specific to the incognito session. This\nproperty will _only_ be present if the `incognito` property in the `details`\nparameter of `get()` was true.\n\n        * levelOfControl\n\nLevelOfControl\n\nThe level of control of the setting.\n\n        * value\n\nT\n\nThe value of the setting.\n\n    * returns\n\nPromise<object>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n  * set\n\nvoid\n\nPromise\n\nSets the value of a setting.\n\nThe `set` function looks like:\n\n        \n        (details: object, callback?: function) => {...}\n\n    * details\n\nobject\n\nWhich setting to change.\n\n      * scope\n\nChromeSettingScope optional\n\nWhere to set the setting (default: regular).\n\n      * value\n\nT\n\nThe value of the setting. Note that every setting has a specific value type,\nwhich is described together with the setting. An extension should _not_ set a\nvalue of a different type.\n\n    * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n          \n          () => void\n\n    * returns\n\nPromise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### ChromeSettingScope\n\nChrome 44+\n\nThe scope of the ChromeSetting. One of\n\n  * `regular`: setting for the regular profile (which is inherited by the incognito profile if not overridden elsewhere),\n  * `regular\\_only`: setting for the regular profile only (not inherited by the incognito profile),\n  * `incognito\\_persistent`: setting for the incognito profile that survives browser restarts (overrides regular preferences),\n  * `incognito\\_session\\_only`: setting for the incognito profile that can only be set during an incognito session and is deleted when the incognito session ends (overrides regular and incognito_persistent preferences).\n\n#### Enum\n\n\"regular\"  \n\n\"regular_only\"  \n\n\"incognito_persistent\"  \n\n\"incognito_session_only\"  \n\n### LevelOfControl\n\nChrome 44+\n\nOne of\n\n  * `not\\_controllable`: cannot be controlled by any extension\n  * `controlled\\_by\\_other\\_extensions`: controlled by extensions with higher precedence\n  * `controllable\\_by\\_this\\_extension`: can be controlled by this extension\n  * `controlled\\_by\\_this\\_extension`: controlled by this extension\n\n#### Enum\n\n\"not_controllable\"  \n\n\"controlled_by_other_extensions\"  \n\n\"controllable_by_this_extension\"  \n\n\"controlled_by_this_extension\"  \n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/userScripts": "#  chrome.userScripts\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `userScripts` API to execute user scripts in the User Scripts context.\n\n## Permissions\n\n`userScripts`  \n\nTo use the User Scripts API, `chrome.userScripts`, add the `\"userScripts\"`\npermission to your manifest.json and `\"host_permissions\"` for sites you want\nto run scripts on.\n\n    \n    \n    {\n      \"name\": \"User script test extension\",\n      \"manifest_version\": 3,\n      \"minimum_chrome_version\": \"120\",\n      \"permissions\": [\n        \"userScripts\"\n      ],\n      \"host_permissions\": [\n        \"*://example.com/*\"\n      ]\n    }\n    \n\n## Availability\n\nChrome 120+ MV3+\n\n## Concepts and usage\n\nA user script is a snippet of code injected into a web page to modify its\nappearance or behavior. Unlike other extension features, such as Content\nScripts and the `chrome.scripting` API, the User Scripts API lets you run\narbitrary code. This API is required for extensions that run scripts provided\nby the user that cannot be shipped as part of your extension package.\n\n### Developer mode for extension users\n\nAs an extension developer, you already have Developer mode enabled in your\ninstallation of Chrome. For user script extensions, your users will also need\nto enable developer mode. Here are instructions that you can copy and paste\ninto your own documentation.\n\n  1. Go to the Extensions page by entering `chrome://extensions` in a new tab. (By design `chrome://` URLs are not linkable.)\n  2. Enable Developer Mode by clicking the toggle switch next to **Developer mode**.  ![Extensions page](/static/docs/extensions/reference/api/userScripts/image/extensions-page-324e88e82e214.png)\n\nExtensions page (chrome://extensions)\n\nYou can determine if developer mode is enabled by checking whether\n`chrome.userScripts` throws an error. For example:\n\n    \n    \n    function isUserScriptsAvailable() {\n      try {\n        // Property access which throws if developer mode is not enabled.\n        chrome.userScripts;\n        return true;\n      } catch {\n        // Not available.\n        return false;\n      }\n    }\n    \n\n### Work in isolated worlds\n\nBoth user and content scripts can run in an isolated world or in the main\nworld. An isolated world is an execution environment that isn't accessible to\na host page or other extensions. This lets a user script change its JavaScript\nenvironment without affecting the host page or other extensions' user and\ncontent scripts. Conversely, user scripts (and content scripts) are not\nvisible to the host page or the user and content scripts of other extensions.\nScripts running in the main world are accessible to host pages and other\nextensions and are visible to host pages and to other extensions. To select\nthe world, pass `\"USER_SCRIPT\"` or `\"MAIN\"` when calling\n`userScripts.register()`.\n\nTo configure a content security policy for the `USER_SCRIPT` world, call\n`userScripts.configureWorld()`:\n\n    \n    \n    chrome.userScripts.configureWorld({\n      csp: \"script-src 'self'\"\n    });\n    \n\n### Messaging\n\nLike content scripts and offscreen documents, user scripts communicate with\nother parts of an extension using messaging (meaning they can call\n`runtime.sendMessage()` and `runtime.connect()` as any other part of an\nextension would). However, they're received using dedicated event handlers\n(meaning, they don't use `onMessage` or `onConnect`). These handlers are\ncalled `runtime.onUserScriptMessage` and `runtime.onUserScriptConnect`.\nDedicated handlers make it easier to identify messages from user scripts,\nwhich are a less-trusted context.\n\nBefore sending a message, you must call `configureWorld()` with the\n`messaging` argument set to `true`. Note that both the `csp` and `messaging`\narguments can be passed at the same time.\n\n    \n    \n    chrome.userScripts.configureWorld({\n      messaging: true\n    });\n    \n\n### Extension updates\n\nUser scripts are cleared when an extension updates. You can add them back by\nrunning code in the `runtime.onInstalled` event handler in the extension\nservice worker. Respond only to the `\"update\"` reason passed to the event\ncallback.\n\n## Example\n\nThis example is from the userScript sample in our samples repository.\n\n### Register a script\n\nThe following example shows a basic call to `register()`. The first argument\nis an array of objects defining the scripts to be registered. There are more\noptions than are shown here.\n\n    \n    \n    chrome.userScripts.register([{\n      id: 'test',\n      matches: ['*://*/*'],\n      js: [{code: 'alert(\"Hi!\")'}]\n    }]);\n    \n\n## Types\n\n### ExecutionWorld\n\nThe JavaScript world for a user script to execute within.\n\n#### Enum\n\n\"MAIN\"  \nSpecifies the execution environment of the DOM, which is the execution\nenvironment shared with the host page's JavaScript.\n\n\"USER_SCRIPT\"  \nSpecifies the execution environment that is specific to user scripts and is\nexempt from the page's CSP.\n\n### InjectionResult\n\nChrome 135+\n\n#### Properties\n\n  * documentId\n\nstring\n\nThe document associated with the injection.\n\n  * error\n\nstring optional\n\nThe error, if any. `error` and `result` are mutually exclusive.\n\n  * frameId\n\nnumber\n\nThe frame associated with the injection.\n\n  * result\n\nany optional\n\nThe result of the script execution.\n\n### InjectionTarget\n\nChrome 135+\n\n#### Properties\n\n  * allFrames\n\nboolean optional\n\nWhether the script should inject into all frames within the tab. Defaults to\nfalse. This must not be true if `frameIds` is specified.\n\n  * documentIds\n\nstring[] optional\n\nThe IDs of specific documentIds to inject into. This must not be set if\n`frameIds` is set.\n\n  * frameIds\n\nnumber[] optional\n\nThe IDs of specific frames to inject into.\n\n  * tabId\n\nnumber\n\nThe ID of the tab into which to inject.\n\n### RegisteredUserScript\n\n#### Properties\n\n  * allFrames\n\nboolean optional\n\nIf true, it will inject into all frames, even if the frame is not the top-most\nframe in the tab. Each frame is checked independently for URL requirements; it\nwill not inject into child frames if the URL requirements are not met.\nDefaults to false, meaning that only the top frame is matched.\n\n  * excludeGlobs\n\nstring[] optional\n\nSpecifies wildcard patterns for pages this user script will NOT be injected\ninto.\n\n  * excludeMatches\n\nstring[] optional\n\nExcludes pages that this user script would otherwise be injected into. See\nMatch Patterns for more details on the syntax of these strings.\n\n  * id\n\nstring\n\nThe ID of the user script specified in the API call. This property must not\nstart with a '_' as it's reserved as a prefix for generated script IDs.\n\n  * includeGlobs\n\nstring[] optional\n\nSpecifies wildcard patterns for pages this user script will be injected into.\n\n  * js\n\nScriptSource[] optional\n\nThe list of ScriptSource objects defining sources of scripts to be injected\ninto matching pages. This property must be specified for ${ref:register}, and\nwhen specified it must be a non-empty array.\n\n  * matches\n\nstring[] optional\n\nSpecifies which pages this user script will be injected into. See Match\nPatterns for more details on the syntax of these strings. This property must\nbe specified for ${ref:register}.\n\n  * runAt\n\nRunAt optional\n\nSpecifies when JavaScript files are injected into the web page. The preferred\nand default value is `document_idle`.\n\n  * world\n\nExecutionWorld optional\n\nThe JavaScript execution environment to run the script in. The default is\n``USER_SCRIPT``.\n\n  * worldId\n\nstring optional\n\nChrome 133+\n\nSpecifies the user script world ID to execute in. If omitted, the script will\nexecute in the default user script world. Only valid if `world` is omitted or\nis `USER_SCRIPT`. Values with leading underscores (`_`) are reserved.\n\n### ScriptSource\n\n#### Properties\n\n  * code\n\nstring optional\n\nA string containing the JavaScript code to inject. Exactly one of `file` or\n`code` must be specified.\n\n  * file\n\nstring optional\n\nThe path of the JavaScript file to inject relative to the extension's root\ndirectory. Exactly one of `file` or `code` must be specified.\n\n### UserScriptFilter\n\n#### Properties\n\n  * ids\n\nstring[] optional\n\n`getScripts` only returns scripts with the IDs specified in this list.\n\n### UserScriptInjection\n\nChrome 135+\n\n#### Properties\n\n  * injectImmediately\n\nboolean optional\n\nWhether the injection should be triggered in the target as soon as possible.\nNote that this is not a guarantee that injection will occur prior to page\nload, as the page may have already loaded by the time the script reaches the\ntarget.\n\n  * js\n\nScriptSource[]\n\nThe list of ScriptSource objects defining sources of scripts to be injected\ninto the target.\n\n  * target\n\nInjectionTarget\n\nDetails specifying the target into which to inject the script.\n\n  * world\n\nExecutionWorld optional\n\nThe JavaScript \"world\" to run the script in. The default is `USER_SCRIPT`.\n\n  * worldId\n\nstring optional\n\nSpecifies the user script world ID to execute in. If omitted, the script will\nexecute in the default user script world. Only valid if `world` is omitted or\nis `USER_SCRIPT`. Values with leading underscores (`_`) are reserved.\n\n### WorldProperties\n\n#### Properties\n\n  * csp\n\nstring optional\n\nSpecifies the world csp. The default is the ``ISOLATED`` world csp.\n\n  * messaging\n\nboolean optional\n\nSpecifies whether messaging APIs are exposed. The default is `false`.\n\n  * worldId\n\nstring optional\n\nChrome 133+\n\nSpecifies the ID of the specific user script world to update. If not provided,\nupdates the properties of the default user script world. Values with leading\nunderscores (`_`) are reserved.\n\n## Methods\n\n### configureWorld()\n\nPromise\n\n    \n    \n    chrome.userScripts.configureWorld(  \n      properties: WorldProperties,  \n      callback?: function,  \n    )\n\nConfigures the ``USER_SCRIPT`` execution environment.\n\n#### Parameters\n\n  * properties\n\nWorldProperties\n\nContains the user script world configuration.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### execute()\n\nPromise Chrome 135+\n\n    \n    \n    chrome.userScripts.execute(  \n      injection: UserScriptInjection,  \n      callback?: function,  \n    )\n\nInjects a script into a target context. By default, the script will be run at\n`document_idle`, or immediately if the page has already loaded. If the\n`injectImmediately` property is set, the script will inject without waiting,\neven if the page has not finished loading. If the script evaluates to a\npromise, the browser will wait for the promise to settle and return the\nresulting value.\n\n#### Parameters\n\n  * injection\n\nUserScriptInjection\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (result: InjectionResult[]) => void\n\n    * result\n\nInjectionResult[]\n\n#### Returns\n\n  * Promise<InjectionResult[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getScripts()\n\nPromise\n\n    \n    \n    chrome.userScripts.getScripts(  \n      filter?: UserScriptFilter,  \n      callback?: function,  \n    )\n\nReturns all dynamically-registered user scripts for this extension.\n\n#### Parameters\n\n  * filter\n\nUserScriptFilter optional\n\nIf specified, this method returns only the user scripts that match it.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (scripts: RegisteredUserScript[]) => void\n\n    * scripts\n\nRegisteredUserScript[]\n\n#### Returns\n\n  * Promise<RegisteredUserScript[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getWorldConfigurations()\n\nPromise Chrome 133+\n\n    \n    \n    chrome.userScripts.getWorldConfigurations(  \n      callback?: function,  \n    )\n\nRetrieves all registered world configurations.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (worlds: WorldProperties[]) => void\n\n    * worlds\n\nWorldProperties[]\n\n#### Returns\n\n  * Promise<WorldProperties[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### register()\n\nPromise\n\n    \n    \n    chrome.userScripts.register(  \n      scripts: RegisteredUserScript[],  \n      callback?: function,  \n    )\n\nRegisters one or more user scripts for this extension.\n\n#### Parameters\n\n  * scripts\n\nRegisteredUserScript[]\n\nContains a list of user scripts to be registered.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### resetWorldConfiguration()\n\nPromise Chrome 133+\n\n    \n    \n    chrome.userScripts.resetWorldConfiguration(  \n      worldId?: string,  \n      callback?: function,  \n    )\n\nResets the configuration for a user script world. Any scripts that inject into\nthe world with the specified ID will use the default world configuration.\n\n#### Parameters\n\n  * worldId\n\nstring optional\n\nThe ID of the user script world to reset. If omitted, resets the default\nworld's configuration.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### unregister()\n\nPromise\n\n    \n    \n    chrome.userScripts.unregister(  \n      filter?: UserScriptFilter,  \n      callback?: function,  \n    )\n\nUnregisters all dynamically-registered user scripts for this extension.\n\n#### Parameters\n\n  * filter\n\nUserScriptFilter optional\n\nIf specified, this method unregisters only the user scripts that match it.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### update()\n\nPromise\n\n    \n    \n    chrome.userScripts.update(  \n      scripts: RegisteredUserScript[],  \n      callback?: function,  \n    )\n\nUpdates one or more user scripts for this extension.\n\n#### Parameters\n\n  * scripts\n\nRegisteredUserScript[]\n\nContains a list of user scripts to be updated. A property is only updated for\nthe existing script if it is specified in this object. If there are errors\nduring script parsing/file validation, or if the IDs specified do not\ncorrespond to a fully registered script, then no scripts are updated.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/vpnProvider": "#  chrome.vpnProvider\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.vpnProvider` API to implement a VPN client.\n\n## Permissions\n\n`vpnProvider`  \n\n## Availability\n\nChrome 43+  ChromeOS only\n\n## Concepts and usage\n\nTypical usage of `chrome.vpnProvider` is as follows:\n\n  * Create VPN configurations by calling `createConfig()`. A VPN configuration is a persistent entry shown to the user in a ChromeOS UI. The user can select a VPN configuration from a list and connect to it or disconnect from it.\n\n  * Add listeners to the `onPlatformMessage`, `onPacketReceived`, and `onConfigRemoved` events.\n\n  * When the user connects to the VPN configuration, `onPlatformMessage` will be received with the message `\"connected\"`. The period between the `\"connected\"` and `\"disconnected\"` messages is called a \"VPN session\". In this time period, the extension that receives the message is said to own the VPN session.\n\n  * Initiate connection to the VPN server and start the VPN client.\n\n  * Set the Parameters of the connection by calling `setParameters()`.\n\n  * Notify the connection state as `\"connected\"` by calling `notifyConnectionStateChanged()`.\n\n  * When the steps previous are completed without errors, a virtual tunnel is created to the network stack of ChromeOS. IP packets can be sent through the tunnel by calling `sendPacket()` and any packets originating on the ChromeOS device will be received using the `onPacketReceived` event handler.\n\n  * When the user disconnects from the VPN configuration, `onPlatformMessage` will be fired with the message `\"disconnected\"`.\n\n  * If the VPN configuration is no longer necessary, it can be destroyed by calling `destroyConfig()`.\n\n## Types\n\n### Parameters\n\n#### Properties\n\n  * address\n\nstring\n\nIP address for the VPN interface in CIDR notation. IPv4 is currently the only\nsupported mode.\n\n  * broadcastAddress\n\nstring optional\n\nBroadcast address for the VPN interface. (default: deduced from IP address and\nmask)\n\n  * dnsServers\n\nstring[]\n\nA list of IPs for the DNS servers.\n\n  * domainSearch\n\nstring[] optional\n\nA list of search domains. (default: no search domain)\n\n  * exclusionList\n\nstring[]\n\nExclude network traffic to the list of IP blocks in CIDR notation from the\ntunnel. This can be used to bypass traffic to and from the VPN server. When\nmany rules match a destination, the rule with the longest matching prefix\nwins. Entries that correspond to the same CIDR block are treated as\nduplicates. Such duplicates in the collated (exclusionList + inclusionList)\nlist are eliminated and the exact duplicate entry that will be eliminated is\nundefined.\n\n  * inclusionList\n\nstring[]\n\nInclude network traffic to the list of IP blocks in CIDR notation to the\ntunnel. This parameter can be used to set up a split tunnel. By default no\ntraffic is directed to the tunnel. Adding the entry \"0.0.0.0/0\" to this list\ngets all the user traffic redirected to the tunnel. When many rules match a\ndestination, the rule with the longest matching prefix wins. Entries that\ncorrespond to the same CIDR block are treated as duplicates. Such duplicates\nin the collated (exclusionList + inclusionList) list are eliminated and the\nexact duplicate entry that will be eliminated is undefined.\n\n  * mtu\n\nstring optional\n\nMTU setting for the VPN interface. (default: 1500 bytes)\n\n  * reconnect\n\nstring optional\n\nChrome 51+\n\nWhether or not the VPN extension implements auto-reconnection.\n\nIf true, the `linkDown`, `linkUp`, `linkChanged`, `suspend`, and `resume`\nplatform messages will be used to signal the respective events. If false, the\nsystem will forcibly disconnect the VPN if the network topology changes, and\nthe user will need to reconnect manually. (default: false)\n\nThis property is new in Chrome 51; it will generate an exception in earlier\nversions. try/catch can be used to conditionally enable the feature based on\nbrowser support.\n\n### PlatformMessage\n\nThe enum is used by the platform to notify the client of the VPN session\nstatus.\n\n#### Enum\n\n\"connected\"  \nIndicates that the VPN configuration connected.\n\n\"disconnected\"  \nIndicates that the VPN configuration disconnected.\n\n\"error\"  \nIndicates that an error occurred in VPN connection, for example a timeout. A\ndescription of the error is given as the error argument to onPlatformMessage.\n\n\"linkDown\"  \nIndicates that the default physical network connection is down.\n\n\"linkUp\"  \nIndicates that the default physical network connection is back up.\n\n\"linkChanged\"  \nIndicates that the default physical network connection changed, e.g.\nwifi->mobile.\n\n\"suspend\"  \nIndicates that the OS is preparing to suspend, so the VPN should drop its\nconnection. The extension is not guaranteed to receive this event prior to\nsuspending.\n\n\"resume\"  \nIndicates that the OS has resumed and the user has logged back in, so the VPN\nshould try to reconnect.\n\n### UIEvent\n\nThe enum is used by the platform to indicate the event that triggered\n`onUIEvent`.\n\n#### Enum\n\n\"showAddDialog\"  \nRequests that the VPN client show the add configuration dialog box to the\nuser.\n\n\"showConfigureDialog\"  \nRequests that the VPN client show the configuration settings dialog box to the\nuser.\n\n### VpnConnectionState\n\nThe enum is used by the VPN client to inform the platform of its current\nstate. This helps provide meaningful messages to the user.\n\n#### Enum\n\n\"connected\"  \nSpecifies that VPN connection was successful.\n\n\"failure\"  \nSpecifies that VPN connection has failed.\n\n## Methods\n\n### createConfig()\n\nPromise\n\n    \n    \n    chrome.vpnProvider.createConfig(  \n      name: string,  \n      callback?: function,  \n    )\n\nCreates a new VPN configuration that persists across multiple login sessions\nof the user.\n\n#### Parameters\n\n  * name\n\nstring\n\nThe name of the VPN configuration.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (id: string) => void\n\n    * id\n\nstring\n\nA unique ID for the created configuration, or `undefined` on failure.\n\n#### Returns\n\n  * Promise<string>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### destroyConfig()\n\nPromise\n\n    \n    \n    chrome.vpnProvider.destroyConfig(  \n      id: string,  \n      callback?: function,  \n    )\n\nDestroys a VPN configuration created by the extension.\n\n#### Parameters\n\n  * id\n\nstring\n\nID of the VPN configuration to destroy.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### notifyConnectionStateChanged()\n\nPromise\n\n    \n    \n    chrome.vpnProvider.notifyConnectionStateChanged(  \n      state: VpnConnectionState,  \n      callback?: function,  \n    )\n\nNotifies the VPN session state to the platform. This will succeed only when\nthe VPN session is owned by the extension.\n\n#### Parameters\n\n  * state\n\nVpnConnectionState\n\nThe VPN session state of the VPN client.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### sendPacket()\n\nPromise\n\n    \n    \n    chrome.vpnProvider.sendPacket(  \n      data: ArrayBuffer,  \n      callback?: function,  \n    )\n\nSends an IP packet through the tunnel created for the VPN session. This will\nsucceed only when the VPN session is owned by the extension.\n\n#### Parameters\n\n  * data\n\nArrayBuffer\n\nThe IP packet to be sent to the platform.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### setParameters()\n\nPromise\n\n    \n    \n    chrome.vpnProvider.setParameters(  \n      parameters: Parameters,  \n      callback?: function,  \n    )\n\nSets the parameters for the VPN session. This should be called immediately\nafter `\"connected\"` is received from the platform. This will succeed only when\nthe VPN session is owned by the extension.\n\n#### Parameters\n\n  * parameters\n\nParameters\n\nThe parameters for the VPN session.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onConfigCreated\n\n    \n    \n    chrome.vpnProvider.onConfigCreated.addListener(  \n      callback: function,  \n    )\n\nTriggered when a configuration is created by the platform for the extension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, name: string, data: object) => void\n\n    * id\n\nstring\n\n    * name\n\nstring\n\n    * data\n\nobject\n\n### onConfigRemoved\n\n    \n    \n    chrome.vpnProvider.onConfigRemoved.addListener(  \n      callback: function,  \n    )\n\nTriggered when a configuration created by the extension is removed by the\nplatform.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string) => void\n\n    * id\n\nstring\n\n### onPacketReceived\n\n    \n    \n    chrome.vpnProvider.onPacketReceived.addListener(  \n      callback: function,  \n    )\n\nTriggered when an IP packet is received via the tunnel for the VPN session\nowned by the extension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (data: ArrayBuffer) => void\n\n    * data\n\nArrayBuffer\n\n### onPlatformMessage\n\n    \n    \n    chrome.vpnProvider.onPlatformMessage.addListener(  \n      callback: function,  \n    )\n\nTriggered when a message is received from the platform for a VPN configuration\nowned by the extension.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (id: string, message: PlatformMessage, error: string) => void\n\n    * id\n\nstring\n\n    * message\n\nPlatformMessage\n\n    * error\n\nstring\n\n### onUIEvent\n\n    \n    \n    chrome.vpnProvider.onUIEvent.addListener(  \n      callback: function,  \n    )\n\nTriggered when there is a UI event for the extension. UI events are signals\nfrom the platform that indicate to the app that a UI dialog needs to be shown\nto the user.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (event: UIEvent, id?: string) => void\n\n    * event\n\nUIEvent\n\n    * id\n\nstring optional\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/wallpaper": "#  chrome.wallpaper\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Important:** This API works **only on ChromeOS**.\n\n## Description\n\nUse the `chrome.wallpaper` API to change the ChromeOS wallpaper.\n\n## Permissions\n\n`wallpaper`  \n\nYou must declare the \"wallpaper\" permission in the app's manifest to use the\nwallpaper API. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"wallpaper\"\n      ],\n      ...\n    }\n    \n\n## Availability\n\nChrome 43+  ChromeOS only\n\n## Examples\n\nFor example, to set the wallpaper as the image at\n`https://example.com/a_file.png`, you can call `chrome.wallpaper.setWallpaper`\nthis way:\n\n    \n    \n    chrome.wallpaper.setWallpaper(\n      {\n        'url': 'https://example.com/a_file.jpg',\n        'layout': 'CENTER_CROPPED',\n        'filename': 'test_wallpaper'\n      },\n      function() {}\n    );\n    \n\n## Types\n\n### WallpaperLayout\n\nChrome 44+\n\nThe supported wallpaper layouts.\n\n#### Enum\n\n\"STRETCH\"  \n\n\"CENTER\"  \n\n\"CENTER_CROPPED\"  \n\n## Methods\n\n### setWallpaper()\n\nPromise\n\n    \n    \n    chrome.wallpaper.setWallpaper(  \n      details: object,  \n      callback?: function,  \n    )\n\nSets wallpaper to the image at _url_ or _wallpaperData_ with the specified\n_layout_\n\n#### Parameters\n\n  * details\n\nobject\n\n    * data\n\nArrayBuffer optional\n\nThe jpeg or png encoded wallpaper image as an ArrayBuffer.\n\n    * filename\n\nstring\n\nThe file name of the saved wallpaper.\n\n    * layout\n\nWallpaperLayout\n\nThe supported wallpaper layouts.\n\n    * thumbnail\n\nboolean optional\n\nTrue if a 128x60 thumbnail should be generated. Layout and ratio are not\nsupported yet.\n\n    * url\n\nstring optional\n\nThe URL of the wallpaper to be set (can be relative).\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (thumbnail?: ArrayBuffer) => void\n\n    * thumbnail\n\nArrayBuffer optional\n\nThe jpeg encoded wallpaper thumbnail. It is generated by resizing the\nwallpaper to 128x60.\n\n#### Returns\n\n  * Promise<ArrayBuffer | undefined>\n\nChrome 96+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/webAuthenticationProxy": "#  chrome.webAuthenticationProxy\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nThe `chrome.webAuthenticationProxy` API lets remote desktop software running\non a remote host intercept Web Authentication API (WebAuthn) requests in order\nto handle them on a local client.\n\n## Permissions\n\n`webAuthenticationProxy`  \n\n## Availability\n\nChrome 115+ MV3+\n\n## Types\n\n### CreateRequest\n\n#### Properties\n\n  * requestDetailsJson\n\nstring\n\nThe `PublicKeyCredentialCreationOptions` passed to\n`navigator.credentials.create()`, serialized as a JSON string. The\nserialization format is compatible with\n`PublicKeyCredential.parseCreationOptionsFromJSON()`.\n\n  * requestId\n\nnumber\n\nAn opaque identifier for the request.\n\n### CreateResponseDetails\n\n#### Properties\n\n  * error\n\nDOMExceptionDetails optional\n\nThe `DOMException` yielded by the remote request, if any.\n\n  * requestId\n\nnumber\n\nThe `requestId` of the `CreateRequest`.\n\n  * responseJson\n\nstring optional\n\nThe `PublicKeyCredential`, yielded by the remote request, if any, serialized\nas a JSON string by calling href=\"https://w3c.github.io/webauthn/#dom-\npublickeycredential-tojson\"> `PublicKeyCredential.toJSON()`.\n\n### DOMExceptionDetails\n\n#### Properties\n\n  * message\n\nstring\n\n  * name\n\nstring\n\n### GetRequest\n\n#### Properties\n\n  * requestDetailsJson\n\nstring\n\nThe `PublicKeyCredentialRequestOptions` passed to\n`navigator.credentials.get()`, serialized as a JSON string. The serialization\nformat is compatible with `PublicKeyCredential.parseRequestOptionsFromJSON()`.\n\n  * requestId\n\nnumber\n\nAn opaque identifier for the request.\n\n### GetResponseDetails\n\n#### Properties\n\n  * error\n\nDOMExceptionDetails optional\n\nThe `DOMException` yielded by the remote request, if any.\n\n  * requestId\n\nnumber\n\nThe `requestId` of the `CreateRequest`.\n\n  * responseJson\n\nstring optional\n\nThe `PublicKeyCredential`, yielded by the remote request, if any, serialized\nas a JSON string by calling href=\"https://w3c.github.io/webauthn/#dom-\npublickeycredential-tojson\"> `PublicKeyCredential.toJSON()`.\n\n### IsUvpaaRequest\n\n#### Properties\n\n  * requestId\n\nnumber\n\nAn opaque identifier for the request.\n\n### IsUvpaaResponseDetails\n\n#### Properties\n\n  * isUvpaa\n\nboolean\n\n  * requestId\n\nnumber\n\n## Methods\n\n### attach()\n\nPromise\n\n    \n    \n    chrome.webAuthenticationProxy.attach(  \n      callback?: function,  \n    )\n\nMakes this extension the active Web Authentication API request proxy.\n\nRemote desktop extensions typically call this method after detecting\nattachment of a remote session to this host. Once this method returns without\nerror, regular processing of WebAuthn requests is suspended, and events from\nthis extension API are raised.\n\nThis method fails with an error if a different extension is already attached.\n\nThe attached extension must call `detach()` once the remote desktop session\nhas ended in order to resume regular WebAuthn request processing. Extensions\nautomatically become detached if they are unloaded.\n\nRefer to the `onRemoteSessionStateChange` event for signaling a change of\nremote session attachment from a native application to to the (possibly\nsuspended) extension.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (error?: string) => void\n\n    * error\n\nstring optional\n\n#### Returns\n\n  * Promise<string | undefined>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### completeCreateRequest()\n\nPromise\n\n    \n    \n    chrome.webAuthenticationProxy.completeCreateRequest(  \n      details: CreateResponseDetails,  \n      callback?: function,  \n    )\n\nReports the result of a `navigator.credentials.create()` call. The extension\nmust call this for every `onCreateRequest` event it has received, unless the\nrequest was canceled (in which case, an `onRequestCanceled` event is fired).\n\n#### Parameters\n\n  * details\n\nCreateResponseDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### completeGetRequest()\n\nPromise\n\n    \n    \n    chrome.webAuthenticationProxy.completeGetRequest(  \n      details: GetResponseDetails,  \n      callback?: function,  \n    )\n\nReports the result of a `navigator.credentials.get()` call. The extension must\ncall this for every `onGetRequest` event it has received, unless the request\nwas canceled (in which case, an `onRequestCanceled` event is fired).\n\n#### Parameters\n\n  * details\n\nGetResponseDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### completeIsUvpaaRequest()\n\nPromise\n\n    \n    \n    chrome.webAuthenticationProxy.completeIsUvpaaRequest(  \n      details: IsUvpaaResponseDetails,  \n      callback?: function,  \n    )\n\nReports the result of a\n`PublicKeyCredential.isUserVerifyingPlatformAuthenticator()` call. The\nextension must call this for every `onIsUvpaaRequest` event it has received.\n\n#### Parameters\n\n  * details\n\nIsUvpaaResponseDetails\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### detach()\n\nPromise\n\n    \n    \n    chrome.webAuthenticationProxy.detach(  \n      callback?: function,  \n    )\n\nRemoves this extension from being the active Web Authentication API request\nproxy.\n\nThis method is typically called when the extension detects that a remote\ndesktop session was terminated. Once this method returns, the extension ceases\nto be the active Web Authentication API request proxy.\n\nRefer to the `onRemoteSessionStateChange` event for signaling a change of\nremote session attachment from a native application to to the (possibly\nsuspended) extension.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (error?: string) => void\n\n    * error\n\nstring optional\n\n#### Returns\n\n  * Promise<string | undefined>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onCreateRequest\n\n    \n    \n    chrome.webAuthenticationProxy.onCreateRequest.addListener(  \n      callback: function,  \n    )\n\nFires when a WebAuthn `navigator.credentials.create()` call occurs. The\nextension must supply a response by calling `completeCreateRequest()` with the\n`requestId` from `requestInfo`.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestInfo: CreateRequest) => void\n\n    * requestInfo\n\nCreateRequest\n\n### onGetRequest\n\n    \n    \n    chrome.webAuthenticationProxy.onGetRequest.addListener(  \n      callback: function,  \n    )\n\nFires when a WebAuthn navigator.credentials.get() call occurs. The extension\nmust supply a response by calling `completeGetRequest()` with the `requestId`\nfrom `requestInfo`\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestInfo: GetRequest) => void\n\n    * requestInfo\n\nGetRequest\n\n### onIsUvpaaRequest\n\n    \n    \n    chrome.webAuthenticationProxy.onIsUvpaaRequest.addListener(  \n      callback: function,  \n    )\n\nFires when a\n`PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()` call\noccurs. The extension must supply a response by calling\n`completeIsUvpaaRequest()` with the `requestId` from `requestInfo`\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestInfo: IsUvpaaRequest) => void\n\n    * requestInfo\n\nIsUvpaaRequest\n\n### onRemoteSessionStateChange\n\n    \n    \n    chrome.webAuthenticationProxy.onRemoteSessionStateChange.addListener(  \n      callback: function,  \n    )\n\nA native application associated with this extension can cause this event to be\nfired by writing to a file with a name equal to the extension's ID in a\ndirectory named `WebAuthenticationProxyRemoteSessionStateChange` inside the\ndefault user data directory\n\nThe contents of the file should be empty. I.e., it is not necessary to change\nthe contents of the file in order to trigger this event.\n\nThe native host application may use this event mechanism to signal a possible\nremote session state change (i.e. from detached to attached, or vice versa)\nwhile the extension service worker is possibly suspended. In the handler for\nthis event, the extension can call the `attach()` or `detach()` API methods\naccordingly.\n\nThe event listener must be registered synchronously at load time.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n### onRequestCanceled\n\n    \n    \n    chrome.webAuthenticationProxy.onRequestCanceled.addListener(  \n      callback: function,  \n    )\n\nFires when a `onCreateRequest` or `onGetRequest` event is canceled (because\nthe WebAuthn request was aborted by the caller, or because it timed out). When\nreceiving this event, the extension should cancel processing of the\ncorresponding request on the client side. Extensions cannot complete a request\nonce it has been canceled.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (requestId: number) => void\n\n    * requestId\n\nnumber\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/webNavigation": "#  chrome.webNavigation\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.webNavigation` API to receive notifications about the status\nof navigation requests in-flight.\n\n## Permissions\n\n`webNavigation`  \n\nAll `chrome.webNavigation` methods and events require you to declare the\n`\"webNavigation\"` permission in the extension manifest. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"webNavigation\"\n      ],\n      ...\n    }\n    \n\n## Concepts and usage\n\n### Event order\n\nFor a navigation that is successfully completed, events are fired in the\nfollowing order:\n\n    \n    \n    onBeforeNavigate -> onCommitted -> [onDOMContentLoaded] -> onCompleted\n    \n\nAny error that occurs during the process results in an `onErrorOccurred`\nevent. For a specific navigation, there are no further events fired after\n`onErrorOccurred`.\n\nIf a navigating frame contains subframes, its `onCommitted` is fired before\nany of its children's `onBeforeNavigate`; while `onCompleted` is fired after\nall of its children's `onCompleted`.\n\nIf the reference fragment of a frame is changed, a\n`onReferenceFragmentUpdated` event is fired. This event can fire any time\nafter `onDOMContentLoaded`, even after `onCompleted`.\n\nIf the history API is used to modify the state of a frame (e.g. using\n`history.pushState()`, a `onHistoryStateUpdated` event is fired. This event\ncan fire any time after `onDOMContentLoaded`.\n\nIf a navigation restored a page from the Back Forward Cache, the\n`onDOMContentLoaded` event won't fire. The event is not fired because the\ncontent has already completed load when the page was first visited.\n\nIf a navigation was triggered using Chrome Instant or Instant Pages, a\ncompletely loaded page is swapped into the current tab. In that case, an\n`onTabReplaced` event is fired.\n\n### Relation to webRequest events\n\nThere is no defined ordering between events of the webRequest API and the\nevents of the webNavigation API. It is possible that webRequest events are\nstill received for frames that already started a new navigation, or that a\nnavigation only proceeds after the network resources are already fully loaded.\n\nIn general, the webNavigation events are closely related to the navigation\nstate that is displayed in the UI, while the webRequest events correspond to\nthe state of the network stack which is generally opaque to the user.\n\n### Tab IDs\n\nNot all navigating tabs correspond to actual tabs in Chrome's UI, for example,\na tab that is being pre-rendered. Such tabs are not accessible using the tabs\nAPI nor can you request information about them by calling\n`webNavigation.getFrame()` or `webNavigation.getAllFrames()`. Once such a tab\nis swapped in, an `onTabReplaced` event is fired and they become accessible\nthrough these APIs.\n\n### Timestamps\n\nIt's important to note that some technical oddities in the OS's handling of\ndistinct Chrome processes can cause the clock to be skewed between the browser\nitself and extension processes. That means that the `timeStamp` property of\nthe `WebNavigation` event `timeStamp` property is only guaranteed to be\n_internally_ consistent. Comparing one event to another event will give you\nthe correct offset between them, but comparing them to the current time inside\nthe extension (using `(new Date()).getTime()`, for instance) might give\nunexpected results.\n\n### Frame IDs\n\nFrames within a tab can be identified by a frame ID. The frame ID of the main\nframe is always 0, the ID of child frames is a positive number. Once a\ndocument is constructed in a frame, its frame ID remains constant during the\nlifetime of the document. As of Chrome 49, this ID is also constant for the\nlifetime of the frame (across multiple navigations).\n\nDue to the multi-process nature of Chrome, a tab might use different processes\nto render the source and destination of a web page. Therefore, if a navigation\ntakes place in a new process, you might receive events both from the new and\nthe old page until the new navigation is committed (i.e. the `onCommitted`\nevent is sent for the new main frame). In other words, it is possible to have\nmore than one pending sequence of webNavigation events with the same\n`frameId`. The sequences can be distinguished by the `processId` key.\n\nAlso note that during a provisional load the process might be switched several\ntimes. This happens when the load is redirected to a different site. In this\ncase, you will receive repeated `onBeforeNavigate` and `onErrorOccurred`\nevents, until you receive the final `onCommitted` event.\n\nAnother concept that is problematic with extensions is the lifecycle of the\nframe. A frame hosts a document (which is associated with a committed URL).\nThe document can change (say by navigating) but the _frameId_ won't, and so it\nis difficult to associate that something happened in a specific document with\njust _frameIds_. We are introducing a concept of a documentId which is a\nunique identifier per document. If a frame is navigated and opens a new\ndocument the identifier will change. This field is useful for determining when\npages change their lifecycle state (between prerender/active/cached) because\nit remains the same.\n\n### Transition types and qualifiers\n\nThe `webNavigation` `onCommitted` event has a `transitionType` and a\n`transitionQualifiers` property. The _transition type_ is the same as used in\nthe history API describing how the browser navigated to this particular URL.\nIn addition, several _transition qualifiers_ can be returned that further\ndefine the navigation.\n\nThe following transition qualifiers exist:\n\nTransition qualifier| Description  \n---|---  \n\"client_redirect\"| One or more redirects caused by JavaScript or meta refresh\ntags on the page happened during the navigation.  \n\"server_redirect\"| One or more redirects caused by HTTP headers sent from the\nserver happened during the navigation.  \n\"forward_back\"| The user used the Forward or Back button to initiate the\nnavigation.  \n\"from_address_bar\"| The user initiated the navigation from the address bar\n(aka Omnibox).  \n  \n## Examples\n\nTo try this API, install the webNavigation API example from the chrome-\nextension-samples repository.\n\n## Types\n\n### TransitionQualifier\n\nChrome 44+\n\n#### Enum\n\n\"client_redirect\"  \n\n\"server_redirect\"  \n\n\"forward_back\"  \n\n\"from_address_bar\"  \n\n### TransitionType\n\nChrome 44+\n\nCause of the navigation. The same transition types as defined in the history\nAPI are used. These are the same transition types as defined in the history\nAPI except with `\"start_page\"` in place of `\"auto_toplevel\"` (for backwards\ncompatibility).\n\n#### Enum\n\n\"link\"  \n\n\"typed\"  \n\n\"auto_bookmark\"  \n\n\"auto_subframe\"  \n\n\"manual_subframe\"  \n\n\"generated\"  \n\n\"start_page\"  \n\n\"form_submit\"  \n\n\"reload\"  \n\n\"keyword\"  \n\n\"keyword_generated\"  \n\n## Methods\n\n### getAllFrames()\n\nPromise\n\n    \n    \n    chrome.webNavigation.getAllFrames(  \n      details: object,  \n      callback?: function,  \n    )\n\nRetrieves information about all frames of a given tab.\n\n#### Parameters\n\n  * details\n\nobject\n\nInformation about the tab to retrieve all frames from.\n\n    * tabId\n\nnumber\n\nThe ID of the tab.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details?: object[]) => void\n\n    * details\n\nobject[] optional\n\nA list of frames in the given tab, null if the specified tab ID is invalid.\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nDocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * errorOccurred\n\nboolean\n\nTrue if the last navigation in this frame was interrupted by an error, i.e.\nthe onErrorOccurred event fired.\n\n      * frameId\n\nnumber\n\nThe ID of the frame. 0 indicates that this is the main frame; a positive value\nindicates the ID of a subframe.\n\n      * frameType\n\nFrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nThe ID of the process that runs the renderer for this frame.\n\n      * url\n\nstring\n\nThe URL currently associated with this frame.\n\n#### Returns\n\n  * Promise<object[] | undefined>\n\nChrome 93+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getFrame()\n\nPromise\n\n    \n    \n    chrome.webNavigation.getFrame(  \n      details: object,  \n      callback?: function,  \n    )\n\nRetrieves information about the given frame. A frame refers to an <iframe> or\na <frame> of a web page and is identified by a tab ID and a frame ID.\n\n#### Parameters\n\n  * details\n\nobject\n\nInformation about the frame to retrieve information about.\n\n    * documentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the document. If the frameId and/or tabId are provided they will\nbe validated to match the document found by provided document ID.\n\n    * frameId\n\nnumber optional\n\nThe ID of the frame in the given tab.\n\n    * processId\n\nnumber optional\n\nDeprecated since Chrome 49\n\nFrames are now uniquely identified by their tab ID and frame ID; the process\nID is no longer needed and therefore ignored.\n\nThe ID of the process that runs the renderer for this tab.\n\n    * tabId\n\nnumber optional\n\nThe ID of the tab in which the frame is.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (details?: object) => void\n\n    * details\n\nobject optional\n\nInformation about the requested frame, null if the specified frame ID and/or\ntab ID are invalid.\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nDocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * errorOccurred\n\nboolean\n\nTrue if the last navigation in this frame was interrupted by an error, i.e.\nthe onErrorOccurred event fired.\n\n      * frameType\n\nFrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * url\n\nstring\n\nThe URL currently associated with this frame, if the frame identified by the\nframeId existed at one point in the given tab. The fact that an URL is\nassociated with a given frameId does not imply that the corresponding frame\nstill exists.\n\n#### Returns\n\n  * Promise<object | undefined>\n\nChrome 93+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onBeforeNavigate\n\n    \n    \n    chrome.webNavigation.onBeforeNavigate.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when a navigation is about to occur.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\n0 indicates the navigation happens in the tab content window; a positive value\nindicates navigation in a subframe. Frame IDs are unique for a given tab and\nprocess.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nDeprecated since Chrome 50\n\nThe processId is no longer set for this event, since the process which will\nrender the resulting document is not known until onCommit.\n\nThe value of -1.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the navigation is about to occur.\n\n      * timeStamp\n\nnumber\n\nThe time when the browser was about to start the navigation, in milliseconds\nsince the epoch.\n\n      * url\n\nstring\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onCommitted\n\n    \n    \n    chrome.webNavigation.onCommitted.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when a navigation is committed. The document (and the resources it\nrefers to, such as images and subframes) might still be downloading, but at\nleast part of the document has been received from the server and the browser\nhas decided to switch to the new document.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\n0 indicates the navigation happens in the tab content window; a positive value\nindicates navigation in a subframe. Frame IDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nChrome 74+\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nThe ID of the process that runs the renderer for this frame.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the navigation occurs.\n\n      * timeStamp\n\nnumber\n\nThe time when the navigation was committed, in milliseconds since the epoch.\n\n      * transitionQualifiers\n\nTransitionQualifier[]\n\nA list of transition qualifiers.\n\n      * transitionType\n\nTransitionType\n\nCause of the navigation.\n\n      * url\n\nstring\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onCompleted\n\n    \n    \n    chrome.webNavigation.onCompleted.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when a document, including the resources it refers to, is completely\nloaded and initialized.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\n0 indicates the navigation happens in the tab content window; a positive value\nindicates navigation in a subframe. Frame IDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nChrome 74+\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nThe ID of the process that runs the renderer for this frame.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the navigation occurs.\n\n      * timeStamp\n\nnumber\n\nThe time when the document finished loading, in milliseconds since the epoch.\n\n      * url\n\nstring\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onCreatedNavigationTarget\n\n    \n    \n    chrome.webNavigation.onCreatedNavigationTarget.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when a new window, or a new tab in an existing window, is created to\nhost a navigation.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * sourceFrameId\n\nnumber\n\nThe ID of the frame with sourceTabId in which the navigation is triggered. 0\nindicates the main frame.\n\n      * sourceProcessId\n\nnumber\n\nThe ID of the process that runs the renderer for the source frame.\n\n      * sourceTabId\n\nnumber\n\nThe ID of the tab in which the navigation is triggered.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the url is opened\n\n      * timeStamp\n\nnumber\n\nThe time when the browser was about to create a new view, in milliseconds\nsince the epoch.\n\n      * url\n\nstring\n\nThe URL to be opened in the new window.\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onDOMContentLoaded\n\n    \n    \n    chrome.webNavigation.onDOMContentLoaded.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when the page's DOM is fully constructed, but the referenced resources\nmay not finish loading.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\n0 indicates the navigation happens in the tab content window; a positive value\nindicates navigation in a subframe. Frame IDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nChrome 74+\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nThe ID of the process that runs the renderer for this frame.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the navigation occurs.\n\n      * timeStamp\n\nnumber\n\nThe time when the page's DOM was fully constructed, in milliseconds since the\nepoch.\n\n      * url\n\nstring\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onErrorOccurred\n\n    \n    \n    chrome.webNavigation.onErrorOccurred.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when an error occurs and the navigation is aborted. This can happen if\neither a network error occurred, or the user aborted the navigation.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * error\n\nstring\n\nThe error description.\n\n      * frameId\n\nnumber\n\n0 indicates the navigation happens in the tab content window; a positive value\nindicates navigation in a subframe. Frame IDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nChrome 74+\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nDeprecated since Chrome 50\n\nThe processId is no longer set for this event.\n\nThe value of -1.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the navigation occurs.\n\n      * timeStamp\n\nnumber\n\nThe time when the error occurred, in milliseconds since the epoch.\n\n      * url\n\nstring\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onHistoryStateUpdated\n\n    \n    \n    chrome.webNavigation.onHistoryStateUpdated.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when the frame's history was updated to a new URL. All future events for\nthat frame will use the updated URL.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\n0 indicates the navigation happens in the tab content window; a positive value\nindicates navigation in a subframe. Frame IDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nChrome 74+\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nThe ID of the process that runs the renderer for this frame.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the navigation occurs.\n\n      * timeStamp\n\nnumber\n\nThe time when the navigation was committed, in milliseconds since the epoch.\n\n      * transitionQualifiers\n\nTransitionQualifier[]\n\nA list of transition qualifiers.\n\n      * transitionType\n\nTransitionType\n\nCause of the navigation.\n\n      * url\n\nstring\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onReferenceFragmentUpdated\n\n    \n    \n    chrome.webNavigation.onReferenceFragmentUpdated.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when the reference fragment of a frame was updated. All future events\nfor that frame will use the updated URL.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nA UUID of the document loaded.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\n0 indicates the navigation happens in the tab content window; a positive value\nindicates navigation in a subframe. Frame IDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the navigation occurred in.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nA UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nChrome 74+\n\nThe ID of the parent frame, or `-1` if this is the main frame.\n\n      * processId\n\nnumber\n\nThe ID of the process that runs the renderer for this frame.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the navigation occurs.\n\n      * timeStamp\n\nnumber\n\nThe time when the navigation was committed, in milliseconds since the epoch.\n\n      * transitionQualifiers\n\nTransitionQualifier[]\n\nA list of transition qualifiers.\n\n      * transitionType\n\nTransitionType\n\nCause of the navigation.\n\n      * url\n\nstring\n\n  * filters\n\nobject optional\n\n    * url\n\nevents.UrlFilter[]\n\nConditions that the URL being navigated to must satisfy. The 'schemes' and\n'ports' fields of UrlFilter are ignored for this event.\n\n### onTabReplaced\n\n    \n    \n    chrome.webNavigation.onTabReplaced.addListener(  \n      callback: function,  \n    )\n\nFired when the contents of the tab is replaced by a different (usually\npreviously pre-rendered) tab.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * replacedTabId\n\nnumber\n\nThe ID of the tab that was replaced.\n\n      * tabId\n\nnumber\n\nThe ID of the tab that replaced the old tab.\n\n      * timeStamp\n\nnumber\n\nThe time when the replacement happened, in milliseconds since the epoch.\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/webRequest": "#  chrome.webRequest\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n**Note:** As of Manifest V3, the `\"webRequestBlocking\"` permission is no\nlonger available for most extensions. Consider `\"declarativeNetRequest\"`,\nwhich enables use the declarativeNetRequest API. Aside from\n`\"webRequestBlocking\"`, the webRequest API is unchanged and available for\nnormal use. Policy installed extensions can continue to use\n`\"webRequestBlocking\"`.\n\n## Description\n\nUse the `chrome.webRequest` API to observe and analyze traffic and to\nintercept, block, or modify requests in-flight.\n\n## Permissions\n\n`webRequest`  \n\nYou must declare the `\"webRequest\"` permission in the extension manifest to\nuse the web request API, along with the necessary host permissions. To\nintercept a sub-resource request, the extension must have access to both the\nrequested URL and its initiator. For example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\n        \"webRequest\"\n      ],\n      \"host_permissions\": [\n        \"*://*.google.com/*\"\n      ],\n      ...\n    }\n    \n\n`webRequestBlocking`\n\nRequired to register blocking event handlers. As of Manifest V3, this is only\navailable to policy installed extensions.\n\n`webRequestAuthProvider`\n\nRequired to use the `onAuthRequired` method. See Handling authentication.\n\n## Concepts and usage\n\n### Life cycle of requests\n\nThe web request API defines a set of events that follow the life cycle of a\nweb request. You can use these events to observe and analyze traffic. Certain\nsynchronous events will allow you to intercept, block, or modify a request.\n\nThe event life cycle for successful requests is illustrated here, followed by\nevent definitions:\n\n![Life cycle of a web request from the perspective of the webrequest\nAPI](/static/docs/extensions/reference/api/webRequest/images/webrequestapi.png)\n\n`onBeforeRequest` (optionally synchronous)\n\n    Fires when a request is about to occur. This event is sent before any TCP connection is made and can be used to cancel or redirect requests.\n`onBeforeSendHeaders` (optionally synchronous)\n\n    Fires when a request is about to occur and the initial headers have been prepared. The event is intended to allow extensions to add, modify, and delete request headers (*). The `onBeforeSendHeaders` event is passed to all subscribers, so different subscribers may attempt to modify the request; see the Implementation details section for how this is handled. This event can be used to cancel the request.\n`onSendHeaders`\n\n    Fires after all extensions have had a chance to modify the request headers, and presents the final (*) version. The event is triggered before the headers are sent to the network. This event is informational and handled asynchronously. It does not allow modifying or cancelling the request.\n`onHeadersReceived` (optionally synchronous)\n\n    Fires each time that an HTTP(S) response header is received. Due to redirects and authentication requests this can happen multiple times per request. This event is intended to allow extensions to add, modify, and delete response headers, such as incoming Content-Type headers. The caching directives are processed before this event is triggered, so modifying headers such as Cache-Control has no influence on the browser's cache. It also allows you to cancel or redirect the request.\n`onAuthRequired` (optionally synchronous)\n\n    Fires when a request requires authentication of the user. This event can be handled synchronously to provide authentication credentials. Note that extensions may provide invalid credentials. Take care not to enter an infinite loop by repeatedly providing invalid credentials. This can also be used to cancel the request.\n`onBeforeRedirect`\n\n    Fires when a redirect is about to be executed. A redirection can be triggered by an HTTP response code or by an extension. This event is informational and handled asynchronously. It does not allow you to modify or cancel the request.\n`onResponseStarted`\n\n    Fires when the first byte of the response body is received. For HTTP requests, this means that the status line and response headers are available. This event is informational and handled asynchronously. It does not allow modifying or canceling the request.\n`onCompleted`\n\n    Fires when a request has been processed successfully.\n`onErrorOccurred`\n\n    Fires when a request could not be processed successfully.\n\nThe web request API guarantees that for each request, either `onCompleted` or\n`onErrorOccurred` is fired as the final event with one exception: If a request\nis redirected to a `data://` URL, `onBeforeRedirect` is the last reported\nevent.\n\n* Note that the web request API presents an abstraction of the network stack to the extension. Internally, one URL request can be split into several HTTP requests (for example, to fetch individual byte ranges from a large file) or can be handled by the network stack without communicating with the network. For this reason, the API does not provide the final HTTP headers that are sent to the network. For example, all headers that are related to caching are invisible to the extension.\n\nThe following headers are currently **not provided** to the\n`onBeforeSendHeaders` event. This list is not guaranteed to be complete or\nstable.\n\n  * Authorization\n  * Cache-Control\n  * Connection\n  * Content-Length\n  * Host\n  * If-Modified-Since\n  * If-None-Match\n  * If-Range\n  * Partial-Data\n  * Pragma\n  * Proxy-Authorization\n  * Proxy-Connection\n  * Transfer-Encoding\n\nStarting from Chrome 79, request header modifications affect Cross-Origin\nResource Sharing (CORS) checks. If modified headers for cross-origin requests\ndo not meet the criteria, it will result in sending a CORS preflight to ask\nthe server if such headers can be accepted. If you really need to modify\nheaders in a way to violate the CORS protocol, you need to specify\n`'extraHeaders'` in `opt_extraInfoSpec`. On the other hand, response header\nmodifications do not work to deceive CORS checks. If you need to deceive the\nCORS protocol, you also need to specify `'extraHeaders'` for the response\nmodifications.\n\nStarting from Chrome 79, the webRequest API **does not** intercept CORS\npreflight requests and responses by default. A CORS preflight for a request\nURL is visible to an extension if there is a listener with `'extraHeaders'`\nspecified in `opt_extraInfoSpec` for the request URL. `onBeforeRequest` can\nalso take `'extraHeaders'` from Chrome 79.\n\nStarting from Chrome 79, the following request header is **not provided** and\ncannot be modified or removed without specifying `'extraHeaders'` in\n`opt_extraInfoSpec`:\n\n  * Origin\n\n**Note:** Modifying the `Origin` request header might not work as intended and\nmay result in unexpected errors in the response's CORS checks. This is because\nwhile extensions can only modify the Origin request header, they can't change\nthe `request origin` or initiator, which is a concept defined in the Fetch\nspec to represent who initiates the request. In such a scenario, the server\nmay allow the CORS access for the modified request and put the header's\n`Origin` into the `Access-Control-Allow-Origin` header in the response. But it\nwon't match the immutable `request origin` and will result in a CORS failure.\n\nStarting from Chrome 72, if you need to modify responses before Cross Origin\nRead Blocking (CORB) can block the response, you need to specify\n`'extraHeaders'` in `opt_extraInfoSpec`.\n\nStarting from Chrome 72, the following request headers are **not provided**\nand cannot be modified or removed without specifying `'extraHeaders'` in\n`opt_extraInfoSpec`:\n\n  * Accept-Language\n  * Accept-Encoding\n  * Referer\n  * Cookie\n\nStarting from Chrome 72, the `Set-Cookie` response header is **not provided**\nand cannot be modified or removed without specifying `'extraHeaders'` in\n`opt_extraInfoSpec`.\n\nStarting from Chrome 89, the `X-Frame-Options` response header cannot be\neffectively modified or removed without specifying `'extraHeaders'` in\n`opt_extraInfoSpec`.\n\n**Note:** Specifying `'extraHeaders'` in `opt_extraInfoSpec` may have a\nnegative impact on performance, hence it should only be used when really\nnecessary.\n\nThe webRequest API only exposes requests that the extension has permission to\nsee, given its host permissions. Moreover, only the following schemes are\naccessible: `http://`, `https://`, `ftp://`, `file://`, `ws://` (since Chrome\n58), `wss://` (since Chrome 58), `urn:` (since Chrome 91), or `chrome-\nextension://`. In addition, even certain requests with URLs using one of the\nabove schemes are hidden. These include `chrome-\nextension://other_extension_id` where `other_extension_id` is not the ID of\nthe extension to handle the request, `https://www.google.com/chrome`, and\nother sensitive requests core to browser functionality. Also synchronous\nXMLHttpRequests from your extension are hidden from blocking event handlers in\norder to prevent deadlocks. Note that for some of the supported schemes the\nset of available events might be limited due to the nature of the\ncorresponding protocol. For example, for the file: scheme, only\n`onBeforeRequest`, `onResponseStarted`, `onCompleted`, and `onErrorOccurred`\nmay be dispatched.\n\nStarting from Chrome 58, the webRequest API supports intercepting the\nWebSocket handshake request. Since the handshake is done by means of an HTTP\nupgrade request, its flow fits into HTTP-oriented webRequest model. Note that\nthe API does **not intercept** :\n\n  * Individual messages sent over an established WebSocket connection.\n  * WebSocket closing connection.\n\nRedirects are **not supported** for WebSocket requests.\n\nStarting from Chrome 72, an extension will be able to intercept a request only\nif it has host permissions to both the requested URL and the request\ninitiator.\n\nStarting from Chrome 96, the webRequest API supports intercepting the\nWebTransport over HTTP/3 handshake request. Since the handshake is done by\nmeans of an HTTP CONNECT request, its flow fits into HTTP-oriented webRequest\nmodel. Note that:\n\n  * Once the session is established, extensions cannot observe or intervene in the session via the webRequest API.\n  * Modifying HTTP request headers in `onBeforeSendHeaders` is ignored.\n  * Redirects and authentications are **not supported** in WebTransport over HTTP/3.\n\n### Request IDs\n\nEach request is identified by a request ID. This ID is unique within a browser\nsession and the context of an extension. It remains constant during the life\ncycle of a request and can be used to match events for the same request. Note\nthat several HTTP requests are mapped to one web request in case of HTTP\nredirection or HTTP authentication.\n\n### Registering event listeners\n\nTo register an event listener for a web request, you use a variation on the\nusual `addListener()` function. In addition to specifying a callback function,\nyou have to specify a filter argument, and you may specify an optional extra\ninfo argument.\n\nThe three arguments to the web request API's `addListener()` have the\nfollowing definitions:\n\n    \n    \n    var callback = function(details) {...};\n    var filter = {...};\n    var opt_extraInfoSpec = [...];\n    \n\nHere's an example of listening for the `onBeforeRequest` event:\n\n    \n    \n    chrome.webRequest.onBeforeRequest.addListener(\n        callback, filter, opt_extraInfoSpec);\n    \n\nEach `addListener()` call takes a mandatory callback function as the first\nparameter. This callback function is passed a dictionary containing\ninformation about the current URL request. The information in this dictionary\ndepends on the specific event type as well as the content of\n`opt_extraInfoSpec`.\n\nIf the optional `opt_extraInfoSpec` array contains the string `'blocking'`\n(only allowed for specific events), the callback function is handled\nsynchronously. That means that the request is blocked until the callback\nfunction returns. In this case, the callback can return a\n`webRequest.BlockingResponse` that determines the further life cycle of the\nrequest. Depending on the context, this response allows canceling or\nredirecting a request (`onBeforeRequest`), canceling a request or modifying\nheaders (`onBeforeSendHeaders`, `onHeadersReceived`), and canceling a request\nor providing authentication credentials (`onAuthRequired`).\n\nIf the optional `opt_extraInfoSpec` array contains the string\n`'asyncBlocking'` instead (only allowed for `onAuthRequired`), the extension\ncan generate the `webRequest.BlockingResponse` asynchronously.\n\nThe `webRequest.RequestFilter` `filter` allows limiting the requests for which\nevents are triggered in various dimensions:\n\nURLs\n\n    URL patterns such as `*://www.google.com/foo*bar`.\nTypes\n\n    Request types such as `main_frame` (a document that is loaded for a top-level frame), `sub_frame` (a document that is loaded for an embedded frame), and `image` (an image on a web site). See `webRequest.RequestFilter`.\nTab ID\n\n    The identifier for one tab.\nWindow ID\n\n    The identifier for a window.\n\nDepending on the event type, you can specify strings in `opt_extraInfoSpec` to\nask for additional information about the request. This is used to provide\ndetailed information on request's data only if explicitly requested.\n\n### Handling authentication\n\nTo handle requests for HTTP authentication, add the `\"webRequestAuthProvider\"`\npermission to your manifest file:\n\n    \n    \n    {\n      \"permissions\": [\n        \"webRequest\",\n        \"webRequestAuthProvider\"\n      ]\n    }\n    \n\nNote that this permission is not required for a policy installed extension\nwith the `\"webRequestBlocking\"` permission.\n\nTo provide credentials synchronously:\n\n    \n    \n    chrome.webRequest.onAuthRequired.addListener((details) => {\n        return {\n          authCredentials: {\n            username: 'guest',\n            password: 'guest'\n          }\n        };\n      },\n      { urls: ['https://httpbin.org/basic-auth/guest/guest'] },\n      ['blocking']\n    );\n    \n\nTo provide credentials asynchronously:\n\n    \n    \n    chrome.webRequest.onAuthRequired.addListener((details, callback) => {\n        callback({\n          authCredentials: {\n            username: 'guest',\n            password: 'guest'\n          }\n        });\n      },\n      { urls: ['https://httpbin.org/basic-auth/guest/guest'] },\n      ['asyncBlocking']\n    );\n    \n\n### Implementation details\n\nSeveral implementation details can be important to understand when developing\nan extension that uses the web request API:\n\n#### web_accessible_resources\n\nWhen an extension uses webRequest APIs to redirect a public resource request\nto a resource that is not web accessible, it is blocked and will result in an\nerror. The above holds true even if the resource that is not web accessible is\nowned by the redirecting extension. To declare resources for use with\ndeclarativeWebRequest APIs, the `\"web_accessible_resources\"` array must be\ndeclared and populated in the manifest as documented here.\n\n#### Conflict resolution\n\nIn the current implementation of the web request API, a request is considered\ncanceled if at least one extension instructs to cancel the request. If an\nextension cancels a request, all extensions are notified by an\n`onErrorOccurred` event. Only one extension can redirect a request or modify a\nheader at a time. If more than one extension attempts to modify the request,\nthe most recently installed extension wins, and all others are ignored. An\nextension is not notified if its instruction to modify or redirect has been\nignored.\n\n#### Caching\n\nChrome employs two cachesan on-disk cache and a very fast in-memory cache.\nThe lifetime of an in-memory cache is attached to the lifetime of a render\nprocess, which roughly corresponds to a tab. Requests that are answered from\nthe in-memory cache are invisible to the web request API. If a request handler\nchanges its behavior (for example, the behavior according to which requests\nare blocked), a simple page refresh might not respect this changed behavior.\nTo ensure the behavior change goes through, call `handlerBehaviorChanged()` to\nflush the in-memory cache. But don't do it often; flushing the cache is a very\nexpensive operation. You don't need to call `handlerBehaviorChanged()` after\nregistering or unregistering an event listener.\n\n#### Timestamps\n\nThe `timestamp` property of web request events is only guaranteed to be\n_internally_ consistent. Comparing one event to another event will give you\nthe correct offset between them, but comparing them to the current time inside\nthe extension (via `(new Date()).getTime()`, for instance) might give\nunexpected results.\n\n#### Error handling\n\nIf you try to register an event with invalid arguments, then a JavaScript\nerror will be thrown, and the event handler will not be registered. If an\nerror is thrown while an event is handled or if an event handler returns an\ninvalid blocking response, an error message is logged to your extension's\nconsole, and the handler is ignored for that request.\n\n## Examples\n\nThe following example illustrates how to block all requests to `www.evil.com`:\n\n    \n    \n    chrome.webRequest.onBeforeRequest.addListener(\n      function(details) {\n        return {cancel: details.url.indexOf(\"://www.evil.com/\") != -1};\n      },\n      {urls: [\"<all_urls>\"]},\n      [\"blocking\"]\n    );\n    \n\nAs this function uses a blocking event handler, it requires the `\"webRequest\"`\nas well as the `\"webRequestBlocking\"` permission in the manifest file.\n\nThe following example achieves the same goal in a more efficient way because\nrequests that are not targeted to `www.evil.com` do not need to be passed to\nthe extension:\n\n    \n    \n    chrome.webRequest.onBeforeRequest.addListener(\n      function(details) { return {cancel: true}; },\n      {urls: [\"*://www.evil.com/*\"]},\n      [\"blocking\"]\n    );\n    \n\nThe following example illustrates how to delete the User-Agent header from all\nrequests:\n\n    \n    \n    chrome.webRequest.onBeforeSendHeaders.addListener(\n      function(details) {\n        for (var i = 0; i < details.requestHeaders.length; ++i) {\n          if (details.requestHeaders[i].name === 'User-Agent') {\n            details.requestHeaders.splice(i, 1);\n            break;\n          }\n        }\n        return {requestHeaders: details.requestHeaders};\n      },\n      {urls: [\"<all_urls>\"]},\n      [\"blocking\", \"requestHeaders\"]\n    );\n    \n\nTo try the `chrome.webRequest` API, install the webRequest sample from the\nchrome-extension-samples repository.\n\n## Types\n\n### BlockingResponse\n\nReturns value for event handlers that have the 'blocking' extraInfoSpec\napplied. Allows the event handler to modify network requests.\n\n#### Properties\n\n  * authCredentials\n\nobject optional\n\nOnly used as a response to the onAuthRequired event. If set, the request is\nmade using the supplied credentials.\n\n    * password\n\nstring\n\n    * username\n\nstring\n\n  * cancel\n\nboolean optional\n\nIf true, the request is cancelled. This prevents the request from being sent.\nThis can be used as a response to the onBeforeRequest, onBeforeSendHeaders,\nonHeadersReceived and onAuthRequired events.\n\n  * redirectUrl\n\nstring optional\n\nOnly used as a response to the onBeforeRequest and onHeadersReceived events.\nIf set, the original request is prevented from being sent/completed and is\ninstead redirected to the given URL. Redirections to non-HTTP schemes such as\n`data:` are allowed. Redirects initiated by a redirect action use the original\nrequest method for the redirect, with one exception: If the redirect is\ninitiated at the onHeadersReceived stage, then the redirect will be issued\nusing the GET method. Redirects from URLs with `ws://` and `wss://` schemes\nare **ignored**.\n\n  * requestHeaders\n\nHttpHeaders optional\n\nOnly used as a response to the onBeforeSendHeaders event. If set, the request\nis made with these request headers instead.\n\n  * responseHeaders\n\nHttpHeaders optional\n\nOnly used as a response to the onHeadersReceived event. If set, the server is\nassumed to have responded with these response headers instead. Only return\n`responseHeaders` if you really want to modify the headers in order to limit\nthe number of conflicts (only one extension may modify `responseHeaders` for\neach request).\n\n### FormDataItem\n\nChrome 66+\n\nContains data passed within form data. For urlencoded form it is stored as\nstring if data is utf-8 string and as ArrayBuffer otherwise. For form-data it\nis ArrayBuffer. If form-data represents uploading file, it is string with\nfilename, if the filename is provided.\n\n#### Enum\n\nArrayBuffer\n\nstring\n\n### HttpHeaders\n\nAn array of HTTP headers. Each header is represented as a dictionary\ncontaining the keys `name` and either `value` or `binaryValue`.\n\n#### Type\n\nobject[]\n\n#### Properties\n\n  * binaryValue\n\nnumber[] optional\n\nValue of the HTTP header if it cannot be represented by UTF-8, stored as\nindividual byte values (0..255).\n\n  * name\n\nstring\n\nName of the HTTP header.\n\n  * value\n\nstring optional\n\nValue of the HTTP header if it can be represented by UTF-8.\n\n### IgnoredActionType\n\nChrome 70+\n\n#### Enum\n\n\"redirect\"  \n\n\"request_headers\"  \n\n\"response_headers\"  \n\n\"auth_credentials\"  \n\n### OnAuthRequiredOptions\n\nChrome 44+\n\n#### Enum\n\n\"responseHeaders\"  \nSpecifies that the response headers should be included in the event.\n\n\"blocking\"  \nSpecifies the request is blocked until the callback function returns.\n\n\"asyncBlocking\"  \nSpecifies that the callback function is handled asynchronously.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### OnBeforeRedirectOptions\n\nChrome 44+\n\n#### Enum\n\n\"responseHeaders\"  \nSpecifies that the response headers should be included in the event.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### OnBeforeRequestOptions\n\nChrome 44+\n\n#### Enum\n\n\"blocking\"  \nSpecifies the request is blocked until the callback function returns.\n\n\"requestBody\"  \nSpecifies that the request body should be included in the event.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### OnBeforeSendHeadersOptions\n\nChrome 44+\n\n#### Enum\n\n\"requestHeaders\"  \nSpecifies that the request header should be included in the event.\n\n\"blocking\"  \nSpecifies the request is blocked until the callback function returns.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### OnCompletedOptions\n\nChrome 44+\n\n#### Enum\n\n\"responseHeaders\"  \nSpecifies that the response headers should be included in the event.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### OnErrorOccurredOptions\n\nChrome 79+\n\n#### Value\n\n\"extraHeaders\"  \n\n### OnHeadersReceivedOptions\n\nChrome 44+\n\n#### Enum\n\n\"blocking\"  \nSpecifies the request is blocked until the callback function returns.\n\n\"responseHeaders\"  \nSpecifies that the response headers should be included in the event.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### OnResponseStartedOptions\n\nChrome 44+\n\n#### Enum\n\n\"responseHeaders\"  \nSpecifies that the response headers should be included in the event.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### OnSendHeadersOptions\n\nChrome 44+\n\n#### Enum\n\n\"requestHeaders\"  \nSpecifies that the request header should be included in the event.\n\n\"extraHeaders\"  \nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\n\n### RequestFilter\n\nAn object describing filters to apply to webRequest events.\n\n#### Properties\n\n  * tabId\n\nnumber optional\n\n  * types\n\nResourceType[] optional\n\nA list of request types. Requests that cannot match any of the types will be\nfiltered out.\n\n  * urls\n\nstring[]\n\nA list of URLs or URL patterns. Requests that cannot match any of the URLs\nwill be filtered out.\n\n  * windowId\n\nnumber optional\n\n### ResourceType\n\nChrome 44+\n\n#### Enum\n\n\"main_frame\"  \nSpecifies the resource as the main frame.\n\n\"sub_frame\"  \nSpecifies the resource as a sub frame.\n\n\"stylesheet\"  \nSpecifies the resource as a stylesheet.\n\n\"script\"  \nSpecifies the resource as a script.\n\n\"image\"  \nSpecifies the resource as an image.\n\n\"font\"  \nSpecifies the resource as a font.\n\n\"object\"  \nSpecifies the resource as an object.\n\n\"xmlhttprequest\"  \nSpecifies the resource as an XMLHttpRequest.\n\n\"ping\"  \nSpecifies the resource as a ping.\n\n\"csp_report\"  \nSpecifies the resource as a Content Security Policy (CSP) report.\n\n\"media\"  \nSpecifies the resource as a media object.\n\n\"websocket\"  \nSpecifies the resource as a WebSocket.\n\n\"webbundle\"  \nSpecifies the resource as a WebBundle.\n\n\"other\"  \nSpecifies the resource as a type not included in the listed types.\n\n### UploadData\n\nContains data uploaded in a URL request.\n\n#### Properties\n\n  * bytes\n\nany optional\n\nAn ArrayBuffer with a copy of the data.\n\n  * file\n\nstring optional\n\nA string with the file's path and name.\n\n## Properties\n\n### MAX_HANDLER_BEHAVIOR_CHANGED_CALLS_PER_10_MINUTES\n\nThe maximum number of times that `handlerBehaviorChanged` can be called per 10\nminute sustained interval. `handlerBehaviorChanged` is an expensive function\ncall that shouldn't be called often.\n\n#### Value\n\n20  \n\n## Methods\n\n### handlerBehaviorChanged()\n\nPromise\n\n    \n    \n    chrome.webRequest.handlerBehaviorChanged(  \n      callback?: function,  \n    )\n\nNeeds to be called when the behavior of the webRequest handlers has changed to\nprevent incorrect handling due to caching. This function call is expensive.\nDon't call it often.\n\n#### Parameters\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 116+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onActionIgnored\n\nChrome 70+\n\n    \n    \n    chrome.webRequest.onActionIgnored.addListener(  \n      callback: function,  \n    )\n\nFired when an extension's proposed modification to a network request is\nignored. This happens in case of conflicts with other extensions.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * action\n\nIgnoredActionType\n\nThe proposed action which was ignored.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n### onAuthRequired\n\n    \n    \n    chrome.webRequest.onAuthRequired.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnAuthRequiredOptions[],  \n    )\n\nFired when an authentication failure is received. The listener has three\noptions: it can provide authentication credentials, it can cancel the request\nand display the error page, or it can take no action on the challenge. If bad\nuser credentials are provided, this may be called multiple times for the same\nrequest. Note, only one of `'blocking'` or `'asyncBlocking'` modes must be\nspecified in the `extraInfoSpec` parameter.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object, asyncCallback?: function) => BlockingResponse | undefined\n\n    * details\n\nobject\n\n      * challenger\n\nobject\n\nThe server requesting authentication.\n\n        * host\n\nstring\n\n        * port\n\nnumber\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * isProxy\n\nboolean\n\nTrue for Proxy-Authenticate, false for WWW-Authenticate.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * realm\n\nstring optional\n\nThe authentication realm provided by the server, if there is one.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * responseHeaders\n\nHttpHeaders optional\n\nThe HTTP response headers that were received along with this response.\n\n      * scheme\n\nstring\n\nThe authentication scheme, e.g. Basic or Digest.\n\n      * statusCode\n\nnumber\n\nChrome 43+\n\nStandard HTTP status code returned by the server.\n\n      * statusLine\n\nstring\n\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9\nresponses (i.e., responses that lack a status line) or an empty string if\nthere are no headers.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n    * asyncCallback\n\nfunction optional\n\nChrome 58+\n\nThe `asyncCallback` parameter looks like:\n\n          \n          (response: BlockingResponse) => void\n\n      * response\n\nBlockingResponse\n\n    * returns\n\nBlockingResponse | undefined\n\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event\nlistener should return an object of this type.\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnAuthRequiredOptions[] optional\n\n### onBeforeRedirect\n\n    \n    \n    chrome.webRequest.onBeforeRedirect.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnBeforeRedirectOptions[],  \n    )\n\nFired when a server-initiated redirect is about to occur.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * fromCache\n\nboolean\n\nIndicates if this response was fetched from disk cache.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * ip\n\nstring optional\n\nThe server IP address that the request was actually sent to. Note that it may\nbe a literal IPv6 address.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * redirectUrl\n\nstring\n\nThe new URL.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * responseHeaders\n\nHttpHeaders optional\n\nThe HTTP response headers that were received along with this redirect.\n\n      * statusCode\n\nnumber\n\nStandard HTTP status code returned by the server.\n\n      * statusLine\n\nstring\n\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9\nresponses (i.e., responses that lack a status line) or an empty string if\nthere are no headers.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnBeforeRedirectOptions[] optional\n\n### onBeforeRequest\n\n    \n    \n    chrome.webRequest.onBeforeRequest.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnBeforeRequestOptions[],  \n    )\n\nFired when a request is about to occur.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => BlockingResponse | undefined\n\n    * details\n\nobject\n\n      * documentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle optional\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType optional\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * requestBody\n\nobject optional\n\nContains the HTTP request body data. Only provided if extraInfoSpec contains\n'requestBody'.\n\n        * error\n\nstring optional\n\nErrors when obtaining request body data.\n\n        * formData\n\nobject optional\n\nIf the request method is POST and the body is a sequence of key-value pairs\nencoded in UTF8, encoded as either multipart/form-data, or application/x-www-\nform-urlencoded, this dictionary is present and for each key contains the list\nof all values for that key. If the data is of another media type, or if it is\nmalformed, the dictionary is not present. An example value of this dictionary\nis {'key': ['value1', 'value2']}.\n\n        * raw\n\nUploadData[] optional\n\nIf the request method is PUT or POST, and the body is not already parsed in\nformData, then the unparsed request body elements are contained in this array.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n    * returns\n\nBlockingResponse | undefined\n\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event\nlistener should return an object of this type.\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnBeforeRequestOptions[] optional\n\n### onBeforeSendHeaders\n\n    \n    \n    chrome.webRequest.onBeforeSendHeaders.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnBeforeSendHeadersOptions[],  \n    )\n\nFired before sending an HTTP request, once the request headers are available.\nThis may occur after a TCP connection is made to the server, but before any\nHTTP data is sent.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => BlockingResponse | undefined\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * requestHeaders\n\nHttpHeaders optional\n\nThe HTTP request headers that are going to be sent out with this request.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n    * returns\n\nBlockingResponse | undefined\n\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event\nlistener should return an object of this type.\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnBeforeSendHeadersOptions[] optional\n\n### onCompleted\n\n    \n    \n    chrome.webRequest.onCompleted.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnCompletedOptions[],  \n    )\n\nFired when a request is completed.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * fromCache\n\nboolean\n\nIndicates if this response was fetched from disk cache.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * ip\n\nstring optional\n\nThe server IP address that the request was actually sent to. Note that it may\nbe a literal IPv6 address.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * responseHeaders\n\nHttpHeaders optional\n\nThe HTTP response headers that were received along with this response.\n\n      * statusCode\n\nnumber\n\nStandard HTTP status code returned by the server.\n\n      * statusLine\n\nstring\n\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9\nresponses (i.e., responses that lack a status line) or an empty string if\nthere are no headers.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnCompletedOptions[] optional\n\n### onErrorOccurred\n\n    \n    \n    chrome.webRequest.onErrorOccurred.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnErrorOccurredOptions[],  \n    )\n\nFired when an error occurs.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request. This value is not present if the\nrequest is a navigation of a frame.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * error\n\nstring\n\nThe error description. This string is _not_ guaranteed to remain backwards\ncompatible between releases. You must not parse and act based upon its\ncontent.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * fromCache\n\nboolean\n\nIndicates if this response was fetched from disk cache.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * ip\n\nstring optional\n\nThe server IP address that the request was actually sent to. Note that it may\nbe a literal IPv6 address.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnErrorOccurredOptions[] optional\n\n### onHeadersReceived\n\n    \n    \n    chrome.webRequest.onHeadersReceived.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnHeadersReceivedOptions[],  \n    )\n\nFired when HTTP response headers of a request have been received.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => BlockingResponse | undefined\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * responseHeaders\n\nHttpHeaders optional\n\nThe HTTP response headers that have been received with this response.\n\n      * statusCode\n\nnumber\n\nChrome 43+\n\nStandard HTTP status code returned by the server.\n\n      * statusLine\n\nstring\n\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9\nresponses (i.e., responses that lack a status line).\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n    * returns\n\nBlockingResponse | undefined\n\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event\nlistener should return an object of this type.\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnHeadersReceivedOptions[] optional\n\n### onResponseStarted\n\n    \n    \n    chrome.webRequest.onResponseStarted.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnResponseStartedOptions[],  \n    )\n\nFired when the first byte of the response body is received. For HTTP requests,\nthis means that the status line and response headers are available.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * fromCache\n\nboolean\n\nIndicates if this response was fetched from disk cache.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * ip\n\nstring optional\n\nThe server IP address that the request was actually sent to. Note that it may\nbe a literal IPv6 address.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * responseHeaders\n\nHttpHeaders optional\n\nThe HTTP response headers that were received along with this response.\n\n      * statusCode\n\nnumber\n\nStandard HTTP status code returned by the server.\n\n      * statusLine\n\nstring\n\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9\nresponses (i.e., responses that lack a status line) or an empty string if\nthere are no headers.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnResponseStartedOptions[] optional\n\n### onSendHeaders\n\n    \n    \n    chrome.webRequest.onSendHeaders.addListener(  \n      callback: function,  \n      filter: RequestFilter,  \n      extraInfoSpec?: OnSendHeadersOptions[],  \n    )\n\nFired just before a request is going to be sent to the server (modifications\nof previous onBeforeSendHeaders callbacks are visible by the time\nonSendHeaders is fired).\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (details: object) => void\n\n    * details\n\nobject\n\n      * documentId\n\nstring\n\nChrome 106+\n\nThe UUID of the document making the request.\n\n      * documentLifecycle\n\nextensionTypes.DocumentLifecycle\n\nChrome 106+\n\nThe lifecycle the document is in.\n\n      * frameId\n\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive\nvalue indicates the ID of a subframe in which the request happens. If the\ndocument of a (sub-)frame is loaded (`type` is `main_frame` or `sub_frame`),\n`frameId` indicates the ID of this frame, not the ID of the outer frame. Frame\nIDs are unique within a tab.\n\n      * frameType\n\nextensionTypes.FrameType\n\nChrome 106+\n\nThe type of frame the request occurred in.\n\n      * initiator\n\nstring optional\n\nChrome 63+\n\nThe origin where the request was initiated. This does not change through\nredirects. If this is an opaque origin, the string 'null' will be used.\n\n      * method\n\nstring\n\nStandard HTTP method.\n\n      * parentDocumentId\n\nstring optional\n\nChrome 106+\n\nThe UUID of the parent document owning this frame. This is not set if there is\nno parent.\n\n      * parentFrameId\n\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no\nparent frame exists.\n\n      * requestHeaders\n\nHttpHeaders optional\n\nThe HTTP request headers that have been sent out with this request.\n\n      * requestId\n\nstring\n\nThe ID of the request. Request IDs are unique within a browser session. As a\nresult, they could be used to relate different events of the same request.\n\n      * tabId\n\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request\nisn't related to a tab.\n\n      * timeStamp\n\nnumber\n\nThe time when this signal is triggered, in milliseconds since the epoch.\n\n      * type\n\nResourceType\n\nHow the requested resource will be used.\n\n      * url\n\nstring\n\n  * filter\n\nRequestFilter\n\n  * extraInfoSpec\n\nOnSendHeadersOptions[] optional\n\n"
  },
  {
    "https://developer.chrome.com/docs/extensions/reference/api/windows": "#  chrome.windows\n\nStay organized with collections  Save and categorize content based on your\npreferences.\n\n## Description\n\nUse the `chrome.windows` API to interact with browser windows. You can use\nthis API to create, modify, and rearrange windows in the browser.\n\n## Permissions\n\nWhen requested, a `windows.Window` contains an array of `tabs.Tab` objects.\nYou must declare the `\"tabs\"` permission in your manifest if you need access\nto the `url`, `pendingUrl`, `title`, or `favIconUrl` properties of `tabs.Tab`.\nFor example:\n\n    \n    \n    {\n      \"name\": \"My extension\",\n      ...\n      \"permissions\": [\"tabs\"],\n      ...\n    }\n    \n\n## Concepts and usage\n\n### The current window\n\nMany functions in the extension system take an optional `windowId` argument,\nwhich defaults to the current window.\n\nThe _current window_ is the window that contains the code that is currently\nexecuting. It's important to realize that this can be different from the\ntopmost or focused window.\n\nFor example, say an extension creates a few tabs or windows from a single HTML\nfile, and that the HTML file contains a call to `tabs.query()`. The current\nwindow is the window that contains the page that made the call, no matter what\nthe topmost window is.\n\nIn the case of service workers, the value of the current window falls back to\nthe last active window. Under some circumstances, there may be no current\nwindow for background pages.\n\n## Examples\n\nTo try this API, install the windows API example from the chrome-extension-\nsamples repository.\n\n![Two windows, each with one\ntab](/static/docs/extensions/reference/api/windows/images/windows.png) Two\nwindows, each with one tab.\n\n## Types\n\n### CreateType\n\nChrome 44+\n\nSpecifies what type of browser window to create. 'panel' is deprecated and is\navailable only to existing allowlisted extensions on Chrome OS.\n\n#### Enum\n\n\"normal\"  \nSpecifies the window as a standard window.\n\n\"popup\"  \nSpecifies the window as a popup window.\n\n\"panel\"  \nSpecifies the window as a panel.\n\n### QueryOptions\n\nChrome 88+\n\n#### Properties\n\n  * populate\n\nboolean optional\n\nIf true, the `windows.Window` object has a `tabs` property that contains a\nlist of the `tabs.Tab` objects. The `Tab` objects only contain the `url`,\n`pendingUrl`, `title`, and `favIconUrl` properties if the extension's manifest\nfile includes the `\"tabs\"` permission.\n\n  * windowTypes\n\nWindowType[] optional\n\nIf set, the `windows.Window` returned is filtered based on its type. If unset,\nthe default filter is set to `['normal', 'popup']`.\n\n### Window\n\n#### Properties\n\n  * alwaysOnTop\n\nboolean\n\nWhether the window is set to be always on top.\n\n  * focused\n\nboolean\n\nWhether the window is currently the focused window.\n\n  * height\n\nnumber optional\n\nThe height of the window, including the frame, in pixels. In some\ncircumstances a window may not be assigned a `height` property; for example,\nwhen querying closed windows from the `sessions` API.\n\n  * id\n\nnumber optional\n\nThe ID of the window. Window IDs are unique within a browser session. In some\ncircumstances a window may not be assigned an `ID` property; for example, when\nquerying windows using the `sessions` API, in which case a session ID may be\npresent.\n\n  * incognito\n\nboolean\n\nWhether the window is incognito.\n\n  * left\n\nnumber optional\n\nThe offset of the window from the left edge of the screen in pixels. In some\ncircumstances a window may not be assigned a `left` property; for example,\nwhen querying closed windows from the `sessions` API.\n\n  * sessionId\n\nstring optional\n\nThe session ID used to uniquely identify a window, obtained from the\n`sessions` API.\n\n  * state\n\nWindowState optional\n\nThe state of this browser window.\n\n  * tabs\n\nTab[] optional\n\nArray of `tabs.Tab` objects representing the current tabs in the window.\n\n  * top\n\nnumber optional\n\nThe offset of the window from the top edge of the screen in pixels. In some\ncircumstances a window may not be assigned a `top` property; for example, when\nquerying closed windows from the `sessions` API.\n\n  * type\n\nWindowType optional\n\nThe type of browser window this is.\n\n  * width\n\nnumber optional\n\nThe width of the window, including the frame, in pixels. In some circumstances\na window may not be assigned a `width` property; for example, when querying\nclosed windows from the `sessions` API.\n\n### WindowState\n\nChrome 44+\n\nThe state of this browser window. In some circumstances a window may not be\nassigned a `state` property; for example, when querying closed windows from\nthe `sessions` API.\n\n#### Enum\n\n\"normal\"  \nNormal window state (not minimized, maximized, or fullscreen).\n\n\"minimized\"  \nMinimized window state.\n\n\"maximized\"  \nMaximized window state.\n\n\"fullscreen\"  \nFullscreen window state.\n\n\"locked-fullscreen\"  \nLocked fullscreen window state. This fullscreen state cannot be exited by user\naction and is available only to allowlisted extensions on Chrome OS.\n\n### WindowType\n\nChrome 44+\n\nThe type of browser window this is. In some circumstances a window may not be\nassigned a `type` property; for example, when querying closed windows from the\n`sessions` API.\n\n#### Enum\n\n\"normal\"  \nA normal browser window.\n\n\"popup\"  \nA browser popup.\n\n\"panel\"  \n_Deprecated in this API._ A Chrome App panel-style window. Extensions can only\nsee their own panel windows.\n\n\"app\"  \n_Deprecated in this API._ A Chrome App window. Extensions can only see their\napp own windows.\n\n\"devtools\"  \nA Developer Tools window.\n\n## Properties\n\n### WINDOW_ID_CURRENT\n\nThe windowId value that represents the current window.\n\n#### Value\n\n-2   \n\n### WINDOW_ID_NONE\n\nThe windowId value that represents the absence of a Chrome browser window.\n\n#### Value\n\n-1   \n\n## Methods\n\n### create()\n\nPromise\n\n    \n    \n    chrome.windows.create(  \n      createData?: object,  \n      callback?: function,  \n    )\n\nCreates (opens) a new browser window with any optional sizing, position, or\ndefault URL provided.\n\n#### Parameters\n\n  * createData\n\nobject optional\n\n    * focused\n\nboolean optional\n\nIf `true`, opens an active window. If `false`, opens an inactive window.\n\n    * height\n\nnumber optional\n\nThe height in pixels of the new window, including the frame. If not specified,\ndefaults to a natural height.\n\n    * incognito\n\nboolean optional\n\nWhether the new window should be an incognito window.\n\n    * left\n\nnumber optional\n\nThe number of pixels to position the new window from the left edge of the\nscreen. If not specified, the new window is offset naturally from the last\nfocused window. This value is ignored for panels.\n\n    * setSelfAsOpener\n\nboolean optional\n\nChrome 64+\n\nIf `true`, the newly-created window's 'window.opener' is set to the caller and\nis in the same unit of related browsing contexts as the caller.\n\n    * state\n\nWindowState optional\n\nChrome 44+\n\nThe initial state of the window. The `minimized`, `maximized`, and\n`fullscreen` states cannot be combined with `left`, `top`, `width`, or\n`height`.\n\n    * tabId\n\nnumber optional\n\nThe ID of the tab to add to the new window.\n\n    * top\n\nnumber optional\n\nThe number of pixels to position the new window from the top edge of the\nscreen. If not specified, the new window is offset naturally from the last\nfocused window. This value is ignored for panels.\n\n    * type\n\nCreateType optional\n\nSpecifies what type of browser window to create.\n\n    * url\n\nstring | string[] optional\n\nA URL or array of URLs to open as tabs in the window. Fully-qualified URLs\nmust include a scheme, e.g., 'http://www.google.com', not 'www.google.com'.\nNon-fully-qualified URLs are considered relative within the extension.\nDefaults to the New Tab Page.\n\n    * width\n\nnumber optional\n\nThe width in pixels of the new window, including the frame. If not specified,\ndefaults to a natural width.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (window?: Window) => void\n\n    * window\n\nWindow optional\n\nContains details about the created window.\n\n#### Returns\n\n  * Promise<Window | undefined>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### get()\n\nPromise\n\n    \n    \n    chrome.windows.get(  \n      windowId: number,  \n      queryOptions?: QueryOptions,  \n      callback?: function,  \n    )\n\nGets details about a window.\n\n#### Parameters\n\n  * windowId\n\nnumber\n\n  * queryOptions\n\nQueryOptions optional\n\nChrome 88+\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (window: Window) => void\n\n    * window\n\nWindow\n\n#### Returns\n\n  * Promise<Window>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getAll()\n\nPromise\n\n    \n    \n    chrome.windows.getAll(  \n      queryOptions?: QueryOptions,  \n      callback?: function,  \n    )\n\nGets all windows.\n\n#### Parameters\n\n  * queryOptions\n\nQueryOptions optional\n\nChrome 88+\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (windows: Window[]) => void\n\n    * windows\n\nWindow[]\n\n#### Returns\n\n  * Promise<Window[]>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getCurrent()\n\nPromise\n\n    \n    \n    chrome.windows.getCurrent(  \n      queryOptions?: QueryOptions,  \n      callback?: function,  \n    )\n\nGets the current window.\n\n#### Parameters\n\n  * queryOptions\n\nQueryOptions optional\n\nChrome 88+\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (window: Window) => void\n\n    * window\n\nWindow\n\n#### Returns\n\n  * Promise<Window>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### getLastFocused()\n\nPromise\n\n    \n    \n    chrome.windows.getLastFocused(  \n      queryOptions?: QueryOptions,  \n      callback?: function,  \n    )\n\nGets the window that was most recently focused  typically the window 'on\ntop'.\n\n#### Parameters\n\n  * queryOptions\n\nQueryOptions optional\n\nChrome 88+\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (window: Window) => void\n\n    * window\n\nWindow\n\n#### Returns\n\n  * Promise<Window>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### remove()\n\nPromise\n\n    \n    \n    chrome.windows.remove(  \n      windowId: number,  \n      callback?: function,  \n    )\n\nRemoves (closes) a window and all the tabs inside it.\n\n#### Parameters\n\n  * windowId\n\nnumber\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        () => void\n\n#### Returns\n\n  * Promise<void>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n### update()\n\nPromise\n\n    \n    \n    chrome.windows.update(  \n      windowId: number,  \n      updateInfo: object,  \n      callback?: function,  \n    )\n\nUpdates the properties of a window. Specify only the properties that to be\nchanged; unspecified properties are unchanged.\n\n#### Parameters\n\n  * windowId\n\nnumber\n\n  * updateInfo\n\nobject\n\n    * drawAttention\n\nboolean optional\n\nIf `true`, causes the window to be displayed in a manner that draws the user's\nattention to the window, without changing the focused window. The effect lasts\nuntil the user changes focus to the window. This option has no effect if the\nwindow already has focus. Set to `false` to cancel a previous `drawAttention`\nrequest.\n\n    * focused\n\nboolean optional\n\nIf `true`, brings the window to the front; cannot be combined with the state\n'minimized'. If `false`, brings the next window in the z-order to the front;\ncannot be combined with the state 'fullscreen' or 'maximized'.\n\n    * height\n\nnumber optional\n\nThe height to resize the window to in pixels. This value is ignored for\npanels.\n\n    * left\n\nnumber optional\n\nThe offset from the left edge of the screen to move the window to in pixels.\nThis value is ignored for panels.\n\n    * state\n\nWindowState optional\n\nThe new state of the window. The 'minimized', 'maximized', and 'fullscreen'\nstates cannot be combined with 'left', 'top', 'width', or 'height'.\n\n    * top\n\nnumber optional\n\nThe offset from the top edge of the screen to move the window to in pixels.\nThis value is ignored for panels.\n\n    * width\n\nnumber optional\n\nThe width to resize the window to in pixels. This value is ignored for panels.\n\n  * callback\n\nfunction optional\n\nThe `callback` parameter looks like:\n\n        \n        (window: Window) => void\n\n    * window\n\nWindow\n\n#### Returns\n\n  * Promise<Window>\n\nChrome 88+\n\nPromises are supported in Manifest V3 and later, but callbacks are provided\nfor backward compatibility. You cannot use both on the same function call. The\npromise resolves with the same type that is passed to the callback.\n\n## Events\n\n### onBoundsChanged\n\nChrome 86+\n\n    \n    \n    chrome.windows.onBoundsChanged.addListener(  \n      callback: function,  \n    )\n\nFired when a window has been resized; this event is only dispatched when the\nnew bounds are committed, and not for in-progress changes.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nThe `callback` parameter looks like:\n\n        \n        (window: Window) => void\n\n    * window\n\nWindow\n\n### onCreated\n\n    \n    \n    chrome.windows.onCreated.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when a window is created.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nChrome 46+\n\nThe `callback` parameter looks like:\n\n        \n        (window: Window) => void\n\n    * window\n\nWindow\n\nDetails of the created window.\n\n  * filters\n\nobject optional\n\n    * windowTypes\n\nWindowType[]\n\nConditions that the window's type being created must satisfy. By default it\nsatisfies `['normal', 'popup']`.\n\n### onFocusChanged\n\n    \n    \n    chrome.windows.onFocusChanged.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when the currently focused window changes. Returns\n`chrome.windows.WINDOW_ID_NONE` if all Chrome windows have lost focus.\n**Note:** On some Linux window managers, `WINDOW_ID_NONE` is always sent\nimmediately preceding a switch from one Chrome window to another.\n\n#### Parameters\n\n  * callback\n\nfunction\n\nChrome 46+\n\nThe `callback` parameter looks like:\n\n        \n        (windowId: number) => void\n\n    * windowId\n\nnumber\n\nID of the newly-focused window.\n\n  * filters\n\nobject optional\n\n    * windowTypes\n\nWindowType[]\n\nConditions that the window's type being removed must satisfy. By default it\nsatisfies `['normal', 'popup']`.\n\n### onRemoved\n\n    \n    \n    chrome.windows.onRemoved.addListener(  \n      callback: function,  \n      filters?: object,  \n    )\n\nFired when a window is removed (closed).\n\n#### Parameters\n\n  * callback\n\nfunction\n\nChrome 46+\n\nThe `callback` parameter looks like:\n\n        \n        (windowId: number) => void\n\n    * windowId\n\nnumber\n\nID of the removed window.\n\n  * filters\n\nobject optional\n\n    * windowTypes\n\nWindowType[]\n\nConditions that the window's type being removed must satisfy. By default it\nsatisfies `['normal', 'popup']`.\n\n"
  }
]